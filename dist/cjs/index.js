'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React$3 = require('react');
var reactNative = require('react-native');
var LinearGradient = require('react-native-web-linear-gradient');
var ReactDOM = require('react-dom');
var emStyled = require('@emotion/styled');
var react = require('@emotion/react');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var React__default = /*#__PURE__*/_interopDefaultLegacy(React$3);
var React__namespace = /*#__PURE__*/_interopNamespace(React$3);
var LinearGradient__default = /*#__PURE__*/_interopDefaultLegacy(LinearGradient);
var ReactDOM__namespace = /*#__PURE__*/_interopNamespace(ReactDOM);
var ReactDOM__default = /*#__PURE__*/_interopDefaultLegacy(ReactDOM);
var emStyled__default = /*#__PURE__*/_interopDefaultLegacy(emStyled);

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var jsxRuntime = {exports: {}};

var reactJsxRuntime_production_min = {};

/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

var objectAssign;
var hasRequiredObjectAssign;

function requireObjectAssign () {
	if (hasRequiredObjectAssign) return objectAssign;
	hasRequiredObjectAssign = 1;
	/* eslint-disable no-unused-vars */
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}

			// Detect buggy property enumeration order in older V8 versions.

			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}

			return true;
		} catch (err) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}

	objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};
	return objectAssign;
}

/** @license React v17.0.2
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactJsxRuntime_production_min;

function requireReactJsxRuntime_production_min () {
	if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
	hasRequiredReactJsxRuntime_production_min = 1;
requireObjectAssign();var f=React__default["default"],g=60103;reactJsxRuntime_production_min.Fragment=60107;if("function"===typeof Symbol&&Symbol.for){var h=Symbol.for;g=h("react.element");reactJsxRuntime_production_min.Fragment=h("react.fragment");}var m=f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,n=Object.prototype.hasOwnProperty,p={key:!0,ref:!0,__self:!0,__source:!0};
	function q(c,a,k){var b,d={},e=null,l=null;void 0!==k&&(e=""+k);void 0!==a.key&&(e=""+a.key);void 0!==a.ref&&(l=a.ref);for(b in a)n.call(a,b)&&!p.hasOwnProperty(b)&&(d[b]=a[b]);if(c&&c.defaultProps)for(b in a=c.defaultProps,a)void 0===d[b]&&(d[b]=a[b]);return {$$typeof:g,type:c,key:e,ref:l,props:d,_owner:m.current}}reactJsxRuntime_production_min.jsx=q;reactJsxRuntime_production_min.jsxs=q;
	return reactJsxRuntime_production_min;
}

var reactJsxRuntime_development = {};

/** @license React v17.0.2
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactJsxRuntime_development;

function requireReactJsxRuntime_development () {
	if (hasRequiredReactJsxRuntime_development) return reactJsxRuntime_development;
	hasRequiredReactJsxRuntime_development = 1;
	(function (exports) {

		if (process.env.NODE_ENV !== "production") {
		  (function() {

		var React = React__default["default"];
		var _assign = requireObjectAssign();

		// ATTENTION
		// When adding new symbols to this file,
		// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
		// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
		// nor polyfill, then a plain number is used for performance.
		var REACT_ELEMENT_TYPE = 0xeac7;
		var REACT_PORTAL_TYPE = 0xeaca;
		exports.Fragment = 0xeacb;
		var REACT_STRICT_MODE_TYPE = 0xeacc;
		var REACT_PROFILER_TYPE = 0xead2;
		var REACT_PROVIDER_TYPE = 0xeacd;
		var REACT_CONTEXT_TYPE = 0xeace;
		var REACT_FORWARD_REF_TYPE = 0xead0;
		var REACT_SUSPENSE_TYPE = 0xead1;
		var REACT_SUSPENSE_LIST_TYPE = 0xead8;
		var REACT_MEMO_TYPE = 0xead3;
		var REACT_LAZY_TYPE = 0xead4;
		var REACT_BLOCK_TYPE = 0xead9;
		var REACT_SERVER_BLOCK_TYPE = 0xeada;
		var REACT_FUNDAMENTAL_TYPE = 0xead5;
		var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
		var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

		if (typeof Symbol === 'function' && Symbol.for) {
		  var symbolFor = Symbol.for;
		  REACT_ELEMENT_TYPE = symbolFor('react.element');
		  REACT_PORTAL_TYPE = symbolFor('react.portal');
		  exports.Fragment = symbolFor('react.fragment');
		  REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
		  REACT_PROFILER_TYPE = symbolFor('react.profiler');
		  REACT_PROVIDER_TYPE = symbolFor('react.provider');
		  REACT_CONTEXT_TYPE = symbolFor('react.context');
		  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
		  REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
		  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
		  REACT_MEMO_TYPE = symbolFor('react.memo');
		  REACT_LAZY_TYPE = symbolFor('react.lazy');
		  REACT_BLOCK_TYPE = symbolFor('react.block');
		  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
		  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
		  symbolFor('react.scope');
		  symbolFor('react.opaque.id');
		  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
		  symbolFor('react.offscreen');
		  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
		}

		var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
		var FAUX_ITERATOR_SYMBOL = '@@iterator';
		function getIteratorFn(maybeIterable) {
		  if (maybeIterable === null || typeof maybeIterable !== 'object') {
		    return null;
		  }

		  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

		  if (typeof maybeIterator === 'function') {
		    return maybeIterator;
		  }

		  return null;
		}

		var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

		function error(format) {
		  {
		    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
		      args[_key2 - 1] = arguments[_key2];
		    }

		    printWarning('error', format, args);
		  }
		}

		function printWarning(level, format, args) {
		  // When changing this logic, you might want to also
		  // update consoleWithStackDev.www.js as well.
		  {
		    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
		    var stack = ReactDebugCurrentFrame.getStackAddendum();

		    if (stack !== '') {
		      format += '%s';
		      args = args.concat([stack]);
		    }

		    var argsWithFormat = args.map(function (item) {
		      return '' + item;
		    }); // Careful: RN currently depends on this prefix

		    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
		    // breaks IE9: https://github.com/facebook/react/issues/13610
		    // eslint-disable-next-line react-internal/no-production-logging

		    Function.prototype.apply.call(console[level], console, argsWithFormat);
		  }
		}

		// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

		var enableScopeAPI = false; // Experimental Create Event Handle API.

		function isValidElementType(type) {
		  if (typeof type === 'string' || typeof type === 'function') {
		    return true;
		  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


		  if (type === exports.Fragment || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {
		    return true;
		  }

		  if (typeof type === 'object' && type !== null) {
		    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
		      return true;
		    }
		  }

		  return false;
		}

		function getWrappedName(outerType, innerType, wrapperName) {
		  var functionName = innerType.displayName || innerType.name || '';
		  return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
		}

		function getContextName(type) {
		  return type.displayName || 'Context';
		}

		function getComponentName(type) {
		  if (type == null) {
		    // Host root, text node or just invalid type.
		    return null;
		  }

		  {
		    if (typeof type.tag === 'number') {
		      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
		    }
		  }

		  if (typeof type === 'function') {
		    return type.displayName || type.name || null;
		  }

		  if (typeof type === 'string') {
		    return type;
		  }

		  switch (type) {
		    case exports.Fragment:
		      return 'Fragment';

		    case REACT_PORTAL_TYPE:
		      return 'Portal';

		    case REACT_PROFILER_TYPE:
		      return 'Profiler';

		    case REACT_STRICT_MODE_TYPE:
		      return 'StrictMode';

		    case REACT_SUSPENSE_TYPE:
		      return 'Suspense';

		    case REACT_SUSPENSE_LIST_TYPE:
		      return 'SuspenseList';
		  }

		  if (typeof type === 'object') {
		    switch (type.$$typeof) {
		      case REACT_CONTEXT_TYPE:
		        var context = type;
		        return getContextName(context) + '.Consumer';

		      case REACT_PROVIDER_TYPE:
		        var provider = type;
		        return getContextName(provider._context) + '.Provider';

		      case REACT_FORWARD_REF_TYPE:
		        return getWrappedName(type, type.render, 'ForwardRef');

		      case REACT_MEMO_TYPE:
		        return getComponentName(type.type);

		      case REACT_BLOCK_TYPE:
		        return getComponentName(type._render);

		      case REACT_LAZY_TYPE:
		        {
		          var lazyComponent = type;
		          var payload = lazyComponent._payload;
		          var init = lazyComponent._init;

		          try {
		            return getComponentName(init(payload));
		          } catch (x) {
		            return null;
		          }
		        }
		    }
		  }

		  return null;
		}

		// Helpers to patch console.logs to avoid logging during side-effect free
		// replaying on render function. This currently only patches the object
		// lazily which won't cover if the log function was extracted eagerly.
		// We could also eagerly patch the method.
		var disabledDepth = 0;
		var prevLog;
		var prevInfo;
		var prevWarn;
		var prevError;
		var prevGroup;
		var prevGroupCollapsed;
		var prevGroupEnd;

		function disabledLog() {}

		disabledLog.__reactDisabledLog = true;
		function disableLogs() {
		  {
		    if (disabledDepth === 0) {
		      /* eslint-disable react-internal/no-production-logging */
		      prevLog = console.log;
		      prevInfo = console.info;
		      prevWarn = console.warn;
		      prevError = console.error;
		      prevGroup = console.group;
		      prevGroupCollapsed = console.groupCollapsed;
		      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

		      var props = {
		        configurable: true,
		        enumerable: true,
		        value: disabledLog,
		        writable: true
		      }; // $FlowFixMe Flow thinks console is immutable.

		      Object.defineProperties(console, {
		        info: props,
		        log: props,
		        warn: props,
		        error: props,
		        group: props,
		        groupCollapsed: props,
		        groupEnd: props
		      });
		      /* eslint-enable react-internal/no-production-logging */
		    }

		    disabledDepth++;
		  }
		}
		function reenableLogs() {
		  {
		    disabledDepth--;

		    if (disabledDepth === 0) {
		      /* eslint-disable react-internal/no-production-logging */
		      var props = {
		        configurable: true,
		        enumerable: true,
		        writable: true
		      }; // $FlowFixMe Flow thinks console is immutable.

		      Object.defineProperties(console, {
		        log: _assign({}, props, {
		          value: prevLog
		        }),
		        info: _assign({}, props, {
		          value: prevInfo
		        }),
		        warn: _assign({}, props, {
		          value: prevWarn
		        }),
		        error: _assign({}, props, {
		          value: prevError
		        }),
		        group: _assign({}, props, {
		          value: prevGroup
		        }),
		        groupCollapsed: _assign({}, props, {
		          value: prevGroupCollapsed
		        }),
		        groupEnd: _assign({}, props, {
		          value: prevGroupEnd
		        })
		      });
		      /* eslint-enable react-internal/no-production-logging */
		    }

		    if (disabledDepth < 0) {
		      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
		    }
		  }
		}

		var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
		var prefix;
		function describeBuiltInComponentFrame(name, source, ownerFn) {
		  {
		    if (prefix === undefined) {
		      // Extract the VM specific prefix used by each line.
		      try {
		        throw Error();
		      } catch (x) {
		        var match = x.stack.trim().match(/\n( *(at )?)/);
		        prefix = match && match[1] || '';
		      }
		    } // We use the prefix to ensure our stacks line up with native stack frames.


		    return '\n' + prefix + name;
		  }
		}
		var reentry = false;
		var componentFrameCache;

		{
		  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
		  componentFrameCache = new PossiblyWeakMap();
		}

		function describeNativeComponentFrame(fn, construct) {
		  // If something asked for a stack inside a fake render, it should get ignored.
		  if (!fn || reentry) {
		    return '';
		  }

		  {
		    var frame = componentFrameCache.get(fn);

		    if (frame !== undefined) {
		      return frame;
		    }
		  }

		  var control;
		  reentry = true;
		  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

		  Error.prepareStackTrace = undefined;
		  var previousDispatcher;

		  {
		    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function
		    // for warnings.

		    ReactCurrentDispatcher.current = null;
		    disableLogs();
		  }

		  try {
		    // This should throw.
		    if (construct) {
		      // Something should be setting the props in the constructor.
		      var Fake = function () {
		        throw Error();
		      }; // $FlowFixMe


		      Object.defineProperty(Fake.prototype, 'props', {
		        set: function () {
		          // We use a throwing setter instead of frozen or non-writable props
		          // because that won't throw in a non-strict mode function.
		          throw Error();
		        }
		      });

		      if (typeof Reflect === 'object' && Reflect.construct) {
		        // We construct a different control for this case to include any extra
		        // frames added by the construct call.
		        try {
		          Reflect.construct(Fake, []);
		        } catch (x) {
		          control = x;
		        }

		        Reflect.construct(fn, [], Fake);
		      } else {
		        try {
		          Fake.call();
		        } catch (x) {
		          control = x;
		        }

		        fn.call(Fake.prototype);
		      }
		    } else {
		      try {
		        throw Error();
		      } catch (x) {
		        control = x;
		      }

		      fn();
		    }
		  } catch (sample) {
		    // This is inlined manually because closure doesn't do it for us.
		    if (sample && control && typeof sample.stack === 'string') {
		      // This extracts the first frame from the sample that isn't also in the control.
		      // Skipping one frame that we assume is the frame that calls the two.
		      var sampleLines = sample.stack.split('\n');
		      var controlLines = control.stack.split('\n');
		      var s = sampleLines.length - 1;
		      var c = controlLines.length - 1;

		      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
		        // We expect at least one stack frame to be shared.
		        // Typically this will be the root most one. However, stack frames may be
		        // cut off due to maximum stack limits. In this case, one maybe cut off
		        // earlier than the other. We assume that the sample is longer or the same
		        // and there for cut off earlier. So we should find the root most frame in
		        // the sample somewhere in the control.
		        c--;
		      }

		      for (; s >= 1 && c >= 0; s--, c--) {
		        // Next we find the first one that isn't the same which should be the
		        // frame that called our sample function and the control.
		        if (sampleLines[s] !== controlLines[c]) {
		          // In V8, the first line is describing the message but other VMs don't.
		          // If we're about to return the first line, and the control is also on the same
		          // line, that's a pretty good indicator that our sample threw at same line as
		          // the control. I.e. before we entered the sample frame. So we ignore this result.
		          // This can happen if you passed a class to function component, or non-function.
		          if (s !== 1 || c !== 1) {
		            do {
		              s--;
		              c--; // We may still have similar intermediate frames from the construct call.
		              // The next one that isn't the same should be our match though.

		              if (c < 0 || sampleLines[s] !== controlLines[c]) {
		                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
		                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');

		                {
		                  if (typeof fn === 'function') {
		                    componentFrameCache.set(fn, _frame);
		                  }
		                } // Return the line we found.


		                return _frame;
		              }
		            } while (s >= 1 && c >= 0);
		          }

		          break;
		        }
		      }
		    }
		  } finally {
		    reentry = false;

		    {
		      ReactCurrentDispatcher.current = previousDispatcher;
		      reenableLogs();
		    }

		    Error.prepareStackTrace = previousPrepareStackTrace;
		  } // Fallback to just using the name if we couldn't make it throw.


		  var name = fn ? fn.displayName || fn.name : '';
		  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

		  {
		    if (typeof fn === 'function') {
		      componentFrameCache.set(fn, syntheticFrame);
		    }
		  }

		  return syntheticFrame;
		}
		function describeFunctionComponentFrame(fn, source, ownerFn) {
		  {
		    return describeNativeComponentFrame(fn, false);
		  }
		}

		function shouldConstruct(Component) {
		  var prototype = Component.prototype;
		  return !!(prototype && prototype.isReactComponent);
		}

		function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

		  if (type == null) {
		    return '';
		  }

		  if (typeof type === 'function') {
		    {
		      return describeNativeComponentFrame(type, shouldConstruct(type));
		    }
		  }

		  if (typeof type === 'string') {
		    return describeBuiltInComponentFrame(type);
		  }

		  switch (type) {
		    case REACT_SUSPENSE_TYPE:
		      return describeBuiltInComponentFrame('Suspense');

		    case REACT_SUSPENSE_LIST_TYPE:
		      return describeBuiltInComponentFrame('SuspenseList');
		  }

		  if (typeof type === 'object') {
		    switch (type.$$typeof) {
		      case REACT_FORWARD_REF_TYPE:
		        return describeFunctionComponentFrame(type.render);

		      case REACT_MEMO_TYPE:
		        // Memo may contain any component type so we recursively resolve it.
		        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

		      case REACT_BLOCK_TYPE:
		        return describeFunctionComponentFrame(type._render);

		      case REACT_LAZY_TYPE:
		        {
		          var lazyComponent = type;
		          var payload = lazyComponent._payload;
		          var init = lazyComponent._init;

		          try {
		            // Lazy may contain any component type so we recursively resolve it.
		            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
		          } catch (x) {}
		        }
		    }
		  }

		  return '';
		}

		var loggedTypeFailures = {};
		var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;

		function setCurrentlyValidatingElement(element) {
		  {
		    if (element) {
		      var owner = element._owner;
		      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
		      ReactDebugCurrentFrame.setExtraStackFrame(stack);
		    } else {
		      ReactDebugCurrentFrame.setExtraStackFrame(null);
		    }
		  }
		}

		function checkPropTypes(typeSpecs, values, location, componentName, element) {
		  {
		    // $FlowFixMe This is okay but Flow doesn't know it.
		    var has = Function.call.bind(Object.prototype.hasOwnProperty);

		    for (var typeSpecName in typeSpecs) {
		      if (has(typeSpecs, typeSpecName)) {
		        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
		        // fail the render phase where it didn't fail before. So we log it.
		        // After these have been cleaned up, we'll let them throw.

		        try {
		          // This is intentionally an invariant that gets caught. It's the same
		          // behavior as without this statement except with a better message.
		          if (typeof typeSpecs[typeSpecName] !== 'function') {
		            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
		            err.name = 'Invariant Violation';
		            throw err;
		          }

		          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
		        } catch (ex) {
		          error$1 = ex;
		        }

		        if (error$1 && !(error$1 instanceof Error)) {
		          setCurrentlyValidatingElement(element);

		          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

		          setCurrentlyValidatingElement(null);
		        }

		        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
		          // Only monitor this failure once because there tends to be a lot of the
		          // same error.
		          loggedTypeFailures[error$1.message] = true;
		          setCurrentlyValidatingElement(element);

		          error('Failed %s type: %s', location, error$1.message);

		          setCurrentlyValidatingElement(null);
		        }
		      }
		    }
		  }
		}

		var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		var RESERVED_PROPS = {
		  key: true,
		  ref: true,
		  __self: true,
		  __source: true
		};
		var specialPropKeyWarningShown;
		var specialPropRefWarningShown;
		var didWarnAboutStringRefs;

		{
		  didWarnAboutStringRefs = {};
		}

		function hasValidRef(config) {
		  {
		    if (hasOwnProperty.call(config, 'ref')) {
		      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

		      if (getter && getter.isReactWarning) {
		        return false;
		      }
		    }
		  }

		  return config.ref !== undefined;
		}

		function hasValidKey(config) {
		  {
		    if (hasOwnProperty.call(config, 'key')) {
		      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

		      if (getter && getter.isReactWarning) {
		        return false;
		      }
		    }
		  }

		  return config.key !== undefined;
		}

		function warnIfStringRefCannotBeAutoConverted(config, self) {
		  {
		    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {
		      var componentName = getComponentName(ReactCurrentOwner.current.type);

		      if (!didWarnAboutStringRefs[componentName]) {
		        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentName(ReactCurrentOwner.current.type), config.ref);

		        didWarnAboutStringRefs[componentName] = true;
		      }
		    }
		  }
		}

		function defineKeyPropWarningGetter(props, displayName) {
		  {
		    var warnAboutAccessingKey = function () {
		      if (!specialPropKeyWarningShown) {
		        specialPropKeyWarningShown = true;

		        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
		      }
		    };

		    warnAboutAccessingKey.isReactWarning = true;
		    Object.defineProperty(props, 'key', {
		      get: warnAboutAccessingKey,
		      configurable: true
		    });
		  }
		}

		function defineRefPropWarningGetter(props, displayName) {
		  {
		    var warnAboutAccessingRef = function () {
		      if (!specialPropRefWarningShown) {
		        specialPropRefWarningShown = true;

		        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
		      }
		    };

		    warnAboutAccessingRef.isReactWarning = true;
		    Object.defineProperty(props, 'ref', {
		      get: warnAboutAccessingRef,
		      configurable: true
		    });
		  }
		}
		/**
		 * Factory method to create a new React element. This no longer adheres to
		 * the class pattern, so do not use new to call it. Also, instanceof check
		 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
		 * if something is a React Element.
		 *
		 * @param {*} type
		 * @param {*} props
		 * @param {*} key
		 * @param {string|object} ref
		 * @param {*} owner
		 * @param {*} self A *temporary* helper to detect places where `this` is
		 * different from the `owner` when React.createElement is called, so that we
		 * can warn. We want to get rid of owner and replace string `ref`s with arrow
		 * functions, and as long as `this` and owner are the same, there will be no
		 * change in behavior.
		 * @param {*} source An annotation object (added by a transpiler or otherwise)
		 * indicating filename, line number, and/or other information.
		 * @internal
		 */


		var ReactElement = function (type, key, ref, self, source, owner, props) {
		  var element = {
		    // This tag allows us to uniquely identify this as a React Element
		    $$typeof: REACT_ELEMENT_TYPE,
		    // Built-in properties that belong on the element
		    type: type,
		    key: key,
		    ref: ref,
		    props: props,
		    // Record the component responsible for creating this element.
		    _owner: owner
		  };

		  {
		    // The validation flag is currently mutative. We put it on
		    // an external backing store so that we can freeze the whole object.
		    // This can be replaced with a WeakMap once they are implemented in
		    // commonly used development environments.
		    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
		    // the validation flag non-enumerable (where possible, which should
		    // include every environment we run tests in), so the test framework
		    // ignores it.

		    Object.defineProperty(element._store, 'validated', {
		      configurable: false,
		      enumerable: false,
		      writable: true,
		      value: false
		    }); // self and source are DEV only properties.

		    Object.defineProperty(element, '_self', {
		      configurable: false,
		      enumerable: false,
		      writable: false,
		      value: self
		    }); // Two elements created in two different places should be considered
		    // equal for testing purposes and therefore we hide it from enumeration.

		    Object.defineProperty(element, '_source', {
		      configurable: false,
		      enumerable: false,
		      writable: false,
		      value: source
		    });

		    if (Object.freeze) {
		      Object.freeze(element.props);
		      Object.freeze(element);
		    }
		  }

		  return element;
		};
		/**
		 * https://github.com/reactjs/rfcs/pull/107
		 * @param {*} type
		 * @param {object} props
		 * @param {string} key
		 */

		function jsxDEV(type, config, maybeKey, source, self) {
		  {
		    var propName; // Reserved names are extracted

		    var props = {};
		    var key = null;
		    var ref = null; // Currently, key can be spread in as a prop. This causes a potential
		    // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
		    // or <div key="Hi" {...props} /> ). We want to deprecate key spread,
		    // but as an intermediary step, we will use jsxDEV for everything except
		    // <div {...props} key="Hi" />, because we aren't currently able to tell if
		    // key is explicitly declared to be undefined or not.

		    if (maybeKey !== undefined) {
		      key = '' + maybeKey;
		    }

		    if (hasValidKey(config)) {
		      key = '' + config.key;
		    }

		    if (hasValidRef(config)) {
		      ref = config.ref;
		      warnIfStringRefCannotBeAutoConverted(config, self);
		    } // Remaining properties are added to a new props object


		    for (propName in config) {
		      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
		        props[propName] = config[propName];
		      }
		    } // Resolve default props


		    if (type && type.defaultProps) {
		      var defaultProps = type.defaultProps;

		      for (propName in defaultProps) {
		        if (props[propName] === undefined) {
		          props[propName] = defaultProps[propName];
		        }
		      }
		    }

		    if (key || ref) {
		      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

		      if (key) {
		        defineKeyPropWarningGetter(props, displayName);
		      }

		      if (ref) {
		        defineRefPropWarningGetter(props, displayName);
		      }
		    }

		    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
		  }
		}

		var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
		var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

		function setCurrentlyValidatingElement$1(element) {
		  {
		    if (element) {
		      var owner = element._owner;
		      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
		      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
		    } else {
		      ReactDebugCurrentFrame$1.setExtraStackFrame(null);
		    }
		  }
		}

		var propTypesMisspellWarningShown;

		{
		  propTypesMisspellWarningShown = false;
		}
		/**
		 * Verifies the object is a ReactElement.
		 * See https://reactjs.org/docs/react-api.html#isvalidelement
		 * @param {?object} object
		 * @return {boolean} True if `object` is a ReactElement.
		 * @final
		 */

		function isValidElement(object) {
		  {
		    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
		  }
		}

		function getDeclarationErrorAddendum() {
		  {
		    if (ReactCurrentOwner$1.current) {
		      var name = getComponentName(ReactCurrentOwner$1.current.type);

		      if (name) {
		        return '\n\nCheck the render method of `' + name + '`.';
		      }
		    }

		    return '';
		  }
		}

		function getSourceInfoErrorAddendum(source) {
		  {
		    if (source !== undefined) {
		      var fileName = source.fileName.replace(/^.*[\\\/]/, '');
		      var lineNumber = source.lineNumber;
		      return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
		    }

		    return '';
		  }
		}
		/**
		 * Warn if there's no key explicitly set on dynamic arrays of children or
		 * object keys are not valid. This allows us to keep track of children between
		 * updates.
		 */


		var ownerHasKeyUseWarning = {};

		function getCurrentComponentErrorInfo(parentType) {
		  {
		    var info = getDeclarationErrorAddendum();

		    if (!info) {
		      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

		      if (parentName) {
		        info = "\n\nCheck the top-level render call using <" + parentName + ">.";
		      }
		    }

		    return info;
		  }
		}
		/**
		 * Warn if the element doesn't have an explicit key assigned to it.
		 * This element is in an array. The array could grow and shrink or be
		 * reordered. All children that haven't already been validated are required to
		 * have a "key" property assigned to it. Error statuses are cached so a warning
		 * will only be shown once.
		 *
		 * @internal
		 * @param {ReactElement} element Element that requires a key.
		 * @param {*} parentType element's parent's type.
		 */


		function validateExplicitKey(element, parentType) {
		  {
		    if (!element._store || element._store.validated || element.key != null) {
		      return;
		    }

		    element._store.validated = true;
		    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

		    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
		      return;
		    }

		    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
		    // property, it may be the creator of the child that's responsible for
		    // assigning it a key.

		    var childOwner = '';

		    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
		      // Give the component that originally created this child.
		      childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
		    }

		    setCurrentlyValidatingElement$1(element);

		    error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

		    setCurrentlyValidatingElement$1(null);
		  }
		}
		/**
		 * Ensure that every element either is passed in a static location, in an
		 * array with an explicit keys property defined, or in an object literal
		 * with valid key property.
		 *
		 * @internal
		 * @param {ReactNode} node Statically passed child of any type.
		 * @param {*} parentType node's parent's type.
		 */


		function validateChildKeys(node, parentType) {
		  {
		    if (typeof node !== 'object') {
		      return;
		    }

		    if (Array.isArray(node)) {
		      for (var i = 0; i < node.length; i++) {
		        var child = node[i];

		        if (isValidElement(child)) {
		          validateExplicitKey(child, parentType);
		        }
		      }
		    } else if (isValidElement(node)) {
		      // This element was passed in a valid location.
		      if (node._store) {
		        node._store.validated = true;
		      }
		    } else if (node) {
		      var iteratorFn = getIteratorFn(node);

		      if (typeof iteratorFn === 'function') {
		        // Entry iterators used to provide implicit keys,
		        // but now we print a separate warning for them later.
		        if (iteratorFn !== node.entries) {
		          var iterator = iteratorFn.call(node);
		          var step;

		          while (!(step = iterator.next()).done) {
		            if (isValidElement(step.value)) {
		              validateExplicitKey(step.value, parentType);
		            }
		          }
		        }
		      }
		    }
		  }
		}
		/**
		 * Given an element, validate that its props follow the propTypes definition,
		 * provided by the type.
		 *
		 * @param {ReactElement} element
		 */


		function validatePropTypes(element) {
		  {
		    var type = element.type;

		    if (type === null || type === undefined || typeof type === 'string') {
		      return;
		    }

		    var propTypes;

		    if (typeof type === 'function') {
		      propTypes = type.propTypes;
		    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
		    // Inner props are checked in the reconciler.
		    type.$$typeof === REACT_MEMO_TYPE)) {
		      propTypes = type.propTypes;
		    } else {
		      return;
		    }

		    if (propTypes) {
		      // Intentionally inside to avoid triggering lazy initializers:
		      var name = getComponentName(type);
		      checkPropTypes(propTypes, element.props, 'prop', name, element);
		    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
		      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

		      var _name = getComponentName(type);

		      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
		    }

		    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
		      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
		    }
		  }
		}
		/**
		 * Given a fragment, validate that it can only be provided with fragment props
		 * @param {ReactElement} fragment
		 */


		function validateFragmentProps(fragment) {
		  {
		    var keys = Object.keys(fragment.props);

		    for (var i = 0; i < keys.length; i++) {
		      var key = keys[i];

		      if (key !== 'children' && key !== 'key') {
		        setCurrentlyValidatingElement$1(fragment);

		        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

		        setCurrentlyValidatingElement$1(null);
		        break;
		      }
		    }

		    if (fragment.ref !== null) {
		      setCurrentlyValidatingElement$1(fragment);

		      error('Invalid attribute `ref` supplied to `React.Fragment`.');

		      setCurrentlyValidatingElement$1(null);
		    }
		  }
		}

		function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
		  {
		    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
		    // succeed and there will likely be errors in render.

		    if (!validType) {
		      var info = '';

		      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
		        info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
		      }

		      var sourceInfo = getSourceInfoErrorAddendum(source);

		      if (sourceInfo) {
		        info += sourceInfo;
		      } else {
		        info += getDeclarationErrorAddendum();
		      }

		      var typeString;

		      if (type === null) {
		        typeString = 'null';
		      } else if (Array.isArray(type)) {
		        typeString = 'array';
		      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
		        typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
		        info = ' Did you accidentally export a JSX literal instead of a component?';
		      } else {
		        typeString = typeof type;
		      }

		      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
		    }

		    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.
		    // TODO: Drop this when these are no longer allowed as the type argument.

		    if (element == null) {
		      return element;
		    } // Skip key warning if the type isn't valid since our key validation logic
		    // doesn't expect a non-string/function type and can throw confusing errors.
		    // We don't want exception behavior to differ between dev and prod.
		    // (Rendering will throw with a helpful message and as soon as the type is
		    // fixed, the key warnings will appear.)


		    if (validType) {
		      var children = props.children;

		      if (children !== undefined) {
		        if (isStaticChildren) {
		          if (Array.isArray(children)) {
		            for (var i = 0; i < children.length; i++) {
		              validateChildKeys(children[i], type);
		            }

		            if (Object.freeze) {
		              Object.freeze(children);
		            }
		          } else {
		            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');
		          }
		        } else {
		          validateChildKeys(children, type);
		        }
		      }
		    }

		    if (type === exports.Fragment) {
		      validateFragmentProps(element);
		    } else {
		      validatePropTypes(element);
		    }

		    return element;
		  }
		} // These two functions exist to still get child warnings in dev
		// even with the prod transform. This means that jsxDEV is purely
		// opt-in behavior for better messages but that we won't stop
		// giving you warnings if you use production apis.

		function jsxWithValidationStatic(type, props, key) {
		  {
		    return jsxWithValidation(type, props, key, true);
		  }
		}
		function jsxWithValidationDynamic(type, props, key) {
		  {
		    return jsxWithValidation(type, props, key, false);
		  }
		}

		var jsx =  jsxWithValidationDynamic ; // we may want to special case jsxs internally to take advantage of static children.
		// for now we can ship identical prod functions

		var jsxs =  jsxWithValidationStatic ;

		exports.jsx = jsx;
		exports.jsxs = jsxs;
		  })();
		}
} (reactJsxRuntime_development));
	return reactJsxRuntime_development;
}

(function (module) {

	if (process.env.NODE_ENV === 'production') {
	  module.exports = requireReactJsxRuntime_production_min();
	} else {
	  module.exports = requireReactJsxRuntime_development();
	}
} (jsxRuntime));

var makeStyles = function (styles) {
    return reactNative.StyleSheet.create(styles);
};
var makeTextStyles = function (styles) {
    return reactNative.StyleSheet.create(styles);
};
var makeViewStyles = function (styles) {
    return reactNative.StyleSheet.create(styles);
};
var openSans = {
    reg: "OpenSans-Regular",
    bold: "OpenSans-Bold",
    boldItalic: "OpenSans-BoldItalic",
    extraBold: "OpenSans-ExtraBold",
    extraBoldItalic: "OpenSans-ExtraBoldItalic",
    italic: "OpenSans-Italic",
    light: "OpenSans-Light",
    lightItalic: "OpenSans-LightItalic",
    semiBold: "OpenSans-SemiBold",
    semiBoldItalic: "OpenSans-SemiBoldItalic",
};
var margins = reactNative.StyleSheet.create({
    m8: { margin: 8 },
    m16: { margin: 16 },
    m24: { margin: 24 },
    m32: { margin: 32 },
    m40: { margin: 40 },
    m48: { margin: 48 },
    mb4: { marginBottom: 4 },
    mb8: { marginBottom: 8 },
    mb16: { marginBottom: 16 },
    mb24: { marginBottom: 24 },
    mb32: { marginBottom: 32 },
    mb40: { marginBottom: 40 },
    mb48: { marginBottom: 48 },
    mt8: { marginTop: 8 },
    mt16: { marginTop: 16 },
    mt24: { marginTop: 24 },
    mt32: { marginTop: 32 },
    mt40: { marginTop: 40 },
    mt48: { marginTop: 48 },
    mr4: { marginRight: 4 },
    mr8: { marginRight: 8 },
    mr16: { marginRight: 16 },
    mr24: { marginRight: 24 },
    mr32: { marginRight: 32 },
    mr40: { marginRight: 40 },
    mr48: { marginRight: 48 },
    ml4: { marginLeft: 4 },
    ml8: { marginLeft: 8 },
    ml16: { marginLeft: 16 },
    ml24: { marginLeft: 24 },
    ml32: { marginLeft: 32 },
    ml40: { marginLeft: 40 },
    ml48: { marginLeft: 48 },
    mh8: { marginHorizontal: 8 },
    mh16: { marginHorizontal: 16 },
    mh24: { marginHorizontal: 24 },
    mh32: { marginHorizontal: 32 },
    mh40: { marginHorizontal: 40 },
    mh48: { marginHorizontal: 48 },
    mv8: { marginVertical: 8 },
    mv16: { marginVertical: 16 },
    mv24: { marginVertical: 24 },
    mv32: { marginVertical: 32 },
    mv40: { marginVertical: 40 },
    mv48: { marginVertical: 48 },
});
var padding = reactNative.StyleSheet.create({
    p4: { padding: 4 },
    p8: { padding: 8 },
    p16: { padding: 16 },
    p24: { padding: 24 },
    p32: { padding: 32 },
    p40: { padding: 40 },
    p48: { padding: 48 },
    pv4: { paddingVertical: 4 },
    pv8: { paddingVertical: 8 },
    pv16: { paddingVertical: 16 },
    pv24: { paddingVertical: 24 },
    pv32: { paddingVertical: 32 },
    pv40: { paddingVertical: 40 },
    pv48: { paddingVertical: 48 },
    ph4: { paddingHorizontal: 4 },
    ph8: { paddingHorizontal: 8 },
    ph16: { paddingHorizontal: 16 },
    ph24: { paddingHorizontal: 24 },
    ph32: { paddingHorizontal: 32 },
    ph40: { paddingHorizontal: 40 },
    ph48: { paddingHorizontal: 48 },
    pl4: { paddingLeft: 4 },
    pl8: { paddingLeft: 8 },
    pl16: { paddingLeft: 16 },
    pl24: { paddingLeft: 24 },
    pl32: { paddingLeft: 32 },
    pl40: { paddingLeft: 40 },
    pl48: { paddingLeft: 48 },
    pr4: { paddingRight: 4 },
    pr8: { paddingRight: 8 },
    pr16: { paddingRight: 16 },
    pr24: { paddingRight: 24 },
    pr32: { paddingRight: 32 },
    pr40: { paddingRight: 40 },
    pr48: { paddingRight: 48 },
    pb4: { paddingBottom: 4 },
    pb8: { paddingBottom: 8 },
    pb16: { paddingBottom: 16 },
    pb24: { paddingBottom: 24 },
    pb32: { paddingBottom: 32 },
    pb40: { paddingBottom: 40 },
    pb48: { paddingBottom: 48 },
    pt4: { paddingTop: 4 },
    pt8: { paddingTop: 8 },
    pt16: { paddingTop: 16 },
    pt24: { paddingTop: 24 },
    pt32: { paddingTop: 32 },
    pt40: { paddingTop: 40 },
    pt48: { paddingTop: 48 },
});
var containers = reactNative.StyleSheet.create({
    shadowXL: {
        shadowColor: "#000",
        shadowOffset: {
            width: 6,
            height: 8,
        },
        shadowOpacity: 0.1,
        shadowRadius: 15,
        elevation: 5,
    },
    shadow: {
        shadowColor: "#000",
        shadowOffset: {
            width: 2,
            height: 2,
        },
        shadowOpacity: 0.15,
        shadowRadius: 3,
        elevation: 5,
    },
    redBorder: {
        borderWidth: 1,
        borderColor: "red",
    },
    alignCenter: {
        alignItems: "center",
    },
    alignStart: {
        alignItems: "flex-start",
    },
    spaceBetween: {
        justifyContent: "space-between",
    },
    center: {
        alignItems: "center",
        justifyContent: "center",
    },
    fullWidth: {
        width: "100%",
    },
    halfWidth: {
        width: "50%",
    },
    fullHeight: {
        height: "100%",
    },
    flex1: {
        flex: 1,
    },
    inputRadius: {
        borderRadius: 3,
    },
    buttonRadius: {
        borderRadius: 3,
    },
    row: {
        flexDirection: "row",
    },
    alignEnd: {
        alignItems: "flex-end",
    },
    justifyCenter: {
        justifyContent: "center",
    },
    justifyEnd: {
        justifyContent: "flex-end",
    },
    justifyStart: {
        justifyContent: "flex-start",
    },
    positionAbsolute: {
        position: "absolute",
    },
    borderRadius: {
        borderRadius: 8,
    },
    borderRadiusXL: {
        borderRadius: 12,
    },
    borderRadius2XL: {
        borderRadius: 16,
    },
    borderRadius3XL: {
        borderRadius: 24,
    },
    alignSelfEnd: {
        alignSelf: "flex-end",
    },
    alignSelfCenter: {
        alignSelf: "center",
    },
    alignSelfStart: {
        alignSelf: "flex-start",
    },
});
var FONT_SIZE_SUB_CAPTION = 8;
var FONT_SIZE_CAPTION = 12;
var FONT_SIZE_BODY = 14;
var FONT_SIZE_SUB_HEADER = 16;
var FONT_SIZE_HEADER = 20;
var FONT_SIZE_LARGE_HEADER = 24;
var FONT_SIZE_TITLE = 28;
var FONT_SIZE_LARGE_TITLE = 48;
var text = reactNative.StyleSheet.create({
    center: {
        textAlign: "center",
    },
    right: {
        textAlign: "right",
    },
    body: {
        fontFamily: openSans.reg,
    },
    bold: {
        fontFamily: openSans.bold,
    },
    h1: {
        fontSize: 36,
    },
    h2: {
        fontSize: 32,
    },
    h3: {
        fontSize: FONT_SIZE_TITLE,
    },
    h4: {
        fontSize: FONT_SIZE_LARGE_HEADER,
    },
    h5: {
        fontSize: FONT_SIZE_HEADER,
    },
    h6: {
        fontSize: FONT_SIZE_SUB_HEADER,
    },
    caption: {
        fontSize: FONT_SIZE_CAPTION,
    },
    subCaption: {
        fontSize: FONT_SIZE_SUB_CAPTION,
    },
    heading: {
        fontSize: 18,
    },
    display: {
        color: "#1AF4FF",
    },
    faded: {
        color: "gray",
    },
    warning: {
        color: "red",
    },
});

var dodgerBlue = "#004eff";
var cyanBlue = "#0085ff";
var darkNavy = "#293354";
var ghostWhite = "#f7f8fb";
var aliceBlue = "#f3f8fe";
var white$1 = "#ffffff";
var grey$1 = "#7C7C7C";
var charcoalBlack = "#212529";
var crimson = "#d0031c";
var orange$1 = "#f7b217";
var solitudeGrey = "#BBBEC2";
var mistyRose = "#ffd8dd";
var lavendar = "#ccddff";
var lightGray = "#c4c4c4";

var openSansRegular = "data:font/ttf;base64,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KzUAAgCw/hQEdQYUABYAIgA+QB8gBhsUEBARBhEkIxIAERsMFgkDCR5GWQkWAxdGWQMQAD8rABg/KxESADk5GD8/ERIBOTkRMxEzMxEzMTABNjYzMhIREAIjIicjFxYVESMRMxEUByUiBgcVFBYzIBE0JgFYQqpq1/Dx1t56DAQIpqYGAUiomAKaqgEvlAO0WU/+1P71/vT+06EiTT/+NQgA/i40Whu4ySnnxwGw19H//wAC/hQEBgXTAiYAXAAAAQYAarUAAAq0AgErESYAKzU1//8AAAAABRAGtAImACQAAAEHAU0APwFSAAizAhIFJgArNf//AF7/7APNBWICJgBEAAABBgFN9QAACLMCKBEmACs1//8AAAAABRAHNwImACQAAAEHAU4AKwFSAAizAg8FJgArNf//AF7/7APNBeUCJgBEAAABBgFO5AAACLMCJREmACs1//8AAP5CBREFvAImACQAAAAHAVEDoAAA//8AXv5CBAAEWgImAEQAAAAHAVECjwAA//8Aff/sBM8HcwImACYAAAEHAHYBCAFSAAizASAFJgArNf//AHP/7AOLBiECJgBGAAABBgB2RAAACLMBIBEmACs1//8Aff/sBM8HcwImACYAAAEHAUsArAFSAAizASUFJgArNf//AHP/7AOLBiECJgBGAAABBgFL1AAACLMBJREmACs1//8Aff/sBM8HMQImACYAAAEHAU8CGwFSAAizASAFJgArNf//AHP/7AOLBd8CJgBGAAABBwFPAVAAAAAIswEgESYAKzX//wB9/+wEzwdzAiYAJgAAAQcBTADBAVIACLMBIgUmACs1//8Ac//sA6EGIQImAEYAAAEGAUzzAAAIswEiESYAKzX//wDJAAAFWAdzAiYAJwAAAQcBTABYAVIACLMCHQUmACs1//8Ac//sBYEGFAImAEcAAAEHAjgDDAAAAAeyAiMAAD81AP//AC8AAAVIBbYCBgCSAAAAAgBz/+wE0wYUABoAJwBkQDclBhIOAB4eFRkWGRAGBCgpGhUYEBEQR1kVDxEfES8RAwkDEREJEwABDAMJCSJGWQkQAxtGWQMWAD8rABg/KxESADk5GD8SOS9fXl0zKxEAMxg/ERIBFzkRMzMRMzMzETMxMCUjBiMiAhEQEjMyFzMmNTUhNSE1MxUzFSMRIyUyNjU1NCYjIgYVFBYDmglz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AAizAhkRJgArNf//AH3/7AW+B3MCJgAyAAABBwFTARQBUgAKtAMCKwUmACs1Nf//AHP/7ARiBiECJgBSAAABBgFTWgAACrQDAiwRJgArNTUAAgB9/+wG5wXNABQAHwBTQC4YBg8TEx0ADREdBgUgIQ8SSVkPDwALCw5JWQsDCRVJWQkEAxtJWQMSABNJWQASAD8rABg/KwAYPysAGD8rERIAORgvKxESARc5ETMRMxEzMTAhIQYjIAAREAAhMhchFSERIRUhESEBIgAREAAzMjcRJgbn/QBmXP65/p8BXAFAZloDDv2zAif92QJN/ET5/v8BAfdwV1cUAYkBagFoAYYXl/4plv3mBJ3+z/7Z/tf+zSEEdR4AAwBx/+wHHwRaAB4AKgAxAFVALR8IDgIWFiUvFRUcJQgEMjMrKAsoRlkuFkZZAgUOCy4uBRELEBgiBSJGWQAFFgA/MysRADMYPzMSOS8SORI5KysRADMREgEXOREzETMSOTkRMzEwBSAnBgYjIgAREAAzMhYXNjYzMhIVFSESITI2NxUGBgEUFjMyNjU0JiMiBiUiBgchNCYFlv7bfT7Rid/+9AEG64PNPjrAfsnu/ScIAUpeoVdYmPshmKejmZulppUER3+RDAIghBTrdHcBMQEIAQkBLHdycHn+9+Jp/ncjJ5QnIAI509vV0d3V2Niknp6k//8AyQAABM8HcwImADUAAAEHAHYAeQFSAAizAh8FJgArNf//ALAAAAMnBiECJgBVAAABBgB23AAACLMBGhEmACs1//8Ayf47BM8FtgImADUAAAAGAjl9AP//AGD+OwMnBFwCJgBVAAAABwI5/u8AAP//AMkAAATPB3MCJgA1AAABBwFMABsBUgAIswIhBSYAKzX//wCCAAADJwYhAiYAVQAAAQcBTP92AAAACLMBHBEmACs1//8Aav/sBAIHcwImADYAAAEHAHYAUAFSAAizAS4FJgArNf//AGr/7ANzBiECJgBWAAABBgB26gAACLMBLhEmACs1//8Aav/sBAIHcwImADYAAAEHAUv/6gFSAAizATMFJgArNf//AGr/7ANzBiECJgBWAAABBgFLlwAACLMBMxEmACs1//8Aav4UBAIFywImADYAAAAHAHoBJwAA//8Aav4UA3MEXAImAFYAAAAHAHoA1QAA//8Aav/sBAIHcwImADYAAAEH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WONZAlkhWUBZdVm3WfxaTVpuWtNbJ1snWydbJ1snWydbJ1snWydbJ1snWydbJ1snXHFczFzdXOVdbF2nXgteHF4tXjleRV5XXoxew17TXuNfQF+XX+BgMWA6YENgTGB6YJlgqmC7YMtg22FOYZlh7WI7Ypti/mM/Y4Bj1mQsZI9k9GVpZeBmjGcwZzhnQGedZ/ZoL2hnaHloi2kBaQ1pgGnzap1rO2vRbDpsfWy/bQNtM21gbYZtrG6QbxtvgW/fcDFwgnDXcUNxe3G0cgZyVXKocvtzB3MTc1BzjHPNdBB0WHSsdOZ1HnVddaJ13XYddnN2xndCd7l3xXfReAJ4NHg8eG94rXjxeTB5cXmueex6MHpzer97C3tDe3p76HxLfMF9LX01fUZ9V32sffx+RH6Hfsx/FX9Vf5Z/2oAegG+AvYDFgNaA5oD4gQmBEYEZgSqBOoGLgdqB7IH9gg+CIYIzgkSCkILaguuC+4MNgx6DMINBg0mDUYNjg3SDhoOXg6iDuIPKg9uD7YP+hBCEIYRMhHeEiYSbhKeEsoS+hMqFEIVWhZSFnIX2hmSGyYcnh4GH1IgriHmIxIkTiWaJsInvii2KioqSip6Kqoq2isKK04rkivaLCIsaiyyLPotQi2KLdIuJi52Lr4vBi9OL5Yv3jAmMG4wtjEKMVoxijG6Mf4yQjKGMsYzDjNWM54z5jQuNHY0vjUGNVo1qjXuNjI2YjaSNsI28jc2N3o3wjgKOFI4mjjiOSo5cjm6Og46XjqiOuI7JjtmO6o77jwyPHI8ojzSPQI9Mj12Pbo9/j4+PoI+wj8GP0o/jj/OP/5ALkBeQI5A0kEWQVpBmkHKQppDhkR2RapHCkfqSMpJ7ks2S9ZMYkzuTRJODk62T7pROlJOU3pTmlQmVEZVulXqV9pYClg6WcZaBlpGWopaylseW2JbplvqXDJcdly6XP5dKl1uXZ5d5l4GXk5ebl62XtZe9l86X2gAAAAEAAAABGduJ7j3fXw889QAJCAAAAAAAyTUxiwAAAADVK8zV+5r91QmiCGIAAAAJAAIAAAAAAAAEzQDBAAAAAAQUAAACFAAAAiMAmAM1AIUFKwAzBJMAgwaWAGgF1wBxAcUAhQJeAFICXgA9BGoAVgSTAGgB9gA/ApMAVAIhAJgC8AAUBJMAZgSTALwEkwBkBJMAXgSTACsEkwCFBJMAdQSTAF4EkwBoBJMAagIhAJgCIQA/BJMAaASTAHcEkwBoA28AGwcxAHkFEAAABS8AyQUMAH0F1QDJBHMAyQQhAMkF0wB9BecAyQKqAFQCI/9gBOkAyQQnAMkHOQDJBggAyQY7AH0E0QDJBjsAfQTyAMkEZABqBG0AEgXTALoEwwAAB2gAGwSeAAgEewAABJEAUgKiAKYC8AAXAqIAMwRWADEDlv/8BJ4BiQRzAF4E5wCwA88AcwTnAHMEfQBzArYAHQRiACcE6QCwAgYAogIG/5EEMwCwAgYAsAdxALAE6QCwBNUAcwTnALAE5wBzA0QAsAPRAGoC0wAfBOkApAQCAAAGOQAXBDEAJwQIAAIDvgBSAwgAPQRoAe4DCABIBJMAaAIUAAACIwCYBJMAvgSTAD8EkwB7BJMAHwRoAe4EIQB7BJ4BNQaoAGQC1QBGA/oAUgSTAGgCkwBUBqgAZAQA//oDbQB/BJMAaALHADECxwAhBJ4BiQT0ALAFPQBxAiEAmAHRACUCxwBMAwAAQgP6AFAGPQBLBj0ALgY9ABoDbwAzBRAAAAUQAAAFEAAABRAAAAUQAAAFEAAABvz//gUMAH0EcwDJBHMAyQRzAMkEcwDJAqoAPAKqAFQCqv//AqoAPAXHAC8GCADJBjsAfQY7AH0GOwB9BjsAfQY7AH0EkwCFBjsAfQXTALoF0wC6BdMAugXTALoEewAABOMAyQT6ALAEcwBeBHMAXgRzAF4EcwBeBHMAXgRzAF4G3QBeA88AcwR9AHMEfQBzBH0AcwR9AHMCBv/aAgYAqQIG/7MCBv/sBMUAcQTpALAE1QBzBNUAcwTVAHME1QBzBNUAcwSTAGgE1QBzBOkApATpAKQE6QCkBOkApAQIAAIE5wCwBAgAAgUQAAAEcwBeBRAAAARzAF4FEAAABHMAXgUMAH0DzwBzBQwAfQPPAHMFDAB9A88AcwUMAH0DzwBzBdUAyQTnAHMFxwAvBOcAcwRzAMkEfQBzBHMAyQR9AHMEcwDJBH0AcwRzAMkEfQBzBHMAyQR9AHMF0wB9BGIAJwXTAH0EYgAnBdMAfQRiACcF0wB9BGIAJwXnAMkE6QCwBecAAATpABQCqv/iAgb/kAKqACoCBv/aAqoAHgIG/8wCqgBUAgYANQKqAFQCBgCwBM0AVAQMAKICI/9gAgb/kQTpAMkEMwCwBCUAsAQnAMkCBgCjBCcAyQIGAFkEJwDJAgYAsAQnAMkCgwCwBC8AHQIX//wGCADJBOkAsAYIAMkE6QCwBggAyQTpALAFcwABBggAyQTpALAGOwB9BNUAcwY7AH0E1QBzBjsAfQTVAHMHYgB9B4kAcQTyAMkDRACwBPIAyQNEAGAE8gDJA0QAggRkAGoD0QBqBGQAagPRAGoEZABqA9EAagRkAGoD0QBqBG0AEgLTAB8EbQASAtMAHwRtABIC0wAfBdMAugTpAKQF0wC6BOkApAXTALoE6QCkBdMAugTpAKQF0wC6BOkApAXTALoE6QCkB2gAGwY5ABcEewAABAgAAgR7AAAEkQBSA74AUgSRAFIDvgBSBJEAUgO+AFICjwCwBJ4AwwUUAAAEcwBeBvz//gbdAF4GOwB9BNUAcwRkAGoD0QBqBLwBDAS8AQwEsgEtBLwBJQIGAKIEngFvAZMAJQS8AQgEngDnBJ4B/ASeARsFEAAAAiEAmATy/9QGff/UA5j/5AaB/+QFhf/UBoH/5AK2/+kFEAAABS8AyQQpAMkEkwAnBHMAyQSRAFIF5wDJBjsAfQKqAFQE6QDJBNMAAAc5AMkGCADJBG0ASAY7AH0F1QDJBNEAyQSJAEoEbQASBHsAAAZiAGoEngAIBl4AbQZCAFACqgA8BHsAAATjAHMDzQBaBOkAsAK2AKgE3wCkBOMAcwUGALAEGQAKBKQAcQPNAFoD3QBzBOkAsAS8AHMCtgCoBCUAsARG//IE9ACwBFYAAAPNAHEE1QBzBTMAGQTVAKYD2wBzBOcAcwPJABIE3wCkBb4AcwRe/+wGBgCkBi8AcwK2AAkE3wCkBNUAcwTfAKQGLwBzBHMAyQXfABIEKQDJBR0AfQRkAGoCqgBUAqoAPAIj/2AHbwAAB6AAyQXfABIE5QDJBPgAGwXVAMkFEAAABOcAyQUvAMkEKQDJBXcADgRzAMkGwQACBKYASgYZAMsGGQDLBOUAyQWiAAAHOQDJBecAyQY7AH0F1QDJBNEAyQUMAH0EbQASBPgAGwZiAGoEngAIBeUAyQWPAKoIQgDJCEQAyQWBABIG0wDJBSUAyQUKAD0IZgDJBRcAMwRzAF4ExQB3BI0AsANtALAEkwApBH0AcwXjAAQD3QBEBRIAsAUSALAEJwCwBJEAEAXhALAFEgCwBNUAcwT4ALAE5wCw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ACAAZABhAHQAYQAgAGMAbwBwAHkAcgBpAGcAaAB0ACAAqQAgADIAMAAxADAALQAyADAAMQAxACwAIABHAG8AbwBnAGwAZQAgAEMAbwByAHAAbwByAGEAdABpAG8AbgAuAE8AcABlAG4AIABTAGEAbgBzAFIAZQBnAHUAbABhAHIAMQAuADEAMAA7ADEAQQBTAEMAOwBPAHAAZQBuAFMAYQBuAHMALQBSAGUAZwB1AGwAYQByAE8AcABlAG4AIABTAGEAbgBzACAAUgBlAGcAdQBsAGEAcgBWAGUAcgBzAGkAbwBuACAAMQAuADEAMABPAHAAZQBuAFMAYQBuAHMALQBSAGUAZwB1AGwAYQByAGgAdAB0AHAAOgAvAC8AdwB3AHcALgBhAHAAYQBjAGgAZQAuAG8AcgBnAC8AbABpAGMAZQBuAHMAZQBzAC8ATABJAEMARQBOAFMARQAtADIALgAwAAAAAgAAAAAAAP9mAGYAAAAAAAAAAAAAAAAAAAAAAAAAAAOqAAABAgACAAMABAAFAAYABwAIAAkACgALAAwADQAOAA8AEAARABIAEwAUABUAFgAXABgAGQAaABsAHAAdAB4AHwAgACEAIgAjACQAJQAmACcAKAApACoAKwEDAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAOgA7ADwAPQA+AD8AQABBAEIAQwBEAEUARgBHAEgASQBKAEsATABNAE4ATwBQAFEAUgBTAFQAVQBWAFcAWABZAFoAWwBcAF0AXgBfAGAAYQCsAKMAhACFAL0AlgDoAIYAjgCLAJ0AqQCkAQQAigEFAIMAkwDyAPMAjQCXAIgAwwDeAPEAngCqAPUA9AD2AKIArQDJAMcArgBiAGMAkABkAMsAZQDIAMoBBgEHAQgBCQDpAGYA0wDQANEArwBnAPAAkQDWANQA1QBoAOsA7QCJAGoAaQBrAG0AbABuAKAAbwBxAHAAcgBzAHUAdAB2AHcA6gB4AHoAeQB7AH0AfAC4AKEAfwB+AIAAgQDsAO4AugEKAQsBDAENAQ4BDwD9AP4BEAERARIBEwD/AQABFAEVARYBAQEXARgBGQEaARsBHAEdAR4BHwEgASEBIgD4APkBIwEkASUBJgEnASgBKQEqASsBLAEtAS4BLwEwATEBMgEzANcBNAE1ATYBNwE4ATkBOgE7ATwBPQE+AT8BQAFBAUIA4gDjAUMBRAFFAUYBRwFIAUkBSgFLAUwBTQFOAU8BUAFRALAAsQFSAVMBVAFVAVYBVwFYAVkBWgFbAPsA/ADkAOUBXAFdAV4BXwFgAWEBYgFjAWQBZQFmAWcBaAFpAWoBawFsAW0BbgFvAXABcQC7AXIBcwF0AXUA5gDnAXYApgF3AXgBeQF6AXsBfAF9AX4A2ADhANoA2wDcAN0A4ADZAN8BfwGAAYEBggGDAYQBhQGGAYcBiAGJAYoBiwGMAY0BjgGPAZABkQGSAZMBlAGVAZYBlwGYAZkBmgGbAZwBnQGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAasBrAGtAa4BrwGwAbEBsgGzAbQBtQG2AbcAmwG4AbkBugG7AbwBvQG+Ab8BwAHBAcIBwwHEAcUBxgHHAcgByQHKAcsBzAHNAc4BzwHQAdEB0gHTAdQB1QHWAdcB2AHZAdoB2wHcAd0B3gHfAeAB4QHiAeMB5AHlAeYB5wHoAekB6gHrAewB7QHuAe8B8AHxAfIB8wH0AfUB9gH3AfgB+QH6AfsB/AH9Af4B/wIAAgECAgIDAgQCBQIGAgcCCAIJAgoCCwIMAg0CDgIPAhACEQISAhMCFAIVAhYCFwIYAhkCGgIbAhwCHQIeAh8CIAIhAiICIwIkAiUCJgInAigCKQIqAisAsgCzAiwCLQC2ALcAxAIuALQAtQDFAIIAwgCHAKsAxgIvAjAAvgC/AjEAvAIyAPcCMwI0AjUCNgI3AjgAjACfAjkCOgI7AjwCPQCYAKgAmgCZAO8ApQCSAJwApwCPAJQAlQC5Aj4CPwJAAkECQgJDAkQCRQJGAkcCSAJJAkoCSwJMAk0CTgJPAlACUQJSAlMCVAJVAlYCVwJYAlkCWgJbAlwCXQJeAl8CYAJhAmICYwJkAmUCZgJnAmgCaQJqAmsCbAJtAm4CbwJwAnECcgJzAnQCdQJ2AncCeAJ5AnoCewJ8An0CfgJ/AoACgQKCAoMChAKFAoYChwKIAokCigKLAowCjQKOAo8CkAKRApICkwKUApUClgKXApgCmQKaApsCnAKdAp4CnwKgAqECogKjAqQCpQKmAqcCqAKpAqoCqwKsAq0CrgKvArACsQKyArMCtAK1ArYCtwK4ArkCugK7ArwCvQK+Ar8CwALBAsICwwLEAsUCxgLHAsgCyQLKAssCzALNAs4CzwLQAtEC0gLTAtQC1QLWAtcC2ALZAtoC2wLcAt0C3gLfAuAC4QLiAuMC5ALlAuYC5wLoAukC6gLrAuwC7QLuAu8C8ALxAvIC8wL0AvUC9gL3AvgC+QL6AvsC/AL9Av4C/wMAAwEDAgMDAwQDBQMGAwcDCAMJAwoDCwMMAw0DDgMPAxADEQMSAxMDFAMVAxYDFwMYAxkDGgMbAxwDHQMeAx8DIAMhAyIDIwMkAyUDJgMnAygDKQMqAysDLAMtAy4DLwMwAzEDMgMzAzQDNQM2AzcDOAM5AzoDOwM8Az0DPgM/A0ADQQNCA0MDRANFA0YDRwNIA0kDSgNLA0wDTQNOA08DUANRA1IDUwNUA1UDVgNXA1gDWQNaA1sDXANdA14DXwNgA2EDYgNjA2QDZQNmA2cDaANpA2oDawNsA20DbgNvA3ADcQNyA3MDdAN1A3YDdwN4A3kDegN7A3wDfQN+A38DgAOBA4IDgwOEA4UDhgOHA4gDiQOKA4sDjAONA44DjwOQA5EDkgOTA5QDlQOWA5cDmAOZA5oDmwOcA50DngOfACwAzwDMAM0AzgOgA6EDogOjAPoDpAOlA6YDpwOoA6kDqgOrA6wDrQRudWxsBUkuYWx0B3VuaTAwQUQJb3ZlcnNjb3JlCklncmF2ZS5hbHQKSWFjdXRlLmFsdA9JY2lyY3VtZmxleC5hbHQNSWRpZXJlc2lzLmFsdAdBbWFjcm9uB2FtYWNyb24GQWJyZXZlBmFicmV2ZQdBb2dvbmVrB2FvZ29uZWsLQ2NpcmN1bWZsZXgLY2NpcmN1bWZsZXgEQ2RvdARjZG90BkRjYXJvbgZkY2Fyb24GRGNyb2F0B0VtYWNyb24HZW1hY3JvbgZFYnJldmUGZWJyZXZlCkVkb3RhY2NlbnQKZWRvdGFjY2VudAdFb2dvbmVrB2VvZ29uZWsGRWNhcm9uBmVjYXJvbgtHY2lyY3VtZmxleAtnY2lyY3VtZmxleARHZG90BGdkb3QMR2NvbW1hYWNjZW50DGdjb21tYWFjY2VudAtIY2lyY3VtZmxleAtoY2lyY3VtZmxleARIYmFyBGhiYXIKSXRpbGRlLmFsdAZpdGlsZGULSW1hY3Jvbi5hbHQHaW1hY3JvbgpJYnJldmUuYWx0BmlicmV2ZQtJb2dvbmVrLmFsdAdpb2dvbmVrDklkb3RhY2NlbnQuYWx0BklKLmFsdAJpagtKY2lyY3VtZmxleAtqY2lyY3VtZmxleAxLY29tbWFhY2NlbnQMa2NvbW1hYWNjZW50DGtncmVlbmxhbmRpYwZMYWN1dGUGbGFjdXRlDExjb21tYWFjY2VudAxsY29tbWFhY2NlbnQGTGNhcm9uBmxjYXJvbgRMZG90BGxkb3QGTmFjdXRlBm5hY3V0ZQxOY29tbWFhY2NlbnQMbmNvbW1hYWNjZW50Bk5jYXJvbgZuY2Fyb24LbmFwb3N0cm9waGUDRW5nA2VuZwdPbWFjcm9uB29tYWNyb24GT2JyZXZlBm9icmV2ZQ1PaHVuZ2FydW1sYXV0DW9odW5nYXJ1bWxhdXQGUmFjdXRlBnJhY3V0ZQxSY29tbWFhY2NlbnQMcmNvbW1hYWNjZW50BlJjYXJvbgZyY2Fyb24GU2FjdXRlBnNhY3V0ZQtTY2lyY3VtZmxleAtzY2lyY3VtZmxleAxUY29tbWFhY2NlbnQMdGNvbW1hYWNjZW50BlRjYXJvbgZ0Y2Fyb24EVGJhcgR0YmFyBlV0aWxkZQZ1dGlsZGUHVW1hY3Jvbgd1bWFjcm9uBlVicmV2ZQZ1YnJldmUFVXJpbmcFdXJpbmcNVWh1bmdhcnVtbGF1dA11aHVuZ2FydW1sYXV0B1VvZ29uZWsHdW9nb25lawtXY2lyY3VtZmxleAt3Y2lyY3VtZmxleAtZY2lyY3VtZmxleAt5Y2lyY3VtZmxleAZaYWN1dGUGemFjdXRlClpkb3RhY2NlbnQKemRvdGFjY2VudAVsb25ncwpBcmluZ2FjdXRlCmFyaW5nYWN1dGUHQUVhY3V0ZQdhZWFjdXRlC09zbGFzaGFjdXRlC29zbGFzaGFjdXRlDFNjb21tYWFjY2VudAxzY29tbWFhY2NlbnQFdG9ub3MNZGllcmVzaXN0b25vcwpBbHBoYXRvbm9zCWFub3RlbGVpYQxFcHNpbG9udG9ub3MIRXRhdG9ub3MNSW90YXRvbm9zLmFsdAxPbWljcm9udG9ub3MMVXBzaWxvbnRvbm9zCk9tZWdhdG9ub3MRaW90YWRpZXJlc2lzdG9ub3MFQWxwaGEEQmV0YQVHYW1tYQd1bmkwMzk0B0Vwc2lsb24EWmV0YQNFdGEFVGhldGEISW90YS5hbHQFS2FwcGEGTGFtYmRhAk11Ak51AlhpB09taWNyb24CUGkDUmhvBVNpZ21hA1RhdQdVcHNpbG9uA1BoaQNDaGkDUHNpB3VuaTAzQTkQSW90YWRpZXJlc2lzLmFsdA9VcHNpbG9uZGllcmVzaXMKYWxwaGF0b25vcwxlcHNpbG9udG9ub3MIZXRhdG9ub3MJaW90YXRvbm9zFHVwc2lsb25kaWVyZXNpc3Rvbm9zBWFscGhhBGJldGEFZ2FtbWEFZGVsdGEHZXBzaWxvbgR6ZXRhA2V0YQV0aGV0YQRpb3RhBWthcHBhBmxhbWJkYQd1bmkwM0JDAm51AnhpB29taWNyb24DcmhvBnNpZ21hMQVzaWdtYQN0YXUHdXBzaWxvbgNwaGkDY2hpA3BzaQVvbWVnYQxpb3RhZGllcmVzaXMPdXBzaWxvbmRpZXJlc2lzDG9taWNyb250b25vcwx1cHNpbG9udG9ub3MKb21lZ2F0b25vcwlhZmlpMTAwMjMJYWZpaTEwMDUxCWFmaWkxMDA1MglhZmlpMTAwNTMJYWZpaTEwMDU0DWFmaWkxMDA1NS5hbHQNYWZpaTEwMDU2LmFsdAlhZmlpMTAwNTcJYWZpaTEwMDU4CWFmaWkxMDA1OQlhZmlpMTAwNjAJYWZpaTEwMDYxCWFmaWkxMDA2MglhZmlpMTAxNDUJYWZpaTEwMDE3CWFmaWkxMDAxOAlhZmlpMTAwMTkJYWZpaTEwMDIwCWFmaWkxMDAyMQlhZmlpMTAwMjIJYWZpaTEwMDI0CWFmaWkxMDAyNQlhZmlpMTAwMjYJYWZpaTEwMDI3CWFmaWkxMDAyOAlhZmlpMTAwMjkJYWZpaTEwMDMwCWFmaWkxMDAzMQlhZmlpMTAwMzIJYWZpaTEwMDMzCWFmaWkxMDAzNAlhZmlpMTAwMzUJYWZpaTEwMDM2CWFmaWkxMDAzNwlhZmlpMTAwMzgJYWZpaTEwMDM5CWFmaWkxMDA0MAlhZmlpMTAwNDEJYWZpaTEwMDQyCWFmaWkxMDA0MwlhZmlpMTAwNDQJYWZpaTEwMDQ1CWFmaWkxMDA0NglhZmlpMTAwNDcJYWZpaTEwMDQ4CWFmaWkxMDA0OQlhZmlpMTAwNjUJYWZpaTEwMDY2CWFmaWkxMDA2NwlhZmlpMTAwNjgJYWZpaTEwMDY5CWFmaWkxMDA3MAlhZmlpMTAwNzIJYWZpaTEwMDczCWFmaWkxMDA3NAlhZmlpMTAwNzUJYWZpaTEwMDc2CWFmaWkxMDA3NwlhZmlpMTAwNzgJYWZpaTEwMDc5CWFmaWkxMDA4MAlhZmlpMTAwODEJYWZpaTEwMDgyCWFmaWkxMDA4MwlhZmlpMTAwODQJYWZpaTEwMDg1CWFmaWkxMDA4NglhZmlpMTAwODcJYWZpaTEwMDg4CWFmaWkxMDA4OQlhZmlpMTAwOTAJYWZpaTEwMDkxCWFmaWkxMDA5MglhZmlpMTAwOTMJYWZpaTEwMDk0CWFmaWkxMDA5NQlhZmlpMTAwOTYJYWZpaTEwMDk3CWFmaWkxMDA3MQlhZmlpMTAwOTkJYWZpaTEwMTAwCWFmaWkxMDEwMQlhZmlpMTAxMDIJYWZpaTEwMTAzCWFmaWkxMDEwNAlhZmlpMTAxMDUJYWZpaTEwMTA2CWFmaWkxMDEwNwlhZmlpMTAxMDgJYWZpaTEwMTA5CWFmaWkxMDExMAlhZmlpMTAxOTMJYWZpaTEwMDUwCWFmaWkxMDA5OAZXZ3JhdmUGd2dyYXZlBldhY3V0ZQZ3YWN1dGUJV2RpZXJlc2lzCXdkaWVyZXNpcwZZZ3JhdmUGeWdyYXZlCWFmaWkwMDIwOA11bmRlcnNjb3JlZGJsDXF1b3RlcmV2ZXJzZWQGbWludXRlBnNlY29uZAlleGNsYW1kYmwJbnN1cGVyaW9yCWFmaWkwODk0MQZwZXNldGEERXVybwlhZmlpNjEyNDgJYWZpaTYxMjg5CWFmaWk2MTM1Mgllc3RpbWF0ZWQJb25lZWlnaHRoDHRocmVlZWlnaHRocwtmaXZlZWlnaHRocwxzZXZlbmVpZ2h0aHMHdW5pRkIwMQd1bmlGQjAyDWN5cmlsbGljYnJldmUIZG90bGVzc2oQY2Fyb25jb21tYWFjY2VudAtjb21tYWFjY2VudBFjb21tYWFjY2VudHJvdGF0ZQx6ZXJvc3VwZXJpb3IMZm91cnN1cGVyaW9yDGZpdmVzdXBlcmlvcgtzaXhzdXBlcmlvcg1zZXZlbnN1cGVyaW9yDWVpZ2h0c3VwZXJpb3IMbmluZXN1cGVyaW9yB3VuaTIwMDAHdW5pMjAwMQd1bmkyMDAyB3VuaTIwMDMHdW5pMjAwNAd1bmkyMDA1B3VuaTIwMDYHdW5pMjAwNwd1bmkyMDA4B3VuaTIwMDkHdW5pMjAwQQd1bmkyMDBCB3VuaUZFRkYHdW5pRkZGQwd1bmlGRkZEB3VuaTAxRjAHdW5pMDJCQwd1bmkwM0QxB3VuaTAzRDIHdW5pMDNENgd1bmkxRTNFB3VuaTFFM0YHdW5pMUUwMAd1bmkxRTAxB3VuaTFGNEQHdW5pMDJGMwlkYXNpYW94aWEHdW5pRkIwMwd1bmlGQjA0BU9ob3JuBW9ob3JuBVVob3JuBXVob3JuB3VuaTAzMDAHdW5pMDMwMQd1bmkwMzAzBGhvb2sIZG90YmVsb3cHdW5pMDQwMAd1bmkwNDBEB3VuaTA0NTAHdW5pMDQ1RAd1bmkwNDYwB3VuaTA0NjEHdW5pMDQ2Mgd1bmkwNDYzB3VuaTA0NjQHdW5pMDQ2NQd1bmkwNDY2B3VuaTA0NjcHdW5pMDQ2OAd1bmkwNDY5B3VuaTA0NkEHdW5pMDQ2Qgd1bmkwNDZDB3VuaTA0NkQHdW5pMDQ2RQd1bmkwNDZGB3VuaTA0NzAHdW5pMDQ3MQd1bmkwNDcyB3VuaTA0NzMHdW5pMDQ3NAd1bmkwNDc1B3VuaTA0NzYHdW5pMDQ3Nwd1bmkwNDc4B3VuaTA0NzkHdW5pMDQ3QQd1bmkwNDdCB3VuaTA0N0MHdW5pMDQ3RAd1bmkwNDdFB3VuaTA0N0YHdW5pMDQ4MAd1bmkwNDgxB3VuaTA0ODIHdW5pMDQ4Mwd1bmkwNDg0B3VuaTA0ODUHdW5pMDQ4Ngd1bmkwNDg4B3VuaTA0ODkHdW5pMDQ4QQd1bmkwNDhCB3VuaTA0OEMHdW5pMDQ4RAd1bmkwNDhFB3VuaTA0OEYHdW5pMDQ5Mgd1bmkwNDkzB3VuaTA0OTQHdW5pMDQ5NQd1bmkwNDk2B3VuaTA0OTcHdW5pMDQ5OAd1bmkwNDk5B3VuaTA0OUEHdW5pMDQ5Qgd1bmkwNDlDB3VuaTA0OUQHdW5pMDQ5RQd1bmkwNDlGB3VuaTA0QTAHdW5pMDRBMQd1bmkwNEEyB3VuaTA0QTMHdW5pMDRBNAd1bmkwNEE1B3VuaTA0QTYHdW5pMDRBNwd1bmkwNEE4B3VuaTA0QTkHdW5pMDRBQQd1bmkwNEFCB3VuaTA0QUMHdW5pMDRBRAd1bmkwNEFFB3VuaTA0QUYHdW5pMDRCMAd1bmkwNEIxB3VuaTA0QjIHdW5pMDRCMwd1bmkwNEI0B3VuaTA0QjUHdW5pMDRCNgd1bmkwNEI3B3VuaTA0QjgHdW5pMDRCOQd1bmkwNEJBB3VuaTA0QkIHdW5pMDRCQwd1bmkwNEJEB3VuaTA0QkUHdW5pMDRCRgt1bmkwNEMwLmFsdAd1bmkwNEMxB3VuaTA0QzIHdW5pMDRDMwd1bmkwNEM0B3VuaTA0QzUHdW5pMDRDNgd1bmkwNEM3B3VuaTA0QzgHdW5pMDRDOQd1bmkwNENBB3VuaTA0Q0IHdW5pMDRDQwd1bmkwNENEB3VuaTA0Q0ULdW5pMDRDRi5hbHQHdW5pMDREMAd1bmkwNEQxB3VuaTA0RDIHdW5pMDREMwd1bmkwNEQ0B3VuaTA0RDUHdW5pMDRENgd1bmkwNEQ3B3VuaTA0RDgHdW5pMDREOQd1bmkwNERBB3VuaTA0REIHdW5pMDREQwd1bmkwNEREB3VuaTA0REUHdW5pMDRERgd1bmkwNEUwB3VuaTA0RTEHdW5pMDRFMgd1bmkwNEUzB3VuaTA0RTQHdW5pMDRFNQd1bmkwNEU2B3VuaTA0RTcHdW5pMDRFOAd1bmkwNEU5B3VuaTA0RUEHdW5pMDRFQgd1bmkwNEVDB3VuaTA0RUQHdW5pMDRFRQd1bmkwNEVGB3VuaTA0RjAHdW5pMDRGMQd1bmkwNEYyB3VuaTA0RjMHdW5pMDRGNAd1bmkwNEY1B3VuaTA0RjYHdW5pMDRGNwd1bmkwNEY4B3VuaTA0RjkHdW5pMDRGQQd1bmkwNEZCB3VuaTA0RkMHdW5pMDRGRAd1bmkwNEZFB3VuaTA0RkYHdW5pMDUwMAd1bmkwNTAxB3VuaTA1MDIHdW5pMDUwMwd1bmkwNTA0B3VuaTA1MDUHdW5pMDUwNgd1bmkwNTA3B3VuaTA1MDgHdW5pMDUwOQd1bmkwNTBBB3VuaTA1MEIHdW5pMDUwQwd1bmkwNTBEB3VuaTA1MEUHdW5pMDUwRgd1bmkwNTEwB3VuaTA1MTEHdW5pMDUxMgd1bmkwNTEzB3VuaTFFQTAHdW5pMUVBMQd1bmkxRUEyB3VuaTFFQTMHdW5pMUVBNAd1bmkxRUE1B3VuaTFFQTYHdW5pMUVBNwd1bmkxRUE4B3VuaTFFQTkHdW5pMUVBQQd1bmkxRUFCB3VuaTFFQUMHdW5pMUVBRAd1bmkxRUFFB3VuaTFFQUYHdW5pMUVCMAd1bmkxRUIxB3VuaTFFQjIHdW5pMUVCMwd1bmkxRUI0B3VuaTFFQjUHdW5pMUVCNgd1bmkxRUI3B3VuaTFFQjgHdW5pMUVCOQd1bmkxRUJBB3VuaTFFQkIHdW5pMUVCQwd1bmkxRUJEB3VuaTFFQkUHdW5pMUVCRgd1bmkxRUMwB3VuaTFFQzEHdW5pMUVDMgd1bmkxRUMzB3VuaTFFQzQHdW5pMUVDNQd1bmkxRUM2B3VuaTFFQzcLdW5pMUVDOC5hbHQHdW5pMUVDOQt1bmkxRUNBLmFsdAd1bmkxRUNCB3VuaTFFQ0MHdW5pMUVDRAd1bmkxRUNFB3VuaTFFQ0YHdW5pMUVEMAd1bmkxRUQxB3VuaTFFRDIHdW5pMUVEMwd1bmkxRUQ0B3VuaTFFRDUHdW5pMUVENgd1bmkxRUQ3B3VuaTFFRDgHdW5pMUVEOQd1bmkxRURBB3VuaTFFREIHdW5pMUVEQwd1bmkxRUREB3VuaTFFREUHdW5pMUVERgd1bmkxRUUwB3VuaTFFRTEHdW5pMUVFMgd1bmkxRUUzB3VuaTFFRTQHdW5pMUVFNQd1bmkxRUU2B3VuaTFFRTcHdW5pMUVFOAd1bmkxRUU5B3VuaTFFRUEHdW5pMUVFQgd1bmkxRUVDB3VuaTFFRUQHdW5pMUVFRQd1bmkxRUVGB3VuaTFFRjAHdW5pMUVGMQd1bmkxRUY0B3VuaTFFRjUHdW5pMUVGNgd1bmkxRUY3B3VuaTFFRjgHdW5pMUVGOQd1bmkyMEFCB3VuaTAzMEYTY2lyY3VtZmxleGFjdXRlY29tYhNjaXJjdW1mbGV4Z3JhdmVjb21iEmNpcmN1bWZsZXhob29rY29tYhNjaXJjdW1mbGV4dGlsZGVjb21iDmJyZXZlYWN1dGVjb21iDmJyZXZlZ3JhdmVjb21iDWJyZXZlaG9va2NvbWIOYnJldmV0aWxkZWNvbWIQY3lyaWxsaWNob29rbGVmdBFjeXJpbGxpY2JpZ2hvb2tVQxFjeXJpbGxpY2JpZ2hvb2tMQwhvbmUucG51bQd6ZXJvLm9zBm9uZS5vcwZ0d28ub3MIdGhyZWUub3MHZm91ci5vcwdmaXZlLm9zBnNpeC5vcwhzZXZlbi5vcwhlaWdodC5vcwduaW5lLm9zAmZmB3VuaTIxMjAIVGNlZGlsbGEIdGNlZGlsbGEFZy5hbHQPZ2NpcmN1bWZsZXguYWx0CmdicmV2ZS5hbHQIZ2RvdC5hbHQQZ2NvbW1hYWNjZW50LmFsdAZJdGlsZGUHSW1hY3JvbgZJYnJldmUHSW9nb25lawJJSglJb3RhdG9ub3MESW90YQxJb3RhZGllcmVzaXMJYWZpaTEwMDU1CWFmaWkxMDA1Ngd1bmkwNEMwB3VuaTA0Q0YHdW5pMUVDOAd1bmkxRUNBAAABAAMACAAKAA0AB///AA8AAQAAAAwAAAAAAAAAAgAFAAACNQABAjcCNwABAjsCWwABAl0DdgABA4IDqQABAAAAAQAAAAoADAAOAAAAAAAAAAEAAAAKAG4BWgABbGF0bgAIABAAAk1PTCAAKFJPTSAAQgAA//8ACQADAAgACwAAAA4AEQAUABcAGgAA//8ACgAEAAYACQAMAAEADwASABUAGAAbAAD//wAKAAUABwAKAA0AAgAQABMAFgAZABwAHWxpZ2EAsGxpZ2EAsGxpZ2EAsGxudW0AtmxudW0AtmxudW0AtmxvY2wAvGxvY2wAvG9udW0Awm9udW0Awm9udW0AwnBudW0AynBudW0AynBudW0AynNhbHQA0HNhbHQA0HNhbHQA0HNzMDEA0HNzMDEA0HNzMDEA0HNzMDIA2HNzMDIA2HNzMDIA2HNzMDMA3nNzMDMA3nNzMDMA3nRudW0A5HRudW0A5HRudW0A5AAAAAEACQAAAAEABwAAAAEACAAAAAIAAgADAAAAAQAEAAAAAgAAAAEAAAABAAAAAAABAAEAAAACAAUABgAKABYAPAB8AJQAzADgAO4BAgEuAVAAAQAAAAEACAACABAABQORA5IDkwOUA5UAAQAFAEoA3wDhAOMA5QABAAAAAQAIAAIALgAUACwAjgCPAJAAkQDqAOwA7gDwAPIA9AFaAWcBdwGhAaICyQLYA0UDRwACAAEDlgOpAAAAAQAAAAEACAABAAYDcAACAAEAEwAcAAAAAQAAAAEACAACABoACgODA4UDhgOHA4gDiQOKA4sDjAOEAAIAAwATABMAAAAVABwAAQOCA4IACQABAAAAAQAIAAEABgNuAAEAAQAUAAEAAAABAAgAAQA8/JAAAQAAAAEACAABAAb8kgABAAEDggABAAAAAQAIAAIAGgAKABMDggAVABYAFwAYABkAGgAbABwAAgABA4MDjAAAAAEAAAABAAgAAgAOAAQDjwOQASABIQABAAQBJAElAUkBSgAEAAAAAQAIAAEANgABAAgABQAMABQAHAAiACgCXgADAEkATwJdAAMASQBMA40AAgBJAjUAAgBPAjQAAgBMAAEAAQBJAAA=";

var openSansBold = "data:font/ttf;base64,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AiYARgAAAQYBS+8AAAizASMRJgArNf//AHf/7ATRB2YCJgAmAAABBwFPAdkBUgAIswEeBSYAKzX//wBc/+wD3QYUAiYARgAAAQcBTwE7AAAACLMBHREmACs1//8Ad//sBNEHcwImACYAAAEHAUwArAFSAAizARwFJgArNf//AFz/7AQfBiECJgBGAAABBgFMAAAACLMBGxEmACs1//8AuAAABXUHcwImACcAAAEHAUwAaAFSAAizAhUFJgArNf//AFz/7AYlBhQCJgBHAAAABwI4A28AAP//AC8AAAV1BbYCBgCSAAAAAgBc/+wFDAYUABsAKABgQDEOAx8KFxkQDAwVExcXKiYDAykJGgYABiNHWRYODw5KWRMPBg8GDxEYFREAABxHWQAWAD8rABg/PxI5OS8vETMrEQAzKxESADk5EQEzETMRMxEzMzMRMzMSOTkSOTEwBSICERASMzIWFzMmNTUhNSE1IRUzFSMRIycjBicyNjc1NCYjIgYVFBYB+MDcxuBsqTUKF/7FATsBMpub+EAMaExuaQRlhW9TZBQBIAECARoBDVRQg2Uzx6Ghx/tUkaXze5YcsIGKqZWWAP//ALgAAAQCBv4CJgAoAAABBwFN//cBUgAIswEPBSYAKzX//wBc/+wEYgWsAiYASAAAAQYBTfsAAAizAh8RJgArNf//ALgAAAQCB30CJgAoAAABBwFO/+oBUgAIswEPBSYAKzX//wBc/+wEYgYrAiYASAAAAQYBTgAAAAizAh8RJgArNf//ALgAAAQCB0kCJgAoAAABBwFPAS8BNQAIswETBSYAKzX//wBc/+wEYgYUAiYASAAAAQcBTwE/AAAACLMCIxEmACs1//8AuP4UBAIFtgImACgAAAAHAVECNQAA//8AXP4oBGIEcwImAEgAAAAHAVECPwAU//8ArwAABBQHcwImACgAAAEHAUz/9QFSAAizAREFJgArNf//AFz/7ARiBiECJgBIAAABBgFMAgAACLMCIREmACs1//8Ad//sBScHcwImACoAAAEHAUsAuAFSAAizASgFJgArNf//AAb+FARtBiECJgBKAAABBgFL3AAACLMDThEmACs1//8Ad//sBScHfQImACoAAAEHAU4AvgFSAAizAR4FJgArNf//AAb+FARtBisCJgBKAAABBgFO4gAACLMDRBEmACs1//8Ad//sBScHZgImACoAAAEHAU8B/AFSAAizASIFJgArNf//AAb+FARtBhQCJgBKAAABBwFPAQgAAAAIswNIESYAKzX//wB3/jsFJwXLAiYAKgAAAAcCOQEXAAD//wAG/hQEbQYhAiYASgAAAQYCOloAAAizA0URJgArNf//ALgAAAVmB3MCJgArAAABBwFLAKABUgAIswEZBSYAKzX//wCgAAAEqAeqAiYASwAAAQcBSwA1AYkAC7QBIyMKAAA/3hE1AAACAAAAAAYfBbYAEwAXAFFAKBQRBQUCAAQEGRcQCAgNCwkJGBcHTFkWAwsLEAAMFwwXDAkSDgMFCRIAPzM/MxI5OS8vETMzMxEzMysRATMRMzMzETMzETMRMzMzETMzMTABMxUjESERIREhESM1MzUhFSE1IQE1IRUFZrm5/sv9vf7KuLgBNgJDATX+y/29BPTH+9MCd/2JBC3HwsLC/cO0tAABAAQAAASoBhQAHABUQCoSCAEAAB4WCRMQCAgNCwkJHRYZBBkER1kTCwwLSlkQDBkMGQwJDgABCRUAPzM/Ejk5Ly8RMysRADMrERIAOREBMxEzMzMRMzMSOREzETMSOTEwISERNCMiBhURIREjNTM1IRUhFSEVFAczNjMyFhUEqP7PtH9z/s+cnAExATv+xQ4SZt7FygJQ8q/C/i8ErMehoccSU7ak0scA////8QAAAy4HYAImACwAAAEHAVL/IgFSAAizARAFJgArNf///5sAAALYBg4CJgDzAAABBwFS/swAAAAIswEIESYAKzX//wA/AAAC5Qb+AiYALAAAAQcBTf8kAVIACLMBDwUmACs1////6QAAAo8FrAImAPMAAAEHAU3+zgAAAAizAQcRJgArNf//AAcAAAMaB30CJgAsAAABBwFO/yQBUgAIswEPBSYAKzX///+vAAACwgYrAiYA8wAAAQcBTv7MAAAACLMBBxEmACs1//8AQv4UAtsFtgImACwAAAAGAVF3AP//ACv+FAHfBhQCJgBMAAAABgFRIQD//wBCAAAC2wdmAiYALAAAAQcBTwBUAVIACLMBEwUmACs1AAEAoAAAAdEEXgADABO3AAEBBAIPARUAPz8RATMRMzEwISERIQHR/s8BMQReAP//AEL+UgULBbYAJgAsAAAABwAtAx0AAP//AJP+FAQpBhQAJgBMAAAABwBNAkoAAP//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swISBSYAKzX//wBW/+wEOwakAiYARAAAAQcCZgTLAAAACLMCJxEmACs1//8AAAAABYUH0QImACQAAAEHA3cFIQFSAAq0AwIUBSYAKzU1//8AVv/sBP4GfwImAEQAAAEHA3cExQAAAAq0AwIpESYAKzU1//8AAAAABYUH0QImACQAAAEHA3gFHwFSAAq0AwIbBSYAKzU1////0//sBDsGfwImAEQAAAEHA3gExwAAAAq0AwIwESYAKzU1//8AAAAABYUISgImACQAAAEHA3kFIQFSAAq0AwInBSYAKzU1//8AVv/sBKgG+AImAEQAAAEHA3kEyQAAAAq0AwI8ESYAKzU1//8AAAAABYUIYgImACQAAAEHA3oFHQFSAAq0AwIsBSYAKzU1//8AVv/sBDsHEAImAEQAAAEHA3oExQAAAAq0AwJBESYAKzU1//8AAP5SBYUHcwImACQAAAAnAUsAWAFSAQcCZwVEAAAACrQCDg4FJgArETX//wBW/lIEOwYgAiYARAAAACYBS/v/AQcCZwTTAAAACrQCIyMRJgArETX//wAAAAAFhQgTAiYAJAAAAQcDewUpAVIACrQDAhkFJgArNTX//wBW/+wEOwbBAiYARAAAAQcDewTNAAAACrQDAi4RJgArNTX//wAAAAAFhQgTAiYAJAAAAQcDfAUnAVIACrQDAiAFJgArNTX//wBW/+wEOwbBAiYARAAAAQcDfATLAAAACrQDAjURJgArNTX//wAAAAAFhQhYAiYAJAAAAQcDfQUnAVIACrQDAisFJgArNTX//wBW/+wEOwcGAiYARAAAAQcDfQTNAAAACrQDAkARJgArNTX//wAAAAAFhQhiAiYAJAAAAQcDfgUnAVIACrQDAhcFJgArNTX//wBW/+wEOwcQAiYARAAAAQcDfgTNAAAACrQDAiwRJgArNTUABAAA/lIFhQd9AAcADQAbACQAACEDIQMhASEBAQImJwYDAQYGIyImJzMeAjMyNwE0MzIVFAYjIgQ3av3rav6yAgQBewIG/f6TJQghnAJGDNymrs8IqgQvVVXOEP5/pqZUUqYBXP6kBbz6RAJgAdl8JID+BwUdmri2nC82GH33apaWR07//wBW/lIEOwYrAiYARAAAACcCZwTJAAABBgFO+wAACLMDLxEmACs1//8AuP5SBAIFtgImACgAAAAHAmcE2wAA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AkgAdQJSAD8EkQBYBJEAWASRAFgD0QAGBy0AZgWFAAAFYAC4BRkAdwXsALgEewC4BGQAuAXLAHcGHwC4Ax0AQgKm/2gFUAC4BIUAuAeLALgGgQC4Bl4AdwUGALgGXgB3BUgAuARoAF4EogApBgwArgUzAAAHvAAABVYAAAT+AAAEogAxAqYAjwNOAAwCpgAzBEIACANK//wE2wFMBNUAVgUQAKAEHQBcBRAAXAS6AFwDGQApBIUABgVCAKACcQCTAnH/fQT2AKACcQCgB9sAoAVCAKAE9ABcBRAAoAUQAFwDogCgA/oAXAN5AC8FQgCaBI0AAAbZABQEoAAKBI0AAAPnADcDJwAfBGgBxwMnAFIEkQBYAhQAAAJKAHUEkQCPBJEAUgSRAHEEkQAGBGgBxwPjAGoE2wEXBqgAZAMQAC8E7ABSBJEAWAKTAD0GqABkBAD/+gNtAFwEkQBYAwgALwMIADsE2wFMBUgAoAU9AHECSAB1AaT/2wMIAFwDGwA5BOwAUgcMAC4HDAAuBwwAWgPRAD0FhQAABYUAAAWFAAAFhQAABYUAAAWFAAAHngAABRkAdwR7ALgEewC4BHsArwR7ALgDHQAqAx0AQgMd/9wDHQA5BewALwaBALgGXgB3Bl4AdwZeAHcGXgB3Bl4AdwSRAIEGXgB3BgwArgYMAK4GDACuBgwArgT+AAAFBgC4BbAAoATVAFYE1QBWBNUAVgTVAFYE1QBWBNUAVgdWAFYEHQBcBLoAXAS6AFwEugBcBLoAXAJx/5sCcQCRAnH/hgJx/+ME9ABcBUIAoAT0AFwE9ABcBPQAXAT0AFwE9ABcBJEAWAT0AFwFQgCaBUIAmgVCAJoFQgCaBI0AAAUQAKAEjQAABYUAAATVAFYFhQAABNUAVgWFAAAE1QBWBRkAdwQdAFwFGQB3BB0AXAUZAHcEHQBcBRkAdwQdAFwF7AC4BRAAXAXsAC8FMQBcBHsAuAS6AFwEewC4BLoAXAR7ALgEugBcBHsAuAS6AFwEewCvBLoAXAXLAHcEhQAGBcsAdwSFAAYFywB3BIUABgXLAHcEhQAGBh8AuAVCAKAGHwAABUIABAMd//ECcf+bAx0APwJx/+kDHQAHAnH/rwMdAEICcQArAx0AQgJxAKAFwwBCBLoAkwKm/2gCcf99BVAAuAT2AKAE9gCgBIUAuAJxAKAEhQC4AnEAYwSFALgCcQCgBIUAuANtAKAEhQACAqQAAAaBALgFQgCgBoEAuAVCAKAGgQC4BUIAoAY7AAYGgQC4BUIAoAZeAHcE9ABcBl4AdwT0AFwGXgB3BPQAXAfJAHcH0wBcBUgAuAOiAKAFSAC4A6IAYwVIALgDogBTBGgAXgP6AFwEaABeA/oAXARoAF4D+gBcBGgAXgP6AFwEogApA3kALwSiACkDeQAvBKIAKQN5AC8GDACuBUIAmgYMAK4FQgCaBgwArgVCAJoGDACuBUIAmgYMAK4FQgCaBgwArgVCAJoHvAAABtkAFAT+AAAEjQAABP4AAASiADED5wA3BKIAMQPnADcEogAxA+cANwMQAKAEkQDFBYUAAATVAFYHngAAB1YAVgZeAHcE9ABcBGgAXgP6AFwE2wC6BNsAugTbARsE2wDjAnEAkwSeAVQBpgAKBNsAzwS0AJwEngHXBJ4AugWF/8gCSAB1BQr/nQau/50EGf+dBrD/xgYd/4gGSv/GA0L/yQWFAAAFYAC4BH0AuAVEADkEewC4BKIAMQYfALgGXgB3Ax0AQgVQALgFMwAAB4sAuAaBALgEkQBSBl4AdwX2ALgFBgC4BL4ATgSiACkE/gAABuEAXAVWAAAHAgBtBkoANwMdADkE/gAABS0AXARxAE4FQgCgA0IAoAUpAI8FLQBcBUgAoASLAAIE9ABcBHEATgP8AFwFQgCgBPIAXANCAKAE9gCgBOwACAVIAKAEwwAGA/wAXAT0AFwF6QAZBPIAeQP8AFwFOQBcBE4AKQUpAI8GVgBcBLz/zwayAI8G5wBtA0IADAUpAI8E9ABcBSkAjwbnAG0EewC4BnEAKQR9ALgFagB3BGgAXgMdAEIDHQA5Aqb/aAf+ABAIBAC4BnEAKQVgALgFOQAABfYAuAWFAAAFGwC4BWAAuAR9ALgGHQAKBHsAuAeLAAAFLwBeBpYAuAaWALgFYAC4BfYAEAeLALgGHwC4Bl4AdwX2ALgFBgC4BRkAdwSiACkFOQAABuEAXAVWAAAGPwC4BdMAbQigALgI6QC4BdEAAAc/ALgFGwC4BU4ASAiPALgFUv/2BNUAVgT6AFwFHQCgA9MAoAVQAB0EugBcBvwAAARxAE4FwwCgBcMAoAT0AKAFKQAABsEAoAVMAKAE9ABcBTcAoAUQAKAEHQBcBG0ALwSNAAAGgwBc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AGkAZwBpAHQAaQB6AGUAZAAgAGQAYQB0AGEAIABjAG8AcAB5AHIAaQBnAGgAdAAgAKkAIAAyADAAMQAwAC0AMgAwADEAMQAsACAARwBvAG8AZwBsAGUAIABDAG8AcgBwAG8AcgBhAHQAaQBvAG4ALgBPAHAAZQBuACAAUwBhAG4AcwBCAG8AbABkADEALgAxADAAOwAxAEEAUwBDADsATwBwAGUAbgBTAGEAbgBzAC0AQgBvAGwAZABPAHAAZQBuACAAUwBhAG4AcwAgAEIAbwBsAGQAVgBlAHIAcwBpAG8AbgAgADEALgAxADAATwBwAGUAbgBTAGEAbgBzAC0AQgBvAGwAZABoAHQAdABwADoALwAvAHcAdwB3AC4AYQBwAGEAYwBoAGUALgBvAHIAZwAvAGwAaQBjAGUAbgBzAGUAcwAvAEwASQBDAEUATgBTAEUALQAyAC4AMAAAAAIAAAAAAAD/ZgBmAAAAAAAAAAAAAAAAAAAAAAAAAAADqgAAAQIAAgADAAQABQAGAAcACAAJAAoACwAMAA0ADgAPABAAEQASABMAFAAVABYAFwAYABkAGgAbABwAHQAeAB8AIAAhACIAIwAkACUAJgAnACgAKQAqACsBAwAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5ADoAOwA8AD0APgA/AEAAQQBCAEMARABFAEYARwBIAEkASgBLAEwATQBOAE8AUABRAFIAUwBUAFUAVgBXAFgAWQBaAFsAXABdAF4AXwBgAGEArACjAIQAhQC9AJYA6ACGAI4AiwCdAKkApAEEAIoBBQCDAJMA8gDzAI0AlwCIAMMA3gDxAJ4AqgD1APQA9gCiAK0AyQDHAK4AYgBjAJAAZADLAGUAyADKAQYBBwEIAQkA6QBmANMA0ADRAK8AZwDwAJEA1gDUANUAaADrAO0AiQBqAGkAawBtAGwAbgCgAG8AcQBwAHIAcwB1AHQAdgB3AOoAeAB6AHkAewB9AHwAuAChAH8AfgCAAIEA7ADuALoBCgELAQwBDQEOAQ8A/QD+ARABEQESARMA/wEAARQBFQEWAQEBFwEYARkBGgEbARwBHQEeAR8BIAEhASIA+AD5ASMBJAElASYBJwEoASkBKgErASwBLQEuAS8BMAExATIBMwDXATQBNQE2ATcBOAE5AToBOwE8AT0BPgE/AUABQQFCAOIA4wFDAUQBRQFGAUcBSAFJAUoBSwFMAU0BTgFPAVABUQCwALEBUgFTAVQBVQFWAVcBWAFZAVoBWwD7APwA5ADlAVwBXQFeAV8BYAFhAWIBYwFkAWUBZgFnAWgBaQFqAWsBbAFtAW4BbwFwAXEAuwFyAXMBdAF1AOYA5wF2AKYBdwF4AXkBegF7AXwBfQF+ANgA4QDaANsA3ADdAOAA2QDfAX8BgAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AJsBuAG5AboBuwG8Ab0BvgG/AcABwQHCAcMBxAHFAcYBxwHIAckBygHLAcwBzQHOAc8B0AHRAdIB0wHUAdUB1gHXAdgB2QHaAdsB3AHdAd4B3wHgAeEB4gHjAeQB5QHmAecB6AHpAeoB6wHsAe0B7gHvAfAB8QHyAfMB9AH1AfYB9wH4AfkB+gH7AfwB/QH+Af8CAAIBAgICAwIEAgUCBgIHAggCCQIKAgsCDAINAg4CDwIQAhECEgITAhQCFQIWAhcCGAIZAhoCGwIcAh0CHgIfAiACIQIiAiMCJAIlAiYCJwIoAikCKgIrALIAswIsAi0AtgC3AMQCLgC0ALUAxQCCAMIAhwCrAMYCLwIwAL4AvwIxALwCMgD3AjMCNAI1AjYCNwI4AIwAnwI5AjoCOwI8Aj0AmACoAJoAmQDvAKUAkgCcAKcAjwCUAJUAuQI+Aj8CQAJBAkICQwJEAkUCRgJHAkgCSQJKAksCTAJNAk4CTwJQAlECUgJTAlQCVQJWAlcCWAJZAloCWwJcAl0CXgJfAmACYQJiAmMCZAJlAmYCZwJoAmkCagJrAmwCbQJuAm8CcAJxAnICcwJ0AnUCdgJ3AngCeQJ6AnsCfAJ9An4CfwKAAoECggKDAoQChQKGAocCiAKJAooCiwKMAo0CjgKPApACkQKSApMClAKVApYClwKYApkCmgKbApwCnQKeAp8CoAKhAqICowKkAqUCpgKnAqgCqQKqAqsCrAKtAq4CrwKwArECsgKzArQCtQK2ArcCuAK5AroCuwK8Ar0CvgK/AsACwQLCAsMCxALFAsYCxwLIAskCygLLAswCzQLOAs8C0ALRAtIC0wLUAtUC1gLXAtgC2QLaAtsC3ALdAt4C3wLgAuEC4gLjAuQC5QLmAucC6ALpAuoC6wLsAu0C7gLvAvAC8QLyAvMC9AL1AvYC9wL4AvkC+gL7AvwC/QL+Av8DAAMBAwIDAwMEAwUDBgMHAwgDCQMKAwsDDAMNAw4DDwMQAxEDEgMTAxQDFQMWAxcDGAMZAxoDGwMcAx0DHgMfAyADIQMiAyMDJAMlAyYDJwMoAykDKgMrAywDLQMuAy8DMAMxAzIDMwM0AzUDNgM3AzgDOQM6AzsDPAM9Az4DPwNAA0EDQgNDA0QDRQNGA0cDSANJA0oDSwNMA00DTgNPA1ADUQNSA1MDVANVA1YDVwNYA1kDWgNbA1wDXQNeA18DYANhA2IDYwNkA2UDZgNnA2gDaQNqA2sDbANtA24DbwNwA3EDcgNzA3QDdQN2A3cDeAN5A3oDewN8A30DfgN/A4ADgQOCA4MDhAOFA4YDhwOIA4kDigOLA4wDjQOOA48DkAORA5IDkwOUA5UDlgOXA5gDmQOaA5sDnAOdA54DnwAsAM8AzADNAM4DoAOhA6IDowD6A6QDpQOmA6cDqAOpA6oDqwOsA60EbnVsbAVJLmFsdAd1bmkwMEFECW92ZXJzY29yZQpJZ3JhdmUuYWx0CklhY3V0ZS5hbHQPSWNpcmN1bWZsZXguYWx0DUlkaWVyZXNpcy5hbHQHQW1hY3JvbgdhbWFjcm9uBkFicmV2ZQZhYnJldmUHQW9nb25lawdhb2dvbmVrC0NjaXJjdW1mbGV4C2NjaXJjdW1mbGV4BENkb3QEY2RvdAZEY2Fyb24GZGNhcm9uBkRjcm9hdAdFbWFjcm9uB2VtYWNyb24GRWJyZXZlBmVicmV2ZQpFZG90YWNjZW50CmVkb3RhY2NlbnQHRW9nb25lawdlb2dvbmVrBkVjYXJvbgZlY2Fyb24LR2NpcmN1bWZsZXgLZ2NpcmN1bWZsZXgER2RvdARnZG90DEdjb21tYWFjY2VudAxnY29tbWFhY2NlbnQLSGNpcmN1bWZsZXgLaGNpcmN1bWZsZXgESGJhcgRoYmFyCkl0aWxkZS5hbHQGaXRpbGRlC0ltYWNyb24uYWx0B2ltYWNyb24KSWJyZXZlLmFsdAZpYnJldmULSW9nb25lay5hbHQHaW9nb25law5JZG90YWNjZW50LmFsdAZJSi5hbHQCaWoLSmNpcmN1bWZsZXgLamNpcmN1bWZsZXgMS2NvbW1hYWNjZW50DGtjb21tYWFjY2VudAxrZ3JlZW5sYW5kaWMGTGFjdXRlBmxhY3V0ZQxMY29tbWFhY2NlbnQMbGNvbW1hYWNjZW50BkxjYXJvbgZsY2Fyb24ETGRvdARsZG90Bk5hY3V0ZQZuYWN1dGUMTmNvbW1hYWNjZW50DG5jb21tYWFjY2VudAZOY2Fyb24GbmNhcm9uC25hcG9zdHJvcGhlA0VuZwNlbmcHT21hY3JvbgdvbWFjcm9uBk9icmV2ZQZvYnJldmUNT2h1bmdhcnVtbGF1dA1vaHVuZ2FydW1sYXV0BlJhY3V0ZQZyYWN1dGUMUmNvbW1hYWNjZW50DHJjb21tYWFjY2VudAZSY2Fyb24GcmNhcm9uBlNhY3V0ZQZzYWN1dGULU2NpcmN1bWZsZXgLc2NpcmN1bWZsZXgMVGNvbW1hYWNjZW50DHRjb21tYWFjY2VudAZUY2Fyb24GdGNhcm9uBFRiYXIEdGJhcgZVdGlsZGUGdXRpbGRlB1VtYWNyb24HdW1hY3JvbgZVYnJldmUGdWJyZXZlBVVyaW5nBXVyaW5nDVVodW5nYXJ1bWxhdXQNdWh1bmdhcnVtbGF1dAdVb2dvbmVrB3VvZ29uZWsLV2NpcmN1bWZsZXgLd2NpcmN1bWZsZXgLWWNpcmN1bWZsZXgLeWNpcmN1bWZsZXgGWmFjdXRlBnphY3V0ZQpaZG90YWNjZW50Cnpkb3RhY2NlbnQFbG9uZ3MKQXJpbmdhY3V0ZQphcmluZ2FjdXRlB0FFYWN1dGUHYWVhY3V0ZQtPc2xhc2hhY3V0ZQtvc2xhc2hhY3V0ZQxTY29tbWFhY2NlbnQMc2NvbW1hYWNjZW50BXRvbm9zDWRpZXJlc2lzdG9ub3MKQWxwaGF0b25vcwlhbm90ZWxlaWEMRXBzaWxvbnRvbm9zCEV0YXRvbm9zDUlvdGF0b25vcy5hbHQMT21pY3JvbnRvbm9zDFVwc2lsb250b25vcwpPbWVnYXRvbm9zEWlvdGFkaWVyZXNpc3Rvbm9zBUFscGhhBEJldGEFR2FtbWEHdW5pMDM5NAdFcHNpbG9uBFpldGEDRXRhBVRoZXRhCElvdGEuYWx0BUthcHBhBkxhbWJkYQJNdQJOdQJYaQdPbWljcm9uAlBpA1JobwVTaWdtYQNUYXUHVXBzaWxvbgNQaGkDQ2hpA1BzaQd1bmkwM0E5EElvdGFkaWVyZXNpcy5hbHQPVXBzaWxvbmRpZXJlc2lzCmFscGhhdG9ub3MMZXBzaWxvbnRvbm9zCGV0YXRvbm9zCWlvdGF0b25vcxR1cHNpbG9uZGllcmVzaXN0b25vcwVhbHBoYQRiZXRhBWdhbW1hBWRlbHRhB2Vwc2lsb24EemV0YQNldGEFdGhldGEEaW90YQVrYXBwYQZsYW1iZGEHdW5pMDNCQwJudQJ4aQdvbWljcm9uA3JobwZzaWdtYTEFc2lnbWEDdGF1B3Vwc2lsb24DcGhpA2NoaQNwc2kFb21lZ2EMaW90YWRpZXJlc2lzD3Vwc2lsb25kaWVyZXNpcwxvbWljcm9udG9ub3MMdXBzaWxvbnRvbm9zCm9tZWdhdG9ub3MJYWZpaTEwMDIzCWFmaWkxMDA1MQlhZmlpMTAwNTIJYWZpaTEwMDUzCWFmaWkxMDA1NA1hZmlpMTAwNTUuYWx0DWFmaWkxMDA1Ni5hbHQJYWZpaTEwMDU3CWFmaWkxMDA1OAlhZmlpMTAwNTkJYWZpaTEwMDYwCWFmaWkxMDA2MQlhZmlpMTAwNjIJYWZpaTEwMTQ1CWFmaWkxMDAxNwlhZmlpMTAwMTgJYWZpaTEwMDE5CWFmaWkxMDAyMAlhZmlpMTAwMjEJYWZpaTEwMDIyCWFmaWkxMDAyNAlhZmlpMTAwMjUJYWZpaTEwMDI2CWFmaWkxMDAyNwlhZmlpMTAwMjgJYWZpaTEwMDI5CWFmaWkxMDAzMAlhZmlpMTAwMzEJYWZpaTEwMDMyCWFmaWkxMDAzMwlhZmlpMTAwMzQJYWZpaTEwMDM1CWFmaWkxMDAzNglhZmlpMTAwMzcJYWZpaTEwMDM4CWFmaWkxMDAzOQlhZmlpMTAwNDAJYWZpaTEwMDQxCWFmaWkxMDA0MglhZmlpMTAwNDMJYWZpaTEwMDQ0CWFmaWkxMDA0NQlhZmlpMTAwNDYJYWZpaTEwMDQ3CWFmaWkxMDA0OAlhZmlpMTAwNDkJYWZpaTEwMDY1CWFmaWkxMDA2NglhZmlpMTAwNjcJYWZpaTEwMDY4CWFmaWkxMDA2OQlhZmlpMTAwNzAJYWZpaTEwMDcyCWFmaWkxMDA3MwlhZmlpMTAwNzQJYWZpaTEwMDc1CWFmaWkxMDA3NglhZmlpMTAwNzcJYWZpaTEwMDc4CWFmaWkxMDA3OQlhZmlpMTAwODAJYWZpaTEwMDgxCWFmaWkxMDA4MglhZmlpMTAwODMJYWZpaTEwMDg0CWFmaWkxMDA4NQlhZmlpMTAwODYJYWZpaTEwMDg3CWFmaWkxMDA4OAlhZmlpMTAwODkJYWZpaTEwMDkwCWFmaWkxMDA5MQlhZmlpMTAwOTIJYWZpaTEwMDkzCWFmaWkxMDA5NAlhZmlpMTAwOTUJYWZpaTEwMDk2CWFmaWkxMDA5NwlhZmlpMTAwNzEJYWZpaTEwMDk5CWFmaWkxMDEwMAlhZmlpMTAxMDEJYWZpaTEwMTAyCWFmaWkxMDEwMwlhZmlpMTAxMDQJYWZpaTEwMTA1CWFmaWkxMDEwNglhZmlpMTAxMDcJYWZpaTEwMTA4CWFmaWkxMDEwOQlhZmlpMTAxMTAJYWZpaTEwMTkzCWFmaWkxMDA1MAlhZmlpMTAwOTgGV2dyYXZlBndncmF2ZQZXYWN1dGUGd2FjdXRlCVdkaWVyZXNpcwl3ZGllcmVzaXMGWWdyYXZlBnlncmF2ZQlhZmlpMDAyMDgNdW5kZXJzY29yZWRibA1xdW90ZXJldmVyc2VkBm1pbnV0ZQZzZWNvbmQJZXhjbGFtZGJsCW5zdXBlcmlvcglhZmlpMDg5NDEGcGVzZXRhBEV1cm8JYWZpaTYxMjQ4CWFmaWk2MTI4OQlhZmlpNjEzNTIJZXN0aW1hdGVkCW9uZWVpZ2h0aAx0aHJlZWVpZ2h0aHMLZml2ZWVpZ2h0aHMMc2V2ZW5laWdodGhzB3VuaUZCMDEHdW5pRkIwMg1jeXJpbGxpY2JyZXZlCGRvdGxlc3NqEGNhcm9uY29tbWFhY2NlbnQLY29tbWFhY2NlbnQRY29tbWFhY2NlbnRyb3RhdGUMemVyb3N1cGVyaW9yDGZvdXJzdXBlcmlvcgxmaXZlc3VwZXJpb3ILc2l4c3VwZXJpb3INc2V2ZW5zdXBlcmlvcg1laWdodHN1cGVyaW9yDG5pbmVzdXBlcmlvcgd1bmkyMDAwB3VuaTIwMDEHdW5pMjAwMgd1bmkyMDAzB3VuaTIwMDQHdW5pMjAwNQd1bmkyMDA2B3VuaTIwMDcHdW5pMjAwOAd1bmkyMDA5B3VuaTIwMEEHdW5pMjAwQgd1bmlGRUZGB3VuaUZGRkMHdW5pRkZGRAd1bmkwMUYwB3VuaTAyQkMHdW5pMDNEMQd1bmkwM0QyB3VuaTAzRDYHdW5pMUUzRQd1bmkxRTNGB3VuaTFFMDAHdW5pMUUwMQd1bmkxRjREB3VuaTAyRjMJZGFzaWFveGlhB3VuaUZCMDMHdW5pRkIwNAVPaG9ybgVvaG9ybgVVaG9ybgV1aG9ybgd1bmkwMzAwB3VuaTAzMDEHdW5pMDMwMwRob29rCGRvdGJlbG93B3VuaTA0MDAHdW5pMDQwRAd1bmkwNDUwB3VuaTA0NUQHdW5pMDQ2MAd1bmkwNDYxB3VuaTA0NjIHdW5pMDQ2Mwd1bmkwNDY0B3VuaTA0NjUHdW5pMDQ2Ngd1bmkwNDY3B3VuaTA0NjgHdW5pMDQ2OQd1bmkwNDZBB3VuaTA0NkIHdW5pMDQ2Qwd1bmkwNDZEB3VuaTA0NkUHdW5pMDQ2Rgd1bmkwNDcwB3VuaTA0NzEHdW5pMDQ3Mgd1bmkwNDczB3VuaTA0NzQHdW5pMDQ3NQd1bmkwNDc2B3VuaTA0NzcHdW5pMDQ3OAd1bmkwNDc5B3VuaTA0N0EHdW5pMDQ3Qgd1bmkwNDdDB3VuaTA0N0QHdW5pMDQ3RQd1bmkwNDdGB3VuaTA0ODAHdW5pMDQ4MQd1bmkwNDgyB3VuaTA0ODMHdW5pMDQ4NAd1bmkwNDg1B3VuaTA0ODYHdW5pMDQ4OAd1bmkwNDg5B3VuaTA0OEEHdW5pMDQ4Qgd1bmkwNDhDB3VuaTA0OEQHdW5pMDQ4RQd1bmkwNDhGB3VuaTA0OTIHdW5pMDQ5Mwd1bmkwNDk0B3VuaTA0OTUHdW5pMDQ5Ngd1bmkwNDk3B3VuaTA0OTgHdW5pMDQ5OQd1bmkwNDlBB3VuaTA0OUIHdW5pMDQ5Qwd1bmkwNDlEB3VuaTA0OUUHdW5pMDQ5Rgd1bmkwNEEwB3VuaTA0QTEHdW5pMDRBMgd1bmkwNEEzB3VuaTA0QTQHdW5pMDRBNQd1bmkwNEE2B3VuaTA0QTcHdW5pMDRBOAd1bmkwNEE5B3VuaTA0QUEHdW5pMDRBQgd1bmkwNEFDB3VuaTA0QUQHdW5pMDRBRQd1bmkwNEFGB3VuaTA0QjAHdW5pMDRCMQd1bmkwNEIyB3VuaTA0QjMHdW5pMDRCNAd1bmkwNEI1B3VuaTA0QjYHdW5pMDRCNwd1bmkwNEI4B3VuaTA0QjkHdW5pMDRCQQd1bmkwNEJCB3VuaTA0QkMHdW5pMDRCRAd1bmkwNEJFB3VuaTA0QkYLdW5pMDRDMC5hbHQHdW5pMDRDMQd1bmkwNEMyB3VuaTA0QzMHdW5pMDRDNAd1bmkwNEM1B3VuaTA0QzYHdW5pMDRDNwd1bmkwNEM4B3VuaTA0QzkHdW5pMDRDQQd1bmkwNENCB3VuaTA0Q0MHdW5pMDRDRAd1bmkwNENFC3VuaTA0Q0YuYWx0B3VuaTA0RDAHdW5pMDREMQd1bmkwNEQyB3VuaTA0RDMHdW5pMDRENAd1bmkwNEQ1B3VuaTA0RDYHdW5pMDRENwd1bmkwNEQ4B3VuaTA0RDkHdW5pMDREQQd1bmkwNERCB3VuaTA0REMHdW5pMDRERAd1bmkwNERFB3VuaTA0REYHdW5pMDRFMAd1bmkwNEUxB3VuaTA0RTIHdW5pMDRFMwd1bmkwNEU0B3VuaTA0RTUHdW5pMDRFNgd1bmkwNEU3B3VuaTA0RTgHdW5pMDRFOQd1bmkwNEVBB3VuaTA0RUIHdW5pMDRFQwd1bmkwNEVEB3VuaTA0RUUHdW5pMDRFRgd1bmkwNEYwB3VuaTA0RjEHdW5pMDRGMgd1bmkwNEYzB3VuaTA0RjQHdW5pMDRGNQd1bmkwNEY2B3VuaTA0RjcHdW5pMDRGOAd1bmkwNEY5B3VuaTA0RkEHdW5pMDRGQgd1bmkwNEZDB3VuaTA0RkQHdW5pMDRGRQd1bmkwNEZGB3VuaTA1MDAHdW5pMDUwMQd1bmkwNTAyB3VuaTA1MDMHdW5pMDUwNAd1bmkwNTA1B3VuaTA1MDYHdW5pMDUwNwd1bmkwNTA4B3VuaTA1MDkHdW5pMDUwQQd1bmkwNTBCB3VuaTA1MEMHdW5pMDUwRAd1bmkwNTBFB3VuaTA1MEYHdW5pMDUxMAd1bmkwNTExB3VuaTA1MTIHdW5pMDUxMwd1bmkxRUEwB3VuaTFFQTEHdW5pMUVBMgd1bmkxRUEzB3VuaTFFQTQHdW5pMUVBNQd1bmkxRUE2B3VuaTFFQTcHdW5pMUVBOAd1bmkxRUE5B3VuaTFFQUEHdW5pMUVBQgd1bmkxRUFDB3VuaTFFQUQHdW5pMUVBRQd1bmkxRUFGB3VuaTFFQjAHdW5pMUVCMQd1bmkxRUIyB3VuaTFFQjMHdW5pMUVCNAd1bmkxRUI1B3VuaTFFQjYHdW5pMUVCNwd1bmkxRUI4B3VuaTFFQjkHdW5pMUVCQQd1bmkxRUJCB3VuaTFFQkMHdW5pMUVCRAd1bmkxRUJFB3VuaTFFQkYHdW5pMUVDMAd1bmkxRUMxB3VuaTFFQzIHdW5pMUVDMwd1bmkxRUM0B3VuaTFFQzUHdW5pMUVDNgd1bmkxRUM3C3VuaTFFQzguYWx0B3VuaTFFQzkLdW5pMUVDQS5hbHQHdW5pMUVDQgd1bmkxRUNDB3VuaTFFQ0QHdW5pMUVDRQd1bmkxRUNGB3VuaTFFRDAHdW5pMUVEMQd1bmkxRUQyB3VuaTFFRDMHdW5pMUVENAd1bmkxRUQ1B3VuaTFFRDYHdW5pMUVENwd1bmkxRUQ4B3VuaTFFRDkHdW5pMUVEQQd1bmkxRURCB3VuaTFFREMHdW5pMUVERAd1bmkxRURFB3VuaTFFREYHdW5pMUVFMAd1bmkxRUUxB3VuaTFFRTIHdW5pMUVFMwd1bmkxRUU0B3VuaTFFRTUHdW5pMUVFNgd1bmkxRUU3B3VuaTFFRTgHdW5pMUVFOQd1bmkxRUVBB3VuaTFFRUIHdW5pMUVFQwd1bmkxRUVEB3VuaTFFRUUHdW5pMUVFRgd1bmkxRUYwB3VuaTFFRjEHdW5pMUVGNAd1bmkxRUY1B3VuaTFFRjYHdW5pMUVGNwd1bmkxRUY4B3VuaTFFRjkHdW5pMjBBQgd1bmkwMzBGE2NpcmN1bWZsZXhhY3V0ZWNvbWITY2lyY3VtZmxleGdyYXZlY29tYhJjaXJjdW1mbGV4aG9va2NvbWITY2lyY3VtZmxleHRpbGRlY29tYg5icmV2ZWFjdXRlY29tYg5icmV2ZWdyYXZlY29tYg1icmV2ZWhvb2tjb21iDmJyZXZldGlsZGVjb21iEGN5cmlsbGljaG9va2xlZnQRY3lyaWxsaWNiaWdob29rVUMRY3lyaWxsaWNiaWdob29rTEMIb25lLnBudW0HemVyby5vcwZvbmUub3MGdHdvLm9zCHRocmVlLm9zB2ZvdXIub3MHZml2ZS5vcwZzaXgub3MIc2V2ZW4ub3MIZWlnaHQub3MHbmluZS5vcwJmZgd1bmkyMTIwCFRjZWRpbGxhCHRjZWRpbGxhBWcuYWx0D2djaXJjdW1mbGV4LmFsdApnYnJldmUuYWx0CGdkb3QuYWx0EGdjb21tYWFjY2VudC5hbHQGSXRpbGRlB0ltYWNyb24GSWJyZXZlB0lvZ29uZWsCSUoJSW90YXRvbm9zBElvdGEMSW90YWRpZXJlc2lzCWFmaWkxMDA1NQlhZmlpMTAwNTYHdW5pMDRDMAd1bmkwNENGB3VuaTFFQzgHdW5pMUVDQQAAAQACAAgACv//AA8AAQAAAAwAAAAAAAAAAgAFAAACNQABAjcCNwABAjsCWwABAl0DdgABA4IDqQABAAAAAQAAAAoADAAOAAAAAAAAAAEAAAAKAG4BWgABbGF0bgAIABAAAk1PTCAAKFJPTSAAQgAA//8ACQADAAgACwAAAA4AEQAUABcAGgAA//8ACgAEAAYACQAMAAEADwASABUAGAAbAAD//wAKAAUABwAKAA0AAgAQABMAFgAZABwAHWxpZ2EAsGxpZ2EAsGxpZ2EAsGxudW0AtmxudW0AtmxudW0AtmxvY2wAvGxvY2wAvG9udW0Awm9udW0Awm9udW0AwnBudW0AynBudW0AynBudW0AynNhbHQA0HNhbHQA0HNhbHQA0HNzMDEA0HNzMDEA0HNzMDEA0HNzMDIA2HNzMDIA2HNzMDIA2HNzMDMA3nNzMDMA3nNzMDMA3nRudW0A5HRudW0A5HRudW0A5AAAAAEACQAAAAEABwAAAAEACAAAAAIAAgADAAAAAQAEAAAAAgAAAAEAAAABAAAAAAABAAEAAAACAAUABgAKABYAPAB8AJQAzADgAO4BAgEuAVAAAQAAAAEACAACABAABQORA5IDkwOUA5UAAQAFAEoA3wDhAOMA5QABAAAAAQAIAAIALgAUACwAjgCPAJAAkQDqAOwA7gDwAPIA9AFaAWcBdwGhAaICyQLYA0UDRwACAAEDlgOpAAAAAQAAAAEACAABAAYDcAACAAEAEwAcAAAAAQAAAAEACAACABoACgODA4UDhgOHA4gDiQOKA4sDjAOEAAIAAwATABMAAAAVABwAAQOCA4IACQABAAAAAQAIAAEABgNuAAEAAQAUAAEAAAABAAgAAQA8/JAAAQAAAAEACAABAAb8kgABAAEDggABAAAAAQAIAAIAGgAKABMDggAVABYAFwAYABkAGgAbABwAAgABA4MDjAAAAAEAAAABAAgAAgAOAAQDjwOQASABIQABAAQBJAElAUkBSgAEAAAAAQAIAAEANgABAAgABQAMABQAHAAiACgCXgADAEkATwJdAAMASQBMA40AAgBJAjUAAgBPAjQAAgBMAAEAAQBJAAA=";

var openSansBoldItalic = "data:font/ttf;base64,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AAq0AgEqESYAKzU1////c/4UBJEGIQImAFwAAAEGAHYOAAAIswEfESYAKzUAAv+8/hQEaAYUABUAIwAnQBQKEwcADwAOGwAWR1kAEAcdR1kHFgA/KwAYPysAGD8/ERI5OTEwATIWFRQCBiMiJyMGBwMhASEDBgczNhciBgYVFBYzMjY2NTQmAy2WpYriibJdCAwfSP7TAbMBLUIdMwiDFUd2SUNIRXhLSwRz1cPH/pS8o5+I/qwIAP7Ng5Wq9ILvf1Bggu2BWFj///9z/hQEkQYEAiYAXAAAAQYAaqkAAAq0AgEqESYAKzU1////hQAABKwG/gImACQAAAEHAU0AkwFSAAizAhMFJgArNf//AFr/7ASeBawCJgBEAAABBgFNIwAACLMCJBEmACs1////hQAABNcHfQImACQAAAEHAU4AXAFSAAizAhIFJgArNf//AFr/7ASeBisCJgBEAAABBgFO7wAACLMCIxEmACs1////hf4UBIsFvAImACQAAAAHAVEDNwAA//8AWv4UBJ4EcwImAEQAAAAHAVECoAAA//8Ae//sBTcHcwImACYAAAEHAHYA/AFSAAizASIFJgArNf//AFr/7AQrBiECJgBGAAABBgB2GwAACLMBIhEmACs1//8Ae//sBTcHcwImACYAAAEHAUsArAFSAAizASAFJgArNf//AFr/7AQmBiECJgBGAAABBgFLxgAACLMBIBEmACs1//8Ae//sBTcHZgImACYAAAEHAU8BxQFSAAizASMFJgArNf//AFr/7APyBhQCJgBGAAABBwFPANEAAAAIswEjESYAKzX//wB7/+wFNwdzAiYAJgAAAQcBTACJAVIACLMBJAUmACs1//8AWv/sBF0GIQImAEYAAAEGAUy7AAAIswEkESYAKzX//wA1AAAFKwdzAiYAJwAAAQcBTABcAVIACLMCHgUmACs1//8AWv/sBqwGFAImAEcAAAAHAjgDJwAA//8AJQAABSsFtgIGAJIAAAACAFr/7AVxBhQAHQArAEpAKQQUFwAQCAkIS1kNCQkACwAlR1kAABAAIAADCQMAABILABceR1kXFhIVAD8/KwAYPxI5L19eXSsREgA5GC8zKxEAMxESOTkxMAEyFhczNDY3ITchNyEHMwcjAyM3IwYGIyImNTQSNhMyNjY1NCYjIgYGFRQWAlRYfS0ICxj+2SkBJyMBLSOaKZz85Q4ETZNVmK6M4lFEdExBSUd6R0wENUVQG2yFx6Ghx/tUkVpL1MO1AU6v/Kp34GxIWHrKb1hYAP//ADUAAAScBv4CJgAoAAABBwFNAFYBUgAIswEPBSYAKzX//wBa/+wEQgWsAiYASAAAAQYBTQoAAAizAiURJgArNf//ADUAAAScB30CJgAoAAABBwFOAB8BUgAIswEOBSYAKzX//wBa/+wEYwYrAiYASAAAAQYBTugAAAizAiQRJgArNf//ADUAAAScB0kCJgAoAAABBwFPAS0BNQAIswEVBSYAKzX//wBa/+wEQgYUAiYASAAAAQcBTwD6AAAACLMCKxEmACs1//8ANf4UBJwFtgImACgAAAAHAVECEgAA//8AWv4oBEIEcwImAEgAAAAHAVEBwQAU//8ANQAABM8HcwImACgAAAEHAUwALQFSAAizARYFJgArNf//AFr/7ASVBiECJgBIAAABBgFM8wAACLMCLBEmACs1//8Ae//sBW0HcwImACoAAAEHAUsAvAFSAAizASQFJgArNf///43+FASmBiECJgBKAAABBgFLRgAACLMDRREmACs1//8Ae//sBW0HfQImACoAAAEHAU4AnAFSAAizASAFJgArNf///43+FASiBisCJgBKAAABBgFOAgAACLMDQREmACs1//8Ae//sBW0HZgImACoAAAEHAU8BxwFSAAizAScFJgArNf///43+FASiBhQCJgBKAAABBwFPASMAAAAIswNIESYAKzX//wB7/jsFbQXNAiYAKgAAAAcCOQEZAAD///+N/hQEogYhAiYASgAAAQYCOncAAAizA0MRJgArNf//ADUAAAWkB3MCJgArAAABBwFLALgBUgAIswESBSYAKzX//wAlAAAErgeqAiYASwAAAQcBSwBOAYkACLMBIAImACs1AAIANQAABi0FtgATABcAM0AbEAADFgQLCwwMFw4XB0xZTBcBFxcJEg4DBQkSAD8zPzMSOS9dKxESADkYLzMSFzkxMAEzByMDIRMhAyETIzczNyEHITchATchBwV7sim04f7Ohv4phv7P4rEpsygBMikB1ykBMf5WJf4pJQT0x/vTAnf9iQQtx8LCwv3DtLQAAAEAJQAABGAGFAAgADxAIRcLGxUNDg1LWRIODhsQGwZHWQAbEBsgGwMbGwsQAAELFQA/Mz8SOS9dKxESADkYLzMrEQAzERI5MTAhIRM2NTQjIgYHAyETIzczNyEHIQchBgczNjYzMhYVFAcD0f7TfRBqXZcrVv7T/qIroCMBLSEBKyv+1SYqCD6VZIyVFgJQRDN758r+bwSsx6Ghx6R9TlyomU9mAP///8UAAAQRB2ACJgAsAAABBwFS/5ABUgAIswEVBSYAKzX//wAlAAADfAYOAiYA8wAAAQcBUv77AAAACLMBDREmACs1////xQAAA7IG/gImACwAAAEHAU3/mQFSAAizAQ8FJgArNf//ACUAAAMYBawCJgDzAAABBwFN/v8AAAAIswEHESYAKzX////FAAAD2Ad9AiYALAAAAQcBTv9dAVIACLMBDgUmACs1//8AJQAAA1MGKwImAPMAAAEHAU7+2AAAAAizAQYRJgArNf///8X+FAOBBbYCJgAsAAAABwFRAKgAAP///7T+FAKNBhQCJgBMAAAABgFRYAD////FAAADgQdmAiYALAAAAQcBTwBzAVIACLMBFQUmACs1AAEAJQAAAj8EXgADAAqzAg8BFQA/PzEwISETIQFS/tPtAS0EXgD////F/lIFwgW2ACYALAAAAAcALQMQAAD//wAl/hQE7wYUACYATAAAAAcATQJgAAD///6+/lIDtQdzAiYALQAAAQcBS/9VAVIACLMBFAUmACs1///++v4UA0QGIQImAjcAAAEHAUv+5AAAAAizARMRJgArNf//ADX+OwWkBbYCJgAuAAAABwI5ALQAAP//ACX+OwTwBhQCJgBOAAAABgI5ewAAAQAlAAAE8AReAA4AGEAMDgYFAgQIAAkPBAgVAD8zPzMSFzkxMAEhAQEhAwcDIRMhAgYHMwOYAVj+DgEd/rC3eEr+0+0BLUcgDQQEXv4I/ZoBpEj+pARe/sF4Kv//ADUAAAPBB3MCJgAvAAABBwB2/7EBUgAIswEOBSYAKzX//wAlAAADrQesAiYATwAAAQcAdv+dAYsACLMBDAImACs1//8ANf47A5wFtgImAC8AAAAGAjlCAP///53+OwKcBhQCJgBPAAAABwI5/yIAAP//ADUAAASmBbcCJgAvAAABBwI4ASH/owAHsgEIAwA/NQD//wAlAAAETgYUAiYATwAAAAcCOADJAAD//wA1AAAEAgW2AiYALwAAAAcBTwF1/XD//wAlAAADrgYUACYATwAAAAcBTwEh/TgAAQAAAAADngW2AA0AJ0AVAQMECgcJBggCAgkIAAUDAAtMWQASAD8rABg/EjkRMxESFzkxMDMTByc3EyEDNxcFAyEDOWc6Zt2SAS9rjmr+yVYCADYB4R7KdwKy/gZOy6f+aP8AAAEAAAAAAtkGFAALAB5AEAYICQMAAgYHBwEBBQoABRUAPz8SOREzEhc5MTABNxcHAyETByc3EyECL0Bq54r+12M8Zt+qASkDqCXLff17AdMhy3kDHgD//wA1AAAGFAdzAiYAMQAAAQcAdgF1AVIACLMBGQUmACs1//8AJQAABIMGIQImAFEAAAEGAHZzAAAIswEfESYAKzX//wA1/jsGFAW2AiYAMQAAAAcCOQECAAD//wAl/jsEbQRzAiYAUQAAAAYCOXMA//8ANQAABhQHcwImADEAAAEHAUwA9AFSAAizARsFJgArNf//ACUAAASoBiECJgBRAAABBgFMBgAACLMBIREmACs1//8AAQAABQsFtgAnAFEAngAAAAYCB5cAAAEANf5SBhQFtgAZAB9ADwgRDhUPAwcOEgAFTFkAIwA/KwAYPzM/MxI5OTEwASInERYzMjcBIwcGBwMhASEBMxI3EyEBBgQC13hGVUzXNv5eBgQgIpH+7QE1AUoBfQYpH4MBEv7LLv73/lIYAQMXqgRSINiq/VAFtvwnAQSJAkz6StfXAAEAJf4UBG0EcwAgACNAEhYYEhUYDUdZGBATDwAFR1kAGwA/KwAYPz8rABg/EjkxMAEiJzUWMzI2NxM2NTQjIgYHAyETMwczNjMyFhUUBwMGBgIjaEY9NT1dEpoQbFyWK2L+0+3mFQaS0YqXF54pyf4UGfIVUVkC2UQze+TM/jEEXs/kp5tJa/0OwLf//wB7/+wFmAb+AiYAMgAAAQcBTQDuAVIACLMCHwUmACs1//8AWv/sBFQFrAImAFIAAAEGAU0OAAAIswIdESYAKzX//wB7/+wFmAd9AiYAMgAAAQcBTgCwAVIACLMCHgUmACs1//8AWv/sBFcGKwImAFIAAAEGAU7cAAAIswIcESYAKzX//wB7/+wF/gdzAiYAMgAAAQcBUwFCAVIACrQDAi0FJgArNTX//wBa/+wFHAYhAiYAUgAAAQYBU2AAAAq0AwIrESYAKzU1AAIAe//sB3sFzQAVACEAQkAlEBNMWQwQAQ0DEBABDAEUTFkBEgwPTFkMAwobTFkKBAMWTFkDEwA/KwAYPysAGD8rABg/KxESADkYL19eXSsxMCEhBiMgABEQEiQzMhchByEDIQchAyEFMjcTJiMiBgIVFBYGRv0IXVf/AP7hxgFc5IxFAyk1/gBEAd03/iNQAgD8NVhGwj5qecpzhRQBJwEGAQkBve4X/v6//v6HECADlCe3/sC7k5YAAAMAWv/sBtsEcwAjADAAOQBLQCkPAwANNBhLWQ80AQwGNDQADRExSlkREA0kR1kNEAYrR1kGFgAdRlkAFgA/KwAYPysAGD8rABg/KxESADkYL19eXSsREgA5OTEwBSImJwYGIyImNTQSJDMyFzYzMhYVFAQhIwcVFBYzMjY3FQYGASIGBhUUFjMyEjU0JiUiBgczMjY1NASudLguP6h7u92KAQay0Wia9bHG/rL+yzMCZmBXjmVduf1oR3BFSUltjEoCiFibGS2brBRNRERN6sjYAUm0oKCjjrvLFRRbaSYw4y4oA5F56H5bYgENymBlHZ12YVNf//8ANQAABLIHcwImADUAAAEHAHYAogFSAAizAh8FJgArNf//ACUAAAP4BiECJgBVAAABBgB26AAACLMBGBEmACs1//8ANf47BKwFtgImADUAAAAHAjkAsAAA////of47A6oEcwImAFUAAAAHAjn/JgAA//8ANQAABOQHcwImADUAAAEHAUwAQgFSAAizAiEFJgArNf//ACUAAAQsBiECJgBVAAABBgFMigAACLMBGhEmACs1//8AKf/sBHgHcwImADYAAAEHAHYAaAFSAAizASwFJgArNf//ABf/7APoBiECJgBWAAABBgB22AAACLMBKxEmACs1//8AKf/sBGQHcwImADYAAAEHAUsABAFSAAizASoFJgArNf//ABf/7APUBiECJgBWAAABBwFL/3QAAAAIswEpESYAKzX//wAp/hQEVgXLAiYANgAAAAcAegFkAAD//wAX/hQDoARzAiYAVgAAAAcAegEvAAD//wAp/+wEkwdzAiYANgAAAQcBTP/xAVIACLMBLgUmACs1//8AF//sBCIGIQImAFYAAAEGAUyAAAAIswEtESYAKzX//wB//jsE0QW2AiYANwAAAAYCOQQA//8AOP47A28FTAImAFcAAAAGAjm9AP//AKgAAATRB3MCJgA3AAABBwFMABQBUgAI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AAAE7ghiAiYAJAAAAQcDegUbAVIACrQDAjUFJgArNTX//wBa/+wEngcQAiYARAAAAQcDegSqAAAACrQDAkYRJgArNTX///+F/lIE0wdzAiYAJAAAACcBSwBzAVIBBwJnBOkAAAAIswIVBSYAKzX//wBa/lIEngYhAiYARAAAACYBS/kAAQcCZwTZAAAACLMCJxEmACs1////hQAABNEIEwImACQAAAEHA3sFDAFSAAq0AwITBSYAKzU1//8AWv/sBJ4GwQImAEQAAAEHA3sEuAAAAAq0AwIkESYAKzU1////hQAABNwIEwImACQAAAEHA3wFFwFSAAq0AwITBSYAKzU1//8AWv/sBJ4GwQImAEQAAAEHA3wEtgAAAAq0AwIkESYAKzU1////hQAABNEIWAImACQAAAEHA30FDAFSAAq0AwITBSYAKzU1//8AWv/sBJ4HBgImAEQAAAEHA30EtAAAAAq0AwIkESYAKzU1////hQAABOcIYgImACQAAAEHA34FDAFSAAq0AwITBSYAKzU1//8AWv/sBJ4HEAImAEQAAAEHA34ErgAAAAq0AwIkESYAKzU1////hf5SBNcHfQImACQAAAAnAU4AXAFSAQcCZwTpAAAACLMCEgUmACs1//8AWv5SBJ4GKwImAEQAAAAmAU4GAAEHAmcE2QAAAAizAiMRJgArNf//ADX+UgScBbYCJgAoAAAABwJnBKAAAP//AFr+UgRCBHMCJgBIAAAABwJnBLgAAP//ADUAAAScB/YCJgAoAAABBwJmBNUBUgAIswEQBSYAKzX//wBa/+wEQgakAiYASAAAAQcCZgSaAAAACLMCJhEmACs1//8ANQAABM8HYAImACgAAAEHAVIATgFSAAizARUFJgArNf//AFr/7ASJBg4CJgBIAAABBgFSCAAACLMCKxEmACs1//8ANQAABecH0QImACgAAAEHA3cE5QFSAAq0AgEZBSYAKzU1//8AWv/sBZEGfwImAEgAAAEHA3cEjwAAAAq0AwIvESYAKzU1//8ANQAABJwH0wImACgAAAEHA3gE5QFSAAq0AgEZBSYAKzU1//8AWv/sBEIGgQImAEgAAAEHA3gEjwAAAAq0AwIvESYAKzU1//8ANQAABYMISgImACgAAAEHA3kE5QFSAAq0AgEqBSYAKzU1//8AWv/sBS0G+AImAEgAAAEHA3kEjwAAAAq0AwJAESYAKzU1//8ANQAABLgIYgImACgAAAEHA3oE5QFSAAq0AgExBSYAKzU1//8AWv/sBGIHEAImAEgAAAEHA3oEjwAAAAq0AwJHESYAKzU1//8ANf5SBJwHcwImACgAAAAnAUsAOQFSAQcCZwSgAAAACLMBDQUmACs1//8AWv5SBEYGIQImAEgAAAAmAUvmAAEHAmcEuAAAAAizAiMRJgArNf///8UAAAOBB/YCJgAsAAABBwJmBBIBUgAIswEQBSYAKzX//wAlAAAC6AakAiYA8wAAAQcCZgOWAAAACLMBCBEmACs1////xf5SA4EFtgImACwAAAAHAmcDzwAA////3/5SAo0GFAImAEwAAAAHAmcDfQAA//8Ae/5SBZgFzQImADIAAAAHAmcFUAAA//8AWv5SBFQEcwImAFIAAAAHAmcE0QAA//8Ae//sBZgH9gImADIAAAEHAmYFfwFSAAizAiAFJgArNf//AFr/7ARUBqQCJgBSAAABBwJmBJYAAAAIswIeESYAKzX//wB7/+wGagfRAiYAMgAAAQcDdwVoAVIACrQDAikFJgArNTX//wBa/+wFoAZ/AiYAUgAAAQcDdwSeAAAACrQDAicRJgArNTX//wB7/+wFmAfTAiYAMgAAAQcDeAVoAVIACrQDAikFJgArNTX//wBa/+wEVAaBAiYAUgAAAQcDeASeAAAACrQDAicRJgArNTX//wB7/+wGBghKAiYAMgAAAQcDeQVoAVIACrQDAjoFJgArNTX//wBa/+wFPAb4AiYAUgAAAQcDeQSeAAAACrQDAjgRJgArNTX//wB7/+wFmAhiAiYAMgAAAQcDegVoAVIACrQDAkEFJgArNTX//wBa/+wEcQcQAiYAUgAAAQcDegSeAAAACrQDAj8RJgArNTX//wB7/lIFmAdzAiYAMgAAACcBSwC8AVIBBwJnBVAAAAAIswIhBSYAKzX//wBa/lIEVQYhAiYAUgAAACYBS/UAAQcCZwTRAAAACLMCHxEmACs1//8Ae//sBwYHcwImAl8AAAEHAHYBDgFSAAizAiwFJgArNf//AFr/7AXZBiECJgJgAAABBgB2SAAACLMCKxEmACs1//8Ae//sBwYHcwImAl8AAAEHAEMAdwFSAAizAiUFJgArNf//AFr/7AXZBiECJgJgAAABBgBDnwAACLMCJBEmACs1//8Ae//sBwYH9gImAl8AAAEHAmYFfwFSAAizAigFJgArNf//AFr/7AXZBqQCJgJgAAABBwJmBJYAAAAIswInESYAKzX//wB7/+wHBgdgAiYCXwAAAQcBUgDNAVIACLMCLQUmACs1//8AWv/sBdkGDgImAmAAAAEGAVL1AAAIswIrESYAKzX//wB7/lIHBgYUAiYCXwAAAAcCZwVQAAD//wBa/lIF2QUGAiYCYAAAAAcCZwTRAAD//wCN/lIFmgW2AiYAOAAAAAcCZwUxAAD//wBv/lIEsgReAiYAWAAAAAcCZwTjAAD//wCN/+wFmgf2AiYAOAAAAQcCZgVgAVIACLMBGQUmACs1//8Ab//sBLIGpAImAFgAAAEHAmYEvAAAAAizARsRJgArNf//AI3/7AdgB3MCJgJhAAABBwB2ARIBUgAIswEmBSYAKzX//wBq/+wGiQYhAiYCYgAAAQYAdnEAAAizASkRJgArNf//AI3/7AdgB3MCJgJhAAABBwBDAEQBUgAIswEfBSYAKzX//wBq/+wGiQYhAiYCYgAAAQYAQ6cAAAizASIRJgArNf//AI3/7AdgB/YCJgJhAAABBwJmBWABUgAIswEiBSYAKzX//wBq/+wGiQakAiYCYgAAAQcCZgS8AAAACLMBJREmACs1//8Ajf/sB2AHYAImAmEAAAEHAVIAwwFSAAizAScFJgArNf//AGr/7AaJBg4CJgJiAAABBgFSMQAACLMBIREmACs1//8Ajf5SB2AGFAImAmEAAAAHAmcFMQAA//8Aav5SBokFBAImAmIAAAAHAmcE4wAA//8Auv5SBT8FtgImADwAAAAHAmcEiwAA////c/4UBJEEXgImAFwAAAAHAmcF4QAA//8AugAABT8H9gImADwAAAEHAmYErgFSAAizAQ0FJgArNf///3P+FASRBqQCJgBcAAABBwJmBEgAAAAIswEbESYAKzX//wC6AAAFPwdgAiYAPAAAAQcBUgApAVIACLMBEgUmACs1////c/4UBJEGDgImAFwAAAEGAVK1AAAIswEgESYAKzX//wA2/rwFcQYUAiYA0wAAAAcAQgDwAAAAAvxgBNn/agYhAAgAEQAOtA0FgAkAAC8yGs0yMTABJiYnNSEWFxUzJiYnNSEWFxX9UkeHJAEbJk3hR4ckARslTQTZRalFFZyTGUWpRRWYlxkAAAL8qATZAQIGfwANABYAGUALERYWAn8KAQqABQAALzIazV0yOS/NMTABJicGByM1NzY3IRYXFSc1NjczFQYGB/7lS05af8tCj0MBPjxqOjB0+BmgRwTZQlxMUhc/iFWHlRfDEjChCh6LMAAC++UE2f+gBoEADQAWABlACxMWFgJ/CgEKgAUAAC8yGs1dMjkvzDEwASYnBgcjNTc2NyEWFxUlJiYnNTMWFxX+5UtOWn/LQo9DAT48avz4O2QU6Bc9BNlCXExSFz+IVYeVF8U2dygOX3QQAAAC/KgE2QCeBvgAEAAeACFADwIFBQkOBAQTfxoBGoAWEQAvMxrNXTI5L8wyOREzMTATFAcHIzc2NTQjIgc1NjMyFgEmJwYHIzU3NjchFhcVnpoOew5/NywoL0ZRW/5HS05af8tCj0MBPjxqBmh4IzV0BkYlDngRT/4wQlxMUhc/iFWHlRcAAAL8qATZ/9MHEAAXACUAS0AylgwBmQABBAyPEp8SAhISAA8PB28HfwePBwSPB58H7wf/BwQHmRoBGgAhAZAhASGAHBgALzMa3V1xMl3EXXEyMjkvXTMzXV0xMAEiBgcjNjYzMhYXFjMyNjczBiMiJicmJhMmJwcjNTc2NyEWFxcV/dslIguHE3lRPnERLC0jJRCDNaolQTY9KfN4KdHLQY88AT4kXiwGby8jeXgxCRgnLfMQGx0K/mpgKYkXPH9NUno8FwAC/QQE2f/FBsEADgAXABS3DwwSDgiADAMALzMa3DLOETkxMAMGBiMiJjU0NzMVFDMyNwU1NjczFQYGBzsi0Z+SnQSQqqtC/ro/ZdkZoEcGK6SukokfGBKYqk4TP5ILHoswAAL9BATZ/8UGwQAOABYAFLcPDBIOCIAMAwAvMxrcMs4ROTEwAwYGIyImNTQ3MxUUMzI3ByYnNTMWFxU7ItGfkp0EkKqrQu1+NdMcOAYrpK6SiR8YEpiqTnNiD2ppEQAC/QQE2f/FBwYADgAhAB9ADRIVFRQUDBofDgiADAMALzMa3DLMMhE5ETkRMzEwAwYGIyImNTQ3MxUUMzI3JxQGBwcjNzY2NTQjIgc1NjMyFjsi0Z+SnQSQqqtCNUNEDWgMNjMtKiAqPEhQBiukrpKJHxgSmKpeNksOK24IHx8dDWUORQAC/P4E2f/bBxAADwAmAD9AKYcMlwynDAMTGyEhHhCPFp8WAo8WnxavFgMWQBcaSBYPkAigCAIIgAwDAC8zGt1dMswrXXEyMjkvMzNdMTADBgYjIiY1NDczBxQzMjY3JSIHIzY2MzIWFxYzMjY3MwYjIiYnJiZEIsybkqMEjwGyWGwj/sA+FYYWdVE1VDI4JSMnDIE1qCk+NSUwBgKQmYJ2GxYNdDhJe0xwbRwaHi4o3xEaEw4AAAH/Rv4UAPgAAAAPAAuzAAsbBgAvPzMxMAMyNTQmJzMWFRQGIyInNRZKbTEttH+Wg1w9Ov7LZjVhOXaIcnwZtBYA//8AcQAAA6AFtgAGABS7AAACAFr/7ARMBIcACQAXABdADBUAT1kVJg4FT1kOGQA/KwAYPysxMAEiAhUUMzISNTQFFAIEIyImNTQSJDMyFgKNcpCQcZEBL43++LHK4pYBBqzL3wOR/trNvQEm1LbG2f6utO3R1wFVse0AAQAnAAADVARzAAoAELYEBwEJEAEYAD8/Ejk5MTAhIRM2NwYHBycBMwJk/s9vEzktUMOHAjX4AfxjvCgyfdcBWAAAAf/sAAAEBASHABoAHUAPEQlOWREmAhkBARlOWQEYAD8rERIAORg/KzEwISE3JTY2NTQmIyIGByc+AjMyFhUUBgcHFSEDtPw4KAFtw4U8NUGUXo9skZ1ZtsWQs88B+sv6hIxKLzdKS8hXTiqunIHJbn0EAAAB/6/+qQPxBIgAJwAtQBcDFxgYF1FZGBgLJSUfT1klJgsRT1kLJQA/KwAYPysREgA5GC8rERIAOTEwARQGBxUWFhUUBgQjIicRFhYzMjY1NCEjNzMyNjU0JiMiByc2NjMyFgPxvaeDh5T+7L3vlFTEXZ6q/v6KLkmnwFZOhpl/fNmKvtgDOpzUHQQaoXmF0nVPAQsyM39xrN18bkNKZMxRQbUAAAL/yf6oBCkEcwAKABIAJ0ATDwMHAQYSBRIFUFkJEhIDBxADJQA/PxI5LzMrERIAOTMREjkxMCUjAyETITcBIQMzITY2NyMGBwED5apN/tlQ/bIxAvYBObqq/jEgJj8GRD3+yhv+jQFz6wNt/JeWr9BwRf6gAAAB/+P+qQQwBHMAHAAmQBQAE1BZAAAHFxcaTlkXEAcNT1kHJQA/KwAYPysREgA5GC8rMTABMhYVFAYEIyImJxEWMzI2NTQmIyIHJxMhAyEDNgI3t9SP/u7Bdcs9rrKarnNtZm9ozwLzN/4XWEgCV864p/qHLiMBDWOOe15eIU4C3f76/tsP//8AWv/sBIMFzQAGABkCAAABAAH+vwR0BHUABgAYQAsAJAUCAwMCTlkDEAA/KxESADkYPzEwEwEhEyEHAQEC4f2LOAPPKf0Q/r8EsgEEwvsMAP//AD//7ARuBc0ABgAbCAAAAgBF/q4EMwSPABkAJwAtQBcOEBcQIVBZEBAEFxcaT1kXJgQJT1kEJQA/KwAYPysREgA5GC8rERIAOTEwARACBCMiJxEWMzI2NjcjBiMiJjU0EjYzMhYFIgYGFRQWMzI2NjU0JgQzxv627oBwb3R5rXMqBG+4o7OS9qPL0/5BQWU3S0Q8Zz1HAqv+6P4G6yABAClis6iez7amAReJ9gJUkFFXWUl/X1RqAAAB/yX+FAaTBh8AOAA4QB0jFRAVR1keEAAJKjYZNkZZDCcZDzIFAAVHWS0AGwA/MisRADMYPzMzKxEAMzMYPzMrEQAzMTADIic1FjMyNjcTIz8CNjYzMhcHJiMiBgcHITc2NjMyFwcmIyIGBwczByMDAiEiJzUWMzI3EyEDAi1oRj02PVwTzKMetxIpw7CDaFBFQDlGDAwBixIpw7CDaE9FQTlFDQzbMdvXTf65aEY9Nogkzf50103+FBnyFVBaA8WRVFS+rzHgH1BBPlS+rzHgH1BBPuX8Dv6NGfIVqgPF/A7+jQACAJ4C3QXRBcEAIgAzAD5AHjElJSsqIxIdAAsdCxsICAMvIwMDKCgqNRsVFS0qAwA/MzMvMxESOS8XMy8zERI5OREzETMREjk5ETMxMAEUBiMiJzUWMzI2NTQmJycmJjU0NjMyFwcmJiMiFRQWFxYWAQMjFxEjETMTEzMRIxE3IwMCZIt1blhzVy0wJCUyYkaAcV9wMzg8KFEuRmdHAYimBwWk+J+q8KgEBq4DsmRxK5A2JyMbJxEaMWVDXXI0fRsQQyAuITJe/uwCEW/+XgLR/gIB/v0vAZh5/e///wCN/hQE0QW2AiYANwAAAAcAegFcAAD//wBW/hQDbwVMAiYAVwAAAAcAegElAAAAAgAb/hQEngRzAA0AKwAuQBgmGSMcKA8jB0dZIxAcAEdZHBYOE0dZDhsAPysAGD8rABg/KwAYPxESOTkxMCUyNjY1NCYjIgYGFRQWAyInERYzMjY3NjcjBgYjIiY1NBI2MzIWFzM3MwMCAhlIeEZGRkV4S0w7/4Kdv2WSExYhCEiOU4uih+GKX448CDno9GTfiOx8UGCC7YFYWP01QgEQWmNPa21eTNa/ygFlw0paj/uH/i///wAb/hQEngYhAiYDjwAAAQYBSxkAAAizAjIRJgArNf//ABv+FASeBisCJgOPAAABBgFOCAAACLMCLhEmACs1//8AG/4UBJ4GFAImA48AAAEHAU8BIwAAAAizAjURJgArNf//ABv+FASeBiECJgOPAAABBgI6ewAACLMCMBEmACs1AAEANQAAAp4FtgADAAqzAQMAEgA/PzEwMwEhATUBOAEx/sgFtvpKAP//ADUAAAKeB3MCJgOUAAABBwBD/vUBUgAIswEFBSYAKzX//wA1AAADywdzAiYDlAAAAQcAdv+7AVIACLMBDAUmACs1//8ANQAAA6kHcwImA5QAAAEHAUv/SQFSAAizAQoFJgArNf//ADUAAAOXB1YCJgOUAAABBwBq/1EBUgAKtAIBFwUmACs1Nf//ADUAAAPQB2ACJgOUAAABBwFS/08BUgAIswENBSYAKzX//wA1AAADfgb+AiYDlAAAAQcBTf9lAVIACLMBBwUmACs1//8ANQAAA68HfQImA5QAAAEHAU7/NAFSAAizAQYFJgArNf///7j+FAKeBbYCJgOUAAAABgFRZAD//wA1AAAC5QdmAiYDlAAAAQcBTwBYAVIACLMBDQUmACs1//8ANf5SBUUFtgAmA5QAAAAHAC0CkwAA//8AIgAAAy8F9QAnA5QAkQAAAQcBVP3t/5cADbcBBjIGBgEBPgArETUA//8ANQAAAp4FtgIGA5QAAP//ADUAAAOXB1YCJgOUAAABBwBq/1EBUgAKtAIBFwUmACs1Nf//ADUAAAKeBbYCBgOUAAD//wA1AAADlwdWAiYDlAAAAQcAav9RAVIACrQCARcFJgArNTX//wA1AAACngW2AgYDlAAA//8ANQAAAp4FtgIGA5QAAP//ADUAAAM7B/YCJgOUAAABBwJmA+kBUgAIswEIBSYAKzX////x/lICngW2AiYDlAAAAAcCZwOPAAAAAQAAA6gAigAWAFcABQACABAALwBcAAABBwCcAAMAAQAAABsAGwAbABsASwBoAL4BKQGUAfwCDwIxAlECeQKkArsCzQLpAv4DOANZA5UD6wQnBGoEvQTZBS8FhAW2BeMGAwYkBkYGlQcXB0oHmAfRCAYIOAheCKUI0Aj2CRsJTAlnCZ8JzgoNCkAKiQrHCw4LLgtgC4gLzwv6DB8MSgxmDHoMlQywDMQM3g0kDXANpQ3yDj8Ohg78DzYPXQ+SD8MP1hAmEFoQkRDbESkRUhGXEdMSCBItEnISnRLTEv0TRxNZE6MT3xPfFA4UVRSdFPIVOhVWFbIV2xZXFpAW0xbyFvoXcxeOF8UX8BgmGHAYihjKGPEY+hkmGUcZcxm6GdAZ5Rn7GksaXBptGn4ajxqhGrIbARsNGx4bLxtAG1IbYxt0G4UblxvhG/IcAxwUHCUcNhxIHHIcyBzZHOoc+x0NHR4dVR3BHdEd4R3xHgEeEh4jHq8eux7LHtse6x78Hw0fHh8vH0EfpB+0H8Qf1B/kH/QgBSBLIJ0grSC9IM0g3iDuITwhTSFeIW4hfyGPIZshpyG4Icgh2SHpIfoiCyIcIiwiPSJJIlEiuiLLItsi7CL8Iw0jHiMqIzYjRyNXI2gjeCOJI5kjqiO7I8cj1yPoI/kkQSSUJKUktiTHJNgk6ST6JQYlESUiJTUlQSVNJV4lbyV7JYYltCXFJdYl4SXtJf4mCiYWJiImVCZ/JpAmoCasJrcmyCbYJuQnJidsJ30njSeeJ64nwCfRKC4oqSi6KMoo1ijiKPMpAykUKSQpNSlGKVIpXilvKX8piimVKaYpsinlKjMqRCpUKmUqdSqGKpYqqCq5Kssq3SrpKvUrBisXKygrOCtKK1srayt8K40rniuuK+EsKSyPLRstLC09LU4tXi1pLXQtmC27Lc0t8i4LLjsuXi6TLr0u1C8PLyMvLC9BL1Yvay9/L5QvqS+8L8QvzC/mL+4v9i/+MAYwWTBhMGkwizCTMJsw0TDZMPkxATEzMTsxQzGcMaQx7DI3MkkyWzJrMnsyizKcMq4zDDNoM5gz6TQ4NIU0ujUFNSw1NDWDNYs1sTYVNh02WjagNuU3JDdYN4c31zglOGk4uDjKONs46zj7OQw5HjlqOXs5xDnMOdQ55jnuOkQ6izrJOto66zsWOx47WTthO2k7pjuuO+s8PTxuPH88qDzgPOg88Dz4PQA9CD0QPRg9UT1ZPWE9jT2+Peo+ID5ZPpY+yT8SP2w/qj+yQARAXECkQPlBAUFzQcBByEHYQgJCP0J8QqZCrkK2Qr5CxkLOQtZDLkM2Q31Dt0QFRGVErET2RTNFdkXBRhJGI0aKRppG20bjRutG/UcFR3FHw0fLR9xH7EgvSFFIckiDSJNIpEi1SMdI2UjqSPtJDUkfSSdJTUllSX1JlEmuSdRJ+0oiSlRKpUrFStVLaUtxS3lLm0vHS9NL6EwcTF5MxE0yTZVN+E5FTq5O8k76T0RPW09yT4lPoE/nUBZQMVBbUHZQlVDyURxRglHAUetSFVJAUkxSWFJ9UqFSu1LWUvFTIFNTU41T1lPwVEBUh1SHVIdUh1SHVIdUh1SHVIdUh1SHVIdUh1SHVaNWAFYRVhlWj1bEVyJXM1dEV1BXXFdoV5ZXzFhcWNtZLll7WcFaElobWiRaLVpVWm5af1qQWqBasFscW1hbp1v7XFdcq1ziXRldaF2vXgReVV64XxdfqWA7YENgS2CZYOJhHGFTYWVhd2GDYY9h8WJKYwBjqGQ6ZJlk1WUMZT1lYmWQZbNl1WaoZy9niGflaCxohmjRaS9pX2mPadZqGWpiattq52rzaylrXmuUa8tsDWxRbIJstGzubSRtW22NbdluIm6bbxpvJm8yb15vxW/Nb/dwNHBtcKVw3HEUcWdxpXHqcjJyenKscuJzRHOgdAt0cnR6dIt0nHTjdSd1a3W0dfd2MnZtdqN24Xcpd253tXe9d8533nfweAF4CXgReCJ4Mnh/eMh42njreP15D3kheTJ5dnm5ecp52nnsef16D3ogeih6MHpCelN6ZXp3eoh6mHqqert6zXreevB7AXsne0x7Xntwe718CXxRfJl81X0PfUN9S32ifgR+Xn62fwh/V3+ogAKAToCVgN2BIYFegZuB7YH1gkeCoIKsgriCyYLaguyC/oMQgyKDNINGg1iDaoN/g5ODpYO3g8mD24Ptg/+EEYQjhDiETIRYhGSEdYSGhJeEp4S5hMuE3YTvhQGFE4UlhTeFTIVghXGFgoWOhZqFpoWyhcOF1IXmhfiGCoYchi6GQIZShmSGeYaNhp6Groa/hs+G4IbxhwKHEocehyqHNodCh1OHZId1h4WHloemh7eHyIfZh+mH9YgBiA2IGYgqiDuITIhciGiIkYjGiPyJP4mhidKKAYpDip6Kv4rHivyLHYtXi6mL5IwnjC+MUIxYjK2NH42NjZmNpY3/jg+OH44wjkCOVI5ljnaOh46ZjqqOu47MjteO6I70jwmPEY8jjyuPPY9Fj02PXo9qAAAAAQAAAAEZ21wfO+VfDzz1AAkIAAAAAADJY0keAAAAANUrzNX75f2oClgIjQADAAkAAgAAAAAAAATNAMEAAAAABBQAAAIUAAACSgAZA6AAyQUrACkEaAAzBtkAcwWqAEQCCgDJArYASgK2/20EXACsBGgAbQI5/5oCkwApAkgAGQNe/6YEaABCBGgAtgRo/88EaAAOBGj/5wRoABsEaABYBGgATgRoADcEaABWAkgAGQJI/5oEaABtBGgAbQRoAG0DrACmBtkAXAUG/4UE9gA1BOUAewVqADUEVgA1BD8ANQWFAHsFmgA1AxD/xQKm/r4E5wA1BCUANQcKADUGCgA1BdcAewSkADUF1wB7BN8ANQQ9ACkEPwCoBYcAjQS4ALgHJwC4BNn/iwSDALoESv/DAqb/2wNeAN0Cpv93BDkAFAMz/0YEbwH8BMEAWgTDACUD3QBaBMEAWgR1AFoC/P8lBFT/jQTVACUCYAAlAmD++ASLACUCYAAlBz0AJQTVACUErgBaBMP/vATBAFoDXgAlA8kAFwNIAF4E1QBvBBkAZgZOAH0EP/+cBCf/cwOk/9EC1//4BGgBxwLX/5wEaABtAhQAAAJK/7YEaACkBGj/9ARoAHMEaABYBGgBxwPjABQEbwGNBqgAfQMEAJgEfwBIBGgAbQKTACkGqAB9BAD/+gNtAKQEaABtAwgAOwMIAFwEbwHjBOH/vAU9AJMCSACDAaT/MQMIAIEC8gCiBH8AAAcMAGEHDABhBwwAhQOs/7wFBv+FBQb/hQUG/4UFBv+FBQb/hQUG/4UHKf+FBOUAewRWADUEVgA1BFYANQRWADUDEP/FAxD/xQMQ/8UDEP/FBWoAJQYKADUF1wB7BdcAewXXAHsF1wB7BdcAewRoAIEF1wBkBYcAjQWHAI0FhwCNBYcAjQSDALoEpAA1BUb+/ATBAFoEwQBaBMEAWgTBAFoEwQBaBMEAWgb6AFoD3QBaBHUAWgR1AFoEdQBaBHUAWgJgACUCYAAlAmAAJAJgACUEngBIBNUAJQSuAFoErgBaBK4AWgSuAFoErgBaBGgAbQSuACsE1QBvBNUAbwTVAG8E1QBvBCf/cwTD/7wEJ/9zBQb/hQTBAFoFBv+FBMEAWgUG/4UEwQBaBOUAewPdAFoE5QB7A90AWgTlAHsD3QBaBOUAewPdAFoFagA1BMEAWgVqACUEwQBaBFYANQR1AFoEVgA1BHUAWgRWADUEdQBaBFYANQR1AFoEVgA1BHUAWgWFAHsEVP+NBYUAewRU/40FhQB7BFT/jQWFAHsEVP+NBZoANQTVACUFmgA1BNUAJQMQ/8UCYAAlAxD/xQJgACUDEP/FAmAAJQMQ/8UCYP+0AxD/xQJgACUFtv/FBMEAJQKm/r4CYP76BOcANQSLACUEiwAlBCUANQJgACUEJQA1AmD/nQQlADUCYAAlBCUANQN5ACUEJwAAAp4AAAYKADUE1QAlBgoANQTVACUGCgA1BNUAJQVzAAEGCgA1BNUAJQXXAHsErgBaBdcAewSuAFoF1wB7BK4AWgc1AHsHDgBaBN8ANQNeACUE3wA1A17/oQTfADUDXgAlBD0AKQPJABcEPQApA8kAFwQ9ACkDyQAXBD0AKQPJABcEPwB/A0gAOAQ/AKgDSABeBD8ApgNIAB8FhwCNBNUAbwWHAI0E1QBvBYcAjQTVAG8FhwCNBNUAbwWHAI0E1QBvBYcAjQTVAG8HJwC4Bk4AfQSDALoEJ/9zBIMAugRK/8MDpP/RBEr/wwOk/9EESv/DA6T/0QLd/woEaP/hBQb/hQS2AFoHKf+FBvoAWgXXAGQErgArBD0AKQPJABcEbwE3BG8BeQRIAYEEbwGuAmABQgSeAhQBpv9UBG8BOwRvARcEbwI1BG8BVgUG/4UCSACDBQoAIgYtACIEEgAiBk4APgW6ACIGZAA+AvAARwUG/4UE9gA1BAYANQTX/8sEVgA1BEr/wwWaADUF8AB7AxD/xQTnADUEzf+FBwoANQYKADUEK//VBdcAewWPADUEpAA1BFj/1QQ/AKgEgwC6BocAewTZ/4sGhwCyBcv/wwMQ/8UEgwC6BNkAWgQbACcE1QAlAvAAYATuAHcE2QBaBPb/vgQZADsEtAA3BBsAJwO0AFoE1QAlBK4AZALwAGAEiwAlBJP/pATh/7wEZgBmA7QAXASuAFoFuABeBMP/vgO0AFoE8gBaA/4AXgTuAHcGHQBaBGr+/AZ3AHcGjwBaAvAAYATuAHcErgBaBO4AdwaPAFoEVgA1BfAAqAQGADUE5QB7BD0AKQMQ/8UDEP/FAqb+vgeq/8MHgQA1BfAAqATDADUEyQAfBY8ANQUG/4UEvAA1BPYANQQGADUFw/87BFYANQbw/4MExQApBgoANQYKADUEwwA1BY//wwcKADUFmgA1BdcAewWPADUEpAA1BOUAewQ/AKgEyQAfBocAewTZ/4sF3QA1BWIAuAgIADUIVgA1BZEAqAbXADUEvAA1BOUAGwgMADUE5/+DBMEAWgSuAG0ElgBaA9UAFATPAFoEdQBaB67/7AQxABkE1QBvBNUAbwSgACUE7P/FBlQAFwTuACUErgBaBNUAJQTD/7wD3QBaBz0AJQQn/3MGGwBaBD//nAT2AGoEwwCkBz0AagdeAGoFZABcBm0AagSBAGgD3QAfBq4AJQSo/+wEdQBaBNUAJQPVABQD3QBaA8kAFwJgACUCYAAlAmD++Abn/8UG5wAxBNUAJQSgACUEJ/9zBNUAagQGADUDtAAlBycAuAZOAH0HJwC4Bk4AfQcnALgGTgB9BIMAugQn/3MD1wApB64AKQeuACkDM/8sAbgAcwG4AGoCOf+aAbgA3wN3AHMDdwBqA/r/mgQMAL4EIQA7AuMAaAaqABkJvgBzAgoAyQOgAMkCmABIApgAAAR9ABkBAP3sAxkAhQRoAAAEaP/0BtkAOQRoACkGHwB7BAAAKQfVABkF/gBqBcv/wwT0AG0HDABhBwwAXAcMAGYHDACUBKYATATX/8sF7gDBBQwAewRoAG0EZABiBagAhQNMAAAEaABtBGgAbQRoAG0EaABtBKoAcQVI/yUFSP8lBG8BPQJg/voEAAHuBAAAewQAAdUDCABiAwgALwMIAF4DCABaAwgAewMIAFIDCABaBAAAAAgAAAAEAAAACAAAAAKqAAACAAAAAVYAAAR5AAACSAAAAZoAAADNAAAAAAAAAAAAAAgAAFQIAABUAmD++gG4AGoFiwB1BJoAuAeBAF4HCgA1Bz0AJQUG/4UEwQBaBjv+7gKq/5oCAABmCAD/JQgA/yUGLQB7BSUAWgYzAI0FsABqAAD87wAA/a8AAPyAAAD9pAAA/GIEVgA1BgoANQR1AFoE1QBvCDEAgQakAGYFBgB7BNMAPQcZADUGAAAlBVr/hQSk/4MHZAA1BrAAJQXX/6oEov+aB+EANQagACUExf+wBDH/pAaHALIGdwB3BdcAewSuAFoFMwC4BF4AZgUzALgEXgBmCe4Aewh9AFoGDgB7BRAAWggxAIEGrgBaCDEAgQakAGYE5QB7A90AWgTfAGgESAEtBHEBPwRvAloEbwI7B+kAKQemACkGkQA1BQgAagS8ADUEhQBzBKQANQTD/7wEBgAdA7T/9AVUADUElgAlB1r/gweu/+wExQApBDEAGQV/ADUE5QAlBMMANQS0AFoE5wA1BIsAJQV7AKgFLwBKBiEANQVIACUGKQA1BbAAJQhCADUG6QAlBdcAewTnAFoE5QB7A90AWgQ/AKgHaAAlBIMAugQZAGYEgwBMBBn/wwWH/4sEtP+cBrIAqAV1AFwF/AC4BR0ApAViALgE1QCkBWIANQTVACUGOwA9BUoAFAY7AD0FSgAUAxD/xQbw/4MHrv/sBYkANQT0ACUGFP/DBUb/xQWaADUE7gAlBiEANQVIACUFYgC4BMMApAeRADUGsgAXAxD/xQUG/4UEwQBaBQb/hQTBAFoHKf+FBvoAWgRWADUEdQBaBUgARAR1ADMFSABEBHUAMwbw/4MHrv/sBMUAKQQxABkEcf/8BGD/pgYKADUE1QBvBgoANQTVAG8F1wB7BK4AWgXXAHsErgBaBdcAewSuAFoE5QAbA90AHwTJAB8EJ/9zBMkAHwQn/3MEyQAfBCf/cwViALgEwwCkBAYANQO0ACUG1wA1Bm0AagQGAB0DtP/0BYf/iwTL/5wE2f+LBD//nASkAD0EwQBaBukAPQcAAFoG4QDFBocAiQVCAIME0wCyB9X/wwcr/8UH3wA1By8AJQXjAHsFDABaBaoAqAViAF4EuABEBBsAJwY1/8MFi//FBQb/hQTBAFoFBv+FBMEAWgUG/4UEwQBaBQb/hQTBAFoFBv+FBMEAWgUG/4UEwQBaBQb/hQTBAFoFBv+FBMEAWgUG/4UEwQBaBQb/hQTBAFoFBv+FBMEAWgUG/4UEwQBaBFYANQR1AFoEVgA1BHUAWgRWADUEdQBaBFYANQR1AFoEVgA1BHUAWgRWADUEdQBaBFYANQR1AFoEVgA1BHUAWgMQ/8UCYAAlAxD/xQJg/98F1wB7BK4AWgXXAHsErgBaBdcAewSuAFoF1wB7BK4AWgXXAHsErgBaBdcAewSuAFoF1wB7BK4AWgYtAHsFJQBaBi0AewUlAFoGLQB7BSUAWgYtAHsFJQBaBi0AewUlAFoFhwCNBNUAbwWHAI0E1QBvBjMAjQWwAGoGMwCNBbAAagYzAI0FsABqBjMAjQWwAGoGMwCNBbAAagSDALoEJ/9z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AGMAkABkAMsAZQDIAMoBBgEHAQgBCQDpAGYA0wDQANEArwBnAPAAkQDWANQA1QBoAOsA7QCJAGoAaQBrAG0AbABuAKAAbwBxAHAAcgBzAHUAdAB2AHcA6gB4AHoAeQB7AH0AfAC4AKEAfwB+AIAAgQDsAO4AugEKAQsBDAENAQ4BDwD9AP4BEAERARIBEwD/AQABFAEVARYBAQEXARgBGQEaARsBHAEdAR4BHwEgASEBIgD4APkBIwEkASUBJgEnASgBKQEqASsBLAEtAS4BLwEwATEBMgEzANcBNAE1ATYBNwE4ATkBOgE7ATwBPQE+AT8BQAFBAUIA4gDjAUMBRAFFAUYBRwFIAUkBSgFLAUwBTQFOAU8BUAFRALAAsQFSAVMBVAFVAVYBVwFYAVkBWgFbAPsA/ADkAOUBXAFdAV4BXwFgAWEBYgFjAWQBZQFmAWcBaAFpAWoBawFsAW0BbgFvAXABcQC7AXIBcwF0AXUA5gDnAXYApgF3AXgBeQF6AXsBfAF9AX4A2ADhANoA2wDcAN0A4ADZAN8BfwGAAYEBggGDAYQBhQGGAYcBiAGJAYoBiwGMAY0BjgGPAZABkQGSAZMBlAGVAZYBlwGYAZkBmgGbAZwBnQGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAasBrAGtAa4BrwGwAbEBsgGzAbQBtQG2AbcAmwG4AbkBugG7AbwBvQG+Ab8BwAHBAcIBwwHEAcUBxgHHAcgByQHKAcsBzAHNAc4BzwHQAdEB0gHTAdQB1QHWAdcB2AHZAdoB2wHcAd0B3gHfAeAB4QHiAeMB5AHlAeYB5wHoAekB6gHrAewB7QHuAe8B8AHxAfIB8wH0AfUB9gH3AfgB+QH6AfsB/AH9Af4B/wIAAgECAgIDAgQCBQIGAgcCCAIJAgoCCwIMAg0CDgIPAhACEQISAhMCFAIVAhYCFwIYAhkCGgIbAhwCHQIeAh8CIAIhAiICIwIkAiUCJgInAigCKQIqAisAsgCzAiwCLQC2ALcAxAIuALQAtQDFAIIAwgCHAKsAxgIvAjAAvgC/AjEAvAIyAPcCMwI0AjUCNgI3AjgAjACfAjkCOgI7AjwCPQCYAKgAmgCZAO8ApQCSAJwApwCPAJQAlQC5Aj4CPwJAAkECQgJDAkQCRQJGAkcCSAJJAkoCSwJMAk0CTgJPAlACUQJSAlMCVAJVAlYCVwJYAlkCWgJbAlwCXQJeAl8CYAJhAmICYwJkAmUCZgJnAmgCaQJqAmsCbAJtAm4CbwJwAnECcgJzAnQCdQJ2AncCeAJ5AnoCewJ8An0CfgJ/AoACgQKCAoMChAKFAoYChwKIAokCigKLAowCjQKOAo8CkAKRApICkwKUApUClgKXApgCmQKaApsCnAKdAp4CnwKgAqECogKjAqQCpQKmAqcCqAKpAqoCqwKsAq0CrgKvArACsQKyArMCtAK1ArYCtwK4ArkCugK7ArwCvQK+Ar8CwALBAsICwwLEAsUCxgLHAsgCyQLKAssCzALNAs4CzwLQAtEC0gLTAtQC1QLWAtcC2ALZAtoC2wLcAt0C3gLfAuAC4QLiAuMC5ALlAuYC5wLoAukC6gLrAuwC7QLuAu8C8ALxAvIC8wL0AvUC9gL3AvgC+QL6AvsC/AL9Av4C/wMAAwEDAgMDAwQDBQMGAwcDCAMJAwoDCwMMAw0DDgMPAxADEQMSAxMDFAMVAxYDFwMYAxkDGgMbAxwDHQMeAx8DIAMhAyIDIwMkAyUDJgMnAygDKQMqAysDLAMtAy4DLwMwAzEDMgMzAzQDNQM2AzcDOAM5AzoDOwM8Az0DPgM/A0ADQQNCA0MDRANFA0YDRwNIA0kDSgNLA0wDTQNOA08DUANRA1IDUwNUA1UDVgNXA1gDWQNaA1sDXANdA14DXwNgA2EDYgNjA2QDZQNmA2cDaANpA2oDawNsA20DbgNvA3ADcQNyA3MDdAN1A3YDdwN4A3kDegN7A3wDfQN+A38DgAOBA4IDgwOEA4UDhgOHA4gDiQOKA4sDjAONA44DjwOQA5EDkgOTA5QDlQOWA5cDmAOZA5oDmwOcA50ALADPAMwAzQDOA54DnwOgA6EA+gOiA6MDpAOlA6YDpwOoA6kDqgOrBG51bGwFSS5hbHQHdW5pMDBBRAlvdmVyc2NvcmUKSWdyYXZlLmFsdApJYWN1dGUuYWx0D0ljaXJjdW1mbGV4LmFsdA1JZGllcmVzaXMuYWx0B0FtYWNyb24HYW1hY3JvbgZBYnJldmUGYWJyZXZlB0FvZ29uZWsHYW9nb25lawtDY2lyY3VtZmxleAtjY2lyY3VtZmxleARDZG90BGNkb3QGRGNhcm9uBmRjYXJvbgZEY3JvYXQHRW1hY3JvbgdlbWFjcm9uBkVicmV2ZQZlYnJldmUKRWRvdGFjY2VudAplZG90YWNjZW50B0VvZ29uZWsHZW9nb25lawZFY2Fyb24GZWNhcm9uC0djaXJjdW1mbGV4C2djaXJjdW1mbGV4BEdkb3QEZ2RvdAxHY29tbWFhY2NlbnQMZ2NvbW1hYWNjZW50C0hjaXJjdW1mbGV4C2hjaXJjdW1mbGV4BEhiYXIEaGJhcgpJdGlsZGUuYWx0Bml0aWxkZQtJbWFjcm9uLmFsdAdpbWFjcm9uCklicmV2ZS5hbHQGaWJyZXZlC0lvZ29uZWsuYWx0B2lvZ29uZWsOSWRvdGFjY2VudC5hbHQGSUouYWx0AmlqC0pjaXJjdW1mbGV4C2pjaXJjdW1mbGV4DEtjb21tYWFjY2VudAxrY29tbWFhY2NlbnQMa2dyZWVubGFuZGljBkxhY3V0ZQZsYWN1dGUMTGNvbW1hYWNjZW50DGxjb21tYWFjY2VudAZMY2Fyb24GbGNhcm9uBExkb3QEbGRvdAZOYWN1dGUGbmFjdXRlDE5jb21tYWFjY2VudAxuY29tbWFhY2NlbnQGTmNhcm9uBm5jYXJvbgtuYXBvc3Ryb3BoZQNFbmcDZW5nB09tYWNyb24Hb21hY3JvbgZPYnJldmUGb2JyZXZlDU9odW5nYXJ1bWxhdXQNb2h1bmdhcnVtbGF1dAZSYWN1dGUGcmFjdXRlDFJjb21tYWFjY2VudAxyY29tbWFhY2NlbnQGUmNhcm9uBnJjYXJvbgZTYWN1dGUGc2FjdXRlC1NjaXJjdW1mbGV4C3NjaXJjdW1mbGV4DFRjb21tYWFjY2VudAx0Y29tbWFhY2NlbnQGVGNhcm9uBnRjYXJvbgRUYmFyBHRiYXIGVXRpbGRlBnV0aWxkZQdVbWFjcm9uB3VtYWNyb24GVWJyZXZlBnVicmV2ZQVVcmluZwV1cmluZw1VaHVuZ2FydW1sYXV0DXVodW5nYXJ1bWxhdXQHVW9nb25lawd1b2dvbmVrC1djaXJjdW1mbGV4C3djaXJjdW1mbGV4C1ljaXJjdW1mbGV4C3ljaXJjdW1mbGV4BlphY3V0ZQZ6YWN1dGUKWmRvdGFjY2VudAp6ZG90YWNjZW50BWxvbmdzCkFyaW5nYWN1dGUKYXJpbmdhY3V0ZQdBRWFjdXRlB2FlYWN1dGULT3NsYXNoYWN1dGULb3NsYXNoYWN1dGUMU2NvbW1hYWNjZW50DHNjb21tYWFjY2VudAV0b25vcw1kaWVyZXNpc3Rvbm9zCkFscGhhdG9ub3MJYW5vdGVsZWlhDEVwc2lsb250b25vcwhFdGF0b25vcw1Jb3RhdG9ub3MuYWx0DE9taWNyb250b25vcwxVcHNpbG9udG9ub3MKT21lZ2F0b25vcxFpb3RhZGllcmVzaXN0b25vcwVBbHBoYQRCZXRhBUdhbW1hB3VuaTAzOTQHRXBzaWxvbgRaZXRhA0V0YQVUaGV0YQhJb3RhLmFsdAVLYXBwYQZMYW1iZGECTXUCTnUCWGkHT21pY3JvbgJQaQNSaG8FU2lnbWEDVGF1B1Vwc2lsb24DUGhpA0NoaQNQc2kHdW5pMDNBORBJb3RhZGllcmVzaXMuYWx0D1Vwc2lsb25kaWVyZXNpcwphbHBoYXRvbm9zDGVwc2lsb250b25vcwhldGF0b25vcwlpb3RhdG9ub3MUdXBzaWxvbmRpZXJlc2lzdG9ub3MFYWxwaGEEYmV0YQVnYW1tYQVkZWx0YQdlcHNpbG9uBHpldGEDZXRhBXRoZXRhBGlvdGEFa2FwcGEGbGFtYmRhB3VuaTAzQkMCbnUCeGkHb21pY3JvbgNyaG8Gc2lnbWExBXNpZ21hA3RhdQd1cHNpbG9uA3BoaQNjaGkDcHNpBW9tZWdhDGlvdGFkaWVyZXNpcw91cHNpbG9uZGllcmVzaXMMb21pY3JvbnRvbm9zDHVwc2lsb250b25vcwpvbWVnYXRvbm9zCWFmaWkxMDAyMwlhZmlpMTAwNTEJYWZpaTEwMDUyCWFmaWkxMDA1MwlhZmlpMTAwNTQNYWZpaTEwMDU1LmFsdA1hZmlpMTAwNTYuYWx0CWFmaWkxMDA1NwlhZmlpMTAwNTgJYWZpaTEwMDU5CWFmaWkxMDA2MAlhZmlpMTAwNjEJYWZpaTEwMDYyCWFmaWkxMDE0NQlhZmlpMTAwMTcJYWZpaTEwMDE4CWFmaWkxMDAxOQlhZmlpMTAwMjAJYWZpaTEwMDIxCWFmaWkxMDAyMglhZmlpMTAwMjQJYWZpaTEwMDI1CWFmaWkxMDAyNglhZmlpMTAwMjcJYWZpaTEwMDI4CWFmaWkxMDAyOQlhZmlpMTAwMzAJYWZpaTEwMDMxCWFmaWkxMDAzMglhZmlpMTAwMzMJYWZpaTEwMDM0CWFmaWkxMDAzNQlhZmlpMTAwMzYJYWZpaTEwMDM3CWFmaWkxMDAzOAlhZmlpMTAwMzkJYWZpaTEwMDQwCWFmaWkxMDA0MQlhZmlpMTAwNDIJYWZpaTEwMDQzCWFmaWkxMDA0NAlhZmlpMTAwNDUJYWZpaTEwMDQ2CWFmaWkxMDA0NwlhZmlpMTAwNDgJYWZpaTEwMDQ5CWFmaWkxMDA2NQlhZmlpMTAwNjYJYWZpaTEwMDY3CWFmaWkxMDA2OAlhZmlpMTAwNjkJYWZpaTEwMDcwCWFmaWkxMDA3MglhZmlpMTAwNzMJYWZpaTEwMDc0CWFmaWkxMDA3NQlhZmlpMTAwNzYJYWZpaTEwMDc3CWFmaWkxMDA3OAlhZmlpMTAwNzkJYWZpaTEwMDgwCWFmaWkxMDA4MQlhZmlpMTAwODIJYWZpaTEwMDgzCWFmaWkxMDA4NAlhZmlpMTAwODUJYWZpaTEwMDg2CWFmaWkxMDA4NwlhZmlpMTAwODgJYWZpaTEwMDg5CWFmaWkxMDA5MAlhZmlpMTAwOTEJYWZpaTEwMDkyCWFmaWkxMDA5MwlhZmlpMTAwOTQJYWZpaTEwMDk1CWFmaWkxMDA5NglhZmlpMTAwOTcJYWZpaTEwMDcxCWFmaWkxMDA5OQlhZmlpMTAxMDAJYWZpaTEwMTAxCWFmaWkxMDEwMglhZmlpMTAxMDMJYWZpaTEwMTA0CWFmaWkxMDEwNQlhZmlpMTAxMDYJYWZpaTEwMTA3CWFmaWkxMDEwOAlhZmlpMTAxMDkJYWZpaTEwMTEwCWFmaWkxMDE5MwlhZmlpMTAwNTAJYWZpaTEwMDk4BldncmF2ZQZ3Z3JhdmUGV2FjdXRlBndhY3V0ZQlXZGllcmVzaXMJd2RpZXJlc2lzBllncmF2ZQZ5Z3JhdmUJYWZpaTAwMjA4DXVuZGVyc2NvcmVkYmwNcXVvdGVyZXZlcnNlZAZtaW51dGUGc2Vjb25kCWV4Y2xhbWRibAluc3VwZXJpb3IJYWZpaTA4OTQxBnBlc2V0YQRFdXJvCWFmaWk2MTI0OAlhZmlpNjEyODkJYWZpaTYxMzUyCWVzdGltYXRlZAlvbmVlaWdodGgMdGhyZWVlaWdodGhzC2ZpdmVlaWdodGhzDHNldmVuZWlnaHRocwd1bmlGQjAxB3VuaUZCMDINY3lyaWxsaWNicmV2ZQhkb3RsZXNzahBjYXJvbmNvbW1hYWNjZW50C2NvbW1hYWNjZW50EWNvbW1hYWNjZW50cm90YXRlDHplcm9zdXBlcmlvcgxmb3Vyc3VwZXJpb3IMZml2ZXN1cGVyaW9yC3NpeHN1cGVyaW9yDXNldmVuc3VwZXJpb3INZWlnaHRzdXBlcmlvcgxuaW5lc3VwZXJpb3IHdW5pMjAwMAd1bmkyMDAxB3VuaTIwMDIHdW5pMjAwMwd1bmkyMDA0B3VuaTIwMDUHdW5pMjAwNgd1bmkyMDA3B3VuaTIwMDgHdW5pMjAwOQd1bmkyMDBBB3VuaTIwMEIHdW5pRkVGRgd1bmlGRkZDB3VuaUZGRkQHdW5pMDFGMAd1bmkwMkJDB3VuaTAzRDEHdW5pMDNEMgd1bmkwM0Q2B3VuaTFFM0UHdW5pMUUzRgd1bmkxRTAwB3VuaTFFMDEHdW5pMUY0RAd1bmkwMkYzCWRhc2lhb3hpYQd1bmlGQjAzB3VuaUZCMDQFT2hvcm4Fb2hvcm4FVWhvcm4FdWhvcm4HdW5pMDMwMAd1bmkwMzAxB3VuaTAzMDMEaG9vawhkb3RiZWxvdwd1bmkwNDAwB3VuaTA0MEQHdW5pMDQ1MAd1bmkwNDVEB3VuaTA0NjAHdW5pMDQ2MQd1bmkwNDYyB3VuaTA0NjMHdW5pMDQ2NAd1bmkwNDY1B3VuaTA0NjYHdW5pMDQ2Nwd1bmkwNDY4B3VuaTA0NjkHdW5pMDQ2QQd1bmkwNDZCB3VuaTA0NkMHdW5pMDQ2RAd1bmkwNDZFB3VuaTA0NkYHdW5pMDQ3MAd1bmkwNDcxB3VuaTA0NzIHdW5pMDQ3Mwd1bmkwNDc0B3VuaTA0NzUHdW5pMDQ3Ngd1bmkwNDc3B3VuaTA0NzgHdW5pMDQ3OQd1bmkwNDdBB3VuaTA0N0IHdW5pMDQ3Qwd1bmkwNDdEB3VuaTA0N0UHdW5pMDQ3Rgd1bmkwNDgwB3VuaTA0ODEHdW5pMDQ4Mgd1bmkwNDgzB3VuaTA0ODQHdW5pMDQ4NQd1bmkwNDg2B3VuaTA0ODgHdW5pMDQ4OQd1bmkwNDhBB3VuaTA0OEIHdW5pMDQ4Qwd1bmkwNDhEB3VuaTA0OEUHdW5pMDQ4Rgd1bmkwNDkyB3VuaTA0OTMHdW5pMDQ5NAd1bmkwNDk1B3VuaTA0OTYHdW5pMDQ5Nwd1bmkwNDk4B3VuaTA0OTkHdW5pMDQ5QQd1bmkwNDlCB3VuaTA0OUMHdW5pMDQ5RAd1bmkwNDlFB3VuaTA0OUYHdW5pMDRBMAd1bmkwNEExB3VuaTA0QTIHdW5pMDRBMwd1bmkwNEE0B3VuaTA0QTUHdW5pMDRBNgd1bmkwNEE3B3VuaTA0QTgHdW5pMDRBOQd1bmkwNEFBB3VuaTA0QUIHdW5pMDRBQwd1bmkwNEFEB3VuaTA0QUUHdW5pMDRBRgd1bmkwNEIwB3VuaTA0QjEHdW5pMDRCMgd1bmkwNEIzB3VuaTA0QjQHdW5pMDRCNQd1bmkwNEI2B3VuaTA0QjcHdW5pMDRCOAd1bmkwNEI5B3VuaTA0QkEHdW5pMDRCQgd1bmkwNEJDB3VuaTA0QkQHdW5pMDRCRQd1bmkwNEJGC3VuaTA0QzAuYWx0B3VuaTA0QzEHdW5pMDRDMgd1bmkwNEMzB3VuaTA0QzQHdW5pMDRDNQd1bmkwNEM2B3VuaTA0QzcHdW5pMDRDOAd1bmkwNEM5B3VuaTA0Q0EHdW5pMDRDQgd1bmkwNENDB3VuaTA0Q0QHdW5pMDRDRQt1bmkwNENGLmFsdAd1bmkwNEQwB3VuaTA0RDEHdW5pMDREMgd1bmkwNEQzB3VuaTA0RDQHdW5pMDRENQd1bmkwNEQ2B3VuaTA0RDcHdW5pMDREOAd1bmkwNEQ5B3VuaTA0REEHdW5pMDREQgd1bmkwNERDB3VuaTA0REQHdW5pMDRERQd1bmkwNERGB3VuaTA0RTAHdW5pMDRFMQd1bmkwNEUyB3VuaTA0RTMHdW5pMDRFNAd1bmkwNEU1B3VuaTA0RTYHdW5pMDRFNwd1bmkwNEU4B3VuaTA0RTkHdW5pMDRFQQd1bmkwNEVCB3VuaTA0RUMHdW5pMDRFRAd1bmkwNEVFB3VuaTA0RUYHdW5pMDRGMAd1bmkwNEYxB3VuaTA0RjIHdW5pMDRGMwd1bmkwNEY0B3VuaTA0RjUHdW5pMDRGNgd1bmkwNEY3B3VuaTA0RjgHdW5pMDRGOQd1bmkwNEZBB3VuaTA0RkIHdW5pMDRGQwd1bmkwNEZEB3VuaTA0RkUHdW5pMDRGRgd1bmkwNTAwB3VuaTA1MDEHdW5pMDUwMgd1bmkwNTAzB3VuaTA1MDQHdW5pMDUwNQd1bmkwNTA2B3VuaTA1MDcHdW5pMDUwOAd1bmkwNTA5B3VuaTA1MEEHdW5pMDUwQgd1bmkwNTBDB3VuaTA1MEQHdW5pMDUwRQd1bmkwNTBGB3VuaTA1MTAHdW5pMDUxMQd1bmkwNTEyB3VuaTA1MTMHdW5pMUVBMAd1bmkxRUExB3VuaTFFQTIHdW5pMUVBMwd1bmkxRUE0B3VuaTFFQTUHdW5pMUVBNgd1bmkxRUE3B3VuaTFFQTgHdW5pMUVBOQd1bmkxRUFBB3VuaTFFQUIHdW5pMUVBQwd1bmkxRUFEB3VuaTFFQUUHdW5pMUVBRgd1bmkxRUIwB3VuaTFFQjEHdW5pMUVCMgd1bmkxRUIzB3VuaTFFQjQHdW5pMUVCNQd1bmkxRUI2B3VuaTFFQjcHdW5pMUVCOAd1bmkxRUI5B3VuaTFFQkEHdW5pMUVCQgd1bmkxRUJDB3VuaTFFQkQHdW5pMUVCRQd1bmkxRUJGB3VuaTFFQzAHdW5pMUVDMQd1bmkxRUMyB3VuaTFFQzMHdW5pMUVDNAd1bmkxRUM1B3VuaTFFQzYHdW5pMUVDNwt1bmkxRUM4LmFsdAd1bmkxRUM5C3VuaTFFQ0EuYWx0B3VuaTFFQ0IHdW5pMUVDQwd1bmkxRUNEB3VuaTFFQ0UHdW5pMUVDRgd1bmkxRUQwB3VuaTFFRDEHdW5pMUVEMgd1bmkxRUQzB3VuaTFFRDQHdW5pMUVENQd1bmkxRUQ2B3VuaTFFRDcHdW5pMUVEOAd1bmkxRUQ5B3VuaTFFREEHdW5pMUVEQgd1bmkxRURDB3VuaTFFREQHdW5pMUVERQd1bmkxRURGB3VuaTFFRTAHdW5pMUVFMQd1bmkxRUUyB3VuaTFFRTMHdW5pMUVFNAd1bmkxRUU1B3VuaTFFRTYHdW5pMUVFNwd1bmkxRUU4B3VuaTFFRTkHdW5pMUVFQQd1bmkxRUVCB3VuaTFFRUMHdW5pMUVFRAd1bmkxRUVFB3VuaTFFRUYHdW5pMUVGMAd1bmkxRUYxB3VuaTFFRjQHdW5pMUVGNQd1bmkxRUY2B3VuaTFFRjcHdW5pMUVGOAd1bmkxRUY5B3VuaTIwQUIHdW5pMDMwRhNjaXJjdW1mbGV4YWN1dGVjb21iE2NpcmN1bWZsZXhncmF2ZWNvbWISY2lyY3VtZmxleGhvb2tjb21iE2NpcmN1bWZsZXh0aWxkZWNvbWIOYnJldmVhY3V0ZWNvbWIOYnJldmVncmF2ZWNvbWINYnJldmVob29rY29tYg5icmV2ZXRpbGRlY29tYhBjeXJpbGxpY2hvb2tsZWZ0CG9uZS5wbnVtB3plcm8ub3MGb25lLm9zBnR3by5vcwh0aHJlZS5vcwdmb3VyLm9zB2ZpdmUub3MGc2l4Lm9zCHNldmVuLm9zCGVpZ2h0Lm9zB25pbmUub3MCZmYHdW5pMjEyMAhUY2VkaWxsYQh0Y2VkaWxsYQVnLmFsdA9nY2lyY3VtZmxleC5hbHQKZ2JyZXZlLmFsdAhnZG90LmFsdBBnY29tbWFhY2NlbnQuYWx0Bkl0aWxkZQdJbWFjcm9uBklicmV2ZQdJb2dvbmVrAklKCUlvdGF0b25vcwRJb3RhDElvdGFkaWVyZXNpcwlhZmlpMTAwNTUJYWZpaTEwMDU2B3VuaTA0QzAHdW5pMDRDRgd1bmkxRUM4B3VuaTFFQ0EAAAEAAgAIAAr//wAPAAEAAAAMAAAAAAAAAAIABQAAAjUAAQI3AjcAAQI7AlsAAQJdA3YAAQOAA6cAAQAAAAEAAAAKAAwADgAAAAAAAAABAAAACgBuAVoAAWxhdG4ACAAQAAJNT0wgAChST00gAEIAAP//AAkAAwAIAAsAAAAOABEAFAAXABoAAP//AAoABAAGAAkADAABAA8AEgAVABgAGwAA//8ACgAFAAcACgANAAIAEAATABYAGQAcAB1saWdhALBsaWdhALBsaWdhALBsbnVtALZsbnVtALZsbnVtALZsb2NsALxsb2NsALxvbnVtAMJvbnVtAMJvbnVtAMJwbnVtAMpwbnVtAMpwbnVtAMpzYWx0ANBzYWx0ANBzYWx0ANBzczAxANBzczAxANBzczAxANBzczAyANhzczAyANhzczAyANhzczAzAN5zczAzAN5zczAzAN50bnVtAOR0bnVtAOR0bnVtAOQAAAABAAkAAAABAAcAAAABAAgAAAACAAIAAwAAAAEABAAAAAIAAAABAAAAAQAAAAAAAQABAAAAAgAFAAYACgAWADwAfACUAMwA4ADuAQIBLgFQAAEAAAABAAgAAgAQAAUDjwOQA5EDkgOTAAEABQBKAN8A4QDjAOUAAQAAAAEACAACAC4AFAAsAI4AjwCQAJEA6gDsAO4A8ADyAPQBWgFnAXcBoQGiAskC2ANFA0cAAgABA5QDpwAAAAEAAAABAAgAAQAGA24AAgABABMAHAAAAAEAAAABAAgAAgAaAAoDgQODA4QDhQOGA4cDiAOJA4oDggACAAMAEwATAAAAFQAcAAEDgAOAAAkAAQAAAAEACAABAAYDbAABAAEAFAABAAAAAQAIAAEAPPySAAEAAAABAAgAAQAG/JQAAQABA4AAAQAAAAEACAACABoACgATA4AAFQAWABcAGAAZABoAGwAcAAIAAQOBA4oAAAABAAAAAQAIAAIADgAEA40DjgEgASEAAQAEASQBJQFJAUoABAAAAAEACAABADYAAQAIAAUADAAUABwAIgAoAl4AAwBJAE8CXQADAEkATAOLAAIASQI1AAIATwI0AAIATAABAAEASQAA";

var openSansExtraBold = "data:font/ttf;base64,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NxEGBgEUFjMyNjU0JiMiBiUiByEmJgWa7pGX+/7+/s8BKwEO4pWb9eMBCP1IBIx0wqpcvvvGTFxbS0xcWU0DmqIOAVQCXBSJiQE+AQ8BFQEzf3/+8PisWnFW/ucvJAJNkpmZkpGUlK20UmIA//8AngAABYMHcwImADUAAAEHAHYArAFSAAizAhwFJgArNf//AIcAAAPrBiECJgBVAAABBgB2LwAACLMBGxEmACs1//8Anv47BYMFtgImADUAAAAHAjkA5wAA//8Abf47A6oEgQImAFUAAAAHAjn/PAAA//8AngAABYMHcwImADUAAAEHAUwAPQFSAAizAhgFJgArNf//AFsAAAPmBiECJgBVAAABBgFMtwAACLMBFxEmACs1//8AWv/sBFoHcwImADYAAAEHAHYAmAFSAAizATAFJgArNf//AHf/7AQSBiECJgBWAAABBgB2VgAACLMBLhEmACs1//8AWv/sBFoHcwImADYAAAEHAUsABgFSAAizATQFJgArNf//AFf/7APyBiECJgBWAAABBgFLswAACLMBMhEmACs1//8AWv4UBFoFywImADYAAAAHAHoBhwAA//8Ad/4UA/IEgQImAFYAAAAHAHoBZAAA//8AWv/sBFoHcwImADYAAAEHAUwADgFSAAizASwFJgArNf//AGH/7APyBiECJgBWAAABBgFMvQAACLMBKhEmACs1//8AM/47BIcFtgImADcAAAAGAjlQAP//ADX+OwNvBVACJgBXAAAABgI5EAD//wAzAAAEhwdzAiYANwAAAQcBTP/1AVIACLMBDQUmACs1//8APf/sBEYGKAAmAFcIAAEHAjgBhQAUAA23ARx0HBwQED4AKxE1AAABADMAAASHBbYADwBBQCEJBwsLDgAMBQwCAxARCg4PDk5ZBw8PAwwSBgIDAk5ZAwMAPysRADMYPxI5LzMrEQAzERIBFzkRMzMzETMzMTABESERIREhETMRIxEhESMRAZj+mwRU/pzT0/51zwNoAQsBQ/69/vX+u/3dAiMBRQABADX/7AONBVAAHgBhQDERCRgUHBwJDBkPFg8NCRYECQQfIA8XFBdGWQMAGxsLDAtMWRgMDAYSERQPBgBHWQYWAD8rABg/M8ESOS8zKxEAMxESOSsRADMREgE5OREzETMzERI5OREzETMzEjkxMAEyNjcRBiMiJjU1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A3oFQgAAAAq0AwJAESYAKzU1//8AAP4hBc8HcwImACQAAAAnAUsAgQFSAQcCZwXRAAAACrQCEBAFJgArETX//wBK/iEEeQYeAiYARAAAACYBSxf9AQcCZwVYAAAACrQCIiIRJgArETX//wAAAAAFzwgTAiYAJAAAAQcDewXJAVIACrQDAhkFJgArNTX//wBK/+wEeQbBAiYARAAAAQcDewVeAAAACrQDAisRJgArNTX//wAAAAAFzwgTAiYAJAAAAQcDfAXJAVIACrQDAhgFJgArNTX//wBK/+wEeQbBAiYARAAAAQcDfAVeAAAACrQDAioRJgArNTX//wAAAAAFzwhcAiYAJAAAAQcDfQWyAVIACrQDAhAFJgArNTX//wBK/+wEeQcKAiYARAAAAQcDfQVGAAAACrQDAiIRJgArNTX//wAAAAAFzwhiAiYAJAAAAQcDfgW2AVIACrQDAhAFJgArNTX//wBK/+wEeQcQAiYARAAAAQcDfgVKAAAACrQDAiIRJgArNTX//wAA/iEFzweSAiYAJAAAACcCZwXRAAABBwFOAIEBRgAKtAMeHgUmACsRNf//AEr+IQR5BkwCJgBEAAAAJwJnBUgAAAEGAU4bAAAKtAMwMBEmACsRNf//AJ7+IQQCBbYCJgAoAAAABwJnBTEAAP//AFb+IQScBIECJgBIAAAABwJnBW0AAP//AJ4AAAQCCAICJgAoAAABBwJmBP4BUgAIswERBSYAKzX//wBW/+wEnAawAiYASAAAAQcCZgVCAAAACLMCIREmACs1//8AngAABAIHfwImACgAAAEHAVL/9QFSAAizARQFJgArNf//AFb/7AScBi0CJgBIAAABBgFSLQAACLMCJBEmACs1//8AngAABTkH0QImACgAAAEHA3cFDgFSAAq0AgESBSYAKzU1//8AVv/sBXUGfwImAEgAAAEHA3cFSgAAAAq0AwIiESYAKzU1////YgAABAIH0QImACgAAAEHA3gFNQFSAAq0AgESBSYAKzU1////lf/sBJwGfwImAEgAAAEHA3gFaAAAAAq0AwIiESYAKzU1//8AngAABMgISgImACgAAAEHA3kFDgFSAAq0AgESBSYAKzU1//8AVv/sBQwG+AImAEgAAAEHA3kFUgAAAAq0AwIiESYAKzU1//8AngAABAIIYgImACgAAAEHA3oFEgFS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B3//9AeB//QHgQBTBAoAJQXPAAAFzwAABc8AAAXPAAAFzwAABc8AAAeR//YFMQBoBGQAmgRkAJ4EZACXBGQAngOF/+oDhQBGA4X//wOFACgF3wAfBqwAngZgAGgGYABoBmAAaAZgAGgGYABoBIcAeQZgAGgGDgCWBg4AlgYOAJYGDgCWBVAAAAUEAJ4GAACHBPwASgT8AEoE/ABKBPwASgT8AEoE/ABKB3sASgRQAFYE8gBWBPIAVgTyAFYE8gBWApr/fgKaAGsCmv+IApr/wwUhAFgFXACHBRkAVgUZAFYFGQBWBRkAVgUZAFYEhwBIBVIAVgVcAIUFXACFBVwAhQVcAIUE4f/+BSUAhwTh//4FzwAABPwASgXPAAAE/ABKBc8AAAT8AEoFMQBoBFAAVgUxAGgEUABWBTEAaARQAFYFMQBoBFAAVgXfAJ4FJQBWBd8AHwVOAFYEZACeBPIAVgRkAJ4E8gBWBGQAngTyAFYEZACeBPIAVgRkAIgE8gBWBewAaATZABQF7ABoBNkAFAXsAGgE2QAUBewAaATZABQGIQCeBVwAhwZCAAAFcQAAA4UAIAKa/6sDhQBGApr/5QOFADICmv+5A4UARgKaAF4DhQBGApoAiQZCAEYFDgB/AtH/XgKY/4IFfwCeBUYAhwVGAIcEqACeApYAbwSoAJ4ClgBxBKgAngKWAIcEqACeBB8AhwTf/+EDVv/hBqwAngVcAIcGrACeBVwAhwasAJ4FXACHBqoAAQasAJ4FXACHBmAAaAUZAFYGYABoBRkAVgZgAGgFGQBWB6gAaAfXAFYFagCeA8EAhwVqAJ4DwQBtBWoAngPBAFsEngBaBEQAdwSeAFoERABXBJ4AWgREAHcEngBaBEQAYQS6ADMDrgA1BLoAMwPXAD0EugAzA9cANQYOAJYFXACFBg4AlgVcAIUGDgCWBVwAhQYOAJYFXACFBg4AlgVcAIUGDgCWBVwAhQhQAB8HSAAZBVAAAATh//4FUAAABOMAPQQOADEE4wA9BA4AMQTjAD0EDgAxAzkAhwRxAIsFywAABPwASgeR//YHewBKBmAAaAVSAFYEngBaBEQAdwTVAKQE1QCkBL4A9ATJANECmgB/BGABJQGy//oEyQCwBK4ATgRUAZYEhQBzBen/sAJQAFYFRv+wBvL/sAS4/7AG1/+wBtH/sAbR/7ADe/+hBc8AAAVkAJ4EoACeBaYAIQRkAJ4E4wA9BiEAngZgAGgDhQBGBX8AngWNAAAHvACeBqwAngSYAFAGYABoBekAngUOAJ4E0QBKBLoAMwVQAAAHJwBMBckABAdxAHEGXgAxA4UAJgVQAAAFYABWBG8APwVcAIcDewCFBU4AgwVgAFYFewCHBNP//gUXAFYEbwA/BBQAVgVcAIcFIwBWA3sAhQVGAIcFUgAABWAAhwT2AAAEIQBWBRkAVgZcABcFMwCDBEQAVgVzAFYEOwAXBU4AgwbFAFYFK//LBycAgwdQAGIDe//WBU4AgwUZAFYFTgCDB1AAYgRkAJ4GoAAzBKAAngV9AGgEngBaA4UARgOFACgC0f9eCD8AGQgSAJ4GqAAzBZMAngVzABkF7ACeBc8AAAUtAJ4FZACeBKAAngaDAAgEZACeCDX/+AVUAFgGwwCeBsMAngWTAJ4GGQAZB7wAngYhAJ4GYABoBekAngUOAJ4FMQBoBLoAMwVzABkHJwBMBckABAamAJ4GEgBqCLQAnglvAJ4GGwAzB2IAngT8AJ4FXABSCJwAngVv/+wE/ABKBTcAWAVcAIcEAgCHBcsAGQTyAFYHw//4BG8ASAXRAIcF0QCHBWgAhwV/ABAG3wCHBVIAhwUZAFYFQgCHBSUAhwRQAFYE0wAxBOH//gbuAFYFCgAKBhcAhwVeAFYICACHCJgAhwW0ADEG7gCHBKQAhwRUADMHOQCHBN//5wTyAFYFcQAABAIAhwRWAFYERAB3ApoAfwKa/7cCmP+YB28AEAclAIcFcQAABWgAhwTh//4FgwCHBNsAngRYAIcIUAAfB0gAGQhQAB8HSAAZCFAAHwdIABkFUAAABOH//gQAAEoIAABKCAAATAQA//wCAAAUAgAAJQJ5ADkCAAAUA/4AFAP+ACUEdwA5BBsAbwQxAG8DIwBKBvAAVgrFACUCVgB5BDEAeQMzAEoDMwBMBKQAUgC8/k4DrgBvBLAAHwSwAGYHtACeBLAANwZtACkEsAA3CMUAjwYpACUGXgAxBPQAZgd/AAsHgQBBB4EAXQd7ACoExQAzBaYAIQXTAI8FCgAZBIcASARmACMFlgBiA2//4wSHAEgEhwBIBIcASASHAEgEngBGBecALQXjAC0EmgBgApj/mAPFASUDxQExA8UBEAMxACkDMQAdAzEAYAMxADEDMQA9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AGkAYwBlAG4AcwBlAHMALwBMAEkAQwBFAE4AUwBFAC0AMgAuADAAAAACAAAAAAAA/2YAZgAAAAAAAAAAAAAAAAAAAAAAAAAAA6oAAAECAAIAAwAEAAUABgAHAAgACQAKAAsADAANAA4ADwAQABEAEgATABQAFQAWABcAGAAZABoAGwAcAB0AHgAfACAAIQAiACMAJAAlACYAJwAoACkAKgArAQMALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADsAPAA9AD4APwBAAEEAQgBDAEQARQBGAEcASABJAEoASwBMAE0ATgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwAXQBeAF8AYABhAKwAowCEAIUAvQCWAOgAhgCOAIsAnQCpAKQBBACKAQUAgwCTAPIA8wCNAJcAiADDAN4A8QCeAKoA9QD0APYAogCtAMkAxwCuAGIAYwCQAGQAywBlAMgAygEGAQcBCAEJAOkAZgDTANAA0QCvAGcA8ACRANYA1ADVAGgA6wDtAIkAagBpAGsAbQBsAG4AoABvAHEAcAByAHMAdQB0AHYAdwDqAHgAegB5AHsAfQB8ALgAoQB/AH4AgACBAOwA7gC6AQoBCwEMAQ0BDgEPAP0A/gEQAREBEgETAP8BAAEUARUBFgEBARcBGAEZARoBGwEcAR0BHgEfASABIQEiAPgA+QEjASQBJQEmAScBKAEpASoBKwEsAS0BLgEvATABMQEyATMA1wE0ATUBNgE3ATgBOQE6ATsBPAE9AT4BPwFAAUEBQgDiAOMBQwFEAUUBRgFHAUgBSQFKAUsBTAFNAU4BTwFQAVEAsACxAVIBUwFUAVUBVgFXAVgBWQFaAVsA+wD8AOQA5QFcAV0BXgFfAWABYQFiAWMBZAFlAWYBZwFoAWkBagFrAWwBbQFuAW8BcAFxALsBcgFzAXQBdQDmAOcBdgCmAXcBeAF5AXoBewF8AX0BfgDYAOEA2gDbANwA3QDgANkA3wF/AYABgQGCAYMBhAGFAYYBhwGIAYkBigGLAYwBjQGOAY8BkAGRAZIBkwGUAZUBlgGXAZgBmQGaAZsBnAGdAZ4BnwGgAaEBogGjAaQBpQGmAacBqAGpAaoBqwGsAa0BrgGvAbABsQGyAbMBtAG1AbYBtwCbAbgBuQG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHGAccByAHJAcoBywHMAc0BzgHPAdAB0QHSAdMB1AHVAdYB1wHYAdkB2gHbAdwB3QHeAd8B4AHhAeIB4wHkAeUB5gHnAegB6QHqAesB7AHtAe4B7wHwAfEB8gHzAfQB9QH2AfcB+AH5AfoB+wH8Af0B/gH/AgACAQICAgMCBAIFAgYCBwIIAgkCCgILAgwCDQIOAg8CEAIRAhICEwIUAhUCFgIXAhgCGQIaAhsCHAIdAh4CHwIgAiECIgIjAiQCJQImAicCKAIpAioCKwCyALMCLAItALYAtwDEAi4AtAC1AMUAggDCAIcAqwDGAi8CMAC+AL8CMQC8AjIA9wIzAjQCNQI2AjcCOACMAJ8COQI6AjsCPAI9AJgAqACaAJkA7wClAJIAnACnAI8AlACVALkCPgI/AkACQQJCAkMCRAJFAkYCRwJIAkkCSgJLAkwCTQJOAk8CUAJRAlICUwJUAlUCVgJXAlgCWQJaAlsCXAJdAl4CXwJgAmECYgJjAmQCZQJmAmcCaAJpAmoCawJsAm0CbgJvAnACcQJyAnMCdAJ1AnYCdwJ4AnkCegJ7AnwCfQJ+An8CgAKBAoICgwKEAoUChgKHAogCiQKKAosCjAKNAo4CjwKQApECkgKTApQClQKWApcCmAKZApoCmwKcAp0CngKfAqACoQKiAqMCpAKlAqYCpwKoAqkCqgKrAqwCrQKuAq8CsAKxArICswK0ArUCtgK3ArgCuQK6ArsCvAK9Ar4CvwLAAsECwgLDAsQCxQLGAscCyALJAsoCywLMAs0CzgLPAtAC0QLSAtMC1ALVAtYC1wLYAtkC2gLbAtwC3QLeAt8C4ALhAuIC4wLkAuUC5gLnAugC6QLqAusC7ALtAu4C7wLwAvEC8gLzAvQC9QL2AvcC+AL5AvoC+wL8Av0C/gL/AwADAQMCAwMDBAMFAwYDBwMIAwkDCgMLAwwDDQMOAw8DEAMRAxIDEwMUAxUDFgMXAxgDGQMaAxsDHAMdAx4DHwMgAyEDIgMjAyQDJQMmAycDKAMpAyoDKwMsAy0DLgMvAzADMQMyAzMDNAM1AzYDNwM4AzkDOgM7AzwDPQM+Az8DQANBA0IDQwNEA0UDRgNHA0gDSQNKA0sDTANNA04DTwNQA1EDUgNTA1QDVQNWA1cDWANZA1oDWwNcA10DXgNfA2ADYQNiA2MDZANlA2YDZwNoA2kDagNrA2wDbQNuA28DcANxA3IDcwN0A3UDdgN3A3gDeQN6A3sDfAN9A34DfwOAA4EDggODA4QDhQOGA4cDiAOJA4oDiwOMA40DjgOPA5ADkQOSA5MDlAOVA5YDlwOYA5kDmgObA5wDnQOeA58ALADPAMwAzQDOA6ADoQOiA6MA+gOkA6UDpgOnA6gDqQOqA6sDrAOtBG51bGwFSS5hbHQHdW5pMDBBRAlvdmVyc2NvcmUKSWdyYXZlLmFsdApJYWN1dGUuYWx0D0ljaXJjdW1mbGV4LmFsdA1JZGllcmVzaXMuYWx0B0FtYWNyb24HYW1hY3JvbgZBYnJldmUGYWJyZXZlB0FvZ29uZWsHYW9nb25lawtDY2lyY3VtZmxleAtjY2lyY3VtZmxleARDZG90BGNkb3QGRGNhcm9uBmRjYXJvbgZEY3JvYXQHRW1hY3JvbgdlbWFjcm9uBkVicmV2ZQZlYnJldmUKRWRvdGFjY2VudAplZG90YWNjZW50B0VvZ29uZWsHZW9nb25lawZFY2Fyb24GZWNhcm9uC0djaXJjdW1mbGV4C2djaXJjdW1mbGV4BEdkb3QEZ2RvdAxHY29tbWFhY2NlbnQMZ2NvbW1hYWNjZW50C0hjaXJjdW1mbGV4C2hjaXJjdW1mbGV4BEhiYXIEaGJhcgpJdGlsZGUuYWx0Bml0aWxkZQtJbWFjcm9uLmFsdAdpbWFjcm9uCklicmV2ZS5hbHQGaWJyZXZlC0lvZ29uZWsuYWx0B2lvZ29uZWsOSWRvdGFjY2VudC5hbHQGSUouYWx0AmlqC0pjaXJjdW1mbGV4C2pjaXJjdW1mbGV4DEtjb21tYWFjY2VudAxrY29tbWFhY2NlbnQMa2dyZWVubGFuZGljBkxhY3V0ZQZsYWN1dGUMTGNvbW1hYWNjZW50DGxjb21tYWFjY2VudAZMY2Fyb24GbGNhcm9uBExkb3QEbGRvdAZOYWN1dGUGbmFjdXRlDE5jb21tYWFjY2VudAxuY29tbWFhY2NlbnQGTmNhcm9uBm5jYXJvbgtuYXBvc3Ryb3BoZQNFbmcDZW5nB09tYWNyb24Hb21hY3JvbgZPYnJldmUGb2JyZXZlDU9odW5nYXJ1bWxhdXQNb2h1bmdhcnVtbGF1dAZSYWN1dGUGcmFjdXRlDFJjb21tYWFjY2VudAxyY29tbWFhY2NlbnQGUmNhcm9uBnJjYXJvbgZTYWN1dGUGc2FjdXRlC1NjaXJjdW1mbGV4C3NjaXJjdW1mbGV4DFRjb21tYWFjY2VudAx0Y29tbWFhY2NlbnQGVGNhcm9uBnRjYXJvbgRUYmFyBHRiYXIGVXRpbGRlBnV0aWxkZQdVbWFjcm9uB3VtYWNyb24GVWJyZXZlBnVicmV2ZQVVcmluZwV1cmluZw1VaHVuZ2FydW1sYXV0DXVodW5nYXJ1bWxhdXQHVW9nb25lawd1b2dvbmVrC1djaXJjdW1mbGV4C3djaXJjdW1mbGV4C1ljaXJjdW1mbGV4C3ljaXJjdW1mbGV4BlphY3V0ZQZ6YWN1dGUKWmRvdGFjY2VudAp6ZG90YWNjZW50BWxvbmdzCkFyaW5nYWN1dGUKYXJpbmdhY3V0ZQdBRWFjdXRlB2FlYWN1dGULT3NsYXNoYWN1dGULb3NsYXNoYWN1dGUMU2NvbW1hYWNjZW50DHNjb21tYWFjY2VudAV0b25vcw1kaWVyZXNpc3Rvbm9zCkFscGhhdG9ub3MJYW5vdGVsZWlhDEVwc2lsb250b25vcwhFdGF0b25vcw1Jb3RhdG9ub3MuYWx0DE9taWNyb250b25vcwxVcHNpbG9udG9ub3MKT21lZ2F0b25vcxFpb3RhZGllcmVzaXN0b25vcwVBbHBoYQRCZXRhBUdhbW1hB3VuaTAzOTQHRXBzaWxvbgRaZXRhA0V0YQVUaGV0YQhJb3RhLmFsdAVLYXBwYQZMYW1iZGECTXUCTnUCWGkHT21pY3JvbgJQaQNSaG8FU2lnbWEDVGF1B1Vwc2lsb24DUGhpA0NoaQNQc2kHdW5pMDNBORBJb3RhZGllcmVzaXMuYWx0D1Vwc2lsb25kaWVyZXNpcwphbHBoYXRvbm9zDGVwc2lsb250b25vcwhldGF0b25vcwlpb3RhdG9ub3MUdXBzaWxvbmRpZXJlc2lzdG9ub3MFYWxwaGEEYmV0YQVnYW1tYQVkZWx0YQdlcHNpbG9uBHpldGEDZXRhBXRoZXRhBGlvdGEFa2FwcGEGbGFtYmRhB3VuaTAzQkMCbnUCeGkHb21pY3JvbgNyaG8Gc2lnbWExBXNpZ21hA3RhdQd1cHNpbG9uA3BoaQNjaGkDcHNpBW9tZWdhDGlvdGFkaWVyZXNpcw91cHNpbG9uZGllcmVzaXMMb21pY3JvbnRvbm9zDHVwc2lsb250b25vcwpvbWVnYXRvbm9zCWFmaWkxMDAyMwlhZmlpMTAwNTEJYWZpaTEwMDUyCWFmaWkxMDA1MwlhZmlpMTAwNTQNYWZpaTEwMDU1LmFsdA1hZmlpMTAwNTYuYWx0CWFmaWkxMDA1NwlhZmlpMTAwNTgJYWZpaTEwMDU5CWFmaWkxMDA2MAlhZmlpMTAwNjEJYWZpaTEwMDYyCWFmaWkxMDE0NQlhZmlpMTAwMTcJYWZpaTEwMDE4CWFmaWkxMDAxOQlhZmlpMTAwMjAJYWZpaTEwMDIxCWFmaWkxMDAyMglhZmlpMTAwMjQJYWZpaTEwMDI1CWFmaWkxMDAyNglhZmlpMTAwMjcJYWZpaTEwMDI4CWFmaWkxMDAyOQlhZmlpMTAwMzAJYWZpaTEwMDMxCWFmaWkxMDAzMglhZmlpMTAwMzMJYWZpaTEwMDM0CWFmaWkxMDAzNQlhZmlpMTAwMzYJYWZpaTEwMDM3CWFmaWkxMDAzOAlhZmlpMTAwMzkJYWZpaTEwMDQwCWFmaWkxMDA0MQlhZmlpMTAwNDIJYWZpaTEwMDQzCWFmaWkxMDA0NAlhZmlpMTAwNDUJYWZpaTEwMDQ2CWFmaWkxMDA0NwlhZmlpMTAwNDgJYWZpaTEwMDQ5CWFmaWkxMDA2NQlhZmlpMTAwNjYJYWZpaTEwMDY3CWFmaWkxMDA2OAlhZmlpMTAwNjkJYWZpaTEwMDcwCWFmaWkxMDA3MglhZmlpMTAwNzMJYWZpaTEwMDc0CWFmaWkxMDA3NQlhZmlpMTAwNzYJYWZpaTEwMDc3CWFmaWkxMDA3OAlhZmlpMTAwNzkJYWZpaTEwMDgwCWFmaWkxMDA4MQlhZmlpMTAwODIJYWZpaTEwMDgzCWFmaWkxMDA4NAlhZmlpMTAwODUJYWZpaTEwMDg2CWFmaWkxMDA4NwlhZmlpMTAwODgJYWZpaTEwMDg5CWFmaWkxMDA5MAlhZmlpMTAwOTEJYWZpaTEwMDkyCWFmaWkxMDA5MwlhZmlpMTAwOTQJYWZpaTEwMDk1CWFmaWkxMDA5NglhZmlpMTAwOTcJYWZpaTEwMDcxCWFmaWkxMDA5OQlhZmlpMTAxMDAJYWZpaTEwMTAxCWFmaWkxMDEwMglhZmlpMTAxMDMJYWZpaTEwMTA0CWFmaWkxMDEwNQlhZmlpMTAxMDYJYWZpaTEwMTA3CWFmaWkxMDEwOAlhZmlpMTAxMDkJYWZpaTEwMTEwCWFmaWkxMDE5MwlhZmlpMTAwNTAJYWZpaTEwMDk4BldncmF2ZQZ3Z3JhdmUGV2FjdXRlBndhY3V0ZQlXZGllcmVzaXMJd2RpZXJlc2lzBllncmF2ZQZ5Z3JhdmUJYWZpaTAwMjA4DXVuZGVyc2NvcmVkYmwNcXVvdGVyZXZlcnNlZAZtaW51dGUGc2Vjb25kCWV4Y2xhbWRibAluc3VwZXJpb3IJYWZpaTA4OTQxBnBlc2V0YQRFdXJvCWFmaWk2MTI0OAlhZmlpNjEyODkJYWZpaTYxMzUyCWVzdGltYXRlZAlvbmVlaWdodGgMdGhyZWVlaWdodGhzC2ZpdmVlaWdodGhzDHNldmVuZWlnaHRocwd1bmlGQjAxB3VuaUZCMDINY3lyaWxsaWNicmV2ZQhkb3RsZXNzahBjYXJvbmNvbW1hYWNjZW50C2NvbW1hYWNjZW50EWNvbW1hYWNjZW50cm90YXRlDHplcm9zdXBlcmlvcgxmb3Vyc3VwZXJpb3IMZml2ZXN1cGVyaW9yC3NpeHN1cGVyaW9yDXNldmVuc3VwZXJpb3INZWlnaHRzdXBlcmlvcgxuaW5lc3VwZXJpb3IHdW5pMjAwMAd1bmkyMDAxB3VuaTIwMDIHdW5pMjAwMwd1bmkyMDA0B3VuaTIwMDUHdW5pMjAwNgd1bmkyMDA3B3VuaTIwMDgHdW5pMjAwOQd1bmkyMDBBB3VuaTIwMEIHdW5pRkVGRgd1bmlGRkZDB3VuaUZGRkQHdW5pMDFGMAd1bmkwMkJDB3VuaTAzRDEHdW5pMDNEMgd1bmkwM0Q2B3VuaTFFM0UHdW5pMUUzRgd1bmkxRTAwB3VuaTFFMDEHdW5pMUY0RAd1bmkwMkYzCWRhc2lhb3hpYQd1bmlGQjAzB3VuaUZCMDQFT2hvcm4Fb2hvcm4FVWhvcm4FdWhvcm4HdW5pMDMwMAd1bmkwMzAxB3VuaTAzMDMEaG9vawhkb3RiZWxvdwd1bmkwNDAwB3VuaTA0MEQHdW5pMDQ1MAd1bmkwNDVEB3VuaTA0NjAHdW5pMDQ2MQd1bmkwNDYyB3VuaTA0NjMHdW5pMDQ2NAd1bmkwNDY1B3VuaTA0NjYHdW5pMDQ2Nwd1bmkwNDY4B3VuaTA0NjkHdW5pMDQ2QQd1bmkwNDZCB3VuaTA0NkMHdW5pMDQ2RAd1bmkwNDZFB3VuaTA0NkYHdW5pMDQ3MAd1bmkwNDcxB3VuaTA0NzIHdW5pMDQ3Mwd1bmkwNDc0B3VuaTA0NzUHdW5pMDQ3Ngd1bmkwNDc3B3VuaTA0NzgHdW5pMDQ3OQd1bmkwNDdBB3VuaTA0N0IHdW5pMDQ3Qwd1bmkwNDdEB3VuaTA0N0UHdW5pMDQ3Rgd1bmkwNDgwB3VuaTA0ODEHdW5pMDQ4Mgd1bmkwNDgzB3VuaTA0ODQHdW5pMDQ4NQd1bmkwNDg2B3VuaTA0ODgHdW5pMDQ4OQd1bmkwNDhBB3VuaTA0OEIHdW5pMDQ4Qwd1bmkwNDhEB3VuaTA0OEUHdW5pMDQ4Rgd1bmkwNDkyB3VuaTA0OTMHdW5pMDQ5NAd1bmkwNDk1B3VuaTA0OTYHdW5pMDQ5Nwd1bmkwNDk4B3VuaTA0OTkHdW5pMDQ5QQd1bmkwNDlCB3VuaTA0OUMHdW5pMDQ5RAd1bmkwNDlFB3VuaTA0OUYHdW5pMDRBMAd1bmkwNEExB3VuaTA0QTIHdW5pMDRBMwd1bmkwNEE0B3VuaTA0QTUHdW5pMDRBNgd1bmkwNEE3B3VuaTA0QTgHdW5pMDRBOQd1bmkwNEFBB3VuaTA0QUIHdW5pMDRBQwd1bmkwNEFEB3VuaTA0QUUHdW5pMDRBRgd1bmkwNEIwB3VuaTA0QjEHdW5pMDRCMgd1bmkwNEIzB3VuaTA0QjQHdW5pMDRCNQd1bmkwNEI2B3VuaTA0QjcHdW5pMDRCOAd1bmkwNEI5B3VuaTA0QkEHdW5pMDRCQgd1bmkwNEJDB3VuaTA0QkQHdW5pMDRCRQd1bmkwNEJGC3VuaTA0QzAuYWx0B3VuaTA0QzEHdW5pMDRDMgd1bmkwNEMzB3VuaTA0QzQHdW5pMDRDNQd1bmkwNEM2B3VuaTA0QzcHdW5pMDRDOAd1bmkwNEM5B3VuaTA0Q0EHdW5pMDRDQgd1bmkwNENDB3VuaTA0Q0QHdW5pMDRDRQt1bmkwNENGLmFsdAd1bmkwNEQwB3VuaTA0RDEHdW5pMDREMgd1bmkwNEQzB3VuaTA0RDQHdW5pMDRENQd1bmkwNEQ2B3VuaTA0RDcHdW5pMDREOAd1bmkwNEQ5B3VuaTA0REEHdW5pMDREQgd1bmkwNERDB3VuaTA0REQHdW5pMDRERQd1bmkwNERGB3VuaTA0RTAHdW5pMDRFMQd1bmkwNEUyB3VuaTA0RTMHdW5pMDRFNAd1bmkwNEU1B3VuaTA0RTYHdW5pMDRFNwd1bmkwNEU4B3VuaTA0RTkHdW5pMDRFQQd1bmkwNEVCB3VuaTA0RUMHdW5pMDRFRAd1bmkwNEVFB3VuaTA0RUYHdW5pMDRGMAd1bmkwNEYxB3VuaTA0RjIHdW5pMDRGMwd1bmkwNEY0B3VuaTA0RjUHdW5pMDRGNgd1bmkwNEY3B3VuaTA0RjgHdW5pMDRGOQd1bmkwNEZBB3VuaTA0RkIHdW5pMDRGQwd1bmkwNEZEB3VuaTA0RkUHdW5pMDRGRgd1bmkwNTAwB3VuaTA1MDEHdW5pMDUwMgd1bmkwNTAzB3VuaTA1MDQHdW5pMDUwNQd1bmkwNTA2B3VuaTA1MDcHdW5pMDUwOAd1bmkwNTA5B3VuaTA1MEEHdW5pMDUwQgd1bmkwNTBDB3VuaTA1MEQHdW5pMDUwRQd1bmkwNTBGB3VuaTA1MTAHdW5pMDUxMQd1bmkwNTEyB3VuaTA1MTMHdW5pMUVBMAd1bmkxRUExB3VuaTFFQTIHdW5pMUVBMwd1bmkxRUE0B3VuaTFFQTUHdW5pMUVBNgd1bmkxRUE3B3VuaTFFQTgHdW5pMUVBOQd1bmkxRUFBB3VuaTFFQUIHdW5pMUVBQwd1bmkxRUFEB3VuaTFFQUUHdW5pMUVBRgd1bmkxRUIwB3VuaTFFQjEHdW5pMUVCMgd1bmkxRUIzB3VuaTFFQjQHdW5pMUVCNQd1bmkxRUI2B3VuaTFFQjcHdW5pMUVCOAd1bmkxRUI5B3VuaTFFQkEHdW5pMUVCQgd1bmkxRUJDB3VuaTFFQkQHdW5pMUVCRQd1bmkxRUJGB3VuaTFFQzAHdW5pMUVDMQd1bmkxRUMyB3VuaTFFQzMHdW5pMUVDNAd1bmkxRUM1B3VuaTFFQzYHdW5pMUVDNwt1bmkxRUM4LmFsdAd1bmkxRUM5C3VuaTFFQ0EuYWx0B3VuaTFFQ0IHdW5pMUVDQwd1bmkxRUNEB3VuaTFFQ0UHdW5pMUVDRgd1bmkxRUQwB3VuaTFFRDEHdW5pMUVEMgd1bmkxRUQzB3VuaTFFRDQHdW5pMUVENQd1bmkxRUQ2B3VuaTFFRDcHdW5pMUVEOAd1bmkxRUQ5B3VuaTFFREEHdW5pMUVEQgd1bmkxRURDB3VuaTFFREQHdW5pMUVERQd1bmkxRURGB3VuaTFFRTAHdW5pMUVFMQd1bmkxRUUyB3VuaTFFRTMHdW5pMUVFNAd1bmkxRUU1B3VuaTFFRTYHdW5pMUVFNwd1bmkxRUU4B3VuaTFFRTkHdW5pMUVFQQd1bmkxRUVCB3VuaTFFRUMHdW5pMUVFRAd1bmkxRUVFB3VuaTFFRUYHdW5pMUVGMAd1bmkxRUYxB3VuaTFFRjQHdW5pMUVGNQd1bmkxRUY2B3VuaTFFRjcHdW5pMUVGOAd1bmkxRUY5B3VuaTIwQUIHdW5pMDMwRhNjaXJjdW1mbGV4YWN1dGVjb21iE2NpcmN1bWZsZXhncmF2ZWNvbWISY2lyY3VtZmxleGhvb2tjb21iE2NpcmN1bWZsZXh0aWxkZWNvbWIOYnJldmVhY3V0ZWNvbWIOYnJldmVncmF2ZWNvbWINYnJldmVob29rY29tYg5icmV2ZXRpbGRlY29tYhBjeXJpbGxpY2hvb2tsZWZ0EWN5cmlsbGljYmlnaG9va1VDEWN5cmlsbGljYmlnaG9va0xDCG9uZS5wbnVtB3plcm8ub3MGb25lLm9zBnR3by5vcwh0aHJlZS5vcwdmb3VyLm9zB2ZpdmUub3MGc2l4Lm9zCHNldmVuLm9zCGVpZ2h0Lm9zB25pbmUub3MCZmYHdW5pMjEyMAhUY2VkaWxsYQh0Y2VkaWxsYQVnLmFsdA9nY2lyY3VtZmxleC5hbHQKZ2JyZXZlLmFsdAhnZG90LmFsdBBnY29tbWFhY2NlbnQuYWx0Bkl0aWxkZQdJbWFjcm9uBklicmV2ZQdJb2dvbmVrAklKCUlvdGF0b25vcwRJb3RhDElvdGFkaWVyZXNpcwlhZmlpMTAwNTUJYWZpaTEwMDU2B3VuaTA0QzAHdW5pMDRDRgd1bmkxRUM4B3VuaTFFQ0EAAAEAAwAIAAoACwAH//8ADwABAAAADAAAAAAAAAACAAUAAAI1AAECNwI3AAECOwJbAAECXQN2AAEDggOpAAEAAAABAAAACgAMAA4AAAAAAAAAAQAAAAoAbgFaAAFsYXRuAAgAEAACTU9MIAAoUk9NIABCAAD//wAJAAMACAALAAAADgARABQAFwAaAAD//wAKAAQABgAJAAwAAQAPABIAFQAYABsAAP//AAoABQAHAAoADQACABAAEwAWABkAHAAdbGlnYQCwbGlnYQCwbGlnYQCwbG51bQC2bG51bQC2bG51bQC2bG9jbAC8bG9jbAC8b251bQDCb251bQDCb251bQDCcG51bQDKcG51bQDKcG51bQDKc2FsdADQc2FsdADQc2FsdADQc3MwMQDQc3MwMQDQc3MwMQDQc3MwMgDYc3MwMgDYc3MwMgDYc3MwMwDec3MwMwDec3MwMwDedG51bQDkdG51bQDkdG51bQDkAAAAAQAJAAAAAQAHAAAAAQAIAAAAAgACAAMAAAABAAQAAAACAAAAAQAAAAEAAAAAAAEAAQAAAAIABQAGAAoAFgA8AHwAlADMAOAA7gECAS4BUAABAAAAAQAIAAIAEAAFA5EDkgOTA5QDlQABAAUASgDfAOEA4wDlAAEAAAABAAgAAgAuABQALACOAI8AkACRAOoA7ADuAPAA8gD0AVoBZwF3AaEBogLJAtgDRQNHAAIAAQOWA6kAAAABAAAAAQAIAAEABgNwAAIAAQATABwAAAABAAAAAQAIAAIAGgAKA4MDhQOGA4cDiAOJA4oDiwOMA4QAAgADABMAEwAAABUAHAABA4IDggAJAAEAAAABAAgAAQAGA24AAQABABQAAQAAAAEACAABADz8kAABAAAAAQAIAAEABvySAAEAAQOCAAEAAAABAAgAAgAaAAoAEwOCABUAFgAXABgAGQAaABsAHAACAAEDgwOMAAAAAQAAAAEACAACAA4ABAOPA5ABIAEhAAEABAEkASUBSQFKAAQAAAABAAgAAQA2AAEACAAFAAwAFAAcACIAKAJeAAMASQBPAl0AAwBJAEwDjQACAEkCNQACAE8CNAACAEwAAQABAEkAAA==";

var openSansExtraBoldItalic = "data:font/ttf;base64,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JjU0EjYzMhYXMzc2NzcjNwMyNjU0JiMiBhUUA3kfAYchnjSd9v7LCggwQ1s+nqR804JNdzoIAgcSAvQxUE1fLipGZAWBk5Py+3F7QjIb39GlAS2tQ1Ulik8O8vuir4JBTrh5j///ACEAAAS6BxcCJgAoAAABBwFNAFQBUgAIswEPBSYAKzX//wBU/+wEdQXFAiYASAAAAQYBTRIAAAizAiURJgArNf//ACEAAATEB54CJgAoAAABBwFOAAoBUgAIswEPBSYAKzX//wBU/+wEsQZMAiYASAAAAQYBTvcAAAizAiURJgArNf//ACEAAAS6B2wCJgAoAAABBwFPAQ4BNQAIswETBSYAKzX//wBU/+wEdQY3AiYASAAAAQcBTwDyAAAACLMCKREmACs1//8AIf30BLoFtgImACgAAAAHAVEB7gAA//8AVP4ABHUEgQImAEgAAAAHAVEBvgAM//8AIQAABRQHcwImACgAAAEHAUwAKwFSAAizARYFJgArNf//AFT/7AT7BiECJgBIAAABBgFMEgAACLMCLBEmACs1//8AaP/sBYUHcwImACoAAAEHAUsA3wFSAAizASEFJgArNf///3v+FATTBiECJgBKAAABBgFLHQAACLMDRxEmACs1//8AaP/sBYEHngImACoAAAEHAU4AhwFSAAizAR4FJgArNf///3v+FATTBkwCJgBKAAABBgFO3AAACLMDRBEmACs1//8AaP/sBYEHiQImACoAAAEHAU8BogFSAAizASIFJgArNf///3v+FATTBjcCJgBKAAABBwFPAPYAAAAIswNIESYAKzX//wBo/jsFgQXNAiYAKgAAAAcCOQEKAAD///97/hQE0wYhAiYASgAAAQYCOkgAAAizA0URJgArNf//ACEAAAXBB3MCJgArAAABBwFLALYBUgAIswESBSYAKzX//wAXAAAE/geqAiYASwAAAQcBSwBYAYkADbcBHnAeHgwMPgArETUAAAIAIQAABkwFtgATABcALEAWFwdOWRYDCwsQAAwXDBcMCRIOAwUJEgA/Mz8zEjk5Ly8RMzMzETMzKzEwATMHIwMhEyEDIRMjNzM3IQchNyEBNyEHBaCsMa7i/nl9/qZ//nnhqi+sIwGHHwFbIAGI/ggc/qQcBRns+9MCUv2uBC3snZ2d/eKVlQABABcAAASFBhQAIAAxQBkCBQwFEkdZABkaGUxZHhoFGgUaFxwADBcVAD8zPxI5OS8vETMrEQAzKxESADkxMAEGBzM2MzIWFRQHAyETNjU0JiMiBgcDIRMjNzM3IQchBwKRHzAIY62Mnxhr/n1tEi0fRFcdYP599ag0pyEBgx4BDDMEj392gauXb3b+DAIETj8sKpaO/j0Ej/KTk/IA////tgAABFsHfwImACwAAAEHAVL/pQFSAAizARYFJgArNf//ABcAAAO5Bi0CJgDzAAABBwFS/wMAAAAIswEOESYAKzX///+2AAAD8gcXAiYALAAAAQcBTf+zAVIACLMBDwUmACs1//8AFwAAA0wFxQImAPMAAAEHAU3/DQAAAAizAQcRJgArNf///7YAAAQoB54CJgAsAAABBwFO/24BUgAIswEPBSYAKzX//wAXAAADpAZMAiYA8wAAAQcBTv7qAAAACLMBBxEmACs1////tv30A9kFtgImACwAAAAHAVEAqgAA////xf30AtUGNwImAEwAAAAHAVEAgwAA////tgAAA9kHiQImACwAAAEHAU8AZgFSAAizARMFJgArNQABABcAAAKLBG0AAwAKswIPARUAPz8xMCEhEyEBmv597wGFBG0A////tv4zBmwFtgAnAC0DaAAAAAYALAAA//8AF/4UBXcGNwAnAE0CmgAAAAYATAAA///+uP4zBBoHcwImAC0AAAEHAUv/dAFSAAizARUFJgArNf///vj+FAOfBiECJgI3AAABBwFL/vkAAAAIswETESYAKzX//wAh/jsF8gW2AiYALgAAAAcCOQDNAAD//wAX/jsFXgYUAiYATgAAAAcCOQCeAAAAAQAXAAAFWgRtABEAF0AKDgsFBQ0RFQkADwA/Mj8zOREzMzEwASEHBgYHMzY3EyEBASEDBwMhAQQBgzMLLQ4JT0zuAbr+GQES/kqLZUX+fQRt8DKNIHdRAQf+AP2TAYc1/q4A//8AIQAABFEHcwImAC8AAAEHAHb/uwFSAAizAQ4FJgArNf//ABcAAARFB6wCJgBPAAABBwB2/68BiwANtwEMcAwMAgI+ACsRNQD//wAh/jsDyQW2AiYALwAAAAYCOT8A////qf47AuMGFAImAE8AAAAHAjn/QwAA//8AIQAABPwFtwImAC8AAAAHAjgBRv+j//8AFwAABNcGFAAmAE8AAAAHAjgBIQAA//8AIQAA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/+wExQcQAiYARAAAAQcDegSqAAAACrQDAi0RJgArNTX///+H/h8FNwdzAiYAJAAAACcBSwCRAVIBBwJnBRAAAAAIswIWBSYAKzX//wBU/h8ExQYeAiYARAAAACYBSwj9AQcCZwUEAAAACLMCJhEmACs1////hwAABTEIFQImACQAAAEHA3sFHwFSAAq0AwISBSYAKzU1//8AVP/sBMUGwwImAEQAAAEHA3sEjQAAAAq0AwIiESYAKzU1////hwAABTEIEwImACQAAAEHA3wFHwFSAAq0AwISBSYAKzU1//8AVP/sBMUGwQImAEQAAAEHA3wEjQAAAAq0AwIiESYAKzU1////hwAABTEIWAImACQAAAEHA30FHwFSAAq0AwISBSYAKzU1//8AVP/sBMUHBgImAEQAAAEHA30EjQAAAAq0AwIiESYAKzU1////hwAABTEIawImACQAAAEHA34FHwFSAAq0AwITBSYAKzU1//8AVP/sBMUHGQImAEQAAAEHA34EjQAAAAq0AwIjESYAKzU1////h/4fBTEHngImACQAAAAnAmcFEAAAAQcBTgB3AVIACLMDHQUmACs1//8AVP4fBMUGTAImAEQAAAAnAmcFBAAAAQYBTuAAAAizAy0RJgArNf//ACH+HwS6BbYCJgAoAAAABwJnBKoAAP//AFT+HwR1BIECJgBIAAAABwJnBOMAAP//ACEAAAS6CAQCJgAoAAABBwJmBMMBUgAIswERBSYAKzX//wBU/+wEdQayAiYASAAAAQcCZgTDAAAACLMCJxEmACs1//8AIQAABQAHfwImACgAAAEHAVIASgFSAAizARYFJgArNf//AFT/7ASzBi0CJgBIAAABBgFS/QAACLMCLBEmACs1//8AIQAABksH0QImACgAAAEHA3cE4QFSAAq0AgEYBSYAKzU1//8AVP/sBf0GfwImAEgAAAEHA3cEkwAAAAq0AwIuESYAKzU1//8AIQAABLoH1QImACgAAAEHA3gE4QFSAAq0AgEhBSYAKzU1//8AT//sBHUGgwImAEgAAAEHA3gEkwAAAAq0AwI3ESYAKzU1//8AIQAABb4IWgImACgAAAEHA3kE4QFSAAq0AgEpBSYAKzU1//8AVP/sBXAHCAImAEgAAAEHA3kEkwAAAAq0AwI/ESYAKzU1//8AIQAABLwIYgImACgAAAEH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BKIAVAR/ACEEogBUBH8AIQSiAFQFlgBoBHn/ewWWAGgEef97BZYAaAR5/3sFlgBoBHn/ewW2ACEE+gAXBbYAIQT6ABcDaP+2ApoAFwNo/7YCmgAXA2j/tgKaABcDaP+2Apr/xQNo/7YCmgAXBmT/tgUzABcC/P64Apr++AVaACEE8AAXBPAAFwQ3ACECmgAXBDcAIQKa/6kENwAhAxkAFwQ3ACEERAAXBEz/0QLX/88GUgAhBPoAFwZSACEE+gAXBlIAIQT6ABcFpP/DBlIAIQT6ABcF5QBoBNsAVAXlAGgE2wBUBeUAaATbAFQHdQBoBwoAVAUzACEDfwAXBTMAIQN//6YFMwAhA38AFwRiACsEBAAfBGIAKwQEAB8EYgArBAQAHwRiACsEBAAfBGoAdAOoADgEagCcA7oAPwRqAI8DqAAXBZwAfQT6AGAFnAB9BPoAYAWcAH0E+gBgBZwAfQT6AGAFnAB9BPoAYAWcAH0E+gBgB3sAmAaWAGYE1QCkBFr/fwTVAKQEUP+kA+H/1wRQ/6QD4f/XBFD/pAPh/9cC8P8MBKT/ywVo/4cE2wBUB5H/gwb8AFQF5QBeBQYAQgRiACsEBAAfBG8A/gRvAUIESAFzBG8BjwKoAT8EngIKAcX/QgRvAS0EbwDTBGICDgRiAQgFaP+HAnMAcwVeAAkGRgAJA2j+8gZ3ACwGHwAJBssAHwMxABsFaP+HBRIAIQQ3ACEFTP+4BH8AIQRQ/6QFtgAhBiMAaANo/7YFWgAhBPD/iwdGACEGUgAhBHP/1wXlAGgFtgAhBPwAIQRq/8MEagCcBNUApAbFAFwFTv+DBw4AoAYv/6wDaP+2BNUApAUKAFQEdQApBPoAFwMxAFYE/gBgBQoAVAUr/7IEYAAtBMkAOQR1ACkD0wBCBPoAFwTlAGADMQBWBPAAFwTV/5EFCP+uBKAAYAPuAEIE2wBUBlQATgTl/7QD/ABUBRkAVAQtAEIE/gBgBrwAVASi/tEG7gBgBuMAQgMxAFYE/gBgBNsAVAT+AGAG4wBCBH8AIQY7AJwENwAhBQoAaARiACsDaP+2A2j/tgL8/rgHtP+kB7QAIQYjAJwFKQAhBQAARAW2ACEFaP+HBN8AIQUSACEENwAhBlr/KQR/ACEHd/99BOwAGQZcACEGXAAhBSkAIQWs/6QHRgAhBbYAIQXlAGgFtgAhBPwAIQUKAGgEagCcBQAARAbFAFwFTv+DBh0AIQWRAJMICgAhCHcAIQWmAJwHiwAhBN8AIQUKAB8IngAhBTP/dQTbAFQEzwBWBNcAVAQMABkFCABUBKIAVAhS/+cEqAAhBPoAYAT6AGAE/gAXBVb/2wbnACEFBAAXBNsAVAT6ABcE2/+uBAgAVAdoABcEWv9/BsMAVASH/4kFLQBgBN0AiwdoAGAHnABgBX0ATgcfAFQErgBUBAgALQclABcE9v/6BKIAVAT6ABcEDAAZBAgAVAQEAB8CmgAXApoAFwKa/vgHaP/bBx8AFwT6ABcE/gAXBFr/fwT6AGAEOwAhBAoAFwd7AJgGlgBmB3sAmAaWAGYHewCYBpYAZgTVAKQEWv9/A9cAIQeuACEHrgAhA5r/MwH0AG0B9ABeAm3/mAH0AL4D5QBtA+UAXgRi/5gEVgC2BFYALwMjAFYHCAAMCokAUAHnALYDogC2As8APQLP//IEyQAMAPj9zQMzAGgEpAAABKT/7gf8ABcEpAA1BiEATASwADcIiwAhBikAZgYv/6wE9ABmB8cAaAfHAHUHxwCFB8cAkQTFACkFTP+4BdMAngUKAC0EhwBmBKQAVgWWAG0Db//jBIcATgSHAEgEhwBSBIcAcQSeAFAF4f8vBeH/LwRiAUgCmv74BB8B3QQfAGYEHwG+A1AAWgNQABADUABeA1AAUgNQAFwDUABGA1IAbQQAAAAIAAAABAAAAAgAAAACqgAAAgAAAAFWAAAEeQAAAmIAAAGaAAAAzQAAAAAAAAAAAAAIAABaCAAAVgKa/vgB9ABeBgYACAT+AKQIHwBOB0YAIQdoABcFaP+HBNsAVAfRACsCqv+FAR3/3whz/y8Ib/8vBm0AaAWoAFQGewB9BiUAYAAA/NoAAP2PAAD8XQAA/ZEAAPwxBH8AIQZcACEEogBUBPoAYAhqAGgG2QBYBN8AIQUSADEHpgAhBlAAFwZo/20FrP9UCPgAIQgnABcHIf95Ba7/WAmwACEIOQAXBRT/qgSo/7AHDgCgBu4AYAXlAGgE2wBUBWgAlgS4AFgFaACWBLgAWAo/AGgJJwBUBicAaAVeAFQIagBoBwwAVAhqAGgG2QBYBQoAaAQIAFQEsAAzBCcA/gRQARsETAI7BEwCAAfhABQHngAZBwoAIQW2AGAE3wAhBK7//gViACEFSv+uBDcACgPT//IFZAAhBMEAFwfR/30IUv/nBOwAGQSoACEFjQAhBVoAFwWYACEFbQAXBVoAIQTwABcF8ACcBXEAQgYdACEFrgAXBocAIQXPABcISAAhByUAFwZmAGgFgwBUBQoAaAQIAFQEagCcB6gAFwTVAKQEWgBYBNUAJwRa/6oGAP+DBSf/iQcOAJwF3QBCBfwAkwVaAIUFkQCTBRIAiQWRACEE3QAXBrYAVgWsABkGtgBWBawAGQNo/7YHd/99CFL/5wWyACEFLwAXBmL/pAYX/9sFtgAhBQQAFwZmACEFwQAXBZEAkwTdAKIH8gAhB6QAIQNo/7YFaP+HBNsAVAVo/4cE2wBUB5H/gwb8AFQEfwAhBKIAVAUfACEEogAtBR8AIQSiAC0Hd/99CFL/5wTsABkEqAAhBJgAAASw/7AGXAAhBPoAYAZcACEE+gBgBeUAaATbAFQF5QBoBNsAVAXlAGgE2wBUBQoAHwQIAC0FAABEBFr/fwUAAEQEWv9/BQAARARa/38FkQCTBN0AiwQ3ACED0wAXB4sAIQcfAFQENwAKA9P/8gZE/4MFYP+JBU7/gwSH/4kE+gBCBNUAVAcZAEIG+ABUBtEAWAY/AEoFRABaBPwASgfP/6QHc//bB9cAIQcfABcF8gBoBRAAVAW6AJwFUgBCBO4ANQR1ACkGSv+kBeP/2wVo/4cE2wBUBWj/hwTbAFQFaP+HBNsAVAVo/4cE2wBUBWj/hwTbAFQFaP+HBNsAVAVo/4cE2wBUBWj/hwTbAFQFaP+HBNsAVAVo/4cE2wBUBWj/hwTbAFQFaP+HBNsAVAR/ACEEogBUBH8AIQSiAFQEfwAhBKIAVAR/ACEEogBUBH8AIQSiAE8EfwAhBKIAVAR/ACEEogBUBH8AIQSiAFQDaP+2ApoAFwNo/7YCmv/NBeUAaATbAFQF5QBoBNsAVAXlAGgE2wBUBeUAaATbAFQF5QBoBNsAVAXlAGgE2wBUBeUAaATbAFQGbQBoBagAVAZtAGgFqABUBm0AaAWoAFQGbQBoBagAVAZtAGgFqABUBZwAfQT6AGAFnAB9BPoAYAZ7AH0GJQBgBnsAfQYlAGAGewB9BiUAYAZ7AH0GJQBgBnsAfQYlAGAE1QCkBFr/fwTVAKQEWv9/BNUApARa/38E1QATAAD8nAAA/KIAAPu8AAD8kwAA/I0AAPzn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AIUAvQCWAOgAhgCOAIsAnQCpAKQBBACKAQUAgwCTAPIA8wCNAJcAiADDAN4A8QCeAKoA9QD0APYAogCtAMkAxwCuAGIAYwCQAGQAywBlAMgAygEGAQcBCAEJAOkAZgDTANAA0QCvAGcA8ACRANYA1ADVAGgA6wDtAIkAagBpAGsAbQBsAG4AoABvAHEAcAByAHMAdQB0AHYAdwDqAHgAegB5AHsAfQB8ALgAoQB/AH4AgACBAOwA7gC6AQoBCwEMAQ0BDgEPAP0A/gEQAREBEgETAP8BAAEUARUBFgEBARcBGAEZARoBGwEcAR0BHgEfASABIQEiAPgA+QEjASQBJQEmAScBKAEpASoBKwEsAS0BLgEvATABMQEyATMA1wE0ATUBNgE3ATgBOQE6ATsBPAE9AT4BPwFAAUEBQgDiAOMBQwFEAUUBRgFHAUgBSQFKAUsBTAFNAU4BTwFQAVEAsACxAVIBUwFUAVUBVgFXAVgBWQFaAVsA+wD8AOQA5QFcAV0BXgFfAWABYQFiAWMBZAFlAWYBZwFoAWkBagFrAWwBbQFuAW8BcAFxALsBcgFzAXQBdQDmAOcBdgCmAXcBeAF5AXoBewF8AX0BfgDYAOEA2gDbANwA3QDgANkA3wF/AYABgQGCAYMBhAGFAYYBhwGIAYkBigGLAYwBjQGOAY8BkAGRAZIBkwGUAZUBlgGXAZgBmQGaAZsBnAGdAZ4BnwGgAaEBogGjAaQBpQGmAacBqAGpAaoBqwGsAa0BrgGvAbABsQGyAbMBtAG1AbYBtwCbAbgBuQG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHGAccByAHJAcoBywHMAc0BzgHPAdAB0QHSAdMB1AHVAdYB1wHYAdkB2gHbAdwB3QHeAd8B4AHhAeIB4wHkAeUB5gHnAegB6QHqAesB7AHtAe4B7wHwAfEB8gHzAfQB9QH2AfcB+AH5AfoB+wH8Af0B/gH/AgACAQICAgMCBAIFAgYCBwIIAgkCCgILAgwCDQIOAg8CEAIRAhICEwIUAhUCFgIXAhgCGQIaAhsCHAIdAh4CHwIgAiECIgIjAiQCJQImAicCKAIpAioCKwCyALMCLAItALYAtwDEAi4AtAC1AMUAggDCAIcAqwDGAi8CMAC+AL8CMQC8AjIA9wIzAjQCNQI2AjcCOACMAJ8COQI6AjsCPAI9AJgAqACaAJkA7wClAJIAnACnAI8AlACVALkCPgI/AkACQQJCAkMCRAJFAkYCRwJIAkkCSgJLAkwCTQJOAk8CUAJRAlICUwJUAlUCVgJXAlgCWQJaAlsCXAJdAl4CXwJgAmECYgJjAmQCZQJmAmcCaAJpAmoCawJsAm0CbgJvAnACcQJyAnMCdAJ1AnYCdwJ4AnkCegJ7AnwCfQJ+An8CgAKBAoICgwKEAoUChgKHAogCiQKKAosCjAKNAo4CjwKQApECkgKTApQClQKWApcCmAKZApoCmwKcAp0CngKfAqACoQKiAqMCpAKlAqYCpwKoAqkCqgKrAqwCrQKuAq8CsAKxArICswK0ArUCtgK3ArgCuQK6ArsCvAK9Ar4CvwLAAsECwgLDAsQCxQLGAscCyALJAsoCywLMAs0CzgLPAtAC0QLSAtMC1ALVAtYC1wLYAtkC2gLbAtwC3QLeAt8C4ALhAuIC4wLkAuUC5gLnAugC6QLqAusC7ALtAu4C7wLwAvEC8gLzAvQC9QL2AvcC+AL5AvoC+wL8Av0C/gL/AwADAQMCAwMDBAMFAwYDBwMIAwkDCgMLAwwDDQMOAw8DEAMRAxIDEwMUAxUDFgMXAxgDGQMaAxsDHAMdAx4DHwMgAyEDIgMjAyQDJQMmAycDKAMpAyoDKwMsAy0DLgMvAzADMQMyAzMDNAM1AzYDNwM4AzkDOgM7AzwDPQM+Az8DQANBA0IDQwNEA0UDRgNHA0gDSQNKA0sDTANNA04DTwNQA1EDUgNTA1QDVQNWA1cDWANZA1oDWwNcA10DXgNfA2ADYQNiA2MDZANlA2YDZwNoA2kDagNrA2wDbQNuA28DcANxA3IDcwN0A3UDdgN3A3gDeQN6A3sDfAN9A34DfwOAA4EDggODA4QDhQOGA4cDiAOJA4oDiwOMA40DjgOPA5ADkQOSA5MDlAOVA5YDlwOYA5kDmgObA5wDnQAsAM8AzADNAM4DngOfA6ADoQD6A6IDowOkA6UDpgOnA6gDqQOqA6sEbnVsbAVJLmFsdAd1bmkwMEFECW92ZXJzY29yZQpJZ3JhdmUuYWx0CklhY3V0ZS5hbHQPSWNpcmN1bWZsZXguYWx0DUlkaWVyZXNpcy5hbHQHQW1hY3JvbgdhbWFjcm9uBkFicmV2ZQZhYnJldmUHQW9nb25lawdhb2dvbmVrC0NjaXJjdW1mbGV4C2NjaXJjdW1mbGV4BENkb3QEY2RvdAZEY2Fyb24GZGNhcm9uBkRjcm9hdAdFbWFjcm9uB2VtYWNyb24GRWJyZXZlBmVicmV2ZQpFZG90YWNjZW50CmVkb3RhY2NlbnQHRW9nb25lawdlb2dvbmVrBkVjYXJvbgZlY2Fyb24LR2NpcmN1bWZsZXgLZ2NpcmN1bWZsZXgER2RvdARnZG90DEdjb21tYWFjY2VudAxnY29tbWFhY2NlbnQLSGNpcmN1bWZsZXgLaGNpcmN1bWZsZXgESGJhcgRoYmFyCkl0aWxkZS5hbHQGaXRpbGRlC0ltYWNyb24uYWx0B2ltYWNyb24KSWJyZXZlLmFsdAZpYnJldmULSW9nb25lay5hbHQHaW9nb25law5JZG90YWNjZW50LmFsdAZJSi5hbHQCaWoLSmNpcmN1bWZsZXgLamNpcmN1bWZsZXgMS2NvbW1hYWNjZW50DGtjb21tYWFjY2VudAxrZ3JlZW5sYW5kaWMGTGFjdXRlBmxhY3V0ZQxMY29tbWFhY2NlbnQMbGNvbW1hYWNjZW50BkxjYXJvbgZsY2Fyb24ETGRvdARsZG90Bk5hY3V0ZQZuYWN1dGUMTmNvbW1hYWNjZW50DG5jb21tYWFjY2VudAZOY2Fyb24GbmNhcm9uC25hcG9zdHJvcGhlA0VuZwNlbmcHT21hY3JvbgdvbWFjcm9uBk9icmV2ZQZvYnJldmUNT2h1bmdhcnVtbGF1dA1vaHVuZ2FydW1sYXV0BlJhY3V0ZQZyYWN1dGUMUmNvbW1hYWNjZW50DHJjb21tYWFjY2VudAZSY2Fyb24GcmNhcm9uBlNhY3V0ZQZzYWN1dGULU2NpcmN1bWZsZXgLc2NpcmN1bWZsZXgMVGNvbW1hYWNjZW50DHRjb21tYWFjY2VudAZUY2Fyb24GdGNhcm9uBFRiYXIEdGJhcgZVdGlsZGUGdXRpbGRlB1VtYWNyb24HdW1hY3JvbgZVYnJldmUGdWJyZXZlBVVyaW5nBXVyaW5nDVVodW5nYXJ1bWxhdXQNdWh1bmdhcnVtbGF1dAdVb2dvbmVrB3VvZ29uZWsLV2NpcmN1bWZsZXgLd2NpcmN1bWZsZXgLWWNpcmN1bWZsZXgLeWNpcmN1bWZsZXgGWmFjdXRlBnphY3V0ZQpaZG90YWNjZW50Cnpkb3RhY2NlbnQFbG9uZ3MKQXJpbmdhY3V0ZQphcmluZ2FjdXRlB0FFYWN1dGUHYWVhY3V0ZQtPc2xhc2hhY3V0ZQtvc2xhc2hhY3V0ZQxTY29tbWFhY2NlbnQMc2NvbW1hYWNjZW50BXRvbm9zDWRpZXJlc2lzdG9ub3MKQWxwaGF0b25vcwlhbm90ZWxlaWEMRXBzaWxvbnRvbm9zCEV0YXRvbm9zDUlvdGF0b25vcy5hbHQMT21pY3JvbnRvbm9zDFVwc2lsb250b25vcwpPbWVnYXRvbm9zEWlvdGFkaWVyZXNpc3Rvbm9zBUFscGhhBEJldGEFR2FtbWEHdW5pMDM5NAdFcHNpbG9uBFpldGEDRXRhBVRoZXRhCElvdGEuYWx0BUthcHBhBkxhbWJkYQJNdQJOdQJYaQdPbWljcm9uAlBpA1JobwVTaWdtYQNUYXUHVXBzaWxvbgNQaGkDQ2hpA1BzaQd1bmkwM0E5EElvdGFkaWVyZXNpcy5hbHQPVXBzaWxvbmRpZXJlc2lzCmFscGhhdG9ub3MMZXBzaWxvbnRvbm9zCGV0YXRvbm9zCWlvdGF0b25vcxR1cHNpbG9uZGllcmVzaXN0b25vcwVhbHBoYQRiZXRhBWdhbW1hBWRlbHRhB2Vwc2lsb24EemV0YQNldGEFdGhldGEEaW90YQVrYXBwYQZsYW1iZGEHdW5pMDNCQwJudQJ4aQdvbWljcm9uA3JobwZzaWdtYTEFc2lnbWEDdGF1B3Vwc2lsb24DcGhpA2NoaQNwc2kFb21lZ2EMaW90YWRpZXJlc2lzD3Vwc2lsb25kaWVyZXNpcwxvbWljcm9udG9ub3MMdXBzaWxvbnRvbm9zCm9tZWdhdG9ub3MJYWZpaTEwMDIzCWFmaWkxMDA1MQlhZmlpMTAwNTIJYWZpaTEwMDUzCWFmaWkxMDA1NA1hZmlpMTAwNTUuYWx0DWFmaWkxMDA1Ni5hbHQJYWZpaTEwMDU3CWFmaWkxMDA1OAlhZmlpMTAwNTkJYWZpaTEwMDYwCWFmaWkxMDA2MQlhZmlpMTAwNjIJYWZpaTEwMTQ1CWFmaWkxMDAxNwlhZmlpMTAwMTgJYWZpaTEwMDE5CWFmaWkxMDAyMAlhZmlpMTAwMjEJYWZpaTEwMDIyCWFmaWkxMDAyNAlhZmlpMTAwMjUJYWZpaTEwMDI2CWFmaWkxMDAyNwlhZmlpMTAwMjgJYWZpaTEwMDI5CWFmaWkxMDAzMAlhZmlpMTAwMzEJYWZpaTEwMDMyCWFmaWkxMDAzMwlhZmlpMTAwMzQJYWZpaTEwMDM1CWFmaWkxMDAzNglhZmlpMTAwMzcJYWZpaTEwMDM4CWFmaWkxMDAzOQlhZmlpMTAwNDAJYWZpaTEwMDQxCWFmaWkxMDA0MglhZmlpMTAwNDMJYWZpaTEwMDQ0CWFmaWkxMDA0NQlhZmlpMTAwNDYJYWZpaTEwMDQ3CWFmaWkxMDA0OAlhZmlpMTAwNDkJYWZpaTEwMDY1CWFmaWkxMDA2NglhZmlpMTAwNjcJYWZpaTEwMDY4CWFmaWkxMDA2OQlhZmlpMTAwNzAJYWZpaTEwMDcyCWFmaWkxMDA3MwlhZmlpMTAwNzQJYWZpaTEwMDc1CWFmaWkxMDA3NglhZmlpMTAwNzcJYWZpaTEwMDc4CWFmaWkxMDA3OQlhZmlpMTAwODAJYWZpaTEwMDgxCWFmaWkxMDA4MglhZmlpMTAwODMJYWZpaTEwMDg0CWFmaWkxMDA4NQlhZmlpMTAwODYJYWZpaTEwMDg3CWFmaWkxMDA4OAlhZmlpMTAwODkJYWZpaTEwMDkwCWFmaWkxMDA5MQlhZmlpMTAwOTIJYWZpaTEwMDkzCWFmaWkxMDA5NAlhZmlpMTAwOTUJYWZpaTEwMDk2CWFmaWkxMDA5NwlhZmlpMTAwNzEJYWZpaTEwMDk5CWFmaWkxMDEwMAlhZmlpMTAxMDEJYWZpaTEwMTAyCWFmaWkxMDEwMwlhZmlpMTAxMDQJYWZpaTEwMTA1CWFmaWkxMDEwNglhZmlpMTAxMDcJYWZpaTEwMTA4CWFmaWkxMDEwOQlhZmlpMTAxMTAJYWZpaTEwMTkzCWFmaWkxMDA1MAlhZmlpMTAwOTgGV2dyYXZlBndncmF2ZQZXYWN1dGUGd2FjdXRlCVdkaWVyZXNpcwl3ZGllcmVzaXMGWWdyYXZlBnlncmF2ZQlhZmlpMDAyMDgNdW5kZXJzY29yZWRibA1xdW90ZXJldmVyc2VkBm1pbnV0ZQZzZWNvbmQJZXhjbGFtZGJsCW5zdXBlcmlvcglhZmlpMDg5NDEGcGVzZXRhBEV1cm8JYWZpaTYxMjQ4CWFmaWk2MTI4OQlhZmlpNjEzNTIJZXN0aW1hdGVkCW9uZWVpZ2h0aAx0aHJlZWVpZ2h0aHMLZml2ZWVpZ2h0aHMMc2V2ZW5laWdodGhzB3VuaUZCMDEHdW5pRkIwMg1jeXJpbGxpY2JyZXZlCGRvdGxlc3NqEGNhcm9uY29tbWFhY2NlbnQLY29tbWFhY2NlbnQRY29tbWFhY2NlbnRyb3RhdGUMemVyb3N1cGVyaW9yDGZvdXJzdXBlcmlvcgxmaXZlc3VwZXJpb3ILc2l4c3VwZXJpb3INc2V2ZW5zdXBlcmlvcg1laWdodHN1cGVyaW9yDG5pbmVzdXBlcmlvcgd1bmkyMDAwB3VuaTIwMDEHdW5pMjAwMgd1bmkyMDAzB3VuaTIwMDQHdW5pMjAwNQd1bmkyMDA2B3VuaTIwMDcHdW5pMjAwOAd1bmkyMDA5B3VuaTIwMEEHdW5pMjAwQgd1bmlGRUZGB3VuaUZGRkMHdW5pRkZGRAd1bmkwMUYwB3VuaTAyQkMHdW5pMDNEMQd1bmkwM0QyB3VuaTAzRDYHdW5pMUUzRQd1bmkxRTNGB3VuaTFFMDAHdW5pMUUwMQd1bmkxRjREB3VuaTAyRjMJZGFzaWFveGlhB3VuaUZCMDMHdW5pRkIwNAVPaG9ybgVvaG9ybgVVaG9ybgV1aG9ybgd1bmkwMzAwB3VuaTAzMDEHdW5pMDMwMwRob29rCGRvdGJlbG93B3VuaTA0MDAHdW5pMDQwRAd1bmkwNDUwB3VuaTA0NUQHdW5pMDQ2MAd1bmkwNDYxB3VuaTA0NjIHdW5pMDQ2Mwd1bmkwNDY0B3VuaTA0NjUHdW5pMDQ2Ngd1bmkwNDY3B3VuaTA0NjgHdW5pMDQ2OQd1bmkwNDZBB3VuaTA0NkIHdW5pMDQ2Qwd1bmkwNDZEB3VuaTA0NkUHdW5pMDQ2Rgd1bmkwNDcwB3VuaTA0NzEHdW5pMDQ3Mgd1bmkwNDczB3VuaTA0NzQHdW5pMDQ3NQd1bmkwNDc2B3VuaTA0NzcHdW5pMDQ3OAd1bmkwNDc5B3VuaTA0N0EHdW5pMDQ3Qgd1bmkwNDdDB3VuaTA0N0QHdW5pMDQ3RQd1bmkwNDdGB3VuaTA0ODAHdW5pMDQ4MQd1bmkwNDgyB3VuaTA0ODMHdW5pMDQ4NAd1bmkwNDg1B3VuaTA0ODYHdW5pMDQ4OAd1bmkwNDg5B3VuaTA0OEEHdW5pMDQ4Qgd1bmkwNDhDB3VuaTA0OEQHdW5pMDQ4RQd1bmkwNDhGB3VuaTA0OTIHdW5pMDQ5Mwd1bmkwNDk0B3VuaTA0OTUHdW5pMDQ5Ngd1bmkwNDk3B3VuaTA0OTgHdW5pMDQ5OQd1bmkwNDlBB3VuaTA0OUIHdW5pMDQ5Qwd1bmkwNDlEB3VuaTA0OUUHdW5pMDQ5Rgd1bmkwNEEwB3VuaTA0QTEHdW5pMDRBMgd1bmkwNEEzB3VuaTA0QTQHdW5pMDRBNQd1bmkwNEE2B3VuaTA0QTcHdW5pMDRBOAd1bmkwNEE5B3VuaTA0QUEHdW5pMDRBQgd1bmkwNEFDB3VuaTA0QUQHdW5pMDRBRQd1bmkwNEFGB3VuaTA0QjAHdW5pMDRCMQd1bmkwNEIyB3VuaTA0QjMHdW5pMDRCNAd1bmkwNEI1B3VuaTA0QjYHdW5pMDRCNwd1bmkwNEI4B3VuaTA0QjkHdW5pMDRCQQd1bmkwNEJCB3VuaTA0QkMHdW5pMDRCRAd1bmkwNEJFB3VuaTA0QkYLdW5pMDRDMC5hbHQHdW5pMDRDMQd1bmkwNEMyB3VuaTA0QzMHdW5pMDRDNAd1bmkwNEM1B3VuaTA0QzYHdW5pMDRDNwd1bmkwNEM4B3VuaTA0QzkHdW5pMDRDQQd1bmkwNENCB3VuaTA0Q0MHdW5pMDRDRAd1bmkwNENFC3VuaTA0Q0YuYWx0B3VuaTA0RDAHdW5pMDREMQd1bmkwNEQyB3VuaTA0RDMHdW5pMDRENAd1bmkwNEQ1B3VuaTA0RDYHdW5pMDRENwd1bmkwNEQ4B3VuaTA0RDkHdW5pMDREQQd1bmkwNERCB3VuaTA0REMHdW5pMDRERAd1bmkwNERFB3VuaTA0REYHdW5pMDRFMAd1bmkwNEUxB3VuaTA0RTIHdW5pMDRFMwd1bmkwNEU0B3VuaTA0RTUHdW5pMDRFNgd1bmkwNEU3B3VuaTA0RTgHdW5pMDRFOQd1bmkwNEVBB3VuaTA0RUIHdW5pMDRFQwd1bmkwNEVEB3VuaTA0RUUHdW5pMDRFRgd1bmkwNEYwB3VuaTA0RjEHdW5pMDRGMgd1bmkwNEYzB3VuaTA0RjQHdW5pMDRGNQd1bmkwNEY2B3VuaTA0RjcHdW5pMDRGOAd1bmkwNEY5B3VuaTA0RkEHdW5pMDRGQgd1bmkwNEZDB3VuaTA0RkQHdW5pMDRGRQd1bmkwNEZGB3VuaTA1MDAHdW5pMDUwMQd1bmkwNTAyB3VuaTA1MDMHdW5pMDUwNAd1bmkwNTA1B3VuaTA1MDYHdW5pMDUwNwd1bmkwNTA4B3VuaTA1MDkHdW5pMDUwQQd1bmkwNTBCB3VuaTA1MEMHdW5pMDUwRAd1bmkwNTBFB3VuaTA1MEYHdW5pMDUxMAd1bmkwNTExB3VuaTA1MTIHdW5pMDUxMwd1bmkxRUEwB3VuaTFFQTEHdW5pMUVBMgd1bmkxRUEzB3VuaTFFQTQHdW5pMUVBNQd1bmkxRUE2B3VuaTFFQTcHdW5pMUVBOAd1bmkxRUE5B3VuaTFFQUEHdW5pMUVBQgd1bmkxRUFDB3VuaTFFQUQHdW5pMUVBRQd1bmkxRUFGB3VuaTFFQjAHdW5pMUVCMQd1bmkxRUIyB3VuaTFFQjMHdW5pMUVCNAd1bmkxRUI1B3VuaTFFQjYHdW5pMUVCNwd1bmkxRUI4B3VuaTFFQjkHdW5pMUVCQQd1bmkxRUJCB3VuaTFFQkMHdW5pMUVCRAd1bmkxRUJFB3VuaTFFQkYHdW5pMUVDMAd1bmkxRUMxB3VuaTFFQzIHdW5pMUVDMwd1bmkxRUM0B3VuaTFFQzUHdW5pMUVDNgd1bmkxRUM3C3VuaTFFQzguYWx0B3VuaTFFQzkLdW5pMUVDQS5hbHQHdW5pMUVDQgd1bmkxRUNDB3VuaTFFQ0QHdW5pMUVDRQd1bmkxRUNGB3VuaTFFRDAHdW5pMUVEMQd1bmkxRUQyB3VuaTFFRDMHdW5pMUVENAd1bmkxRUQ1B3VuaTFFRDYHdW5pMUVENwd1bmkxRUQ4B3VuaTFFRDkHdW5pMUVEQQd1bmkxRURCB3VuaTFFREMHdW5pMUVERAd1bmkxRURFB3VuaTFFREYHdW5pMUVFMAd1bmkxRUUxB3VuaTFFRTIHdW5pMUVFMwd1bmkxRUU0B3VuaTFFRTUHdW5pMUVFNgd1bmkxRUU3B3VuaTFFRTgHdW5pMUVFOQd1bmkxRUVBB3VuaTFFRUIHdW5pMUVFQwd1bmkxRUVEB3VuaTFFRUUHdW5pMUVFRgd1bmkxRUYwB3VuaTFFRjEHdW5pMUVGNAd1bmkxRUY1B3VuaTFFRjYHdW5pMUVGNwd1bmkxRUY4B3VuaTFFRjkHdW5pMjBBQgd1bmkwMzBGE2NpcmN1bWZsZXhhY3V0ZWNvbWITY2lyY3VtZmxleGdyYXZlY29tYhJjaXJjdW1mbGV4aG9va2NvbWITY2lyY3VtZmxleHRpbGRlY29tYg5icmV2ZWFjdXRlY29tYg5icmV2ZWdyYXZlY29tYg1icmV2ZWhvb2tjb21iDmJyZXZldGlsZGVjb21iEGN5cmlsbGljaG9va2xlZnQIb25lLnBudW0HemVyby5vcwZvbmUub3MGdHdvLm9zCHRocmVlLm9zB2ZvdXIub3MHZml2ZS5vcwZzaXgub3MIc2V2ZW4ub3MIZWlnaHQub3MHbmluZS5vcwJmZgd1bmkyMTIwCFRjZWRpbGxhCHRjZWRpbGxhBWcuYWx0D2djaXJjdW1mbGV4LmFsdApnYnJldmUuYWx0CGdkb3QuYWx0EGdjb21tYWFjY2VudC5hbHQGSXRpbGRlB0ltYWNyb24GSWJyZXZlB0lvZ29uZWsCSUoJSW90YXRvbm9zBElvdGEMSW90YWRpZXJlc2lzCWFmaWkxMDA1NQlhZmlpMTAwNTYHdW5pMDRDMAd1bmkwNENGB3VuaTFFQzgHdW5pMUVDQQAAAQADAAgACgALAAf//wAPAAEAAAAMAAAAAAAAAAIABQAAAjUAAQI3AjcAAQI7AlsAAQJdA3YAAQOAA6cAAQAAAAEAAAAKAAwADgAAAAAAAAABAAAACgBuAVoAAWxhdG4ACAAQAAJNT0wgAChST00gAEIAAP//AAkAAwAIAAsAAAAOABEAFAAXABoAAP//AAoABAAGAAkADAABAA8AEgAVABgAGwAA//8ACgAFAAcACgANAAIAEAATABYAGQAcAB1saWdhALBsaWdhALBsaWdhALBsbnVtALZsbnVtALZsbnVtALZsb2NsALxsb2NsALxvbnVtAMJvbnVtAMJvbnVtAMJwbnVtAMpwbnVtAMpwbnVtAMpzYWx0ANBzYWx0ANBzYWx0ANBzczAxANBzczAxANBzczAxANBzczAyANhzczAyANhzczAyANhzczAzAN5zczAzAN5zczAzAN50bnVtAOR0bnVtAOR0bnVtAOQAAAABAAkAAAABAAcAAAABAAgAAAACAAIAAwAAAAEABAAAAAIAAAABAAAAAQAAAAAAAQABAAAAAgAFAAYACgAWADwAfACUAMwA4ADuAQIBLgFQAAEAAAABAAgAAgAQAAUDjwOQA5EDkgOTAAEABQBKAN8A4QDjAOUAAQAAAAEACAACAC4AFAAsAI4AjwCQAJEA6gDsAO4A8ADyAPQBWgFnAXcBoQGiAskC2ANFA0cAAgABA5QDpwAAAAEAAAABAAgAAQAGA24AAgABABMAHAAAAAEAAAABAAgAAgAaAAoDgQODA4QDhQOGA4cDiAOJA4oDggACAAMAEwATAAAAFQAcAAEDgAOAAAkAAQAAAAEACAABAAYDbAABAAEAFAABAAAAAQAIAAEAPPySAAEAAAABAAgAAQAG/JQAAQABA4AAAQAAAAEACAACABoACgATA4AAFQAWABcAGAAZABoAGwAcAAIAAQOBA4oAAAABAAAAAQAIAAIADgAEA40DjgEgASEAAQAEASQBJQFJAUoABAAAAAEACAABADYAAQAIAAUADAAUABwAIgAoAl4AAwBJAE8CXQADAEkATAOLAAIASQI1AAIATwI0AAIATAABAAEASQAA";

var openSansItalic = "data:font/ttf;base64,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Rys1UEMvNgKogqRdS3+UXWYzH4EwNKeafNB3Ym1kAUpNWzQ0R18zAP///4sAAAQQB3MCJgAkAAABBwBD/9gBUgAKtAIQEAUmACsRNf///4sAAARNB3MCJgAkAAABBwB2AJMBUgAKtAIYGAUmACsRNf///4sAAAQ4B3MCJgAkAAABBwFLAEIBUgAKtAIVFQUmACsRNf///4sAAASPBy8CJgAkAAABBwFSAGABUgAKtAIYGAUmACsRNf///4sAAAQrByUCJgAkAAABBwBqAEIBUgAMtQMCIiIFJgArETU1////iwAABBAHAgImACQAAAEHAVAAAgCBABlADwMC7xgB3xgBbxgBDxgBGAARXV1dXTU1AAAC/4kAAAbdBbYADwATADxAIAoNSVkKCgEGEwNJWRMTAQYFEgkSBhJJWQYDAQ5JWQESAD8rABg/KxEAMxg/ERI5LysREgA5GC8rMTAhIRMhASMBIQchAyEHIQMhARMjAQWo/R9i/kr+28UDqgOqIf3LZAIQHP3vcwI2/X+TVP5OAdH+LwW2mf4rlv3mAdUCsP1Q//8Alv4UBQoFywImACYAAAAHAHoCIwAA//8AVgAABGoHcwImACgAAAEHAEP/+wFSAAq0AQ0NBSYAKxE1//8AVgAABGoHcwImACgAAAEHAHYAfQFSAAq0ARUVBSYAKxE1//8AVgAABGoHcwImACgAAAEHAUsARgFSAAq0ARISBSYAKxE1//8AVgAABGoHJQImACgAAAEHAGoAQgFSAAy1AgEfHwUmACsRNTX////ZAAADAAdzAiYALAAAAQcAQ/7zAVIACrQBDQ0FJgArETX////ZAAADawdzAiYALAAAAQcAdv+xAVIACrQBFRUFJgArETX////ZAAADSQdzAiYALAAAAQcBS/9TAVIACrQBEhIFJgArETX////ZAAADPgclAiYALAAAAQcAav9VAVIADLUCAR8fBSYAKxE1NQACAEgAAAUUBbYADQAbAC1AFxoHCAdJWRcICAUKChZKWQoDBRtKWQUSAD8rABg/KxESADkYLzMrEQAzMTABEAIEISETIzczEyEgAAEyJBI1NCYjIwMhByEDBRTS/nr++v6gh5Uglo0BVgEUAR/8rcoBMqPOx7JvAUoh/rZqA23++/5w2AKJlgKX/tX8CLcBTtfX3f38lv4K//8AVAAABagHLwIm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AAABBwN+BPABUgAMtQMCJSUFJgArETU1//8AYv/sBIUHEAImAEQAAAEHA34EugAAAAy1AwI3NxEmACsRNTX///+L/qAETgc3AiYAJAAAACcBTgAzAVIBBwJnBKwAAAAKtAISEgUmACsRNf//AGL+oARgBeUCJgBEAAAAJgFOAgABBwJnBJYAAAAKtAIkJBEmACsRNf//AFb+oARqBbYCJgAoAAAABwJnBI8AAP//AGL+oAO0BFwCJgBIAAAABwJnBHUAAP//AFYAAARqB98CJgAoAAABBwJmBPABUgAKtAEREQUmACsRNf//AGL/7AO0Bo0CJgBIAAABBwJmBIMAAAAKtAIoKBEmACsRNf//AFYAAASDBy8CJgAoAAABBwFSAFQBUgAKtAEVFQUmACsRNf//AGL/7AQJBd0CJgBIAAABBgFS2gAACrQCLCwRJgArETX//wBWAAAFVgfRAiYAKAAAAQcDdwTsAVIADLUCARcXBSYAKxE1Nf//AGL/7ATxBn8CJgBIAAABBwN3BIcAAAAMtQMCLi4RJgArETU1//8AVgAABGoH0QImACgAAAEHA3gE7AFSAAy1AgEXFwUmACsRNTX//wBi/+wDvgZ/AiYASAAAAQcDeASHAAAADLUDAi4uESYAKxE1Nf//AFYAAAUJCC8CJgAoAAABBwN5BOwBUgAMtQIBFxcFJgArETU1//8AYv/sBKQG3QImAEgAAAEHA3kEhwAAAAy1AwIuLhEmACsRNTX//wBWAAAEywhiAiYAKAAAAQcDegTsAVIADLUCAS0tBSYAKxE1Nf//AGL/7ARmBxACJgBIAAABBwN6BIcAAAAMtQMCREQRJgArETU1//8AVv6gBGoHcwImACgAAAAnAmcEjwAAAQcBSwBGAVIACrQCGBgFJgArETX//wBi/qADxgYhAiYASAAAACcCZwR1AAABBgFL0AAACrQDLy8RJgArETX////ZAAADKQffAiYALAAAAQcCZgQSAVIACrQBEREFJgArETX//wA7AAACpgaNAiYA8wAAAQcCZgOPAAAACrQBCQkRJgArETX////Z/qADAAW2AiYALAAAAAcCZwOgAAD////6/qACHwXfAiYATAAAAAcCZwNOAAD//wCW/qAFgwXNAiYAMgAAAAcCZwU1AAD//wBi/qAEHQRWAiYAUgAAAAcCZwSyAAD//wCW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XYFd515JXuRfeV+BX4lf2mAiYFxgkWCkYLdgw2DPYTphomI/YtZjYWO8Y/VkLGRjZIdks2TWZPdlzWZXZqpnCWdRZ6Zn82hWaIZotWj/aUppjmoGahJqHmpQaoJqvmr5azNrdGuja9JsBWw5bGtsnGzqbThtq24XbiNuL25Zbshu0G73by1vZW+Zb81wBHBbcJ1w4nEscXpxsXHrclZyuXMsc5lzoXOzc8V0C3RQdI901XUSdUx1f3WzdfV2OXZ8dr52xnbYdul2/HcOdxZ3Hncwd0F3kHfad+13/3gSeCV4OHhLeI940njkePV5CHkaeS15P3lHeU95Ynl0eYd5mnmseb150HniefV6B3oaeix6Unp3eop6nXrpezV7eXu9e/l8NHxlfG18wn0nfYd94341fop+2n82f39/yYASgFWAkoDTgSWBLYF7gdCB3IHogfqCDIIfgjKCRYJYgmuCfoKRgqSCuoLPguKC9YMIgxuDLoNBg1SDZ4N9g5KDnoOqg7yDzoPgg/GEBIQXhCqEPYRQhGOEdoSJhJ+EtITGhNiE5ITwhPyFCIUahSyFP4VShWWFeIWLhZ6FsYXEhdqF94YJhhqGLIY9hk+GYYZzhoSGkIachqiGtIbGhtiG6ob7hw2HHocwh0KHVIdlh3GHfYeJh5WHp4e5h8uH3IfoiBCISIh9iMKJDolAiXKJson8ih6KJ4phioOKvosQi0mLj4uXi7aLvowUjI6M7Iz4jQSNXo1vjYCNko2jjbaNyI3ajeyN/44RjiOONY5AjlKOXo5rjnOOho6OjqGOqY6xjsOOzwAAAAEAAAABGdvbhMhtXw889QAJCAAAAAAAyWNIwAAAAADVK8zV/AT92wnZCGIAAgAJAAIAAAAAAAAEzQDBAAAAAAQUAAACFAAAAhIAKwMXAOEFKwA/BGgASAZYAKgFXABCAbwA4QJIAFICSP9gBGoA1wRoAH8B7P+cAn8ANwIGACsCzf+iBGgAeQRoAS8EaAAMBGgALwRoABAEaABQBGgAhQRoAK4EaABgBGgAYgIGACsCBv+cBGgAeQRoAH8EaAB5A2oAngbHAG8Ecf+LBMkAVgSuAJYFVABWBBcAVgPHAFYFagCWBW0AVgKL/9kCI/7BBHUAVgPLAFYGsgBUBZ4AVAXDAJYEhwBWBcMAlgSNAFYEBAAnA/wAugVoAKQEYgC8BtEA3wQn/5gEBgC8BD//8AJK//ACzQDdAkr/agQjADUDJ/9EBG8CPwSFAGIEngA7A5oAYgSeAGID8gBiAoH/GwQC/4EEngA7AggAOwII/v4D5wA5AggAOQb6ADsEngA7BH0AYgSe/9UEngBiAysAOwNtAAgCmABaBJ4AcQOyAGIFvAB1A9P/tgOy/zsDjf/jAssAGwRoAh0Cy/+2BGgAcwIUAAACEv/yBGgA4QRo/+kEaACoBGgAfwRoAh0D4wA7BG8ByQaoAIsCrgCqA74AWARoAH8CfwA3BqgAiwMOAOMDbQDXBGgAfwLNAGACzQB3BG8CFASq/9UFPQDHAgYAqgGk/1YCzQECArAAqAO+ABcF7gB7Be4AQgYdAFcDav/8BHH/iwRx/4sEcf+LBHH/iwRx/4sEcf+LBon/iQSuAJYEFwBWBBcAVgQXAFYEFwBWAov/2QKL/9kCi//ZAov/2QVUAEgFngBUBcMAlgXDAJYFwwCWBcMAlgXDAJYEaACoBcMAdwVoAKQFaACkBWgApAVoAKQEBgC8BIcAVgSe/wAEhQBiBIUAYgSFAGIEhQBiBIUAYgSFAGIGhQBiA5oAYgPyAGID8gBiA/IAYgPyAGICCAA7AggAOwIIADsCCAA7BI0AWgSeADsEfQBiBH0AYgR9AGIEfQBiBH0AYgRoAH8EfQA9BJ4AcQSeAHEEngBxBJ4AcQOy/zsEnv/VA7L/OwRx/4sEhQBiBHH/iwSFAGIEcf+LBIUAYgSuAJYDmgBiBK4AlgOaAGIErgCWA5oAYgSuAJYDmgBiBVQAVgSeAGIFVABIBJ4AYgQXAFYD8gBiBBcAVgPyAGIEFwBWA/IAYgQXAFYD8gBiBBcAVgPyAGIFagCWBAL/gQVqAJYEAv+BBWoAlgQC/4EFagCWBAL/gQVtAFYEngA7BW0AVgSeADsCi//ZAggAOwKL/9kCCAA7Aov/2QIIADsCi//ZAgj/mgKL/9kCCAA7BKz/2QQQADsCI/7BAgj+/gR1AFYD5wA5A+cAOQPLAFYCCAA5A8sAVgII/58DywBWAggAOQPLAFYCRAA5A8sAFwIAAAQFngBUBJ4AOwWeAFQEngA7BZ4AVASeADsFKQBdBZ4AVASeADsFwwCWBH0AYgXDAJYEfQBiBcMAlgR9AGIG1wCWBukAYgSNAFYDKwA7BI0AVgMr/5kEjQBWAysAOwQEACcDbQAIBAQAJwNtAAgEBAAnA20ACAQEACcDbQAIA/wAkQKYADsD/AC6ApgAWgP8AKoCmAArBWgApASeAHEFaACkBJ4AcQVoAKQEngBxBWgApASeAHEFaACkBJ4AcQVoAKQEngBxBtEA3wW8AHUEBgC8A7L/OwQGALwEP//wA43/4wQ///ADjf/jBD//8AON/+MCM/78BGgABARx/40EhQBiBon/iQaFAGIFwwB3BH0APQQEACcDbQAIBG8BjwRvAdMESAGWBG8B2wHyAUQEngInAXX/bwRvAVAEbwGNBIECbwSBAcEEcf+LAgYAqgSLAEcGCABHA4UAYAYOAFwFHwBHBkIAVAJxAGgEcf+LBMkAVgPPAFYEd//JBBcAVgQ///AFbQBWBcMAlgKL/9kEdQBWBHf/iwayAFQFngBUBCP/5QXDAJYFbwBWBIcAVgQr/+MD/AC6BAYAvAX0AJYEJ/+YBeEAxwXd//ACi//ZBAYAvASNAGIDjwA/BJ4AOwJxAGgEnACFBI0AYgSe/9MDrABUBG0ASgOPAD8DoABiBJ4AOwRYAGICcQBoA+cAOQPd/4sEqv/VA+kAYgOPAFIEfQBiBM0ATASR/9UDoABiBKYAYgNYAEwEnACFBVwAYgQG/xsFtgCPBdcAYgJxAGgEnACFBH0AYgScAIUF1wBiBBcAVgVWALoDzwBWBK4AlgQEACcCi//ZAov/2QIj/sEHHf++BzcAVgVWALoEeQBWBJP//AVvAFYEcf+LBIMAWgTJAFYDzwBWBPj/VgQXAFYGNf+cBEL/+gWTAFYFkwBWBHkAVgUn/74GsgBUBW0AVgXDAJYFbwBWBIcAVgSuAJYD/AC6BJP//AX0AJYEJ/+YBVIAVAUdAPoHpABUB6gAVAUAALoGSgBWBG8AVgSuABIH1QBWBI3/tASFAGIEVABkBE4AYgOoADcEgQBiA/IAYgas/90Dff/8BJ4AcQSeAHED0QA7BEz/ogWFAD0EywA7BH0AYgSeADsEnv/VA5oAYgb6ADsDsv87BU4AYgPT/7YEwwBxBHEAngb6AHEHHwBxBLwAVAXFAIEEJwCBA6YAEgY/ADsEN//VA/IAYgSeADsDqAA3A5oAYgNtAAgCCAA7AggAOwII/v4GGf+iBn8AOQSeADsD0QA7A7L/OwSeAHEDzwBWAxAAOwbRAN8FvAB1BtEA3wW8AHUG0QDfBbwAdQQGALwDsv87A9cANweuADcHrgA3Ayf/MQFcAHsBXAB9Aez/nAFcAOUCzwB7As8AfQNa/5wDugDZA88ATgMGAMcGGwArCPAAqAG8AOEDFwDhAkQAWAJEABcD1//mAQz+GQLyAKgEaAAtBGj/6QXNADcEaAA/BjkAywQAAKAHmgA7Bf4AeQXd//AE9AB/BgYAVgaBAFMGjQBdBgAAUgSmAHcEd//JBe4A9gUMAMMEaAB/BGQAYgWoAJgDEgAnBGgAcwRoAH8EaAB/BGgAfwSqAJgEjf8bBI3/GwSBAVwCCP7+A9ECBgPRAJwD0QH4As0AkwLNAFwCzQCHAs0ApgLNAK4CzQCDAs0AjQQAAAAIAAAABAAAAAgAAAACqgAAAgAAAAFWAAAEeQAAAiEAAAGaAAAAzQAAAAAAAAAAAAAIAABUCAAAVAII/v4BXAB9BI8ALwQUALwGVgBtBrIAVAb6ADsEcf+LBIUAYgY7/3MCqv+6A1oBMwcX/xsHF/8bBbYAlgR9AGIFxwCkBPAAcQAA/S4AAP3mAAD8tQAA/b4AAPysBBcAVgWTAFYD8gBiBJ4AcQegAJYFvgBoBPQAlgRqAFwG4wBWBX8AOwTP/4sEO/+kBroAVgXFADsFSP+uBNP/kQdSAFYGaAA7BEL/uAOT/6IF4QDHBbYAjwXDAJYEfQBiBHkAvAOFAGAEeQC8A4UAYAl5AJYICABiBekAlgSgAGIHoACWBhIAYgegAJYFvgBoBK4AlgOaAGIE3wB1BHsBVASkAXcEpAJ9BKQCmAfpACkHpgApBaAAVgSiAHEEbQBWBCcAfwSHAFYEnv/VA8UATgMQAAwE0wBWA+4AOwaT/5wGtP/dBEL/+gN9//wEzQBUBCsAOwR5AFQDzQA1BHUAVgPTADkFDgC6BHsATgVqAFYEywA7BgoAVgWBADsH+ABWBosAOwXDAJYEywBiBK4AlgOaAGID/AC6BxQAOwQGALwDsgBiBAYAbQOy/+UEjf+YBCv/8gY3ALoFQgBaBRcA+ARaAJwFHQD4BG8AnAUdAFQEnAA7Bh8AgQS+AFAGHwCBBL4AUAKL/9kGNf+cBqz/3QUIAFYEHQA7BTP/vgRK/6IFbQBWBMsAOwV5AFYEywA7BR0A+ASgAMsGvABUBYMAPQKL/9kEcf+LBIUAYgRx/4sEhQBi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ADsATwBwAGUAbgBTAGEAbgBzAC0ASQB0AGEAbABpAGMATwBwAGUAbgAgAFMAYQBuAHMAIABJAHQAYQBsAGkAYwBWAGUAcgBzAGkAbwBuACAAMQAuADEAMABPAHAAZQBuAFMAYQBuAHMALQBJAHQAYQBsAGkAYwBoAHQAdABwADoALwAvAHcAdwB3AC4AYQBwAGEAYwBoAGUALgBvAHIAZwAvAGwAaQBjAGUAbgBzAGUAcwAvAEwASQBDAEUATgBTAEUALQAyAC4AMAAAAAIAAP/0AAD/ZgBmAAAAAAAAAAAAAAAAAAAAAAAAAAADqAAAAQIAAgADAAQABQAGAAcACAAJAAoACwAMAA0ADgAPABAAEQASABMAFAAVABYAFwAYABkAGgAbABwAHQAeAB8AIAAhACIAIwAkACUAJgAnACgAKQAqACsBAwAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5ADoAOwA8AD0APgA/AEAAQQBCAEMARABFAEYARwBIAEkASgBLAEwATQBOAE8AUABRAFIAUwBUAFUAVgBXAFgAWQBaAFsAXABdAF4AXwBgAGEArACjAIQAhQC9AJYA6ACGAI4AiwCdAKkApAEEAIoBBQCDAJMA8gDzAI0AlwCIAMMA3gDxAJ4AqgD1APQA9gCiAK0AyQDHAK4AYgBjAJAAZADLAGUAyADKAQYBBwEIAQkA6QBmANMA0ADRAK8AZwDwAJEA1gDUANUAaADrAO0AiQBqAGkAawBtAGwAbgCgAG8AcQBwAHIAcwB1AHQAdgB3AOoAeAB6AHkAewB9AHwAuAChAH8AfgCAAIEA7ADuALoBCgELAQwBDQEOAQ8A/QD+ARABEQESARMA/wEAARQBFQEWAQEBFwEYARkBGgEbARwBHQEeAR8BIAEhASIA+AD5ASMBJAElASYBJwEoASkBKgErASwBLQEuAS8BMAExATIBMwDXATQBNQE2ATcBOAE5AToBOwE8AT0BPgE/AUABQQFCAOIA4wFDAUQBRQFGAUcBSAFJAUoBSwFMAU0BTgFPAVABUQCwALEBUgFTAVQBVQFWAVcBWAFZAVoBWwD7APwA5ADlAVwBXQFeAV8BYAFhAWIBYwFkAWUBZgFnAWgBaQFqAWsBbAFtAW4BbwFwAXEAuwFyAXMBdAF1AOYA5wF2AKYBdwF4AXkBegF7AXwBfQF+ANgA4QDaANsA3ADdAOAA2QDfAX8BgAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AJsBuAG5AboBuwG8Ab0BvgG/AcABwQHCAcMBxAHFAcYBxwHIAckBygHLAcwBzQHOAc8B0AHRAdIB0wHUAdUB1gHXAdgB2QHaAdsB3AHdAd4B3wHgAeEB4gHjAeQB5QHmAecB6AHpAeoB6wHsAe0B7gHvAfAB8QHyAfMB9AH1AfYB9wH4AfkB+gH7AfwB/QH+Af8CAAIBAgICAwIEAgUCBgIHAggCCQIKAgsCDAINAg4CDwIQAhECEgITAhQCFQIWAhcCGAIZAhoCGwIcAh0CHgIfAiACIQIiAiMCJAIlAiYCJwIoAikCKgIrALIAswIsAi0AtgC3AMQCLgC0ALUAxQCCAMIAhwCrAMYCLwIwAL4AvwIxALwCMgD3AjMCNAI1AjYCNwI4AIwAnwI5AjoCOwI8Aj0AmACoAJoAmQDvAKUAkgCcAKcAjwCUAJUAuQI+Aj8CQAJBAkICQwJEAkUCRgJHAkgCSQJKAksCTAJNAk4CTwJQAlECUgJTAlQCVQJWAlcCWAJZAloCWwJcAl0CXgJfAmACYQJiAmMCZAJlAmYCZwJoAmkCagJrAmwCbQJuAm8CcAJxAnICcwJ0AnUCdgJ3AngCeQJ6AnsCfAJ9An4CfwKAAoECggKDAoQChQKGAocCiAKJAooCiwKMAo0CjgKPApACkQKSApMClAKVApYClwKYApkCmgKbApwCnQKeAp8CoAKhAqICowKkAqUCpgKnAqgCqQKqAqsCrAKtAq4CrwKwArECsgKzArQCtQK2ArcCuAK5AroCuwK8Ar0CvgK/AsACwQLCAsMCxALFAsYCxwLIAskCygLLAswCzQLOAs8C0ALRAtIC0wLUAtUC1gLXAtgC2QLaAtsC3ALdAt4C3wLgAuEC4gLjAuQC5QLmAucC6ALpAuoC6wLsAu0C7gLvAvAC8QLyAvMC9AL1AvYC9wL4AvkC+gL7AvwC/QL+Av8DAAMBAwIDAwMEAwUDBgMHAwgDCQMKAwsDDAMNAw4DDwMQAxEDEgMTAxQDFQMWAxcDGAMZAxoDGwMcAx0DHgMfAyADIQMiAyMDJAMlAyYDJwMoAykDKgMrAywDLQMuAy8DMAMxAzIDMwM0AzUDNgM3AzgDOQM6AzsDPAM9Az4DPwNAA0EDQgNDA0QDRQNGA0cDSANJA0oDSwNMA00DTgNPA1ADUQNSA1MDVANVA1YDVwNYA1kDWgNbA1wDXQNeA18DYANhA2IDYwNkA2UDZgNnA2gDaQNqA2sDbANtA24DbwNwA3EDcgNzA3QDdQN2A3cDeAN5A3oDewN8A30DfgN/A4ADgQOCA4MDhAOFA4YDhwOIA4kDigOLA4wDjQOOA48DkAORA5IDkwOUA5UDlgOXA5gDmQOaA5sDnAOdACwAzwDMAM0AzgOeA58DoAOhAPoDogOjA6QDpQOmA6cDqAOpA6oDqwRudWxsBUkuYWx0B3VuaTAwQUQJb3ZlcnNjb3JlCklncmF2ZS5hbHQKSWFjdXRlLmFsdA9JY2lyY3VtZmxleC5hbHQNSWRpZXJlc2lzLmFsdAdBbWFjcm9uB2FtYWNyb24GQWJyZXZlBmFicmV2ZQdBb2dvbmVrB2FvZ29uZWsLQ2NpcmN1bWZsZXgLY2NpcmN1bWZsZXgEQ2RvdARjZG90BkRjYXJvbgZkY2Fyb24GRGNyb2F0B0VtYWNyb24HZW1hY3JvbgZFYnJldmUGZWJyZXZlCkVkb3RhY2NlbnQKZWRvdGFjY2VudAdFb2dvbmVrB2VvZ29uZWsGRWNhcm9uBmVjYXJvbgtHY2lyY3VtZmxleAtnY2lyY3VtZmxleARHZG90BGdkb3QMR2NvbW1hYWNjZW50DGdjb21tYWFjY2VudAtIY2lyY3VtZmxleAtoY2lyY3VtZmxleARIYmFyBGhiYXIKSXRpbGRlLmFsdAZpdGlsZGULSW1hY3Jvbi5hbHQHaW1hY3JvbgpJYnJldmUuYWx0BmlicmV2ZQtJb2dvbmVrLmFsdAdpb2dvbmVrDklkb3RhY2NlbnQuYWx0BklKLmFsdAJpagtKY2lyY3VtZmxleAtqY2lyY3VtZmxleAxLY29tbWFhY2NlbnQMa2NvbW1hYWNjZW50DGtncmVlbmxhbmRpYwZMYWN1dGUGbGFjdXRlDExjb21tYWFjY2VudAxsY29tbWFhY2NlbnQGTGNhcm9uBmxjYXJvbgRMZG90BGxkb3QGTmFjdXRlBm5hY3V0ZQxOY29tbWFhY2NlbnQMbmNvbW1hYWNjZW50Bk5jYXJvbgZuY2Fyb24LbmFwb3N0cm9waGUDRW5nA2VuZwdPbWFjcm9uB29tYWNyb24GT2JyZXZlBm9icmV2ZQ1PaHVuZ2FydW1sYXV0DW9odW5nYXJ1bWxhdXQGUmFjdXRlBnJhY3V0ZQxSY29tbWFhY2NlbnQMcmNvbW1hYWNjZW50BlJjYXJvbgZyY2Fyb24GU2FjdXRlBnNhY3V0ZQtTY2lyY3VtZmxleAtzY2lyY3VtZmxleAxUY29tbWFhY2NlbnQMdGNvbW1hYWNjZW50BlRjYXJvbgZ0Y2Fyb24EVGJhcgR0YmFyBlV0aWxkZQZ1dGlsZGUHVW1hY3Jvbgd1bWFjcm9uBlVicmV2ZQZ1YnJldmUFVXJpbmcFdXJpbmcNVWh1bmdhcnVtbGF1dA11aHVuZ2FydW1sYXV0B1VvZ29uZWsHdW9nb25lawtXY2lyY3VtZmxleAt3Y2lyY3VtZmxleAtZY2lyY3VtZmxleAt5Y2lyY3VtZmxleAZaYWN1dGUGemFjdXRlClpkb3RhY2NlbnQKemRvdGFjY2VudAVsb25ncwpBcmluZ2FjdXRlCmFyaW5nYWN1dGUHQUVhY3V0ZQdhZWFjdXRlC09zbGFzaGFjdXRlC29zbGFzaGFjdXRlDFNjb21tYWFjY2VudAxzY29tbWFhY2NlbnQFdG9ub3MNZGllcmVzaXN0b25vcwpBbHBoYXRvbm9zCWFub3RlbGVpYQxFcHNpbG9udG9ub3MIRXRhdG9ub3MNSW90YXRvbm9zLmFsdAxPbWljcm9udG9ub3MMVXBzaWxvbnRvbm9zCk9tZWdhdG9ub3MRaW90YWRpZXJlc2lzdG9ub3MFQWxwaGEEQmV0YQVHYW1tYQd1bmkwMzk0B0Vwc2lsb24EWmV0YQNFdGEFVGhldGEISW90YS5hbHQFS2FwcGEGTGFtYmRhAk11Ak51AlhpB09taWNyb24CUGkDUmhvBVNpZ21hA1RhdQdVcHNpbG9uA1BoaQNDaGkDUHNpB3VuaTAzQTkQSW90YWRpZXJlc2lzLmFsdA9VcHNpbG9uZGllcmVzaXMKYWxwaGF0b25vcwxlcHNpbG9udG9ub3MIZXRhdG9ub3MJaW90YXRvbm9zFHVwc2lsb25kaWVyZXNpc3Rvbm9zBWFscGhhBGJldGEFZ2FtbWEFZGVsdGEHZXBzaWxvbgR6ZXRhA2V0YQV0aGV0YQRpb3RhBWthcHBhBmxhbWJkYQd1bmkwM0JDAm51AnhpB29taWNyb24DcmhvBnNpZ21hMQVzaWdtYQN0YXUHdXBzaWxvbgNwaGkDY2hpA3BzaQVvbWVnYQxpb3RhZGllcmVzaXMPdXBzaWxvbmRpZXJlc2lzDG9taWNyb250b25vcwx1cHNpbG9udG9ub3MKb21lZ2F0b25vcwlhZmlpMTAwMjMJYWZpaTEwMDUxCWFmaWkxMDA1MglhZmlpMTAwNTMJYWZpaTEwMDU0DWFmaWkxMDA1NS5hbHQNYWZpaTEwMDU2LmFsdAlhZmlpMTAwNTcJYWZpaTEwMDU4CWFmaWkxMDA1OQlhZmlpMTAwNjAJYWZpaTEwMDYxCWFmaWkxMDA2MglhZmlpMTAxNDUJYWZpaTEwMDE3CWFmaWkxMDAxOAlhZmlpMTAwMTkJYWZpaTEwMDIwCWFmaWkxMDAyMQlhZmlpMTAwMjIJYWZpaTEwMDI0CWFmaWkxMDAyNQlhZmlpMTAwMjYJYWZpaTEwMDI3CWFmaWkxMDAyOAlhZmlpMTAwMjkJYWZpaTEwMDMwCWFmaWkxMDAzMQlhZmlpMTAwMzIJYWZpaTEwMDMzCWFmaWkxMDAzNAlhZmlpMTAwMzUJYWZpaTEwMDM2CWFmaWkxMDAzNwlhZmlpMTAwMzgJYWZpaTEwMDM5CWFmaWkxMDA0MAlhZmlpMTAwNDEJYWZpaTEwMDQyCWFmaWkxMDA0MwlhZmlpMTAwNDQJYWZpaTEwMDQ1CWFmaWkxMDA0NglhZmlpMTAwNDcJYWZpaTEwMDQ4CWFmaWkxMDA0OQlhZmlpMTAwNjUJYWZpaTEwMDY2CWFmaWkxMDA2NwlhZmlpMTAwNjgJYWZpaTEwMDY5CWFmaWkxMDA3MAlhZmlpMTAwNzIJYWZpaTEwMDczCWFmaWkxMDA3NAlhZmlpMTAwNzUJYWZpaTEwMDc2CWFmaWkxMDA3NwlhZmlpMTAwNzgJYWZpaTEwMDc5CWFmaWkxMDA4MAlhZmlpMTAwODEJYWZpaTEwMDgyCWFmaWkxMDA4MwlhZmlpMTAwODQJYWZpaTEwMDg1CWFmaWkxMDA4NglhZmlpMTAwODcJYWZpaTEwMDg4CWFmaWkxMDA4OQlhZmlpMTAwOTAJYWZpaTEwMDkxCWFmaWkxMDA5MglhZmlpMTAwOTMJYWZpaTEwMDk0CWFmaWkxMDA5NQlhZmlpMTAwOTYJYWZpaTEwMDk3CWFmaWkxMDA3MQlhZmlpMTAwOTkJYWZpaTEwMTAwCWFmaWkxMDEwMQlhZmlpMTAxMDIJYWZpaTEwMTAzCWFmaWkxMDEwNAlhZmlpMTAxMDUJYWZpaTEwMTA2CWFmaWkxMDEwNwlhZmlpMTAxMDgJYWZpaTEwMTA5CWFmaWkxMDExMAlhZmlpMTAxOTMJYWZpaTEwMDUwCWFmaWkxMDA5OAZXZ3JhdmUGd2dyYXZlBldhY3V0ZQZ3YWN1dGUJV2RpZXJlc2lzCXdkaWVyZXNpcwZZZ3JhdmUGeWdyYXZlCWFmaWkwMDIwOA11bmRlcnNjb3JlZGJsDXF1b3RlcmV2ZXJzZWQGbWludXRlBnNlY29uZAlleGNsYW1kYmwJbnN1cGVyaW9yCWFmaWkwODk0MQZwZXNldGEERXVybwlhZmlpNjEyNDgJYWZpaTYxMjg5CWFmaWk2MTM1Mgllc3RpbWF0ZWQJb25lZWlnaHRoDHRocmVlZWlnaHRocwtmaXZlZWlnaHRocwxzZXZlbmVpZ2h0aHMHdW5pRkIwMQd1bmlGQjAyDWN5cmlsbGljYnJldmUIZG90bGVzc2oQY2Fyb25jb21tYWFjY2VudAtjb21tYWFjY2VudBFjb21tYWFjY2VudHJvdGF0ZQx6ZXJvc3VwZXJpb3IMZm91cnN1cGVyaW9yDGZpdmVzdXBlcmlvcgtzaXhzdXBlcmlvcg1zZXZlbnN1cGVyaW9yDWVpZ2h0c3VwZXJpb3IMbmluZXN1cGVyaW9yB3VuaTIwMDAHdW5pMjAwMQd1bmkyMDAyB3VuaTIwMDMHdW5pMjAwNAd1bmkyMDA1B3VuaTIwMDYHdW5pMjAwNwd1bmkyMDA4B3VuaTIwMDkHdW5pMjAwQQd1bmkyMDBCB3VuaUZFRkYHdW5pRkZGQwd1bmlGRkZEB3VuaTAxRjAHdW5pMDJCQwd1bmkwM0QxB3VuaTAzRDIHdW5pMDNENgd1bmkxRTNFB3VuaTFFM0YHdW5pMUUwMAd1bmkxRTAxB3VuaTFGNEQHdW5pMDJGMwlkYXNpYW94aWEHdW5pRkIwMwd1bmlGQjA0BU9ob3JuBW9ob3JuBVVob3JuBXVob3JuB3VuaTAzMDAHdW5pMDMwMQd1bmkwMzAzBGhvb2sIZG90YmVsb3cHdW5pMDQwMAd1bmkwNDBEB3VuaTA0NTAHdW5pMDQ1RAd1bmkwNDYwB3VuaTA0NjEHdW5pMDQ2Mgd1bmkwNDYzB3VuaTA0NjQHdW5pMDQ2NQd1bmkwNDY2B3VuaTA0NjcHdW5pMDQ2OAd1bmkwNDY5B3VuaTA0NkEHdW5pMDQ2Qgd1bmkwNDZDB3VuaTA0NkQHdW5pMDQ2RQd1bmkwNDZGB3VuaTA0NzAHdW5pMDQ3MQd1bmkwNDcyB3VuaTA0NzMHdW5pMDQ3NAd1bmkwNDc1B3VuaTA0NzYHdW5pMDQ3Nwd1bmkwNDc4B3VuaTA0NzkHdW5pMDQ3QQd1bmkwNDdCB3VuaTA0N0MHdW5pMDQ3RAd1bmkwNDdFB3VuaTA0N0YHdW5pMDQ4MAd1bmkwNDgxB3VuaTA0ODIHdW5pMDQ4Mwd1bmkwNDg0B3VuaTA0ODUHdW5pMDQ4Ngd1bmkwNDg4B3VuaTA0ODkHdW5pMDQ4QQd1bmkwNDhCB3VuaTA0OEMHdW5pMDQ4RAd1bmkwNDhFB3VuaTA0OEYHdW5pMDQ5Mgd1bmkwNDkzB3VuaTA0OTQHdW5pMDQ5NQd1bmkwNDk2B3VuaTA0OTcHdW5pMDQ5OAd1bmkwNDk5B3VuaTA0OUEHdW5pMDQ5Qgd1bmkwNDlDB3VuaTA0OUQHdW5pMDQ5RQd1bmkwNDlGB3VuaTA0QTAHdW5pMDRBMQd1bmkwNEEyB3VuaTA0QTMHdW5pMDRBNAd1bmkwNEE1B3VuaTA0QTYHdW5pMDRBNwd1bmkwNEE4B3VuaTA0QTkHdW5pMDRBQQd1bmkwNEFCB3VuaTA0QUMHdW5pMDRBRAd1bmkwNEFFB3VuaTA0QUYHdW5pMDRCMAd1bmkwNEIxB3VuaTA0QjIHdW5pMDRCMwd1bmkwNEI0B3VuaTA0QjUHdW5pMDRCNgd1bmkwNEI3B3VuaTA0QjgHdW5pMDRCOQd1bmkwNEJBB3VuaTA0QkIHdW5pMDRCQwd1bmkwNEJEB3VuaTA0QkUHdW5pMDRCRgt1bmkwNEMwLmFsdAd1bmkwNEMxB3VuaTA0QzIHdW5pMDRDMwd1bmkwNEM0B3VuaTA0QzUHdW5pMDRDNgd1bmkwNEM3B3VuaTA0QzgHdW5pMDRDOQd1bmkwNENBB3VuaTA0Q0IHdW5pMDRDQwd1bmkwNENEB3VuaTA0Q0ULdW5pMDRDRi5hbHQHdW5pMDREMAd1bmkwNEQxB3VuaTA0RDIHdW5pMDREMwd1bmkwNEQ0B3VuaTA0RDUHdW5pMDRENgd1bmkwNEQ3B3VuaTA0RDgHdW5pMDREOQd1bmkwNERBB3VuaTA0REIHdW5pMDREQwd1bmkwNEREB3VuaTA0REUHdW5pMDRERgd1bmkwNEUwB3VuaTA0RTEHdW5pMDRFMgd1bmkwNEUzB3VuaTA0RTQHdW5pMDRFNQd1bmkwNEU2B3VuaTA0RTcHdW5pMDRFOAd1bmkwNEU5B3VuaTA0RUEHdW5pMDRFQgd1bmkwNEVDB3VuaTA0RUQHdW5pMDRFRQd1bmkwNEVGB3VuaTA0RjAHdW5pMDRGMQd1bmkwNEYyB3VuaTA0RjMHdW5pMDRGNAd1bmkwNEY1B3VuaTA0RjYHdW5pMDRGNwd1bmkwNEY4B3VuaTA0RjkHdW5pMDRGQQd1bmkwNEZCB3VuaTA0RkMHdW5pMDRGRAd1bmkwNEZFB3VuaTA0RkYHdW5pMDUwMAd1bmkwNTAxB3VuaTA1MDIHdW5pMDUwMwd1bmkwNTA0B3VuaTA1MDUHdW5pMDUwNgd1bmkwNTA3B3VuaTA1MDgHdW5pMDUwOQd1bmkwNTBBB3VuaTA1MEIHdW5pMDUwQwd1bmkwNTBEB3VuaTA1MEUHdW5pMDUwRgd1bmkwNTEwB3VuaTA1MTEHdW5pMDUxMgd1bmkwNTEzB3VuaTFFQTAHdW5pMUVBMQd1bmkxRUEyB3VuaTFFQTMHdW5pMUVBNAd1bmkxRUE1B3VuaTFFQTYHdW5pMUVBNwd1bmkxRUE4B3VuaTFFQTkHdW5pMUVBQQd1bmkxRUFCB3VuaTFFQUMHdW5pMUVBRAd1bmkxRUFFB3VuaTFFQUYHdW5pMUVCMAd1bmkxRUIxB3VuaTFFQjIHdW5pMUVCMwd1bmkxRUI0B3VuaTFFQjUHdW5pMUVCNgd1bmkxRUI3B3VuaTFFQjgHdW5pMUVCOQd1bmkxRUJBB3VuaTFFQkIHdW5pMUVCQwd1bmkxRUJEB3VuaTFFQkUHdW5pMUVCRgd1bmkxRUMwB3VuaTFFQzEHdW5pMUVDMgd1bmkxRUMzB3VuaTFFQzQHdW5pMUVDNQd1bmkxRUM2B3VuaTFFQzcLdW5pMUVDOC5hbHQHdW5pMUVDOQt1bmkxRUNBLmFsdAd1bmkxRUNCB3VuaTFFQ0MHdW5pMUVDRAd1bmkxRUNFB3VuaTFFQ0YHdW5pMUVEMAd1bmkxRUQxB3VuaTFFRDIHdW5pMUVEMwd1bmkxRUQ0B3VuaTFFRDUHdW5pMUVENgd1bmkxRUQ3B3VuaTFFRDgHdW5pMUVEOQd1bmkxRURBB3VuaTFFREIHdW5pMUVEQwd1bmkxRUREB3VuaTFFREUHdW5pMUVERgd1bmkxRUUwB3VuaTFFRTEHdW5pMUVFMgd1bmkxRUUzB3VuaTFFRTQHdW5pMUVFNQd1bmkxRUU2B3VuaTFFRTcHdW5pMUVFOAd1bmkxRUU5B3VuaTFFRUEHdW5pMUVFQgd1bmkxRUVDB3VuaTFFRUQHdW5pMUVFRQd1bmkxRUVGB3VuaTFFRjAHdW5pMUVGMQd1bmkxRUY0B3VuaTFFRjUHdW5pMUVGNgd1bmkxRUY3B3VuaTFFRjgHdW5pMUVGOQd1bmkyMEFCB3VuaTAzMEYTY2lyY3VtZmxleGFjdXRlY29tYhNjaXJjdW1mbGV4Z3JhdmVjb21iEmNpcmN1bWZsZXhob29rY29tYhNjaXJjdW1mbGV4dGlsZGVjb21iDmJyZXZlYWN1dGVjb21iDmJyZXZlZ3JhdmVjb21iDWJyZXZlaG9va2NvbWIOYnJldmV0aWxkZWNvbWIQY3lyaWxsaWNob29rbGVmdAhvbmUucG51bQd6ZXJvLm9zBm9uZS5vcwZ0d28ub3MIdGhyZWUub3MHZm91ci5vcwdmaXZlLm9zBnNpeC5vcwhzZXZlbi5vcwhlaWdodC5vcwduaW5lLm9zAmZmB3VuaTIxMjAIVGNlZGlsbGEIdGNlZGlsbGEFZy5hbHQPZ2NpcmN1bWZsZXguYWx0CmdicmV2ZS5hbHQIZ2RvdC5hbHQQZ2NvbW1hYWNjZW50LmFsdAZJdGlsZGUHSW1hY3JvbgZJYnJldmUHSW9nb25lawJJSglJb3RhdG9ub3MESW90YQxJb3RhZGllcmVzaXMJYWZpaTEwMDU1CWFmaWkxMDA1Ngd1bmkwNEMwB3VuaTA0Q0YHdW5pMUVDOAd1bmkxRUNBAAABAAMACAAKAA0AB///AA8AAQAAAAwAAAAAAAAAAgAFAAACNQABAjcCNwABAjsCWwABAl0DdgABA4ADpwABAAAAAQAAAAoADAAOAAAAAAAAAAEAAAAKAG4BWgABbGF0bgAIABAAAk1PTCAAKFJPTSAAQgAA//8ACQADAAgACwAAAA4AEQAUABcAGgAA//8ACgAEAAYACQAMAAEADwASABUAGAAbAAD//wAKAAUABwAKAA0AAgAQABMAFgAZABwAHWxpZ2EAsGxpZ2EAsGxpZ2EAsGxudW0AtmxudW0AtmxudW0AtmxvY2wAvGxvY2wAvG9udW0Awm9udW0Awm9udW0AwnBudW0AynBudW0AynBudW0AynNhbHQA0HNhbHQA0HNhbHQA0HNzMDEA0HNzMDEA0HNzMDEA0HNzMDIA2HNzMDIA2HNzMDIA2HNzMDMA3nNzMDMA3nNzMDMA3nRudW0A5HRudW0A5HRudW0A5AAAAAEACQAAAAEABwAAAAEACAAAAAIAAgADAAAAAQAEAAAAAgAAAAEAAAABAAAAAAABAAEAAAACAAUABgAKABYAPAB8AJQAzADgAO4BAgEuAVAAAQAAAAEACAACABAABQOPA5ADkQOSA5MAAQAFAEoA3wDhAOMA5QABAAAAAQAIAAIALgAUACwAjgCPAJAAkQDqAOwA7gDwAPIA9AFaAWcBdwGhAaICyQLYA0UDRwACAAEDlAOnAAAAAQAAAAEACAABAAYDbgACAAEAEwAcAAAAAQAAAAEACAACABoACgOBA4MDhAOFA4YDhwOIA4kDigOCAAIAAwATABMAAAAVABwAAQOAA4AACQABAAAAAQAIAAEABgNsAAEAAQAUAAEAAAABAAgAAQA8/JIAAQAAAAEACAABAAb8lAABAAEDgAABAAAAAQAIAAIAGgAKABMDgAAVABYAFwAYABkAGgAbABwAAgABA4EDigAAAAEAAAABAAgAAgAOAAQDjQOOASABIQABAAQBJAElAUkBSgAEAAAAAQAIAAEANgABAAgABQAMABQAHAAiACgCXgADAEkATwJdAAMASQBMA4sAAgBJAjUAAgBPAjQAAgBMAAEAAQBJAAA=";

var openSansLight = "data:font/ttf;base64,AAEAAAARAQAABAAQR0RFRgt6DNIAAYfkAAAALkdQT1MAGQAMAAGIFAAAABBHU1VC450pmgABiCQAAALuT1MvMqDNm5EAAVm4AAAAYGNtYXCuofXtAAFaGAAAA4hjdnQgEusTqQABZpAAAACqZnBnbX5hthEAAV2gAAAHtGdhc3AAHgAjAAGH1AAAABBnbHlmP0JlEwAAARwAAUI2aGVhZAJ/RsQAAUrIAAAANmhoZWENhAkiAAFZlAAAACRobXR4O1lLvgABSwAAAA6SbG9jYZrMShoAAUN0AAAHUm1heHAFaAH4AAFDVAAAACBuYW1lImM/SgABZzwAAAG8cG9zdOiucnUAAWj4AAAe23ByZXDejqJdAAFlVAAAAToAAgDBAAAECgW2AAMABwAeQAwFAgQDAgMJCAQDBwEALzMvMxESATk5ETMRMzEwEyERITchESHBA0n8t2gCef2HBbb6SmgE5gAAAgCk/+wBRgW2AAMACwApQBMIAwQDAgINDAEBCgIDCgZRWQoTAD8rABg/EjkvERIBOREzMxEzMTABIwMzAzQzMhUUIyIBFD0dd41QUlJQAXkEPfqYYmJiAAIAhQOmAk4FtgADAAcAH0ANBwQAAwQDCQgGAgcDAwA/M80yERIBOTkRMxEzMTABAyMDIQMjAwEEIT0hAckhPSEFtv3wAhD98AIQAAACADcAAAT0BbYAGwAfAKNAXwgfHBUEFAkRDAwJEg8OCwQKExMUFh0eBwQGFwQBABkEGAUFBhQGCiEDGhcDGAoYICEIBAwNDFJZHAENHwAQERBSWRkVET8NTw1/Dc8NBD8RTxGPEQMNEQ0RBRcTAwoFAC8zPzMSOTkvL11dETMzKxEAMzMRMzMrEQAzMxESATk5ERczERI5OREzERIXORESFzkRMxESFzkyMhEzERIXOTEwAQMhFSEDIxMhAyMTITUhEyE1IRMzAyETMwMhFQEhEyEDx0wBL/7AVlpY/phWWFb+5QErTP7XATdWW1kBbVhWWAEd/MQBa07+lQOg/nJP/j0Bw/49AcNPAY5QAcb+OgHG/jpQ/nIBjgADAKT/iQPfBhIAIAAnAC4Ae0AnDRUYHiUrBgQEBSEAKBIABQoSGgUwLyQOHisrDk5ZJQ0DBgYNTVkGuP/AsxYZSAa4/8BAFw0QSCwdFR1NWRgVDQYrFRUrBg0EFwUXAC8vEhc5Ly8vLxEzKxEAMysrKxEAMxEzKxEAMxEzERIBFzkRMxEzETMSFzkxMAEUBgcVIzUmJic1FhYzES4CNTQ2NzUzFRYXByYnERYWBzQmJxE2NgEUFhcRBgYD38avUVzZQEvRWZGMQL2gUcWaIY2x1aBufol6jf24cn53eQG4hagW7OgCKR5nJDIB/CxYeFZ8qRTAvgk/Wj4K/hpCnHpVbyj+KQ18Ar9WbiYBxRB4AAUAcf/pBgQFywAKABYAIAAsADAAS0AnMC0uLxwhFycFCwARCxEhJy0vBjIxHioqMAMODi8wBi8YCBQHGiQZAD8zPzM/PxI5LzMROS8zERIBFzkRMxEzETMRMxEzETMxMBMUFjMyETQmIyIGBRQGIyImNTQ2MzIWARQWMzIRECMiBgUUBiMiJjU0NjMyFgEBIwHTWmDBY15gWgHdlo2Fl5CMi5gBd1pgwcFgWgHdlI2IlpOLiZj+/PzVYAMrBAK6uwF1uLm5uOLr8dzf6vH83Lm5AXIBcbe64uvz2uHo8AMn+koFtgAAAwB7/+wFhwXNACAAKwA3AFFALRkYFBUyDSwHKQAABw0VGAU5OBcaESQEFCUvAxAEFAoZEgo1TFkKBB4hTFkeEwA/KwAYPysAGD8SORc5Ehc5ERIBFzkRMxEzETMRMxEzMTATNDY3JyYmNTQ2MzIWFRQGBwE2NjczBgcBIycOAiMiJgUyNjcBDgIVFBYDFBYXNjY1NCYjIgZ7k8lLQkC/oZu1jLcBxD1WIGA/kgEKh8FckKtt0e8Bx4DVZ/4diHk3uihQcJ98fGpygwFzisJsUkeISo+ooo9pr2v+N0iqdPa0/vTFWlMsznRXZwHlSGV2T4+iBFJPhmtVlF9edXQAAAEAhQOmAQQFtgADABS3AAMDBQQCAwMAP80REgE5ETMxMAEDIwMBBCE9IQW2/fACEAAAAQBS/rwB8AW2AAwAH0AOBwAKAwQDCQkADg0KAwMAPy8REgE5OREXMxEzMTATEBI3MwYCERABIyYCUpuScZSeATBvk5oCMQEJAc6utv4z/wD+Hf5sqgHGAAEAPf68AdsFtgAMAB9ADgMJCgMEBgAEAA4NBAkDAD8vERIBOTkRMxEXMzEwARACByMAERACJzMWEgHbm5JvATCelHGTmgIx/vn+OqgBlAHjAQEBzbWv/jEAAAEAaAKiA/wGFAAOABtADwMFBAEHDQoJCwkPEAgOAAA/xBESARc5MTABAyUXBRMHAwMnEyU3BQMCdyUBlRX+dfd8v7R98v56EwGRJwYU/mtogyf+rEcBe/6FRwFUJ4NoAZUAAQBvAPoEIwSuAAsAOEAjCQAEBAUFDQwDBwgHUlkADwgvCD8IXwh/CI8Irwi/CN8ICQgAL10zKxEAMxESATkRMxI5OTEwASEVIREjESE1IREzAnEBsv5OUv5QAbBSAvxS/lABsFIBsgABAET++AEzAO4ABgARtQQBCAcEAAAvLxESATk5MTAlFwIHIxI3AScMS2NBTSHuFf732AET4wABAFwCAAI3AlIAAwAVQAkDAAUEAQBTWQEALysREgE5OTEwEzUhFVwB2wIAUlIAAQCi/+wBRACwAAcAGEALBAAACQgGAlFZBhMAPysREgE5ETMxMDc0MzIVFCMiolBSUlBOYmJiAAABABkAAAKiBbYAAwAcQAwDAAECAgAFBAMDAhIAPz8REgE5OREzETMxMAEBIwECov3faAIgBbb6SgW2AAACAHP/7AQfBc0ACwAXAChAFBIADAYGABkYCRVNWQkHAw9NWQMZAD8rABg/KxESATk5ETMRMzEwARACIyICERASMzISARASMzISERACIyICBB/r7uXu5+zn8vzAsrW9ra29vaoC3/5//o4BfQF2AX4BcP6D/o/+rP67AVABSQFEAVD+sAABAMcAAAKqBbYACgAgQA4JCAABAQwLBwkBGAQJBgA/Mz8SORESATkRMzMzMTAhIxE0NwYGBScBMwKqYgwPIP7bOQGNVgQpkZwPHOVHASkAAAEAcQAABAQFywAYADJAGgcSFwICDRIYBBoZAhcBDwpNWQ8HARdOWQEYAD8rABg/KxESADkREgEXOREzETMxMCEhNQE+AjU0JiMiByc2MzIWFRQCBwEVIQQE/G0BhaSEPqyJt6c2t9+/25PD/okDDlgBlqq0pFqDpIVFmsyzkf7xx/5/BAAAAQBe/+wEAAXLACgAUUArBBccABMHIwwABwwXBCopAxcYGBdOWQ8YAQsDGBgKJiYfTVkmBwoQTVkKGQA/KwAYPysREgA5GC9fXl0rERIAORESARc5ETMRMxEzEjkxMAEUBgcVFhYVFAQhIic1FhYzMjY1NCYjIzUzMjY1NCYjIgYHJzY2MzIWA9OrkLC4/un++t+mVNFc3d7j3J6gttWtjG20cDFV8HvK3AReiLoaBha0mM3hU2MsMrOjkZxgrZR6kz1KQ0dTvwACACsAAAR1Bb4ACgASAEBAIQsJBwQBEgYGAQADFBMGAQkDEgUFEk1ZBQUHAxgODw8HBgA/MxEzPxI5LysREgAXORESARc5ETMRMzMzMzEwASMRIxEhNQEzETMhERA3IwYHAQR1/F79EALVefz+pg4IFGf9/AF1/osBdUMEBvwNAaIBLs0ll/0fAAABAI//7AQQBbYAHAA6QB8QAxsWAwkWGQQeHQATTVkAAAYXFxpOWRcGBg1NWQYZAD8rABg/KxESADkYLysREgEXOREzETMxMAEyBBUUBCMiJic1FhYzMjY1NCYjIgcnEyEVIQM2AhnqAQ3+6PZtxEJsqF/A6OLCgo48OgLA/Z4tnANv4sbh+isoZzcry62juicnAp1g/fwdAAIAg//sBCMFzQAYACYATkAqHBMjDAwAAAcTAygnDRAWEB9PWQ8QfxACCgMQEBYEBAlPWQQHFhlNWRYZAD8rABg/KxESADkYL19eXSsREgA5ERIBFzkRMxEzETMxMBMQEiQzMhcVJiMiAAMzNjYzMhYVFAIjIgAFMjY1NCYjIgYGFRQWFoObAR3JXk5JZ/f+7RENTMRtzefzzt7+/wHfpLa0m2avaGOpAm8BHQGFvBdYG/6c/qxiZOrO4P79AVP7zr+ovFqVTm/NeAABAG0AAAQfBbYABgArQBUGAAEFAAIFAwgHABgFAgMDAk5ZAwYAPysREgA5GD8REgEXOREzETMxMCEBITUhFQEBTgJa/MUDsv2kBVZgSfqTAAMAef/sBBQFzwAYACQAMQBXQC8fCS8DKBUZDwMJDxUiLAYzMgYSEiIsLCJPWQ8sAQsDLCwMAAAlTVkABwwcTVkMGQA/KwAYPysREgA5GC9fXl0rERIAOREzERIBFzkRMxEzETMRMzEwATIWFRQGBxYWFRQGIyImNTQ2NyYmNTQ2NgMUFjMyNjU0JicGBgEiBhUUFhYXNjY1NCYCRrrjjZ7AnP3V3eymrqGEar/yu6ikyJ3guJoBZY2rP3eMo46pBc++onCsSU+8hrXYysGDxkZMqXZpn1b7mYqYoYp8m1VHrAOLi3lGa1c6P5hreIwAAAIAb//sBAwFzQAaACgATkAqJQ0NAB4UAAcUAyopDhcRESFPWQARcBECCgMREQQXFxtNWRcHBApPWQQZAD8rABg/KxESADkYL19eXSsREgA5ERIBFzkRMxEzETMxMAEQAgQjIic1FhYzMgATIwYGIyImNTQSMzIWEgEiBhUUFjMyNjY1NCYmBAyX/t/NaFgreSD3ARgQDEnKbsvj+ceQ2HX+I568rqJlr2ddpwNK/uD+fLoaVg4PAWUBVmBn4M7cARCX/twBY9W5rrRalU11zHMAAAIAov/sAUQELQAHABEAOUAiDAgEBAAAExIKD1FZDwovCk8Kbwp/Co8KBg4DCgYCUVkGEwA/KwAYL19eXSsREgE5ETMSOTkxMDc0MzIVFCMiETQzMhUUBiMiJqJQUlJQUFIvIyIuTmJiYgPfYmI1Li4AAAIATP74AUQELQAHABEAL0AcDAgBBAgDExIHBAoPUVlfCn8Knwq/Cs8K3woGCgAvXSsAGC8vERIBFzkRMzEwJRcCByM2EjcDNDMyFRQGIyImAS8MS2NBHUIPGFBSLyMiLu4V/vfYYQEpbALdYmI1Li4AAAEAbwEKBCMEwQAGACBAEQUBAAEEAwgHAA8DPwNfAwMDAC9dxhESARc5ETMxMAEBNQEVAQEEI/xMA7T8yQM3AQoBoD0B2l/+a/6dAAACAG8B3QQjA8cAAwAHAD9AKQQHAAMECQgEBVJZ7wQBAAQQBAIJAwQBAQBSWQ8BLwFvAa8BvwHfAQYBAC9dKwAYEMZfXl1dKxESARc5MTATNSEVATUhFW8DtPxMA7QDdVJS/mhSUgABAG8BCgQjBMEABgAgQBEBBQIFBgMIBwYPAz8DXwMDAwAvXcYREgEXOREzMTATAQE1ARUBbwM3/MkDtPxMAWoBYwGVX/4mPf5gAAIAOf/sAxQFywAfACcAQUAhCBUkIB8AAA8VIAQpKAQaGhIAACYSEgtQWRIEJiJRWSYTAD8rABg/KxESADkYLxI5ETMREgEXOREzETMRMzEwATU0Njc3NjY1NCYjIgYHJzY2MzIWFRQOAgcOAhUVAzQzMhUUIyIBJUtlW0g+p4hPilAlbpVPt9IkQVw4QEUfc1BSUlABeSV7nFlPPXhOf5YjJ1AwIMWsRGZXUS82WWJhDv7VYmJiAAACAHH/OwamBawANQBAAFRALRoAPBI7BhQ2DSIuAA0SFCguBkJBBwo+EBArFzk5AzAKQAqACgMKCjIlKx4yAwA/My8zEjkvXTMzETMROS8zEjkREgEXOREzETMRMzMRMxEzMTABFAIjIiYnIwYGIyImNTQSMzIXAxUUFjMyNjU0AiQjIgQCFRAAITI2NxUGIyAAERASJDMyBBIBFBYzMhMTJiMiBgamtZtZbwkEK6JslKLxwoqUFkZRZ4Oe/tu85v6hvQFOATNdv4jL0/6j/nrZAY361wFLs/vTbnf/EhBPcpWwAtXk/uxsXWRlwa7KAQEp/jAeaGnpu8IBJJ3H/pTs/r7+oSQ0Y1ABkQFlAQABmeKy/rX+n4+QAVoBIxvNAAACAAAAAATNBbwABwAOADxAIAQFDAcGAgMDDAEICQAGBxAPDAMECAFMWQgIAwQDBwMSAD8zPxI5LysREgA5ERIBFzkRMxEzETMzMTABIQMjATMBIwEhAyYnBgcDj/2uzHECTEECQHP9CAILxxkjGyACBP38Bbz6RAJgAg8+bmBOAAMAzwAABJEFtgAPABgAHwBRQCsdCxAaGg8UBAsEDwcEICEIGRAQGUxZDxABCwMQEA8ADxpMWQ8SABhMWQADAD8rABg/KxESADkYL19eXSsREgA5ERIBFzkRMxEzETMRMzEwEyEgFhUUBgcVFhYVFAQjIRMhMjY1NCYjIRERISARECHPAZEBD/6bla+l/vT2/kBmAULOu9PR/tkBWAGW/lQFtri6f6kYBhqpl8raAyuJkpKE/XX9iQFKAS0AAQCB/+wEuAXLABYAJkAUAw4UCA4DFxgSAExZEgQLBkpZCxMAPysAGD8rERIBFzkRMzEwASAAERAAITI3FQYjIAARNBIkMzIXByYDP/7t/sQBKgEVuJqR2f7M/p6pAT3S1qkpoAVv/qD+zv7H/qYvWjMBjgFl3wFUuVBcUAAAAgDPAAAFJQW2AAgAEAAoQBQOBAkABAAREgUNTFkFAwQOTFkEEgA/KwAYPysREgE5OREzETMxMAEQACEhESEgAAMQACEhETMgBSX+fv6K/qIBiwFeAW1v/sH+y/7z8gKPAun+kP6HBbb+kv6dAToBPfr+AAABAM8AAAPuBbYACwBFQCUGCgoBBAAACAEDDQwGCUpZDwYBCwMGBgECAgVKWQIDAQpKWQESAD8rABg/KxESADkYL19eXSsREgEXOREzETMRMzEwISERIRUhESEVIREhA+784QMf/UcCkv1uArkFtl791179jQAAAQDPAAAD8AW2AAkAPEAhBgAAAQQHAQMKCwYJSlkPBj8GAgsDBgYBAgIFSlkCAwESAD8/KxESADkYL19eXSsREgEXOREzETMxMCEjESEVIREhFSEBNWYDIf1FApT9bAW2Xv2UXwAAAQCB/+wFKQXNABoAOkAfEwcYAgINGgcEGxwAGktZAAAECwsQTFkLBAQWTFkEEwA/KwAYPysREgA5GC8rERIBFzkRMxEzMTABIREGISAAETQSJDMyFwcmIyAAERAAITI3ESEDDgIb1P73/qb+j7cBVd3vvim+zP7f/q0BQgE4yo3+TQLh/WVaAYcBZt8BWbxYXFj+m/7R/rb+szkCAgABAM8AAATyBbYACwA3QBwIBAQFCQEBAAUADA0IA0pZLwgBCAgFCgYDAQUSAD8zPzMSOS9dKxESATk5ETMRMxEzETMxMCEjESERIxEzESERMwTyZ/yqZmYDVmcCz/0xBbb9dwKJAAABAFoAAAIUBbYACwA3QBwFAgoDCAsLAwIDDA0JBAYETFkGAwoDAQNMWQESAD8rEQAzGD8rEQAzERIBFzkRMxEzETMxMCEhNTcRJzUhFQcRFwIU/kaqqgG6qqpCFAUKFUFBFfr2FAAB/0j+jwE1BbYACwAfQA4DCgcHDA0IAwAFSlkAIgA/KwAYPxESATkRMzMxMAMiJzUWMzIRETMRECFcO05H8mb+jxtYFAEIBcD6Sv6PAAABAM8AAASmBbYADAA1QBwBAAoLCAQEBQUACwIMBQ4NDAgCAwQFCgYDAQUSAD8zPzMSFzkREgEXOREzETMRMxEzMTAhIwEHESMRMxE3ATMBBKZ9/c/DZmaiAj2C/akDBKz9qAW2/QiiAlb9lgABAM8AAAPuBbYABQAfQA4DAAAEBgcBAwADS1kAEgA/KwAYPxESATk5ETMxMDMRMxEhFc9mArkFtvqqYAABAM8AAAYZBbYAEwA+QB4TAAkIBQUGCw4ODQ0JBgMUFRIRAgoCBgsHAw4ABhIAPzMzPzMSOTkRMzMREgEXOREzETMRMxEzETMzMTAhASMWFREjETMBMwEzESMRNDcjAQNS/d8ICGKeAgYGAgaaZwwI/d0FRnyC+7gFtvr6BQb6SgRUdHz6vAAAAQDPAAAE9gW2AA8ALkAVAQ0NAAkGBgcHABEQAwsHDggDAQcSAD8zPzMSOTkREgE5OREzETMRMxEzMTAhIwEjFhURIxEzATMmNREzBPZn/J4IDGJmA2EGCWMFEuh2/EwFtvrwtKIDugACAIH/7AWcBc0ACwAXAChAFAwGEgAGABgZCRVLWQkEAw9LWQMTAD8rABg/KxESATk5ETMRMzEwARAAISAAERAAISAAARAAISAAERAAISAABZz+pP7O/s/+pAFfATABMgFa+1QBGAEGAQgBF/7p/vr++/7lAt3+pP5rAZUBXgFdAZH+bf6j/sb+qQFUAT0BPAFR/qwAAgDPAAAEPwW2AAkAEgA0QBoOAAoFBQYGABQTCgRMWQoKBgcHEkxZBwMGEgA/PysREgA5GC8rERIBOTkRMxEzETMxMAEUBCEjESMRISABMzI2NTQmIyMEP/7g/vjiZgFmAgr89sn33NDa8gQS1OL9pAW2/P6jt6mjAAACAIH+pAWcBc0AEAAcADlAHgUEAwYXABELAAQGCwQeHQ4aS1kOBAMFCAgUSlkIEwA/KwAYEMYzPysREgEXOREzETMRMxEzMTABEAIHASMBByMgABEQACEgAAEQACEgABEQACEgAAWc/N8BTab+5iEf/s/+pAFfATABMgFa+1QBGAEGAQgBF/7p/vr++/7lAt3+2v5/Nv6kAUoCAZUBXgFdAZH+bf6j/sb+qQFUAT0BPAFR/qwAAAIAzwAABJMFtgANABYAUkAuCg0MCxIHDgEBAgIHCw0EGBcKAA4ATFkPDh8OPw5PDgQJAw4OAwwCEgMWTFkDAwA/KwAYPzMSOS9fXl0rEQAzERIBFzkRMxEzETMRMxEzMTABESMRISAEFRQGBwEjASUhMjY1NCYjIwE1ZgFcARABBJueAY16/of+lQEXuczI4vICff2DBbbJypPKLP1mAn1YpaGnmAABAG//7AP2BcsAJAA0QBsdEgsAABcSBQQlJgsdAxUVGkxZFQQDCEpZAxMAPysAGD8rERIAOTkREgEXOREzETMxMAEUBCMgJzUWMzI2NTQmJicmJjU0JDMyFwcmIyIGFRQWFhceAgP2/vPf/vSPnvW000aemeCrAQHKzrUltqaiwDuGo6usTwF5t9Y7ZkOlhlNtWjRNs5Wkz05YTJaBUWhTOjtvjQAAAQAKAAAEJwW2AAcAJUASAAEBAwYDCQgBEgcDBANLWQQDAD8rEQAzGD8REgEXOREzMTAhIxEhNSEVIQJMZ/4lBB3+JQVWYGAAAQC+/+wFAgW2ABEAJUAREAEKBwcBExIRCAMEDUxZBBMAPysAGD8zERIBOTkRMxEzMTABERQAISIANREzERQWMzI2NREFAv7c/vv+/uNn6tbR5gW2/E78/uQBHf8DrvxO0+vnzQO8AAABAAAAAASeBbYACgAqQBQDAggAAQUEAQQIAwwLCAMABAMDEgA/PzMSORESARc5ETMRMxEzMzEwATMBIwEzARYXNjcEL2/93Vr9320BcFQdFDsFtvpKBbb8HeFxS54AAQAzAAAG8AW2ABsAREAiAQAXCAcQFBMEGhsKCQQJEBcbBR0cBAkXEBAIGhMJAwEIEgA/Mz8zMxI5ETMRORESARc5ETMRMxEzMxEzMxEzMzEwISMBJicGBgEjATMBHgMXNhMTMwEWFzY2ATMFXFT+vygUEDv+21b+bmsBAA8aFREHGE76cQElMxYNKQEgZwRoi1lX4vvtBbb8UjlhVU8oiAEVA3f8BrBsSKIELAAAAQAAAAAETgW2AAsANUAcAQAJCgcGAwQAAgQFBggKCwgNDAIIBAkGAwEEEgA/Mz8zEjk5ERIBFzkRMxEzETMRMzEwISMBASMBATMBATMBBE51/lD+SHEB7P5BcwGLAZFt/jsCqv1WAvoCvP2OAnL9RgAAAQAAAAAEOQW2AAgALEAVAAMDBgECCAcCBgcDCgkABQEHAwUSAD8/MxI5ERIBFzkRMxEzETMSOTEwAQEzAREjEQEzAh8BrG7+GWn+F3UClgMg/H/9ywItA4kAAQBSAAAESgW2AAkAOEAdAwcIAgIEBwkECwoHBAUFBEtZBQMCCAEBCEtZARIAPysREgA5GD8rERIAORESARc5ETMRMzEwISE1ASE1IRUBIQRK/AgDWPzPA7r8pgNxTAUKYEz69gAAAQCu/rwCWgW2AAcAH0ANBAcGAQcBCQgGAQUCAwA/My8zERIBOTkRMxEzMTABIREhFSERIQJa/lQBrP62AUr+vAb6XvnDAAEAGQAAAqIFtgADABxADAIBAAMDAQUEAwMCEgA/PxESATk5ETMRMzEwEwEjAX8CI2f93gW2+koFtgABADP+vAHfBbYABwAfQA0BBgMABgAJCAAHAwQDAD8zLzMREgE5OREzETMxMBchESE1IREhMwFK/rYBrP5U5QY9XvkGAAEAWAIxBDkFwQAGACdAEgIBBQQDBgAAAwUDCAcFAAQCAwA/zTI5ERIBFzkRMxEzETMzMTATATMBIwEBWAHRRAHMZP51/nICMQOQ/HADF/zpAAAB//z+9gNO/0gAAwAVQAkDBQIEAgFTWQIALysRATMRMzEwASE1IQNO/K4DUv72UgABAYkE2QMIBiEACQAYQAkGBAQACwoGgAEALxrNERIBOTkRMzEwASMmJic1MxYWFwMIRWC5IY4akUYE2U+5LxEwvEwAAAIAYv/sA5MEUgAZACQAUUAsAQwdHRkiCAgZEwMmJQIAFQweSVkPDB8MAgsDDAwVABUVEEhZFRAFGkZZBRYAPysAGD8rABg/EjkvX15dKxESADkREgEXOREzETMRMzMxMCEnIwYGIyImNTQkNzc1NCYjIgcnNjMyFhURJTI2NTUHBgYVFBYDShkIUq12oLIBCfvPfoyXoiWzr7Ox/ieuyb7lw32saVekkZ+wBQZIm55UVlS6xf0tRsexawgLeYBmcQAAAgC2/+wETAYUABUAIQA+QB8gAwoZDw8MDAMjIgoSBgANAAwVABZGWQAQBh1IWQYWAD8rABg/KwAYPz8REjk5ERIBOTkRMxEzMxEzMTABMhIREAIjIiYnIwcjETMRFAcHMzY2FyIGFRUUFjMyNjUQAoHk5/PcdLo2CRw+YwQDBz6vecCmrbeytARU/uH+7P7x/tpgWKQGFP55WEpVYlxa3P0R9tb55gHXAAABAHf/7AOFBFQAFQAmQBQOAwMIEwMXFgYLRlkGEAARRlkAFgA/KwAYPysREgEXOREzMTAFIgAREAAzMhcHJiMiBhUUFjMyNxUGAmjp/vgBEu6NgRuNaMjOzrmUf2gUASYBBwEOAS0xWC/36Nz5NVwzAAACAHf/7AQMBhQAEwAfAD5AHwsdBgYJFxERCSEgBAwOAAcAChUAFEZZABAOGUhZDhYAPysAGD8rABg/PxESOTkREgE5OREzETMRMzMxMAEyFhczJjURMxEjJyMGIyICERASFyIGFRAhMjY1NTQmAkR2rEQGBmJBGQh86OHu7OGyswFnuKypBFRWaH55AYf57Ka6ARgBDAEaASpa+u7+Mtb2EfzdAAIAd//sA+4EVAAUABsAR0AnGQkYCwsDAwkRAx0cGAtIWQ8YHxgCCwMYGAAGBhVIWQYQAA5GWQAWAD8rABg/KxESADkYL19eXSsREgEXOREzETMRMzEwBSIAERAAMzISFRUhFhYzMjY3FQYGAyIGByE0JgJt7f73AQDZwN788QLNv12NbFyce52+EAKgpBQBJAEHAQQBOf705lDg7BorWigdBBDPw73VAAEAHQAAAtUGHwAVAD1AHw0UFAcCAgMAAwUDFxYDFQsQSFkLAAUBBxQUAUhZFA8APysRADMRMxg/KwAYPxESARc5ETMSOTkRMzEwASERIxEjNTc1NDYzMhcHJiMiBhUVIQJK/wBjysqTp1paF1BPdGEBAAPp/BcD6TolVMi7G1YZiZplAAMALf4UBAYEVAApADMAPwCAQEcMHzoENCQuEyoZAQQTGR8kBkFABCcHHDIPIQkHBzdJWQAHYAeQBwMNAwcHFikPMkdZDw8WKSc9SVknECkCSVkpDxYsSVkWGwA/KwAYPysAGD8rERIAORgvKxESADkYL19eXSsRADMzERI5ERI5ERIBFzkRMxEzETMRMxEzMTABFQcWFRQGIyInBgYVFBYzMzIWFRQEISImNTQ2NyYmNTQ3JiY1NDYzMhcBFCEgETQmIyMgExQWMzI2NTQmIyIGBAbhWtGwSh47Pk9dvrG8/un+/s3hi3cxO4tfas+wazv97AFNAayGlrL+1VOZgIiRlYaClQQ/RQ5whp3DBh9ULzQwj4ysu56NcJQbFU0ybVMnp2yjxRX7CeABEWJYArl+i4qDi4uVAAEAtgAABA4GFAAUADNAGQAUDQwICAkUCRYVDQkREQRGWREQCgAACRUAPzM/PysREgA5ERIBOTkRMxEzMxEzMTAhETQmIyIGFREjETMRBzM2NjMgEREDrIqRw7VjYwUHPbqKAXICwaSVxd39qAYU/hGLYlj+c/05AAIAqAAAASkFzQADAA0AJUASCQAEAAEBDw5gDAEMBgQCDwEVAD8/P81dERIBOREzMxEzMTAhIxEzAzQzMhYVFAYjIgEZY2NxPx8jIx8/BD8BLmAyLi00AAAC/57+FAEpBc0ADAAWADRAGhIKDQMKBwcYFwAVAQ8DFUAPBAgPAAVGWQAbAD8rABg/PxrNX15dERIBOREzMzMRMzEwEyInNRYzMjURMxEUBhM0MzIWFRQGIyIlUDdFPJdjfw4/HyMjHz/+FBlWFLAFIPruh5IHWWAyLi00AAABALYAAAPfBhQADQA4QB4FBAECDAgICQIDBAYJBQ8OAwYNBwQJAQoAAQ8FCRUAPzM/PxESFzkREgEXOREzETMRMxEzMTABATMBASMBBxEjETMRAwEXAit4/lQB0Xf+Y7JjYwcB3QJi/jD9kQIlov59BhT89P7VAAABALYAAAEZBhQAAwAWQAkAAQEFBAIAARUAPz8REgE5ETMxMCEjETMBGWNjBhQAAQC2AAAGZgRUACIASEAkGggJACIICRQQEBEJESIDJCMbFBEYEg8ACREVBAwYDEZZHhgQAD8zKxEAMxg/MzM/ERI5ORESARc5ETMRMxEzETMREjkxMCERNCYjIgYVESMRECMiBhURIxEzFzM2NjMgFzM2NjMyFhURBgR8gKegZfyrnGNSFQYtpmQBAUkENbNysrICyZ+SuMX9gwLnARPH2/2oBD+VUVnBXWS+z/05AAABALYAAAQOBFQAEgAxQBgMCAgJABIJEhMUDAkPDwRGWQ8QCg8ACRUAPzM/PysREgA5ERIBOTkRMxEzETMxMCERNCYjIgYVESMRMxczNiEgEREDrIqRw7VjVBMGagEPAXICwaSVxd39qAQ/lar+c/05AAACAHf/7AQ5BFQADAAYAChAFA0HEwAHABkaChZGWQoQAxBGWQMWAD8rABg/KxESATk5ETMRMzEwARAAIyImAjUQADMyEgEUFjMyNjU0JiMiBgQ5/v7jj9p0AQLh4P/8psW0tMXHtLTDAiH+9v7VigECqQEKASn+0/764Pv74OH49wAAAgC2/hQETARUABMAHwBBQCEdCwYDBwcIFxEIESAhAwsADg4ZRlkOEAkPCBsAFEhZABYAPysAGD8/PysREgA5ORESATk5ETMRMxEzMzMzMTAFIicjFxYVESMRMxczNjMyEhEQAicyNjUQISIGFRUUFgKH+3MHAwRjVBMGcPbc5/PUp7f+pr6yqxS8VEpY/mIGK5uw/t/+7P70/tlY+N8B39HsIP/aAAIAd/4UBAwEVAASAB8APkAfFgkNDQwdAwwDISAJEQAGCg8NGwYaRlkGEAATSFkAFgA/KwAYPysAGD8/ERI5ORESATk5ETMRMxEzMzEwBSICERASMzIXMzczESMRNDcjBicyNhE1NCYjIgYVFBYCOdbs7NzsdQYSVGIGBnb5xqmqurC3sxQBHAEMARMBLa6Z+dUBnnp+vljaAQEM9dr48OXpAAEAtgAAAvYEVAAQACxAFQ0JCQoKAhIRDQoACw8KFQAFRlkAEAA/KwAYPz8REjkREgE5OREzETMxMAEyFwcmIyIGFREjETMXMzY2AmJFTxNESYuyY1QKB0OYBFQOXxHstP2oBD/EeGEAAQBU/+wDWARUACMANEAbCwAdEgAFEhcEJSQLHQMVFRpGWRUQAwhGWQMWAD8rABg/KxESADk5ERIBFzkRMxEzMTABFAYjIic1FjMyNjU0JicuAjU0NjMyFwcmIyIGFRQWFx4CA1jezNqApLahp4WYo4RDzbiwniWgiYWcebCThkMBG5KdQ2tSa1lScDY7VWtNeo5CWkJYTlVmPzVVbAABABn/7AJ5BUYAFQA7QB4PDBMTCAIIChEEFxYODgwPCRIPEkhZDw8FAEhZBRYAPysAGD8rEQAzETMzGC8REgEXOREzEjk5MTAlMjcVBiMiJjURIzU3NzMRIRUhERQWAdVeRkhekImhoTIzAT/+wVhEEFAYmqUCvjot9v75Vv1QfXgAAQCq/+wEAgQ/ABIAMEAXDAcHCgEREQoUEw0LCBIPCxUPBEZZDxYAPysAGD8/MxI5ERIBOTkRMxEzETMxMAERFBYzMjY1ETMRIycjBiEgEREBDIqRwrdiVBIGav7x/o0EP/1ApJXE3QJY+8GWqgGNAsYAAQAAAAADrAQ/AAsAKEATCwAFCQoCAQEFCgMNDAkBDwUAFQA/Mj8zERIBFzkRMxEzETMzMTAhATMBFhczNjcBMwEBpP5cZgEZOBwGKSsBGWb+XAQ//R2OaohyAuH7wQAAAQAfAAAFqgQ/ABsATEAnGRoKCRIRBBsAFQgHDgQJDhUaBR0cAwQECRYVDgMNDQgZEQkPAAgVAD8zPzMzEjkRFzMROREzERIBFzkRMzMRMzMRMzMRMxEzMTAhAyYnIwcHAyMBMxMWFzM2NxMzExYXMzYTEzMBBBvuFyQGFS3yYv7Jaq49EwY7G+Ba1UgQBghIpmT+2QLXSo9Kkf0rBD/9iupu6k0Cl/1r60xBARsCcPvBAAEANwAAA8UEPwALADNAGggHBAUCAQoLAAEFBgcLBg0MCQMLBAEPCAsVAD8zPzMSOTkREgEXOREzETMRMxEzMTABATMBATMBASMBASMBwf6FcgFEAUFt/osBkHP+qv6obQIvAhD+NgHK/fD90QHl/hsAAAEAAP4UA6wEPwAYADJAGQgJAQAYCgUABQkRBBoZBBgIAA8OE0ZZDhsAPysAGD8zLzMREgEXOREzMxEzETMxMBEzExIXMzYTEzMBDgIjIic1FjMyPgI3ZuZpHAYqX+Zm/hk7UGtMOUY6QzNOP1MMBD/9nv7nYoEBAAJc+xGabDYVVhAwZdshAAABAFIAAANaBD8ACQA4QB0DBwgCAgQHCQQLCgcEBQUESFkFDwIIAQEISFkBFQA/KxESADkYPysREgA5ERIBFzkRMxEzMTAhITUBITUhFQEhA1r8+AKF/aoC1/13Aos/A6hYP/xYAAABAD3+vAKLBbYAHQA3QBoaChIDFg4AAAcDBwoDHx4ZCgoLCxEDBBIRAwA/My8zEjkvMxI5ERIBFzkRMxI5OREzETMxMAUUFhcVIiY1ETQnNTY2NREQJRUGBhURFAYHFRYWFQGFd4/DpeZ6bAFoinxYYmFZG2ZlA1uWnAFRzQRQAmJjAV4BKwZaBWpo/s+CgBUIFH97AAABAfz+BgJYBhkAAwAWQAkCAwMFBAAAAxwAPz8REgE5ETMxMAEzESMB/FxcBhn37QABAEj+vAKWBbYAHgA3QBoDFAsbDwgeHhcUFxsDIB8EFBQTEwwbGgsMAwA/My8zEjkvMxI5ERIBFzkRMxI5OREzETMxMAE0Njc1JiY1ETQmJzUyFhURFBYXFQYVERQGIzU2NjUBTllhYVl7i666bXnmpcONeQEne38UCBSAgwExZ2sFWpuW/qJkYQJQBM3+r5uXWwJlZwABAG8CaAQjAz0AFQAsQBgOAxcWAxIOCxKAAG8GfwafBgMGQAkNSAYALytdMxrNMsQQxBESATk5MTABIgYHNTYzMhYXFjMyNjcVBgYjIicmAU4xdjhsfT1sZX5eOGs+MHFJdJp8Auk9O15uGyw6PUBgMUBIOQAAAgCm/okBSARUAAMADQApQBMIAgQCAwMPDgAABgMiBgtRWQYQAD8rABg/EjkvERIBOREzMxEzMTATMxMjAzQzMhUUBiMiJtc9HXcUUFIvIyIuAsf7wgVpYmI1Li4AAAEA0//sA80FywAdAF9AOwgHHBwdAwwXHQQfHgkPTVkGAAmwCcAJ0AkEEgMJCR0HABsbFU1ZEBsgGzAbA2AbcBuAGwMbGx0HBx0ZAD8/EjkvXXErEQAzERI5GC9fXl0zKxESARc5ETMSOTkxMCUmAjU0Ejc1MxUzMhcHJiMiBhUUFjMyNxUGIyMVIwJaus3NulIOg5Afhme7y8m0g4hunQxSvh4BIuvoASshrqY3VDP17OH5Olw4zAABAE4AAAQxBckAHgBPQCoECBwPAAAMBQgMDRUeBiAfAA0ODU9ZHA4OBxMTGE1ZEwcIBAcHBE5ZBxgAPysREgA5GD8rERIAORgvMysRADMREgEXOREzEjk5ETMxMAERFAYHIRUhNTY2NREjNTMRNDYzMhcHJiMiBhURIRUBnEZOAyn8HW5709PEt6+bI52KjYkBmwKk/wB0oDBgVBWyhwECUgEpzN5EVkKirP7TUgACAH8BCgQQBJ4AGwAnAFRAGx8AJQ4AAgUJDA4QExcaCikoGBJADBRIEhUECrj/wEAYDBRIChMQFxoMCQUCCBwHIm8VjxXfFQMVAC9dM9QyFznGKzIQxisyERIBFzkRMxEzMTABFAcXBycGIyInByc3JjU0Nyc3FzYzMhc3FwcWATI2NTQmIyIGFRQWA99aizuJbpaZa4o7i1paizuKZ52baYk7i1r+aYa9voWGvr0C05dpjTyOXV2OPI1qlpNvjTyOXV2OPI1v/iW/iYjCwoiIwAABACsAAARkBbYAFgBjQDoABxADCwsMAgUJDA4SFQcYFwYSExJPWQADDxMfEwIJAxMTDBUKDg8OT1kHfw+PD58PAw8PDAEVBgwYAD8/MxI5L10zKxEAMxESORgvX15dMzMrEQAzERIBFzkRMxIXOTEwAQEzASEVIRUhFSERIxEhNSE1ITUhATMCSgGsbv5QARv+rgFS/q5p/q8BUf6vARb+UnUCmgMc/OxSzVL+zwExUs1SAxQAAAIB/P4GAlgGGQADAAcAKEASAwIFBQQECQgDAwcEBAcAAAccAD8/ETkvETkvERIBOREzEjk5MTABMxEjETMRIwH8XFxcXAYZ/QT95f0EAAIAgf/8A4cGGQAwAD4AUEAtNRsqHjgZPAMSBjEAAAMGCxkbHiUIQD88AxUDNRstAyEJCQ9JWQkAISdJWSEVAD8rABg/KxESABc5FzkREgEXOREzETMRMxEzETMRMzEwEzQ2NyYmNTQ2MzIXByYmIyIGFRQWFhcWFhUUBxYWFRQGIyImJzUWMzI2NTQmJicmJjcUFhYXNjY1NCYmJwYGkWVYVk7Lrq+hI1uHTYaPM3iAwJC6VlbixlyeVraWoqoyf3/IkGU/lLBSWECZoFFjAy1TiyYvblF1hUBQIhpZSzZFPitAiWatZSpsUoeRHiVfTmNbN0FCLkmJcUFOSD8pckA+UEoyF3AAAAIBUAUXA0wFwwAIABEAHkAMCQ4FAA4AExIMAxAHAC8zzTIREgE5OREzETMxMAE0NjMyFRQjIiU0NjMyFRQjIgFQHyBAQD8BfR8gQEA/BW0uKFZWVi4oVlYAAAMAZP/sBkQFywAVACUANQBOQC8DDi4eJhYIDhMWHgU3NgARABEQEeAR8BEEBgsPCx8L7wv/CwQRCxELIjIaBCoiEwA/Mz8zEjk5Ly9dETNdETMREgEXOREzETMRMzEwASIGFRQWMzI3FQYjIiY1NDYzMhcHJgE0EiQzMgQSFRQCBCMiJAI3FBIEMzIkEjU0AiQjIgQCA4GOoZWSVHJmarvL3rp3bCVi/IfIAV7KyAFeysL+otDP/qLDXbEBMLKyAS+yq/7NtbD+z7IERL2qurIrWC3m2ND5NFMt/pfIAV7KyP6iysX+ptDPAVrGsv7RsrEBMLKuAS64sf7MAAIATgMhAkQFxwAWACEAN0AcCgEdHRYXBgYRFgMjIh4KChMaAAADEAMCAw4THwA/M9RdxDMSOS8zERIBFzkRMxEzETMzMTABJwYjIiY1NDY3NzU0JiMiByc2MzIVESUUFjMyNjU1BwYGAgAZVHZfcKChX0xEV20hdXLk/mRGPVppWHR6Ay1IVGJaZGcIBCtNSzFJONf+PbQ2PmRcQAUGPQACAFIAfQMtA6gABgANAC1AFgMGCg0CBAsJCQQNBgQODwwFCF8BAQEAL10zxDIREgEXOREzETMRMxEzMTATARcDEwcBJQEXAxMHAVIBNT7+/j7+ywFoATY9/v49/soCHwGJK/6V/pYrAYcbAYkr/pX+lisBhwAAAQBvAQ4EDgL8AAUAM0AgAgEEAQYHAgUFBFJZDwUvBT8FXwV/BY8FrwW/Bd8FCQUAL10rABgQxBESATk5ETMxMAERIxEhNQQOUvyzAvz+EgGcUgD//wBcAgACNwJSAgYAEAAAAAQAZP/sBkQFywAHABUAJQA1AGNANgsOBAgNDAAQEBEuHiYWCAwOERYeBjc2Cw8PAAASDREPER8RAgcSABIQEgIREhESIjIaBCoiEwA/Mz8zEjk5Ly9dETNdETMSOS8zETMREgEXOREzETMRMxEzETMRMxEzMTABMzI2NTQjIwUUBgcTIwMjESMRMzIWATQSJDMyBBIVFAIEIyIkAjcUEgQzMiQSNTQCJCMiBAICxXBbaMVuAZtNSO150qhl04+e/ATIAV7KyAFeysL+otDP/qLDXbEBMLKyAS+yq/7NtbD+z7IC211ZrKdPeSL+dwFo/pgDcHz+xMgBXsrI/qLKxf6m0M8BWsay/tGysQEwsq4BLrix/swAAf/6BhQEBgZmAAMAFUAJAAUBBAIBU1kCAC8rEQEzETMxMAEhNSEEBvv0BAwGFFIAAgCLA3UC4QXLAAsAFwAjQBASBgwABgAZGA8/CQEJFQMEAD8zxF0yERIBOTkRMxEzMTATNDYzMhYVFAYjIiY3FBYzMjY1NCYjIgaLrX5+ra1+gqlaeldWe3hZWncEoISnp4SEp6aFW358XVx9gP//AG8AAQQjBK4AJwIrAAD9VwAGAA4AAAABADUCSgJ1BcsAFwAlQBIGERYCAgwRFwQZGAkOHwIWASAAPzMzPzMREgEXOREzETMxMAEhNTc2NjU0JiMiByc2MzIWFRQOAgEhAnX9wPJ9Xl1NbG0xd5d8jBo2U/71Ab8CSk7teZBNR1NSQWd/by9UV13+/AAAAQApAjkCgQXLACMAP0AlEAUZAAsfFAMABQYlJAMUFE8VXxVvFQMLFRsVAhUVCBwhHw0IIQA/Mz8zEjkvXV0zEjkREgEXOREzETMxMAEUBgcWFRQGIyInNRYzMjY1NCYjIzUzMjY1NCYjIgcnNjMyFgJoWEm6sZ+QeIiCc3d3d4OHaWpeUIB2L4Kjf5EE7E5rFi2mgo88WD5iV1NOVFdNQ1FORl54AAEBiQTZAwgGIQAJABhACQMECQQLCgSACQAvGs0REgE5OREzMTABNjY3MxUGBgcjAYlJjxqNJK1oRgTpT7kwETSsVwAAAQC2/hQEDgQ/ABgAP0AfDAcHCgEWFhcXChoZExgMDQ0LCBgPCxUXGxAERlkQFgA/KwAYPz8/MxI5ETMRORESATk5ETMRMxEzETMxMAERFBYzMjY1ETMRIycjBgYjIiYnFhURIxEBGYqQwrdiVBIGMsh1Y4kzBWMEP/1ApJXE3QJY+8GWTV03OVxO/mIGKwAAAQBx/vwEUgYUAA8ALUAVAQAEBQAFCwMREAEFCAgOBQ4DSlkOAC8rABgvEjkvETMREgEXOREzETMxMAEjESMRIxEGIyImNRA2MyEEUmTkZEBS2Mva6AIf/vwGuvlGAzMS+vsBBP7//wCiAm8BRAMzAAcAEQAAAoMAAQAr/hQBiQAAABEAJ0ASCwAQDQAGDQMTEg0QEA8IAxsPAC8/MxI5LzMREgEXOREzETMxMAEUBiMiJzUWMzI2NTQnNzMHFgGJh3lEGh4+TlLBXWBCqP7dZGULWAo4NF4brnUlAAEATAJKAboFtgAJAB5ADQIAAwkDCwoIAyAGAB4APzI/ORESATk5ETMzMTABMxEjETQ3BgcnAV5cYgwazy8FtvyUAiNjhhd6TQAAAgBGAyECngXHAAsAFQAlQBIQAAwGAAYXFg4AAxADAgMTCR8APzPEXTIREgE5OREzETMxMAEUBiMiJjU0NjMyFgUQMzIRNCYjIgYCnqCPj5qckY6d/gLR0WRtbWQEdaGzrKiisK6k/vgBCIN/fwACAEgAfQMjA6gABgANAClAFQsJBAIAAwcCCgkGDg8IAQEMXwUBBQAvXTPELzIREgEXOREzETMxMAEBJxMDNwEFAScTAzcBAyP+yz7+/j4BNf6X/ss9/v49ATUCBv53KwFqAWsr/nkb/ncrAWoBayv+ef//ADsAAAVwBbYAJgB77wAAJwIXAj8AAAEHAjwC3/23AAmzAwIRGAA/NTUA//8ACwAABXsFtgAmAHu/AAAnAhcB9AAAAQcAdAMG/bcAB7ICDxgAPzUA//8AKQAABdcFywAmAHUAAAAnAhcC1wAAAQcCPANG/bcACbMDAisYAD81NQAAAgBK/nUDJQRUAB4AKAA/QCAjHwAeCBUPFR4fBCopBBkZHh4SISEmUVkhEBILUFkSIwA/KwAYPysREgA5GC85ETMREgEXOREzETMRMzEwARUUBgcHBgYVFBYzMjc3FwYGIyImNTQ2Njc+AjU1AzQzMhUUBiMiJgI5T2FaST6ki31sQCVvlU640ShNhUBFHi9QUi8jIi4CxyV9n1VPPXdPfJguG08wIMaqRmxgbzVbYWEPAStiYjUuLgD//wAAAAAEzQdzAiYAJAAAAQcAQ//IAVIACLMCEAUmACs1//8AAAAABM0HcwImACQAAAEHAHYAbwFSAAizAhgFJgArNf//AAAAAATNB3MCJgAkAAABBwFLAB0BUgAIswIcBSYAKzX//wAAAAAEzQcbAiYAJAAAAQcBUgAEAVIACLMCGQUmACs1//8AAAAABM0HFQImACQAAAEHAGoAHwFSAAq0AwIfBSYAKzU1//8AAAAABM0HHQImACQAAAEHAVAAHwCaAAmzAwIeAwA/NTUAAAL//gAABfgFtgAPABMAbUA7BhMTEREKDg4BCAAEBQUAAQwQEgUVFAoNSlkPCgELAwoKAQYQA0xZEBABBgUSCRMGE0pZBgMBDkpZARIAPysAGD8rEQAzGD8REjkvKxESADkYL19eXSsREgEXOTMRMxEzETMSOTkRMxEzMTAhIREhAyMBIRUhESEVIREhASERIwX4/TP+JeNvAo0Dbf2ZAkD9wAJn+4EBsmQCBP38BbZe/dde/Y0CAgL4//8Agf4UBLgFywImACYAAAAHAHoCBgAA//8AzwAAA+4HcwImACgAAAEHAEP/sQFSAAizAQ0FJgArNf//AM8AAAPuB3MCJgAoAAABBwB2AEYBUgAIswEVBSYAKzX//wDPAAAD7gdzAiYAKAAAAQcBSwAQAVIACLMBGQUmACs1//8AzwAAA+4HFQImACgAAAEHAGoAEgFSAAq0AgEcBSYAKzU1//8ANAAAAhQHcwImACwAAAEHAEP+qwFSAAizAQ0FJgArNf//AFoAAAJfB3MCJgAsAAABBwB2/1cBUgAIswEVBSYAKzX//wAVAAACWwdzAiYALAAAAQcBS/7qAVIACLMBGQUmACs1//8AOgAAAjYHFQImACwAAAEHAGr+6gFSAAq0AgEcBSYAKzU1AAIALwAABSUFtgAMABgAW0A2DQASCBYWBAAEBhQEGhkVBgcGSlkSDwc/B18HbwePB58HvwcHCwMHBwQJCRFMWQkDBBZMWQQSAD8rABg/KxESADkYL19eXTMrEQAzERIBFzkRMxI5OREzMTABEAAhIREjNTMRISAAAxAAISERIRUhETMgBSX+fv6K/qKgoAGLAV4BbW/+wf7L/vMBlv5q8gKPAun+kP6HAqZeArL+kv6dAToBPf2oXv20//8AzwAABPYHGwImADEAAAEHAVIAdQFSAAizARoFJgArNf//AIH/7AWcB3MCJgAyAAABBwBDAG0BUgAIswIZBSYAKzX//wCB/+wFnAdzAiYAMgAAAQcAdgElAVIACLMCIQUmACs1//8Agf/sBZwHcwImADIAAAEHAUsAwQFSAAizAiUFJgArNf//AIH/7AWcBxsCJgAyAAABBwFSAKABUgAIswIiBSYAKzX//wCB/+wFnAcVAiYAMgAAAQcAagDBAVIACrQDAigFJgArNTUAAQB3AQIEGwSkAAsAHkARAAIEBggKBg0MXwl/Cd8JAwkAGS9dERIBFzkxMAEBFwEBBwEBJwEBNwJIAZk6/mgBljr+af5qOQGV/mk5AwwBmDr+af5oOQGY/mg5AZgBlzoAAwCB/+wFnAXsABMAGwAjAFVAMRYXHh8EFBwUABwKAAUICg8SBiUkFx4fFgQhGQ8SCAUEAxANBgMNIUtZDQQDGUtZAxMAPysAGD8rEQAzETMSFzkREhc5ERIBFzkRMxEzERIXOTEwARAAISInByc3JhEQACEyFzcXBxYDECcBFjMgAAEQFwEmIyAABZz+pP7O7J9WSlq8AV8BMOigbEhvv2+L/RqFzQEIARf7w4sC44XJ/vv+5QLd/qT+a3h4O3/IAXEBXQGReZg8mc/+lQE7q/vzagFUAT3+yKsECmb+rP//AL7/7AUCB3MCJgA4AAABBwBDADkBUgAIswETBSYAKzX//wC+/+wFAgdzAiYAOAAAAQcAdgDwAVIACLMBGwUmACs1//8Avv/sBQIHcwImADgAAAEHAUsAkQFSAAizAR8FJgArNf//AL7/7AUCBxUCJgA4AAABBwBqAJEBUgAKtAIBIgUmACs1Nf//AAAAAAQ5B3MCJgA8AAABBwB2ACkBUgAIswESBSYAKzUAAgDPAAAEPwW2AAsAFABAQCEQAAwJBQUGBgAWFQkUTFkJCQYHDARMWS8MAQwMBgcDBhIAPz8SOS9dKxESADkYLysREgE5OREzETMzETMxMAEUBCEjESMRMxEhIAEzMjY1NCYjIwQ//uD++OJmZgEAAgr89sn33NDa8gMK1OL+rAW2/vj8/qO3qaMAAQC2/+wERAYfADQAQUAiBSAmABoNLS4ADSAuFAU2NRomEDIuFTIpSFkyABAXSFkQFgA/KwAYPysAGD8REjk5ERIBFzkRMxEzETMRMzEwARQHBgYVFBYWFx4CFRQGIyImJzUWFjMyNjU0JicmJjU0Njc2NjU0JiMiBhURIxE0NjMyFgPBi1E7HUpBalstsJ5fny9Bp0VyeU5uf2BBSkpBjISRomPPvbzDBQSLb0BJJywwQi1LY2tDnKslHmsmMG1qU3pLV3hWPGQ6OWE6XWSKf/tCBLatvJH//wBi/+wDkwYhAiYARAAAAQcAQ/92AAAACLMCJhEmACs1//8AYv/sA5MGIQImAEQAAAEGAHYdAAAIswIuESYAKzX//wBi/+wDkwYhAiYARAAAAQYBS9AAAAizAjIRJgArNf//AGL/7AOTBckCJgBEAAABBgFSrQAACLMCLxEmACs1//8AYv/sA5MFwwImAEQAAAEGAGrKAAAKtAMCNREmACs1Nf//AGL/7AOTBoMCJgBEAAABBgFQ0gAACrQDAigRJgArNTUAAwBi/+wGTARUACYAMQA3AIJASTUdAgwXHgQ0NCsvCAgTHSMrBTk4FwIFFQwrSVkPDB8MAgsDDAwFFTQeSFkPNB80AgsDNDQFFTIQFRBIWRkSFRAgJwUnRlkABRYAPzMrEQAzGD8zMysRADMREjkYL19eXSsREgA5GC9fXl0rERIAOTkREgEXOREzETMSFzkRMzEwBSADBgYjIiY1NDY3NzU0JiMiByc2MyAXNjMyEhUVIRAhMjY3FQYGJTI2NTUHBgYVFBYBIAMhNCYE2/7ZZkTImJys+vzJe4mUnSWtrQEFQG/suNP9NQFcVYJtXJL8f6nCu9u8egN8/uQeAlybFAEAhXulkJqyCAZIm55UVlTT1f7z5VD+NBgtWikcWsexawgLeYBmcQO2/m681v//AHf+FAOFBFQCJgBGAAAABwB6AUoAAP//AHf/7APuBiECJgBIAAABBgBDpQAACLMCHREmACs1//8Ad//sA+4GIQImAEgAAAEGAHY7AAAIswIlESYAKzX//wB3/+wD7gYhAiYASAAAAQYBS/cAAAizAikRJgArNf//AHf/7APuBcMCJgBIAAABBgBq+wAACrQDAiwRJgArNTX////eAAABXQYhAiYA8wAAAQcAQ/5VAAAACLMBBREmACs1//8AawAAAeoGIQImAPMAAAEHAHb+4gAAAAizAQ0RJgArNf///8YAAAIMBiECJgDzAAABBwFL/psAAAAIswERESYAKzX////rAAAB5wXDAiYA8wAAAQcAav6bAAAACrQCARQRJgArNTUAAgB1/+wEHwYUABwAKABPQCoNHR0AIwYABhEUGAUqKRIPFxoEGBAQFQwDCQkgRlkJCQMYFQADJkZZAxYAPysAGD8zEjkvKxESADkSORgvEhc5ERIBFzkRMxEzETMxMAEQAiMiAjU0EjMyFhc3AicFJzcmJzcWFzcXBxYSBzQmIyIGFRQWMzI2BB/44db7/dhsn0UEQM3+8jH0VnEtk2XhMcqamWnCqrm0va6zuwIv/uz+0QEE5+QBA0I/AgEOvZ1Nkj45UUVMiVR5l/5s55Klycy6z/YA//8AtgAABA4FyQImAFEAAAEGAVL/AAAIswEdESYAKzX//wB3/+wEOQYhAiYAUgAAAQYAQ8YAAAizAhoRJgArNf//AHf/7AQ5BiECJgBSAAABBgB2agAACLMCIhEmACs1//8Ad//sBDkGIQImAFIAAAEGAUsKAAAIswImESYAKzX//wB3/+wEOQXJAiYAUgAAAQYBUu0AAAizAiMRJgArNf//AHf/7AQ5BcMCJgBSAAABBgBqCgAACrQDAikRJgArNTUAAwBvARAEIwSWAAMADQAXAFxAPQgEEhIOAAMOAxkYFRBSWdAVAQAVEBVQFZAVBAkDFQYLUllABgEGFQYADwEvAT8BXwF/AY8BrwG/Ad8BCQEAL10zMzMvXSsAGC9fXl1xKxESARc5ETMSOTkxMBM1IRUBNDMyFRQGIyImETQzMhUUBiMiJm8DtP3VUFIvIyIuUFIvIyIuAqpSUgGJY2M0Li79dGJiNS4uAAADAHf/3QQ5BGgAEwAbACMAVUAxFhceHwQcFBwAFAoABQgKDxIGJSQfFhceBBkhBQgPEgQDEA0NGUZZDRAGAwMhRlkDFgA/KxEAMxg/KxEAMxIXORESFzkREgEXOREzETMREhc5MTABEAAjIicHJzcmNRAAMzIXNxcHFgUUFwEmIyIGBTQnARYzMjYEOf7+4612VkhdeQEC4bN6YEpocPymTgIfYpS0wwLySP3hXpC0xQIh/vb+1WJxOniZ+QEKASlofDeJk/TIegLBWvfivnf9QlL7//8Aqv/sBAIGIQImAFgAAAEGAEOnAAAIswEUESYAKzX//wCq/+wEAgYhAiYAWAAAAQYAdmYAAAizARwRJgArNf//AKr/7AQCBiECJgBYAAABBgFLDgAACLMBIBEmACs1//8Aqv/sBAIFwwImAFgAAAEGAGoOAAAKtAIBIxEmACs1Nf//AAD+FAOsBiECJgBcAAABBgB24AAACLMBIhEmACs1AAIAtv4UBEwGFAAUACAAPkAfGAUeEg8PEBAFIiEKAAgCEQAQGwIaRlkCEAgVSFkIFgA/KwAYPysAGD8/ERI5ORESATk5ETMRMzMRMzEwATYzMhIREAIjIicjFxYVESMRMxEHATI2NRAhIgYVFRQWARly/tzn89L7cwcDBGNjBwFzp7f+pMGtqwOWvv7f/uz+9P7ZvFRKWP5iCAD+eff8rvjfAd/S+RL/2gD//wAA/hQDrAXDAiYAXAAAAQYAaoYAAAq0AgEpESYAKzU1//8AAAAABM0GhwImACQAAAEHAU0AMQFSAAizAhIFJgArNf//AGL/7AOTBTUCJgBEAAABBgFN7QAACLMCKBEmACs1//8AAAAABM0HIQImACQAAAEHAU4AHwFSAAizAg8FJgArNf//AGL/7AOTBc8CJgBEAAABBgFO3gAACLMCJREmACs1//8AAP5CBOEFvAImACQAAAAHAVEDgwAAAAIAYv5CA8AEUgApADQAakA8AAoPGi4uJzIWBAoWIScFNjUCAAdAB1AHAwsDBw4PJyMaLklZDxofGgILAxoaIycVIx5IWSMQEypGWRMWAD8rABg/KwAYPxI5L19eXSsREgA5ORgvX15dMxESARc5ETMRMxEzMxEzMTAFFDMyNxUGIyImNTQ3NjcnIwYGIyImNTQkNzc1NCYjIgcnNjMyFhURBgYlMjY1NQcGBhUUFgMEajEhKEBUYygmWRcIUq12oLIBCfvPfoyXoiWzr7OxSEf+tq7JvuXDffhuDFQQX1dGRUNHn2lXpJGfsAUGSJueVFZUusX9LT9x9sexawgLeYBmcQD//wCB/+wEuAdzAiYAJgAAAQcAdgEIAVIACLMBIAUmACs1//8Ad//sA4UGIQImAEYAAAEGAHYzAAAIswEfESYAKzX//wCB/+wEuAdzAiYAJgAAAQcBSwCuAVIACLMBJAUmACs1//8Ad//sA4UGIQImAEYAAAEGAUv3AAAIswEjESYAKzX//wCB/+wEuAcfAiYAJgAAAQcBTwIbAVIACLMBHwUmACs1//8Ad//sA4UFzQImAEYAAAEHAU8BWAAAAAizAR4RJgArNf//AIH/7AS4B3MCJgAmAAABBwFMAKoBUgAIswEaBSYAKzX//wB3/+wDhQYhAiYARgAAAQYBTPcAAAizARkRJgArNf//AM8AAAUlB3MCJgAnAAABBwFMAFABUgAIswIUBSYAKzX//wB3/+wFOwYUAiYARwAAAAcCOALZAAD//wAvAAAFJQW2AgYAkgAAAAIAd//sBKgGFAAbACcAYkA4Cg0TJAQHBxEfGQgPERkEKSgUBBYAEAgJCElZDQkJAAsAEhUAHEZZAAAQACAAAwkDABAWIUhZFhYAPysAGD9fXl0rABg/PxI5LzMrEQAzERI5ORESARc5ETMRMxIXOTEwATIWFzMmNTUhNSE1MxUzFSMRIycjBiMiAhEQEhciBhUQITI2NTU0JgJEdqxEBgb+JwHZYpycQRkIfOjh7uzhsrMBZ7isqQRUVmh+eWtSyspS+wimugEYAQwBGgEqWvru/jLW9hH83QD//wDPAAAD7gaHAiYAKAAAAQcBTQAdAVIACLMBDwUmACs1//8Ad//sA+4FNQImAEgAAAEGAU0QAAAIswIfESYAKzX//wDPAAAD7gchAiYAKAAAAQcBTgAKAVIACLMBDAUmACs1//8Ad//sA+4FzwImAEgAAAEGAU77AAAIswIcESYAKzX//wDPAAAD7gcCAiYAKAAAAQcBTwFtATUACLMBFAUmACs1//8Ad//sA+4FzQImAEgAAAEHAU8BTgAAAAizAiQRJgArNf//AM/+QgPuBbYCJgAoAAAABwFRAlAAAP//AHf+ZwPuBFQCJgBIAAAABwFRAk4AJf//AM8AAAPuB3MCJgAoAAABBwFMAAgBUgAIswEPBSYAKzX//wB3/+wD7gYhAiYASAAAAQYBTPEAAAizAh8RJgArNf//AIH/7AUpB3MCJgAqAAABBwFLANUBUgAIswEoBSYAKzX//wAt/hQEBgYhAiYASgAAAQYBS7sAAAizA00RJgArNf//AIH/7AUpByECJgAqAAABBwFOANUBUgAIswEbBSYAKzX//wAt/hQEBgXPAiYASgAAAQYBTrcAAAizA0ARJgArNf//AIH/7AUpBx8CJgAqAAABBwFPAj8BUgAIswEjBSYAKzX//wAt/hQEBgXNAiYASgAAAQcBTwEdAAAACLMDSBEmACs1//8Agf47BSkFzQImACoAAAAHAjkBHwAA//8ALf4UBAYGIQImAEoAAAEGAjo/AAAIswNEESYAKzX//wDPAAAE8gdzAiYAKwAAAQcBSwCRAVIACLMBGQUmACs1//8AtgAABA4HqgImAEsAAAEHAUsADgGJAAizASICJgArNQACAAAAAAXBBbYAEwAXAGBANAQHFAMLDAADFwMPEAwLDxAJCxASBBkYChYSExJKWQcDExMQARcOSlkvFwEXFxAFAQMMEBIAPzM/MxI5L10rERIAORgvMzMrEQAzMxESARc5ETMRMxESFzkREhc5MTATETMRIREzETMVIxEjESERIxEjNQERIRHPZgNWZ8/PZ/yqZs8Ei/yqBKgBDv7yAQ7+8l77tgLP/TEESl7+hQEd/uMAAQAbAAAEDgYUABwAWUAyDRATAwgJABwICQkLEhwEHh0WFRUJGRMLDAtJWRAMDBkOAAAJFRkERlkAGRAZIBkDGQ8AP10rABg/Mz8SOS8zKxEAMxESOREzERIBFzkRMxEzERIXOTEwIRE0JiMiBhURIxEjNTM1MxUhFSEVBzM2NjMgEREDrIqRxbNjm5tjAdn+JwUHPbqKAXICoqSVxN79xwT4UsrKUvKLYlj+c/1YAP///+cAAAKhBxsCJgAsAAABBwFS/swBUgAIswEWBSYAKzX///+VAAACTwXJAiYA8wAAAQcBUv56AAAACLMBDhEmACs1//8AJAAAAk8GhwImACwAAAEHAU3+/wFSAAizAQ8FJgArNf///9QAAAH/BTUCJgDzAAABBwFN/q8AAAAIswEHESYAKzX//wAkAAACTQchAiYALAAAAQcBTv7tAVIACLMBDAUmACs1////1AAAAf0FzwImAPMAAAEHAU7+nQAAAAizAQQRJgArNf//AFr+QgIUBbYCJgAsAAAABgFRZgD//wAn/kIBRgXNAiYATAAAAAYBUegA//8AWgAAAhQHHwImACwAAAEHAU8ARgFSAAizARQFJgArNQABALYAAAEZBD8AAwAWQAkAAQEFBAIPARUAPz8REgE5ETMxMCEjETMBGWNjBD///wBa/o8DpAW2ACYALAAAAAcALQJvAAD//wCo/hQC+AXNACYATAAAAAcATQHPAAD///9I/o8CJAdzAiYALQAAAQcBS/6zAVIACLMBGQUmACs1////nv4UAgwGIQImAjcAAAEHAUv+mwAAAAizARoRJgArNf//AM/+OwSmBbYCJgAuAAAABwI5AIEAAP//ALb+OwPfBhQCJgBOAAAABgI5KQAAAQC2AAAD3wQ/AA0AN0AdBQQBAgwICAkCAwQGCQUPDgMGDQcECQEBCg8FCRUAPzM/MxESFzkREgEXOREzETMRMxEzMTABATMBASMBBxEjETMRAwEXAit4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RjNGZEafRs9HCUdUR6JH5Ug4SJ5I70j3SVhJu0nbSiNKK0p5StlLCksaS09LhkvOTAVMDUwyTDpMQkxoTHBM0UzZTQpNSE15TbROAU5STpZO5k9FT49PoFAIUBhQaVBxUHlQi1CTUPVRT1FXUWdRd1GnUc5R9VIGUhZSJ1I4UkpSXFJtUn5SlVKsUrRSzlLvUw9TM1NUU4pTv1PkVCJUhFSpVLlVVVVdVWVViFWsVbhV1VYMVldWxFc0V7dYKFiMWQdZWVlhWbNZylnhWfhaD1pzWqpa0FsOWy9bW1vEW/ZcaVzEXNZc6F0fXStdN11hXYhdql3MXe5eJF5nXqpe818WX3pfy1/LX8tfy1/LX8tfy1/LX8tfy1/LX8tfy1/LYQhhaGF5YYFiBWJHYrZix2LYYuRi8GMCYzhjdmOGY5Zj+mRVZKJk+WUCZQtlFGU5ZVBlYWVyZYJlkmYQZmhmxWchZ4hn7mg8aIRo6WlNacBqMWq1azFr4GyObJZsnm0BbVttnW3cbe5uAG6Bbo1vAW9qcC1w5HGEcgJyR3KEctNzBHM5c2NzjXSjdT51qnYRdmt2zXcsd5532ngZeG54u3kVeXB5fHmIecx6DnpTept66Hs4e3Z7s3v2fD18fHy+fRd9aH31fnx+iH6UfsV+937/fzR/en+/gAaATYCKgMiBEYFcgbyCFoJPgoeC/YNng+WEWYRhhHKEgoTbhS6FeYXAhgqGU4aZhuOHK4d2h8iIIIgoiDmISYhbiGyIdIh8iI2InYjwiUCJUoljiXWJhomYiaqJ+IpPimCKcIqCipOKpYq2ir6KxorYiumK+4sMix2LLYs/i1CLYotzi4WLlovCi+6MAIwSjGmMwo0WjWuNuI4IjkeOT46xjxuPio/0kFWQrZEIkVqRp5H3kkySl5LWkxWTdZN9k9OUJJQwlDyUTZRelHCUgpSUlKaUuJTKlNyU7pUDlReVKZU7lU2VX5VxlYOVlZWnlbyV0JXcleiV+ZYKlhuWK5Y9lk+WYZZzloWWl5aplruW0JbklvWXBpcSlx6XKpc2l0eXWJdql3yXjpegl7KXxJfWl+iX/ZgRmCKYMphDmFOYZJh1mIaYlpiimK6YupjGmNeY6Jj5mQmZGpkqmTuZTJldmW2ZeZmFmZGZnZmumb+Z0Jnhme2aGZpNmoCaw5sYm1GbiZvQnCScUpx6nLic350nnYudzZ4ZniGeSZ5Rnreew585n0WfUZ+zn8Of05/kn/SgCaAaoCugPKBOoF+gcKCBoIygnaCpoLqgwqDUoNyg7qD2oP6hD6EbAAAAAQAAAAEZ22TZ2mRfDzz1AAkIAAAAAADJQhTbAAAAANUrzNX71f3ZCR8IYgAAAAkAAgAAAAAAAATNAMEAAAAABBQAAAIUAAAB7ACkAtMAhQUrADcEkQCkBnUAcQW0AHsBiQCFAi0AUgItAD0EaABoBJEAbwG4AEQCkwBcAecAogK6ABkEkQBzBJEAxwSRAHEEkQBeBJEAKwSRAI8EkQCDBJEAbQSRAHkEkQBvAecAogHnAEwEkQBvBJEAbwSRAG8DXgA5BxcAcQTNAAAFBADPBPgAgQWmAM8EagDPBAQAzwXJAIEFwQDPAm8AWgH6/0gEpgDPBBsAzwbnAM8FxQDPBh0AgQSuAM8GHQCBBMEAzwRcAG8EMQAKBcEAvgSeAAAHIwAzBE4AAAQ5AAAEnABSAo0ArgK6ABkCjQAzBJEAWANK//wEngGJBD0AYgTDALYDzQB3BMMAdwRkAHcCZgAdBC8ALQS4ALYBzwCoAc//ngPfALYBzwC2BxAAtgS4ALYEsAB3BMMAtgTDAHcDHQC2A7oAVAKuABkEuACqA6wAAAXJAB8D/AA3A6wAAAOwAFIC0wA9BFQB/ALTAEgEkQBvAhQAAAHsAKYEkQDTBJEATgSRAH8EkQArBFQB/AQhAIEEngFQBqgAZAKuAE4DdQBSBJEAbwKTAFwGqABkBAD/+gNtAIsEkQBvArAANQKwACkEngGJBMUAtgU9AHEB5wCiAaQAKwKwAEwC4wBGA3UASAXsADsF7AALBewAKQNeAEoEzQAABM0AAATNAAAEzQAABM0AAATNAAAGdf/+BPgAgQRqAM8EagDPBGoAzwRqAM8CbwA0Am8AWgJvABUCbwA6BboALwXFAM8GHQCBBh0AgQYdAIEGHQCBBh0AgQSRAHcGHQCBBcEAvgXBAL4FwQC+BcEAvgQ5AAAErgDPBKoAtgQ9AGIEPQBiBD0AYgQ9AGIEPQBiBD0AYgbDAGIDzQB3BGQAdwRkAHcEZAB3BGQAdwHP/94BzwBrAc//xgHP/+sElgB1BLgAtgSwAHcEsAB3BLAAdwSwAHcEsAB3BJEAbwSwAHcEuACqBLgAqgS4AKoEuACqA6wAAATDALYDrAAABM0AAAQ9AGIEzQAABD0AYgTNAAAEPQBiBPgAgQPNAHcE+ACBA80AdwT4AIEDzQB3BPgAgQPNAHcFpgDPBMMAdwW6AC8EwwB3BGoAzwRkAHcEagDPBGQAdwRqAM8EZAB3BGoAzwRkAHcEagDPBGQAdwXJAIEELwAtBckAgQQvAC0FyQCBBC8ALQXJAIEELwAtBcEAzwS4ALYFwQAABLgAGwJv/+cBz/+VAm8AJAHP/9QCbwAkAc//1AJvAFoBzwAnAm8AWgHPALYEaABaA54AqAH6/0gBz/+eBKYAzwPfALYD3wC2BBsAzwHPAIgEGwDPAc8AYQQbAM8BzwC2BBsAzwHdALYEGwAdAc8ACAXFAM8EuAC2BcUAzwS4ALYFxQDPBLgAtgUEAAEFxQDPBLgAtgYdAIEEsAB3Bh0AgQSwAHcGHQCBBLAAdwcvAIEHlgB3BMEAzwMdALYEwQDPAx0AbQTBAM8DHQCjBFwAbwO6AFQEXABvA7oAVARcAG8DugBUBFwAbwO6AFQEMQAKAq4AGQQxAAoCrgAZBDEACgKuABkFwQC+BLgAqgXBAL4EuACqBcEAvgS4AKoFwQC+BLgAqgXBAL4EuACqBcEAvgS4AKoHIwAzBckAHwQ5AAADrAAABDkAAAScAFIDsABSBJwAUgOwAFIEnABSA7AAUgJzALYEkQC+BM3/9AQ9AGIGdf/+BsMAYgYdAIEEsAB3BFwAbwO6AFQEngErBJ4BKwR1ASUEngE3AeMAsgSeAXMBZAA/BJ4BGwSeAQIEngISBJ4BNQTNAAAB5wCiBMX/2AYb/9gDIf/YBin/2AUp/9gGSP/YAnX/zgTNAAAFBADPBAQAzwSRABQEagDPBJwAUgXBAM8GHQCBAm8AWgSmAM8EzQAABucAzwXFAM8EPwApBh0AgQW2AM8ErgDPBGgAPQQxAAoEOQAABhkAbwROAAAGHQB7BjMAUgJvADoEOQAABLgAdwOgAF4EuAC2AnUApgTDAKYEuAB3BN0AtgPXAAoEpgB1A6AAXgO8AHcEuAC2BI8AdwJ1AKYD3wC2BAb/9ATFALYEG//+A6wAdwSwAHcE5QAZBKwAsAPNAHcEsgB3A5EAFATDAKYFbQB3BB3/7AXFAKYF3wB3AnUAAwTDAKYEsAB3BMMApgXfAHcEagDPBZEACgQEAM8E+ACB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AKIArQDJAMcArgBiAGMAkABkAMsAZQDIAMoBBgEHAQgBCQDpAGYA0wDQANEArwBnAPAAkQDWANQA1QBoAOsA7QCJAGoAaQBrAG0AbABuAKAAbwBxAHAAcgBzAHUAdAB2AHcA6gB4AHoAeQB7AH0AfAC4AKEAfwB+AIAAgQDsAO4AugEKAQsBDAENAQ4BDwD9AP4BEAERARIBEwD/AQABFAEVARYBAQEXARgBGQEaARsBHAEdAR4BHwEgASEBIgD4APkBIwEkASUBJgEnASgBKQEqASsBLAEtAS4BLwEwATEBMgEzANcBNAE1ATYBNwE4ATkBOgE7ATwBPQE+AT8BQAFBAUIA4gDjAUMBRAFFAUYBRwFIAUkBSgFLAUwBTQFOAU8BUAFRALAAsQFSAVMBVAFVAVYBVwFYAVkBWgFbAPsA/ADkAOUBXAFdAV4BXwFgAWEBYgFjAWQBZQFmAWcBaAFpAWoBawFsAW0BbgFvAXABcQC7AXIBcwF0AXUA5gDnAXYApgF3AXgBeQF6AXsBfAF9AX4A2ADhANoA2wDcAN0A4ADZAN8BfwGAAYEBggGDAYQBhQGGAYcBiAGJAYoBiwGMAY0BjgGPAZABkQGSAZMBlAGVAZYBlwGYAZkBmgGbAZwBnQGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAasBrAGtAa4BrwGwAbEBsgGzAbQBtQG2AbcAmwG4AbkBugG7AbwBvQG+Ab8BwAHBAcIBwwHEAcUBxgHHAcgByQHKAcsBzAHNAc4BzwHQAdEB0gHTAdQB1QHWAdcB2AHZAdoB2wHcAd0B3gHfAeAB4QHiAeMB5AHlAeYB5wHoAekB6gHrAewB7QHuAe8B8AHxAfIB8wH0AfUB9gH3AfgB+QH6AfsB/AH9Af4B/wIAAgECAgIDAgQCBQIGAgcCCAIJAgoCCwIMAg0CDgIPAhACEQISAhMCFAIVAhYCFwIYAhkCGgIbAhwCHQIeAh8CIAIhAiICIwIkAiUCJgInAigCKQIqAisAsgCzAiwCLQC2ALcAxAIuALQAtQDFAIIAwgCHAKsAxgIvAjAAvgC/AjEAvAIyAPcCMwI0AjUCNgI3AjgAjACfAjkCOgI7AjwCPQCYAKgAmgCZAO8ApQCSAJwApwCPAJQAlQC5Aj4CPwJAAkECQgJDAkQCRQJGAkcCSAJJAkoCSwJMAk0CTgJPAlACUQJSAlMCVAJVAlYCVwJYAlkCWgJbAlwCXQJeAl8CYAJhAmICYwJkAmUCZgJnAmgCaQJqAmsCbAJtAm4CbwJwAnECcgJzAnQCdQJ2AncCeAJ5AnoCewJ8An0CfgJ/AoACgQKCAoMChAKFAoYChwKIAokCigKLAowCjQKOAo8CkAKRApICkwKUApUClgKXApgCmQKaApsCnAKdAp4CnwKgAqECogKjAqQCpQKmAqcCqAKpAqoCqwKsAq0CrgKvArACsQKyArMCtAK1ArYCtwK4ArkCugK7ArwCvQK+Ar8CwALBAsICwwLEAsUCxgLHAsgCyQLKAssCzALNAs4CzwLQAtEC0gLTAtQC1QLWAtcC2ALZAtoC2wLcAt0C3gLfAuAC4QLiAuMC5ALlAuYC5wLoAukC6gLrAuwC7QLuAu8C8ALxAvIC8wL0AvUC9gL3AvgC+QL6AvsC/AL9Av4C/wMAAwEDAgMDAwQDBQMGAwcDCAMJAwoDCwMMAw0DDgMPAxADEQMSAxMDFAMVAxYDFwMYAxkDGgMbAxwDHQMeAx8DIAMhAyIDIwMkAyUDJgMnAygDKQMqAysDLAMtAy4DLwMwAzEDMgMzAzQDNQM2AzcDOAM5AzoDOwM8Az0DPgM/A0ADQQNCA0MDRANFA0YDRwNIA0kDSgNLA0wDTQNOA08DUANRA1IDUwNUA1UDVgNXA1gDWQNaA1sDXANdA14DXwNgA2EDYgNjA2QDZQNmA2cDaANpA2oDawNsA20DbgNvA3ADcQNyA3MDdAN1A3YDdwN4A3kDegN7A3wDfQN+A38DgAOBA4IDgwOEA4UDhgOHA4gDiQOKA4sDjAONA44DjwOQA5EDkgOTA5QDlQOWA5cDmAOZA5oDmwOcA50ALADPAMwAzQDOA54DnwOgA6EA+gOiA6MDpAOlA6YDpwOoA6kDqgOrBG51bGwFSS5hbHQHdW5pMDBBRAlvdmVyc2NvcmUKSWdyYXZlLmFsdApJYWN1dGUuYWx0D0ljaXJjdW1mbGV4LmFsdA1JZGllcmVzaXMuYWx0B0FtYWNyb24HYW1hY3JvbgZBYnJldmUGYWJyZXZlB0FvZ29uZWsHYW9nb25lawtDY2lyY3VtZmxleAtjY2lyY3VtZmxleARDZG90BGNkb3QGRGNhcm9uBmRjYXJvbgZEY3JvYXQHRW1hY3JvbgdlbWFjcm9uBkVicmV2ZQZlYnJldmUKRWRvdGFjY2VudAplZG90YWNjZW50B0VvZ29uZWsHZW9nb25lawZFY2Fyb24GZWNhcm9uC0djaXJjdW1mbGV4C2djaXJjdW1mbGV4BEdkb3QEZ2RvdAxHY29tbWFhY2NlbnQMZ2NvbW1hYWNjZW50C0hjaXJjdW1mbGV4C2hjaXJjdW1mbGV4BEhiYXIEaGJhcgpJdGlsZGUuYWx0Bml0aWxkZQtJbWFjcm9uLmFsdAdpbWFjcm9uCklicmV2ZS5hbHQGaWJyZXZlC0lvZ29uZWsuYWx0B2lvZ29uZWsOSWRvdGFjY2VudC5hbHQGSUouYWx0AmlqC0pjaXJjdW1mbGV4C2pjaXJjdW1mbGV4DEtjb21tYWFjY2VudAxrY29tbWFhY2NlbnQMa2dyZWVubGFuZGljBkxhY3V0ZQZsYWN1dGUMTGNvbW1hYWNjZW50DGxjb21tYWFjY2VudAZMY2Fyb24GbGNhcm9uBExkb3QEbGRvdAZOYWN1dGUGbmFjdXRlDE5jb21tYWFjY2VudAxuY29tbWFhY2NlbnQGTmNhcm9uBm5jYXJvbgtuYXBvc3Ryb3BoZQNFbmcDZW5nB09tYWNyb24Hb21hY3JvbgZPYnJldmUGb2JyZXZlDU9odW5nYXJ1bWxhdXQNb2h1bmdhcnVtbGF1dAZSYWN1dGUGcmFjdXRlDFJjb21tYWFjY2VudAxyY29tbWFhY2NlbnQGUmNhcm9uBnJjYXJvbgZTYWN1dGUGc2FjdXRlC1NjaXJjdW1mbGV4C3NjaXJjdW1mbGV4DFRjb21tYWFjY2VudAx0Y29tbWFhY2NlbnQGVGNhcm9uBnRjYXJvbgRUYmFyBHRiYXIGVXRpbGRlBnV0aWxkZQdVbWFjcm9uB3VtYWNyb24GVWJyZXZlBnVicmV2ZQVVcmluZwV1cmluZw1VaHVuZ2FydW1sYXV0DXVodW5nYXJ1bWxhdXQHVW9nb25lawd1b2dvbmVrC1djaXJjdW1mbGV4C3djaXJjdW1mbGV4C1ljaXJjdW1mbGV4C3ljaXJjdW1mbGV4BlphY3V0ZQZ6YWN1dGUKWmRvdGFjY2VudAp6ZG90YWNjZW50BWxvbmdzCkFyaW5nYWN1dGUKYXJpbmdhY3V0ZQdBRWFjdXRlB2FlYWN1dGULT3NsYXNoYWN1dGULb3NsYXNoYWN1dGUMU2NvbW1hYWNjZW50DHNjb21tYWFjY2VudAV0b25vcw1kaWVyZXNpc3Rvbm9zCkFscGhhdG9ub3MJYW5vdGVsZWlhDEVwc2lsb250b25vcwhFdGF0b25vcw1Jb3RhdG9ub3MuYWx0DE9taWNyb250b25vcwxVcHNpbG9udG9ub3MKT21lZ2F0b25vcxFpb3RhZGllcmVzaXN0b25vcwVBbHBoYQRCZXRhBUdhbW1hB3VuaTAzOTQHRXBzaWxvbgRaZXRhA0V0YQVUaGV0YQhJb3RhLmFsdAVLYXBwYQZMYW1iZGECTXUCTnUCWGkHT21pY3JvbgJQaQNSaG8FU2lnbWEDVGF1B1Vwc2lsb24DUGhpA0NoaQNQc2kHdW5pMDNBORBJb3RhZGllcmVzaXMuYWx0D1Vwc2lsb25kaWVyZXNpcwphbHBoYXRvbm9zDGVwc2lsb250b25vcwhldGF0b25vcwlpb3RhdG9ub3MUdXBzaWxvbmRpZXJlc2lzdG9ub3MFYWxwaGEEYmV0YQVnYW1tYQVkZWx0YQdlcHNpbG9uBHpldGEDZXRhBXRoZXRhBGlvdGEFa2FwcGEGbGFtYmRhB3VuaTAzQkMCbnUCeGkHb21pY3JvbgNyaG8Gc2lnbWExBXNpZ21hA3RhdQd1cHNpbG9uA3BoaQNjaGkDcHNpBW9tZWdhDGlvdGFkaWVyZXNpcw91cHNpbG9uZGllcmVzaXMMb21pY3JvbnRvbm9zDHVwc2lsb250b25vcwpvbWVnYXRvbm9zCWFmaWkxMDAyMwlhZmlpMTAwNTEJYWZpaTEwMDUyCWFmaWkxMDA1MwlhZmlpMTAwNTQNYWZpaTEwMDU1LmFsdA1hZmlpMTAwNTYuYWx0CWFmaWkxMDA1NwlhZmlpMTAwNTgJYWZpaTEwMDU5CWFmaWkxMDA2MAlhZmlpMTAwNjEJYWZpaTEwMDYyCWFmaWkxMDE0NQlhZmlpMTAwMTcJYWZpaTEwMDE4CWFmaWkxMDAxOQlhZmlpMTAwMjAJYWZpaTEwMDIxCWFmaWkxMDAyMglhZmlpMTAwMjQJYWZpaTEwMDI1CWFmaWkxMDAyNglhZmlpMTAwMjcJYWZpaTEwMDI4CWFmaWkxMDAyOQlhZmlpMTAwMzAJYWZpaTEwMDMxCWFmaWkxMDAzMglhZmlpMTAwMzMJYWZpaTEwMDM0CWFmaWkxMDAzNQlhZmlpMTAwMzYJYWZpaTEwMDM3CWFmaWkxMDAzOAlhZmlpMTAwMzkJYWZpaTEwMDQwCWFmaWkxMDA0MQlhZmlpMTAwNDIJYWZpaTEwMDQzCWFmaWkxMDA0NAlhZmlpMTAwNDUJYWZpaTEwMDQ2CWFmaWkxMDA0NwlhZmlpMTAwNDgJYWZpaTEwMDQ5CWFmaWkxMDA2NQlhZmlpMTAwNjYJYWZpaTEwMDY3CWFmaWkxMDA2OAlhZmlpMTAwNjkJYWZpaTEwMDcwCWFmaWkxMDA3MglhZmlpMTAwNzMJYWZpaTEwMDc0CWFmaWkxMDA3NQlhZmlpMTAwNzYJYWZpaTEwMDc3CWFmaWkxMDA3OAlhZmlpMTAwNzkJYWZpaTEwMDgwCWFmaWkxMDA4MQlhZmlpMTAwODIJYWZpaTEwMDgzCWFmaWkxMDA4NAlhZmlpMTAwODUJYWZpaTEwMDg2CWFmaWkxMDA4NwlhZmlpMTAwODgJYWZpaTEwMDg5CWFmaWkxMDA5MAlhZmlpMTAwOTEJYWZpaTEwMDkyCWFmaWkxMDA5MwlhZmlpMTAwOTQJYWZpaTEwMDk1CWFmaWkxMDA5NglhZmlpMTAwOTcJYWZpaTEwMDcxCWFmaWkxMDA5OQlhZmlpMTAxMDAJYWZpaTEwMTAxCWFmaWkxMDEwMglhZmlpMTAxMDMJYWZpaTEwMTA0CWFmaWkxMDEwNQlhZmlpMTAxMDYJYWZpaTEwMTA3CWFmaWkxMDEwOAlhZmlpMTAxMDkJYWZpaTEwMTEwCWFmaWkxMDE5MwlhZmlpMTAwNTAJYWZpaTEwMDk4BldncmF2ZQZ3Z3JhdmUGV2FjdXRlBndhY3V0ZQlXZGllcmVzaXMJd2RpZXJlc2lzBllncmF2ZQZ5Z3JhdmUJYWZpaTAwMjA4DXVuZGVyc2NvcmVkYmwNcXVvdGVyZXZlcnNlZAZtaW51dGUGc2Vjb25kCWV4Y2xhbWRibAluc3VwZXJpb3IJYWZpaTA4OTQxBnBlc2V0YQRFdXJvCWFmaWk2MTI0OAlhZmlpNjEyODkJYWZpaTYxMzUyCWVzdGltYXRlZAlvbmVlaWdodGgMdGhyZWVlaWdodGhzC2ZpdmVlaWdodGhzDHNldmVuZWlnaHRocwd1bmlGQjAxB3VuaUZCMDINY3lyaWxsaWNicmV2ZQhkb3RsZXNzahBjYXJvbmNvbW1hYWNjZW50C2NvbW1hYWNjZW50EWNvbW1hYWNjZW50cm90YXRlDHplcm9zdXBlcmlvcgxmb3Vyc3VwZXJpb3IMZml2ZXN1cGVyaW9yC3NpeHN1cGVyaW9yDXNldmVuc3VwZXJpb3INZWlnaHRzdXBlcmlvcgxuaW5lc3VwZXJpb3IHdW5pMjAwMAd1bmkyMDAxB3VuaTIwMDIHdW5pMjAwMwd1bmkyMDA0B3VuaTIwMDUHdW5pMjAwNgd1bmkyMDA3B3VuaTIwMDgHdW5pMjAwOQd1bmkyMDBBB3VuaTIwMEIHdW5pRkVGRgd1bmlGRkZDB3VuaUZGRkQHdW5pMDFGMAd1bmkwMkJDB3VuaTAzRDEHdW5pMDNEMgd1bmkwM0Q2B3VuaTFFM0UHdW5pMUUzRgd1bmkxRTAwB3VuaTFFMDEHdW5pMUY0RAd1bmkwMkYzCWRhc2lhb3hpYQd1bmlGQjAzB3VuaUZCMDQFT2hvcm4Fb2hvcm4FVWhvcm4FdWhvcm4HdW5pMDMwMAd1bmkwMzAxB3VuaTAzMDMEaG9vawhkb3RiZWxvdwd1bmkwNDAwB3VuaTA0MEQHdW5pMDQ1MAd1bmkwNDVEB3VuaTA0NjAHdW5pMDQ2MQd1bmkwNDYyB3VuaTA0NjMHdW5pMDQ2NAd1bmkwNDY1B3VuaTA0NjYHdW5pMDQ2Nwd1bmkwNDY4B3VuaTA0NjkHdW5pMDQ2QQd1bmkwNDZCB3VuaTA0NkMHdW5pMDQ2RAd1bmkwNDZFB3VuaTA0NkYHdW5pMDQ3MAd1bmkwNDcxB3VuaTA0NzIHdW5pMDQ3Mwd1bmkwNDc0B3VuaTA0NzUHdW5pMDQ3Ngd1bmkwNDc3B3VuaTA0NzgHdW5pMDQ3OQd1bmkwNDdBB3VuaTA0N0IHdW5pMDQ3Qwd1bmkwNDdEB3VuaTA0N0UHdW5pMDQ3Rgd1bmkwNDgwB3VuaTA0ODEHdW5pMDQ4Mgd1bmkwNDgzB3VuaTA0ODQHdW5pMDQ4NQd1bmkwNDg2B3VuaTA0ODgHdW5pMDQ4OQd1bmkwNDhBB3VuaTA0OEIHdW5pMDQ4Qwd1bmkwNDhEB3VuaTA0OEUHdW5pMDQ4Rgd1bmkwNDkyB3VuaTA0OTMHdW5pMDQ5NAd1bmkwNDk1B3VuaTA0OTYHdW5pMDQ5Nwd1bmkwNDk4B3VuaTA0OTkHdW5pMDQ5QQd1bmkwNDlCB3VuaTA0OUMHdW5pMDQ5RAd1bmkwNDlFB3VuaTA0OUYHdW5pMDRBMAd1bmkwNEExB3VuaTA0QTIHdW5pMDRBMwd1bmkwNEE0B3VuaTA0QTUHdW5pMDRBNgd1bmkwNEE3B3VuaTA0QTgHdW5pMDRBOQd1bmkwNEFBB3VuaTA0QUIHdW5pMDRBQwd1bmkwNEFEB3VuaTA0QUUHdW5pMDRBRgd1bmkwNEIwB3VuaTA0QjEHdW5pMDRCMgd1bmkwNEIzB3VuaTA0QjQHdW5pMDRCNQd1bmkwNEI2B3VuaTA0QjcHdW5pMDRCOAd1bmkwNEI5B3VuaTA0QkEHdW5pMDRCQgd1bmkwNEJDB3VuaTA0QkQHdW5pMDRCRQd1bmkwNEJGC3VuaTA0QzAuYWx0B3VuaTA0QzEHdW5pMDRDMgd1bmkwNEMzB3VuaTA0QzQHdW5pMDRDNQd1bmkwNEM2B3VuaTA0QzcHdW5pMDRDOAd1bmkwNEM5B3VuaTA0Q0EHdW5pMDRDQgd1bmkwNENDB3VuaTA0Q0QHdW5pMDRDRQt1bmkwNENGLmFsdAd1bmkwNEQwB3VuaTA0RDEHdW5pMDREMgd1bmkwNEQzB3VuaTA0RDQHdW5pMDRENQd1bmkwNEQ2B3VuaTA0RDcHdW5pMDREOAd1bmkwNEQ5B3VuaTA0REEHdW5pMDREQgd1bmkwNERDB3VuaTA0REQHdW5pMDRERQd1bmkwNERGB3VuaTA0RTAHdW5pMDRFMQd1bmkwNEUyB3VuaTA0RTMHdW5pMDRFNAd1bmkwNEU1B3VuaTA0RTYHdW5pMDRFNwd1bmkwNEU4B3VuaTA0RTkHdW5pMDRFQQd1bmkwNEVCB3VuaTA0RUMHdW5pMDRFRAd1bmkwNEVFB3VuaTA0RUYHdW5pMDRGMAd1bmkwNEYxB3VuaTA0RjIHdW5pMDRGMwd1bmkwNEY0B3VuaTA0RjUHdW5pMDRGNgd1bmkwNEY3B3VuaTA0RjgHdW5pMDRGOQd1bmkwNEZBB3VuaTA0RkIHdW5pMDRGQwd1bmkwNEZEB3VuaTA0RkUHdW5pMDRGRgd1bmkwNTAwB3VuaTA1MDEHdW5pMDUwMgd1bmkwNTAzB3VuaTA1MDQHdW5pMDUwNQd1bmkwNTA2B3VuaTA1MDcHdW5pMDUwOAd1bmkwNTA5B3VuaTA1MEEHdW5pMDUwQgd1bmkwNTBDB3VuaTA1MEQHdW5pMDUwRQd1bmkwNTBGB3VuaTA1MTAHdW5pMDUxMQd1bmkwNTEyB3VuaTA1MTMHdW5pMUVBMAd1bmkxRUExB3VuaTFFQTIHdW5pMUVBMwd1bmkxRUE0B3VuaTFFQTUHdW5pMUVBNgd1bmkxRUE3B3VuaTFFQTgHdW5pMUVBOQd1bmkxRUFBB3VuaTFFQUIHdW5pMUVBQwd1bmkxRUFEB3VuaTFFQUUHdW5pMUVBRgd1bmkxRUIwB3VuaTFFQjEHdW5pMUVCMgd1bmkxRUIzB3VuaTFFQjQHdW5pMUVCNQd1bmkxRUI2B3VuaTFFQjcHdW5pMUVCOAd1bmkxRUI5B3VuaTFFQkEHdW5pMUVCQgd1bmkxRUJDB3VuaTFFQkQHdW5pMUVCRQd1bmkxRUJGB3VuaTFFQzAHdW5pMUVDMQd1bmkxRUMyB3VuaTFFQzMHdW5pMUVDNAd1bmkxRUM1B3VuaTFFQzYHdW5pMUVDNwt1bmkxRUM4LmFsdAd1bmkxRUM5C3VuaTFFQ0EuYWx0B3VuaTFFQ0IHdW5pMUVDQwd1bmkxRUNEB3VuaTFFQ0UHdW5pMUVDRgd1bmkxRUQwB3VuaTFFRDEHdW5pMUVEMgd1bmkxRUQzB3VuaTFFRDQHdW5pMUVENQd1bmkxRUQ2B3VuaTFFRDcHdW5pMUVEOAd1bmkxRUQ5B3VuaTFFREEHdW5pMUVEQgd1bmkxRURDB3VuaTFFREQHdW5pMUVERQd1bmkxRURGB3VuaTFFRTAHdW5pMUVFMQd1bmkxRUUyB3VuaTFFRTMHdW5pMUVFNAd1bmkxRUU1B3VuaTFFRTYHdW5pMUVFNwd1bmkxRUU4B3VuaTFFRTkHdW5pMUVFQQd1bmkxRUVCB3VuaTFFRUMHdW5pMUVFRAd1bmkxRUVFB3VuaTFFRUYHdW5pMUVGMAd1bmkxRUYxB3VuaTFFRjQHdW5pMUVGNQd1bmkxRUY2B3VuaTFFRjcHdW5pMUVGOAd1bmkxRUY5B3VuaTIwQUIHdW5pMDMwRhNjaXJjdW1mbGV4YWN1dGVjb21iE2NpcmN1bWZsZXhncmF2ZWNvbWISY2lyY3VtZmxleGhvb2tjb21iE2NpcmN1bWZsZXh0aWxkZWNvbWIOYnJldmVhY3V0ZWNvbWIOYnJldmVncmF2ZWNvbWINYnJldmVob29rY29tYg5icmV2ZXRpbGRlY29tYhBjeXJpbGxpY2hvb2tsZWZ0CG9uZS5wbnVtB3plcm8ub3MGb25lLm9zBnR3by5vcwh0aHJlZS5vcwdmb3VyLm9zB2ZpdmUub3MGc2l4Lm9zCHNldmVuLm9zCGVpZ2h0Lm9zB25pbmUub3MCZmYHdW5pMjEyMAhUY2VkaWxsYQh0Y2VkaWxsYQVnLmFsdA9nY2lyY3VtZmxleC5hbHQKZ2JyZXZlLmFsdAhnZG90LmFsdBBnY29tbWFhY2NlbnQuYWx0Bkl0aWxkZQdJbWFjcm9uBklicmV2ZQdJb2dvbmVrAklKCUlvdGF0b25vcwRJb3RhDElvdGFkaWVyZXNpcwlhZmlpMTAwNTUJYWZpaTEwMDU2B3VuaTA0QzAHdW5pMDRDRgd1bmkxRUM4B3VuaTFFQ0EAAAEAAwAIAAoAFgAH//8ADwABAAAADAAAAAAAAAACAAUAAAI1AAECNwI3AAECOwJbAAECXQN2AAEDgAOnAAEAAAABAAAACgAMAA4AAAAAAAAAAQAAAAoAbgFaAAFsYXRuAAgAEAACTU9MIAAoUk9NIABCAAD//wAJAAMACAALAAAADgARABQAFwAaAAD//wAKAAQABgAJAAwAAQAPABIAFQAYABsAAP//AAoABQAHAAoADQACABAAEwAWABkAHAAdbGlnYQCwbGlnYQCwbGlnYQCwbG51bQC2bG51bQC2bG51bQC2bG9jbAC8bG9jbAC8b251bQDCb251bQDCb251bQDCcG51bQDKcG51bQDKcG51bQDKc2FsdADQc2FsdADQc2FsdADQc3MwMQDQc3MwMQDQc3MwMQDQc3MwMgDYc3MwMgDYc3MwMgDYc3MwMwDec3MwMwDec3MwMwDedG51bQDkdG51bQDkdG51bQDkAAAAAQAJAAAAAQAHAAAAAQAIAAAAAgACAAMAAAABAAQAAAACAAAAAQAAAAEAAAAAAAEAAQAAAAIABQAGAAoAFgA8AHwAlADMAOAA7gECAS4BUAABAAAAAQAIAAIAEAAFA48DkAORA5IDkwABAAUASgDfAOEA4wDlAAEAAAABAAgAAgAuABQALACOAI8AkACRAOoA7ADuAPAA8gD0AVoBZwF3AaEBogLJAtgDRQNHAAIAAQOUA6cAAAABAAAAAQAIAAEABgNuAAIAAQATABwAAAABAAAAAQAIAAIAGgAKA4EDgwOEA4UDhgOHA4gDiQOKA4IAAgADABMAEwAAABUAHAABA4ADgAAJAAEAAAABAAgAAQAGA2wAAQABABQAAQAAAAEACAABADz8kgABAAAAAQAIAAEABvyUAAEAAQOAAAEAAAABAAgAAgAaAAoAEwOAABUAFgAXABgAGQAaABsAHAACAAEDgQOKAAAAAQAAAAEACAACAA4ABAONA44BIAEhAAEABAEkASUBSQFKAAQAAAABAAgAAQA2AAEACAAFAAwAFAAcACIAKAJeAAMASQBPAl0AAwBJAEwDiwACAEkCNQACAE8CNAACAEwAAQABAEkAAA==";

var openSansLightItalic = "data:font/ttf;base64,AAEAAAARAQAABAAQR0RFRgt6DNIAAWPgAAAALkdQT1MAGQAMAAFkEAAAABBHU1VC450pmgABZCAAAALuT1MvMqDhmw8AATWIAAAAYGNtYXCuofXtAAE16AAAA4hjdnQgDk0WlwABQkgAAACqZnBnbX5hthEAATlwAAAHtGdhc3AAHgAjAAFj0AAAABBnbHlmwXl5rwAAARwAAR4GaGVhZAMvexcAASaYAAAANmhoZWEPxBDWAAE1ZAAAACRobXR4TkrpewABJtAAAA6SbG9jYU3hBc4AAR9EAAAHUm1heHAFWAGoAAEfJAAAACBuYW1lKq9EOQABQvQAAAH+cG9zdOiicnUAAUT0AAAe23ByZXAUDn9KAAFBJAAAASQAAgDBAAAECgW2AAMABwAStgQHBAcBAwEALy8SOTkvLzEwEyERITchESHBA0n8t2gCef2HBbb6SmgE5gAAAgBQ//AB/AW2AAMADQAYQAsBAQwCAwwHUVkMFgA/KwAYPxI5LzEwEyMTMwE0NjMyFRQGIyL4Pst3/lQyLEIyK0MBeQQ9+oM4QUg1RQAAAgD4A6YDEAW2AAMABwANtAYCBwMDAD8zzTIxMAEDIxMhAyMTAceSPVAByJE9TwW2/fACEP3wAhAAAAIAUgAABUoFtgAbAB8AM0AYDh8CAgsHAwMFEhYaGg8cGxsYCQUDFBgSAD8zPzMSOS8zMzMRMzMROS8zMzMRMzMxMAETITchEzMDIRMzAyEHIQMhByEDIxMhAyMTITchIRMhAYV3/tcIATeGWogBbYdWhwEdCP7SdgEvCP7AhVqH/piGWIb+5QgBgQFreP6WAhIBjlABxv46Acb+OlD+ck/+PQHD/j0Bw08BjgADAI3/iQQhBhAAIQAoAC8APkAiJSwSACgOHi8IFQ0DBg0GTVkiDR0pFSlNWRgVDRUNFRcFFwAvLxI5OS8vETMrEQAzETMrEQAzERIXOTEwARQGBwcjNyYmJzUWFjMTLgI1NDY3NzMHFhcHJicDHgIBNjY1NCYnEwYGFRQWFwOg3bs1UjNPnjpBsUhublYv06cpUCmVgCNukm18YTL+eY6jYG0xho5KZAHTl7gL8PACIBteIicCADVMY0ObvwTAwAU/Tj0J/f48T2L+tgeHdExrLAJUCY5zTmUuAAUAkf/pBfAFyQADABEAHgArADkAHUAOMyMsKgcSDxkIGQMGAhgAPz8/M8QyPzPEMjEwAQEjARMUAgYjIiY1NBI2MzIWJyIGAhUUFjMyEjU0JgEUAgYjIiY1NBI2MzIHIgYCFRQWMzI2EjU0JgWy+41qBG+sZKxvcHhorGt5b+xQhVBSSIKfSP2mZKxvcHhorGvo7E+EUlJIVIFMSAW2+koFtvyur/7QnJeUoAEwm49Fkf78hXR0AU3cbWwBea/+0JyXlKABMJtKj/75hXN0kAEIkW1sAAADAE7/7AUbBc0ACgAVADUALUAaKioOJzAtGQUPJggfLxIfAElZHwQzC0pZMxMAPysAGD8rABg/Ehc5OS8xMAEiBhUUFzY2NTQmATI2NwEOAhUUFgM0NjcnJjU0NjMyFhUUBgYHATY2NzMGBxcjJwYGIyImAux9im3LmXH+jGzPd/6gpIhHnP7G4ilOyqORpFKgsAFKSX0db2a3uHuDefKRp8cFc4h8hJVZlWxbaPrMVWgB7U9viVp3kgEFoudkQ4B7ncGZglWKdk/+MUvLVfe99rhsYLwAAQD+A6YBzQW2AAMACbICAwMAP80xMAEDIxMBzZI9UAW2/fACEAABAGj+vALJBbYACwAKswMDCicAPz8xMBMQEgEzAAIREBMjAmj0AQRp/v37f1CSAQ4BVwJEAQ3+7P24/rr+w/7lAQYAAAH/ZP68AcUFtgAMAAqzCgMEJwA/PzEwARACASMAEhE0AiczEgHF9/7/aQEB/TlGUJIDZP6n/br+9wESAkkBR5QBJKD++gABAOkCcwSLBhcADgAgQA4IBwYKBAwNDgQBAQYOAAA/xDkvMxI5ORI5ETk5MTABAyUHJRMHAwEnASU3BRMDQm0Btgj+YLVzh/7jTgE+/ngnAYovBgT+awhrHf5vJQGh/qROAT59ZqgBmAAAAQCiARAEKQSYAAsAErcJAQIBU1kGAgAvMysRADMxMAEhNSERMxEhFSERIwIz/m8BkWUBkf5vZQKgZAGU/mxk/nAAAf+m/vgBAgDuAAgACLEFAAAvzTEwNxcGAgcjNhI3+ggioFBKT3wa7hdc/uVohAEWXAABAFIB9gItAlAAAwALtAEAR1kBAC8rMTATNyEHUhIByRAB9lpaAAEAUv/uAPIAsAAJAAy1CANRWQgWAD8rMTA3NDYzMhUUBiMiUjIsQjIqRDc4QUg1RQAAAf+cAAADOwW2AAMACrMDAwISAD8/MTABASMBAzv8z24DLwW2+koFtgAAAgCL/+wEMwXNAA4AHAAXQAwND0tZDQcFFktZBRkAPysAGD8rMTABFAICBiMiJhE0EhI2MyAFIgYCFRQWMzI2EhE0JgQzUpfYhrCxWZ/XhQFU/qCG14R9h4vSencD+Mn+aP7kj/0BBboBhwEViVji/lDr3tbgAcIBCMfAAAEBYgAAA1IFtgAKAA61BAcJBgEYAD8/zTMxMCEjEzY3BgYHJwEzAhlp4RM3KkPYNAGWWgQfXMkkMohOAQIAAQAnAAAELQXLABkAHkAPBwEPDwpLWQ8HARhMWQEYAD8rABg/KxESADkxMCEhNwE+AjU0JiMiByc2MzIWFRQGBgcBFSEDjfyaFgHBxqxRhIOwnTa01q2/V8TV/oEC4GgBkrHHrl1whIFJkqqYbsXivv6uBAABADf/7AQZBcsAKAAtQBcDGBkZGExZGRkLJiYgS1kmBwsRS1kLGQA/KwAYPysREgA5GC8rERIAOTEwARQGBxUWFhUUBgYjIiYnNRYzMjY1NCYjIzczMjY1NCYjIgcnNjYzMhYEGdS0dYmA559gsUGsrMXVsp51FW7R+H99p7ExVNByobcElqLiHgQYt4eGxmIpIGVWs6ORnGC/o3J6g0tDS6UAAAIAFwAABEQFxQAKABIAIUAQDwcBBRIFS1kJEhIDBwcDGAA/PxI5LzMrEQAzETMxMAEhAyMTITcBMwMhIRISNyMGBwEEL/74UGBQ/VAUA3F21wEJ/pVPUC4EQj/9dQFz/o0Bc2AD8vwGAXEBe6VbS/0VAAEAWP/sBDMFtgAbAC9AGBQaGgAAEk1ZAAAGFhYZTFkWBgYMS1kGGQA/KwAYPysREgA5GC8rEQAzETMxMAEyFhUUACEiJic1FjMyNjU0JiMiBycTIQchAzYCRrzR/tj+/VS7Qaqq0PGqjIVuQsECcBL945ViA2/Mse3+5ygfa1rlx4yfKTECk2D9/B0AAgCq/+wEVgXJABkAKAAtQBcMFwQQIUtZEBAXBAQJS1kEBxcaS1kXGQA/KwAYPysREgA5GC8rERIAOTEwExASJDMyFwcmIyIAAzM2NjMyFhUUBgYjIiYFMjY2NTQmIyIOAhUUFqrSAUnbezsSVlTp/r9JCETAc6GzeN6Sq70BdXCpW4aAUZJwLJEBrAEbAgv3FVoX/qT+uF5iybac+ozulnXPfpKdP293cqS2AAEA9AAABIMFtgAGABZACgAYBQIDAkxZAwYAPysRADMYPzEwMwEhNyEHAfQDHP0CFwNaFPz1BVZgbvq4AAMAYv/sBEIFzQAYACQAMAAjQBMrEwYZBA0ADR9LWQ0ZACVLWQAHAD8rABg/KxESABc5MTABMhYVFAYHFhYVFAYGIyImNTQ2NyYmNTQ2EwYGFRQWMzI2NTQmAyIGFRQWFzY2NTQmAuGjvqjJgnh015my08ndZFjkMtq/m46ozHwTgqlTdMCujQXNqpCKwUxOuXR0uGm5oZ/bTkigZJ/U/RBJvYOIjbaOaKoC4qR5W4hKPqR8bX8AAgBz/+wEIwXJABcAJgAtQBcMBBUfDkxZHx8EFRUYS1kVBwQJTVkEGQA/KwAYPysREgA5GC8rERIAOTEwARACBCMiJzUWMyATIwYjIiY1NDY2MzIWJSIGBhUUFjMyPgI1NCYEI8v+vOdySFdpAdqZCIzjorp33pKuu/6LcKtah31TlW0sjgQI/uD9+PQWWh0CosDSs5v8jOePddB+kaBBbnZ1prQAAAIAZv/uAaQEVgAJABMAF0AMAwhRWQMQEg1RWRIWAD8rABg/KzEwATQ2MzIVFAYjIgM0NjMyFRQGIyIBBDMrQjIqRJ4zLEEzKUQD3TlASDdE/KQ4QUg3QwAC/8v++AGqBFYACAASABdACgUIBQwMEVFZDBAAPysAGBDEL8YxMCUXBgIHIzYSNxM0NjMyFRQGIyIBHwgjp0lJT3waWjMrQjIqRO4XYP7cW4QBFlwC7zlASDdEAAEAiQEGBBsExQAGABG1AAMgAQIFABkvMzMazc0xMAEBNQEVAQEEG/xuA5L83wMhAQYBnkoB12f+cf6iAAIAqAHNBC8D2QADAAcAF0ALBQRTWQUBAQBTWQEALysAGBDGKzEwEzUhFQE1IRWoA4f8eQOHA3VkZP5YYmIAAQCqAQYEPQTFAAYAEbUGAyAFBAEAGS8zMxrNzTEwEwEBNQEVAaoDIfzfA5P8bQFxAV4Bj2f+KUr+YgAAAgCq//IDcwXLABsAJQApQBQIEQAAJBEkH1FZJBYNERELUFkRBAA/KxEAMxg/KxESADkYLxI5MTATNzY2Nz4CNTQmIyIHJzY2MzIWFRQGBw4CBwM0NjMyFRQGIyLyBh1qaHZyO4dzi6gnVa1ln7eEpVVfMxWkMixCMStEAWodhJVJVHuES2x8ZVYxOqmRf9Z3PV9fYP7ROEFHNkUAAgB9/0gGmAWyADkARgBBQCEIQTYSOkZZEhIuNgQLQQtGWRpBQS42LilHWS42IkdZNgMAPysAGC8rERIAORgvMysRADMREjkYLysREgA5MTABFAIGIyImNSMGBiMiJjU0NjYzMhcDBhUUFjMyNjY1NCYmIyIEAhUQACEyNxUGIyIkAjUQEiQhMgQSBSIGBhUUFjMyNjcTJgaYcMVxYnEENp1acIR+5pJ6glQnRUJWlFeC9Krr/oXUATYBGM/V0trL/suo8wGvAQK9ARuf/Vhxt2ZRSWWfLU5CA1qz/t+lbllhZpKBnP6PNP7FjFFHUZP5f5zyhtn+efT+4P6+UlpSpQE51gEUAbPvkf7nP3bVhFxlsqYBIRcAAAL/kQAAA9MFvAAHAA4AHUAOCwQOAUlZDg4DBAMHAxIAPzM/EjkvKxEAMzEwASEBIwEzEyMDAyYnBgYBAyX+AP7hdQM2Q8lpUScfCB5F/vACCP34Bbz6RAJkASPyoD+G/hAAAwBmAAAEngW2AA8AGAAhAC1AFwcQGRAZSVkQEA8AABhJWQADDxpJWQ8SAD8rABg/KxESADkYLysREgA5MTABITIWFRQGBxUWFhUUBCMhASEyNjU0JiMhAwMhMjY1NCYjAZwBe77JtKR9f/7n+v43ARMBFs7WnJf+8IqHAVbJ2bS5BbaonZnAHAQfpXrN7QMrop13e/11/YmvqZGOAAABAKr/7AT0BcsAGAAXQAwTAElZEwQMB0lZDBMAPysAGD8rMTABIgQCFRQWMzI3FQYjIgAREBIkMzIXByYmA8HF/su13c+MpJyg/P700QFo3rGCLTeLBW3R/nDx4fIzXjEBIgEJAQoBvO5EWh4iAAIAZgAABQgFtgAJABIAF0AMBhFJWQYDBRJJWQUSAD8rABg/KzEwARQCBCMhASEgAAEyJBI1ECEjAQUI2/6C//62ATYBMQEaASH8puIBUbn+JM7+7QNv/f5f0QW2/tn7y70BaucB8vsAAAABAGYAAARzBbYACwAmQBQGCUlZBgYBAgIFSVkCAwEKSVkBEgA/KwAYPysREgA5GC8rMTAhIQEhByEDIQchAyEDPf0pATYC1xX9kHUCThX9tIcCcwW2Xv3XXv2NAAEAZgAABGAFtgAJAB1ADwYJSVkGBgIBEgIFSVkCAwA/KwAYPxI5LysxMDMjASEHIQMhByHNZwE2AsQU/aSGAjoV/ccFtl79lF8AAQCq/+wFPQXLAB0AJkAUAB1JWQAABAsLEklZCwQEGUlZBBMAPysAGD8rERIAORgvKzEwASEDBiMgABEQEiQzMhYXByYmIyIEAhUUFjMyNxMhA1gBlpbTwv7//ujSAWXZcbReJm6fWLj+yrLl1Juadf7RAt/9VkkBJAETAQkBteomKF4uINf+fO/l9i8CDgAAAQBmAAAFXAW2AAsAGkANCANJWQgIBQoGAwEFEgA/Mz8zEjkvKzEwISMTIQMjATMDIRMzBCdkl/0IlWcBNmaLAviJZALP/TEFtv13AokAAf/bAAACsgW2AAsAIEAQCQQGBEpZBgMKAwEDSlkBEgA/KxEAMxg/KxEAMzEwISE3NwEnNyEHBwEXAX/+XA6kARWeCgGkCqD+6pk/CwUgC0FBC/rgCwAB/rz+mAH0BbYADQARtwkDAAZJWQAiAD8rABg/MTADIiYnNxYzMjcBMwEGBrQwUBALOVDVMQE1af7GI7T+mBAIXBTxBc36LaqhAAEAZgAABRsFtgAMABhADAgDAgwEBQoGAwEFEgA/Mz8zEhc5MTAhIwEHAyMBMwM3ATMBA9Nv/qq+g2cBNmaehQKoiv1FAxSZ/YUFtv0teQJa/Z4AAAEAZgAAA04FtgAFABG3AQMAA0lZABIAPysAGD8xMDMBMwEhB2YBNmb+3wJtFwW2+qpgAAABAG0AAAZ3BbYAEwAZQAwAEAEMBwMRAwoEEBIAPzMzPxczETMxMCUBMwEjExI3IwEjAyMGAwMjATMTAwQC3Zb+02W/TxUG/PQz3gYUOsRgATWPzc0E6fpKA4UBcU76vAVEmv7w/GYFtvsXAAABAGYAAAViBbYADwAStwMOCAMLAQcSAD8zMz8zMzEwISMBIwYGAyMBMwEzNjcTMwQtVv38CBcyvV8BNlACCggXM7xeBQSV+PyJBbb68rDwA24AAgCs/+wFewXLAA0AGwAXQAwLDklZCwQEFUlZBBMAPysAGD8rMTABFAIEIyIAERASJDMyACUiBAIVFBIzMiQSNTQmBXu8/sTP+v7yugFE0/cBB/30rv7zoNvSqQEGntEDj//+O98BKgEZAQYBr+f+18vK/nbc9f8AxQGT5fD4AAACAGYAAAR5BbYACQARAB1ADwoDSVkKCgYFEgYRSVkGAwA/KwAYPxI5LysxMAEQISMDIwEhMhYBMzI2NRAhIwR5/Z7JgWcBNgE7ytj85b/88/630wRO/gz9pgW2uf25wdEBEgAAAgCs/qQFewXLABEAHwAjQBEEBw8GCA8SSVkPBAgZSVkIEwA/KwAYPysAGBDGEjk5MTABFAIGBwEjAwciABEQEiQzMgAlIgQCFRQSMzIkEjU0JgV7jOmeAQuO50r6/vK6AUTT9wEH/fSu/vOg29KpAQae0QOP2P5s9C3+ogFMBAEqARkBBgGv5/7Xy8r+dtz1/wDFAZPl8PgAAAIAZgAABHkFtgANABUAKEAUCQ0DAA4ASVkODgMMAhIDFUlZAwMAPysAGD8zEjkvKxESADk5MTABAyMBISARFAYHEhcjAyUzMjY1ECEjAVCDZwE2AS8Brs+yyRRv0/7T/NDa/rfTAnn9hwW2/pi28h/9sTgCeVy/ugEMAAABACX/7AQMBcsAKQAgQBANIwQZGSBKWRkEBApJWQQTAD8rABg/KxESADk5MTABFAYGIyImJzUWMzI2NTQuAicmJjU0NjYzMhYXByYmIyIGFRQWFx4CA3+D5JtYqVejubzXIkdvTJZ3dtSDY6JXIEKrT6PBYoWadzsBk37FZCIpbVytkj1XRkIqTLB2drNjIyteKC6liGeGQk9mfAABAMEAAASiBbYABwAWQAoBEgcDBANJWQQDAD8rEQAzGD8xMCEjASE3IQchAbZmASH+UBQDzRP+SAVYXl4AAAEAsP/sBXMFtgATABRACRMJAwQPSVkEEwA/KwAYPzMxMAEDAgQjIBE0NxMzAwYVECEyNjcTBXPPOv7q7P5IG7pnwRQBVsPhLs8Ftvwv/vLrAZFTdgNw/H1ZX/7Lwd4D0QAAAQDJAAAE9gW2AAsAELYLBgMHAwYSAD8/MxEzMTAlNjcBMwEjAzMTFhcByTNJAjx1/OFYtmR1GgmTb4gELPpKBbb8StmUAAEA7gAABzsFtgAeABdADA0VHgMFAxoKEgMEEgA/FzM/FzMxMAEGBgEjAzMTFwczNjcBMxMSFTM2NgEzAgADIwMmNTcD+htG/fBSSWQvBAIGVVUBsmk9EwYePwHObKn+vadOTgsBBT1Mm/uqBbb7+aVW4qwDdPyS/vaQVpoEGP6T/ST+kwQzjk0vAAH/eQAABH0FtgALABVACQgCBAkGAwEEEgA/Mz8zEjk5MTAhIwMBIwEBMxMBMwEDb2v+/fJ/AmD+8GrwAeN3/dUCpv1aAv4CuP2OAnL9MQAAAQDBAAAEgwW2AAgAELYABQEHAwUSAD8/MxI5MTABATMBAyMTAzMB7gIgdf2JbGl37WQChQMx/Fz97gIhA5UAAAH/9AAABMkFtgAJACBAEAIIBwQFBElZBQMBCElZARIAPysAGD8rEQAzETMxMCEhNwEhNyEHASEDkfxjFgQt/QQXA3cT+9MDH1wE/F5Y+wAAAf/H/rwC7AW2AAcADrUFAgMGAScAPzM/MzEwASEBIQchASEBcf5WAXgBrRP+tv6sAUr+vAb6Wvm7AAEA0QAAAhkFtgADAAqzAwMCEgA/PzEwARMjAwEn8lL2Bbb6SgW2AAAB/1D+vAJ1BbYABwAOtQcAAwQDJwA/Mz8yMTATIQEhNyEBIcsBqv6H/lQSAUoBVP62Bbb5BlsGRQAAAQBGAjkD8AXDAAYADbQABAUBAwA/M8QyMTATATMBIwMBRgJLWwEEadn+DAI5A4r8dgMp/NcAAf9K/t0Cg/8zAAMAEUAJAQUCFQIlAgMCAC9dMzEwASE3IQJx/NkSAyf+3VYAAAEB5wTZAv4GIQAIAAqyBoABAC8azTEwASMmJic1MxYXAv5CMoAjcy52BNk0uUYVga4AAgBm/+wENwRQABEAIQAnQBQJAgAMBA8HFQAbRlkAEAwSR1kMFgA/KwAYPysAGD8/ERI5OTEwATIXMzczAyMTIwYGIyARNBI2AzI+AjU0JiYjIgYCFRQWAo/oLwY7UOVSLQZUzob+55b7YVmxjUo0Zkx8yIBkBFDbyvvBARKOmAF2xQFmw/v2fND8V099SaT+uaKYjwAAAgBM//AEHQYUABMAIgAnQBQKBAAOBwAGFQ4UR1kOEAAcRlkAFgA/KwAYPysAGD8/ERI5OTEwBSImJyMHIwEzAgczNjYzIBEUAgYTIg4CFRQWMzI2EjU0JgH0cZIYBjdQAUdfgx8GXdR9ARmY+mNbso9GgGZ8yIBiEHZr0QYU/Yx7nJP+icv+nsAECnvY/k+Bk6YBRKOYjwABAGb/7AOJBFAAGAAXQAwHDEZZBxAAE0dZABYAPysAGD8rMTAFIiY1NBI2MzIXByYjIgYCFRQWMzI2NxUGAd2uyZP6pYZrHGtvgc92k4dHeUd0FN3EwQFRsStaL5r+3q+eqxohXDkAAAIAZv/sBJwGFAARAB8AJ0AUAgoMAAUACBUAGkZZABAMEkdZDBYAPysAGD8rABg/PxESOTkxMAEyFzM2EzMBIxMjAiMgETQSNgMyPgI1NCYjIgYCFRACj+YxBAyDY/62Ui0Grfv+54/8W1mzjUh7a3zIgARQ20ICXfnsARL+2gF2wQFiy/v2fdP7VH6Xpv7BqP7ZAAACAGb/7AN9BFAAFwAgACZAFBsORlkbGwAHBxhGWQcQABNHWQAWAD8rABg/KxESADkYLysxMAUiJjU0EjYzMhYVFAQhIwYVFBYzMjcVBhMiBgczIBE0JgHVrcKO+ZZyiP65/r4hBpSLhJCMA4PhMjECBVcU28S1AUzEemm1viw2pa1JXkUEDufBAQ5DVwAAAf8X/hQDcQYfAB8AJ0AVEBVGWRABHAoMCkhZGQwPAAVHWQAbAD8rABg/MysRADMYPysxMAMiJzUWMzI2NxMjPwI2NjMyFwcmIyIGBwczByMDBgaDMDY1L1hcHfbNDs0jI6OSSV0ZVzxgcxsj+BD4/CGO/hQTWhBqhQSOQw6gqJgfUBtrfaRR+1qhkwAD/6j+FARMBFQAKgA3AEUASEAoKgJHWSoPHTU1EUhZBSELAwkoCTtGWTUJNQkYKChCRlkoEBguRlkYGwA/KwAYPysREgA5ORgvLysREgAXOSsRADMYPysxMAEHBxYWFRQGBiMiJwYGFRQWFxcEFRQGBiMiJjU0JSY1NDcmJjU0NjYzMhcBFBYzMjY1NCYnJwYGARQWMzI2NjU0JiMiBgYETBHzGiNtu3g/DlBYP1J5AVqC9Km60wE1Tr9HT2u9cEVO/Suij8vkfZygnYoBD3VqWIRJcGVdiEoEP08LHHA6bcNgCSFQKSkvCAsf6XCrXJCD7GIqUXtPJItYb7pqFfryZWKVglVbDA8tiwMzcHRKmlxoc1aSAAEATAAABAoGFAAbABxADhEMFRUGRlkVEA0AAAwVAD8zPz8rERIAOTEwIRM2NTQmIyIGBgcDIwEzAwYHMzY2MzIWFRQHAwL8lRVXW3DFhyRmYgFMYFYsFgZO2Xl8iBiUArRcQFBahvKl/iMGFP5lyE9xfYJ2RnD9XgAAAgBMAAAB6QXPAAMADgAOtQwHAg8BFQA/P8QyMTAzIxMzAzQ2MzIVFAYjIiauYudgNSwmOSwjHR8EPwEXN0JIOUInAAAC/un+FAHpBc8ADQAYABZAChYRCQ8ABUdZABsAPysAGD/EMjEwAyInNRYzMjY3ATMBBgYBNDYzMhUUBiMiJqY+My9CUl0aAQpg/vQjjwGPLCY5LCMdH/4UE1wWZ34E7fsJpY8HQjdCSDlCJwABAEwAAAPsBhQADQAbQA4NBgcDBAkBCgABDwUJFQA/Mz8/ERIXOTEwAQEzAQEjAQcDIwEzAwMBDgJhff4mASlq/vjNUGABSmCmRgHdAmL+K/2WAi+8/o0GFPz0/tUAAQBMAAAB+AYUAAMACrMCAAEVAD8/MTAzIwEzql4BTl4GFAAAAQBIAAAGXgRQACsAJUASDhULDA8AIQsVJwUSBUZZGRIQAD8zKxEAMxg/MzM/Ejk5MTAhEzY1NCMiBgYHAyMTMwczNjYzMhYXMzY2MzIWFRQGBwMjEzY1NCYjIgIHAwLHkxmaaryCI2Ri51AhBlDLb2pyAwZN0HZ1gwURmGSVGVZMnfEwbQKifSW2h/Km/iUEP9JxcoaAgYV7cx03XP1OAqh4OE1V/u3h/foAAAEATAAABAoEUAAYABxADg8MEhIGRlkSEA0PAAwVAD8zPz8rERIAOTEwIRM2NTQmIyIGBgcDIxMzBzM2MzIWFRQHAwL8lRVXW3DFhyRmYudSJQak/IKCGJQCtFxAUFqG8ab+IwQ/3e6AeEZw/V4AAgBi/+wEAgRUAA0AGgAXQAwADkZZABAHFEZZBxYAPysAGD8rMTABMhYVFAIGIyImNTQSNhciBgIVECEyNhI1NCYCibTFj/iiuL+S+JV8xnYBGn/FdZIEVNm/xf6ptNvMvwFOtFad/tuk/qqbAS20mqYAAv/f/hQEGwRUABMAIQAmQBQDCQANDRRHWQ0QBw8GGwAcRlkAFgA/KwAYPz8/KxESADk5MTAFIicjBgMjATMDMzY2MzIWFRQCBhMiBgYCFRQWMzI2EjUQAfLmMQQNiGMBUFItBlvRfIeSkPtcV66VSHtrfMp+ENtI/ZEGK/7umY65vsP+oMoECnXa/v9QfZeoAT+mAScAAgBi/isEMwRQABMAIgAnQBQDCw4ABQ8IGwAcRlkAEA4UR1kOFgA/KwAYPysAGD8/ERI5OTEwATIWFzM3MwEjExMjBgYjIBE0EjYDMj4CNTQmIyIGAhUUFgKLbZUZBjdQ/rlfYkAGXdR9/ueX+mJctI1Ff2d8yIBbBFB0bdD57AHWARqckwF2yQFkwfv2fdr/SYKTpv68o4+YAAEASAAAA0QEUgASABtADQ4LAAwPCxUABUdZABAAPysAGD8/ERI5MTABMhcHJiMiBgIHAyMTMwczPgICyUU2FS9CXqqIIGRi51AdBklkcQRSDl0PgP8Alf4fBD/MXlMuAAEAGf/sAzEEUAAmACBAEAwfAxYWHEZZFhADCUZZAxYAPysAGD8rERIAOTkxMAEUBiMiJzUWFjMyNjU0JiYnJiY1NDYzMhYXByYjIgYVFBYWFx4CAsnOsa2ESp5FipIfRWKUaMWhS6c5I4iAdIwiV0xyXy0BJ5CrS2suMnNqKkA7OFCDXoCjIx1YQGpVN0JHKT9RXAABAHH/7AK2BT8AGAAnQBMWGEASAhQYGAJIWRgPDAdGWQwWAD8rABg/KxEAMxEzGhgQzTEwAQchAwYVFDMyNxUGIyImNTQ3EyM/AjMDArYS/uWHFn5EVGVFY2wdgbYOuGE3NwQ/Uf2FY0GLGlYcbWhJhQJfQxH9/wAAAAEAbf/wBCsEPwAYABtADRASCxgPDhUSBkZZEhYAPysAGD8/MxI5MTABAwYVFBYzMjY2NxMzAyM3IwYjIiY1NDcTAX2YFl9bbsOFIWli51AcBqfsg4cWlgQ//UZqNEpXg/OeAeX7wc3dfHc8bgKyAAABAGgAAAPdBD8ACwAOtQkBDwUAFQA/Mj8zMTAhAzMTFhczNjcBMwEBFKxlbBoHBjNOAZZm/agEP/0hpVlzjQLd+8EAAAEAeQAABa4EPwAaABlADBUMEBgEAwkPDAAIFQA/MzM/FzMRMzEwIQMmNSMGBwEjAzMTBzM2NwEzExYVMzc3ATMBA0Y8DgYibv6cdRRcDQMGPVkBdU1ADgYYZQFAYP4EAq7gKlzG/WoEP/zLnYajAqn9V5OWPewCqfvBAAAB/7gAAAO6BD8ACwAVQAkGAAIHBA8LAhUAPzM/MxI5OTEwAQEjAQMzEwEzAQEjAbr+d3kB1/VkzwF1eP5AAQJiAeP+HQIvAhD+MgHO/er91wAAAf8n/hQD8AQ/ABcAGkAMFwQRCAAPDhNGWQ4bAD8rABg/MxI5OTEwEzMTEhczNhMBMwEOAiMiJzUWMzI2Njd7ZFIzBAsrjwFcZ/03SGV/U0Q9R0JQhn4lBD/93P6hYmkBBgJ2+vZ/ZjwVXBtj5kUAAAH/4wAAA38EPwAJACBAEAIIBwQFBEhZBQ8BCEZZARUAPysAGD8rEQAzETMxMCEhNwEhNyEHASECvP0nDwMI/eERApMS/QYCWkgDpFNT/GgAAQA7/rwDHwW2ACgAKUAWHAkJCk9ZCQkRAAAnT1kRE09ZEQMAJwA/PysrERIAORgvKxEAMzEwASA1NDc3NjU0IzcyNjcTNjYzMwcOAgcDBgYHFRYWFRQHBwYVFBYzFQGo/wAQOBLHFX6CGFkemIsdEVZWNRJKHntnREsYLw1LZf68xy1G/Foln05ibQGJh3lWAiVWTf6uhnkSBBJlRzRw4TorPThWAAECSP4CAqwGGQADAAqzAAADHAA/PzEwATMRIwJIZGQGGffpAAH/1/68ArAFtgArACZAFR4MDAtPWQwUKysqT1kUFU9ZFCcrAwA/PysrERIAOSsRADMxMAEyFhUUBwcGFRQWMwciBgcDBgYjIzU+AjcTNjY3NSYmNTQ3EzY1NCYmIzcBTIN1ETcTY2QUfYQYWCCZiRJgVDURSht5bEtFEjYMJEhQFAW2ZmApSvxfIE1TTmFt/naLdVYCJlRPAVJ+fxMFFGlBN0wBAj0oLDIWVgABAH8CaAQzAz0AFQAeQA4DEQ4GEQtSWREGAFJZBgAvKwAYLysRADMRMzEwASIGBzU2MzIWFxYzMjY3FQYjIicmJgFeMXY4bH09bGZ+XTZrQG96dZo+ZQLpPTtebhssOjpDYHFIHRwAAAIABP6JAbAEUAADAA0AGEALAAAMAyIMB1FZDBAAPysAGD8SOS8xMAEzAyMBFAYjIjU0NjMyAQg+y3cBrDIsQjIrQwLH+8IFfThBSDdEAAEA+v/sBB0FywAdAChAFQkRTVkMCQIdGB1LWQkYCRgBCgcBGQA/PxI5OS8vKxEAMxEzKzEwBSM3JiY1NBI2NzczBxYXByYjIgYCFRQWMzI3FQYjAkJdLYSUf+WOJFomdGUda26CzneVhn+JdqMU1xnXpbgBOsAPsrAEJ1ovmP7esaSmPFw6AAAB//wAAASoBccAHgAtQBcNGRoZTVkKGhoTAAAGS1kABxMQTFkTGAA/KwAYPysREgA5GC8zKxEAMzEwATIXBycmIyIGBwMhByEDBgchByE3NjY3EyM3MxM2NgNvqo8nNmx7hq0fSQGZEv5oOTKKAvcU/FYQXZEjOccRxkwp5AXHTlQaMpWS/qxS/vThWV5UC6mYAQRSAV67uAAAAgDPATMEEgR1ABsAKABEQCQKBAcSGBUTEAwJFxoCBQUCGhcJDBATCBUHFR9SWRUHByZSWQcALysAGBDEKxESABc5GC8vLy8vLy8vEMYyEMYyMTABNDcnNxc2MzIXNxcHFhUUBxcHJwYjIicHJzcmNxQWMzI2NTQmJiMiBgEGSoE/f2l9dmmDPYFOToE9g2h3fmaBPX9KWKB1daNJhEtyowLTdmuBQIFOToE+gWp5h1x/Pn9MUIE+f2J/dKGic0uCTqQAAAEApgAABN0FtgAWAEBAIwYSAAMTExJNWQ8THxMvEwMJAxMPCg4PDk1ZBw8PDAEVBgwYAD8/MxI5LzMrEQAzGBDEX15dKxEAMzMRMzEwAQEzASEHIQchByEDIxMhNyE3ITchAzMCSAIgdf3RAQoQ/sUnAT0S/sQ7aUD+1RIBKyn+0xEBAtdkAoUDMfzJTL5U/t8BIVS+TAM3AAACAkL+AgKmBhkAAwAHABVACQMEAwQHAAAHHAA/PxE5OS8vMTABMxEjETMRIwJCZGRkZAYZ/Qz90f0MAAACAGb//gPuBhcALwA8ACdAFxIGHSoDMDcbCCEKCg9GWQoAISdGWSEVAD8rABg/KxESABc5MTATNDY3JiY1NDY2MzIXByYjIgYVFBYXHgIVFAcWFRQGBiMiJzUWFjMyNjU0JicmJgEGBhUUFhYXNjY1NCbTi4FAT1ytdKN+H4p+fJ1ciXBdMfl6YLeCnXYvnkqVnlV8m3EBXHeJMXGDZ3ZzAwplojEfbUJKeUQ6UDZdTTtbPTRLXz/FeECFVodMNWMbJ2liPlg0QYIBYh6HVzlPQzAxgVxIbAACAewFFwPHBcEACQATAAyzDQMSCAAvM80yMTABNDYzMhUUBiMiJTQ2MzIVFAYjIgNEKSQ2KiI3/qgpJDYqIjcFVjE6QDA6PzE6QDA6AAADAJP/7AZzBcsAFQAlADUAP0AmCwZHWREAR1kPCx8LAgAREBECCQMLEQsRIhoaMkdZGgQiKkdZIhMAPysAGD8rERIAOTkYLy9fXl1dKysxMAEiBhUUFjMyNxUGIyImNTQ2MzIXByYBNBIkMzIEEhUUAgQjIiQCNxQSBDMyJBI1NAIkIyIEAgOwjqGVklVyaGm7yty7d2wkY/yHyAFeysgBXsrC/qLQz/6iw12xATCyrgEuuLL+0bO2/s6rBES9qrqyK1gt6NbP+jRTLf6XyAFeysj+osrF/qbQzwFaxrL+0bKrATO1sgEwsrj+0gAAAgCqAysC9gXNABEAHgAmQBMKBAwADBJUWQgMAAUfABpUWQAfAD8rABg/EMQyKxESADk5MTABMhYXMzczAyM3IwYjIiY1NBITMjY3NjU0JiMiBhUUAec3VRgGI0KJSBYEYH9QXrUSQoceEEg5XocFzTo5Z/12fYlxbL0BCP2ol20zSDpV36CPAAIAPQB7A0wDpAAGAA0AJEAPCwcJBAACIA0MCQYFAgkCABkvLxEzMxEzMxoQzc0Qzc0xMAEXARMHAzcBFwETBwM3Aao5/sPVQP4CAtM6/sbRP/4CA6Qx/rD+fycBohoBbTH+sP5/JwGiGgABAH0BEAQEAwQABQARtgIFBQRTWQUALysAGBDEMTABESMRITUEBGT83QME/gwBkGQA//8ATQH2AigCUAAGABD7AAAEAJb/7AZ1BcsABwAVACUANQBSQC4LEg8PAEhZDw8REhIHRlkNDxEfEQIAEhASAgkDERIREiIaGjJHWRoEIipHWSITAD8rABg/KxESADk5GC8vX15dXTMrERIAORgvKxESADkxMAEzMjY1NCMjBRQGBxMjAyMRIxEzMhYBNBIkMzIEEhUUAgQjIiQCNxQSBDMyJBI1NAIkIyIEAgL2cF1mxW4Bm09G7XjTqGXTj578Bc8BWsbIAV7Kwv6i0Mz+p8pcsQEwsq4BLriy/tGztv7OqwLbXVmsp1B6IP53AWj+mANwfP7EzwFew8j+osrF/qbQyQFZzbL+0bKrATO1sgEwsrj+0gAAAQFcBhQEHwZ1AAMAC7QCAUlZAgAvKzEwASE3IQPp/XM1Ao4GFGEAAAIA8gOBAzsFywALABcAGkANCQ9SWQkJAwMVUlkDBAA/KxEAMxgvKzEwEzQ2MzIWFRQGIyImNxQWMzI2NTQmIyIG8qp7eqqreXqrSYFbXH+AW1qCBKZ4ra14equrelmAgFlag4MAAAIAfwAABAYEbQALAA8AHkAOAAkDBgYJU1kGDA1TWQwALysAGC8rEQAzETMxMAEhNSERMxEhFSERIwU1IRUCEP5vAZFlAZH+b2X+bwOHAnViAZb+amL+cOVkZAAAAQBSAkoCyQXHABcAG0AODglOWQ4fAhYBFk5ZASAAPysRADMYPysxMAEhNwE2NjU0JiMiByc2MzIWFhUUBgcFIQJc/fYQASmJW01DX2MpbINJaDV2fP72AaACSlABAnaRUTtMTD5aNlo3arlm3wABAG0COQLBBckAJwAtQBcEGRgZGE5ZGRkLJSUgTlklHwsSTlkLIQA/KwAYPysREgA5GC8rERIAOTEwARQGBxUWFhUUBgYjIiYnNRYWMzI2NTQjIzczMjY1NCYjIgcnNjMyFgLBYWpCT06MWzuBKS58P2N4xFQQVmaFS0RkYyhtjmR2BPxVfhkEEGhITYBGHxlaHChpWqJPY1BERURAVnEAAQJEBNkD5QYhAAkACrIEgAkALxrNMTABNjY3MxUGBgcjAkRCqS2JM9VWQwTuM7ZKF0K5NgAAAf/j/hQESAQ/ABsAIEAQEw0PCBgPCxUXGw8DRlkPFgA/KwAYPz8/MxI5OTEwNxQWMzI2NjcTMwMjNyMGIyImJyMGBwMjATMDBu5hV27CgyRoY+pOHQak8FVsFgYSIT9hAVJlmBTyUlqB7KcB5fvBzd1BOYSY/sYGK/1GYAAAAQDX/vwEuAYUAA8AIUAPAQUGAwgIBQNAAw5JWQMDAD8rABoYEM05LxI5ETMxMAEjESMRIxEGIyImNRA2MyEEuGTjZUBR2Mza6QIe/vwGuvlGAzMS+vsBBP7//wDPAnEBbwMzAAcAEQB9AoMAAf9S/hQAxQAAABAAELUPDAwIAw4AL8wyOS8zMTATFAYjIic1FjMyNTQnNzMHFsWXji4gHirGl25QToz+315tB08Gc2EKvokeAAABAP4CSgJQBbYADQAQtgwMAyAJAB4APzI/OS8xMAEzAyMTPgM3BgYHJwIAULpUdgUNDxAHIjR1JwW2/JQCORU7PTkVHylJOwACAL4DJwLnBccADQAaABhADAcUVFkHAAAOVFkAHwA/KwAYEMQrMTABMhYVFAYGIyImNTQ2NhciBgYVFDMyNjY1NCYCBml4UJRlcm5TlVZGbDycSWk6TgXHgHRzxnOHdXDDcUpdnFm6XaJfU1sAAAIAIQB7Ay8DpAAGAA0AJEAPAAQCBgUCBwsJIA0MCQIJABkvLxEzMxoQzc0RMzMQzc0xMCUnAQM3EwcBJwEDNxMHAcM6ATrRP/4C/S05ATnRQP4CezEBUAGBJ/5eG/6UMQFQAYEn/l4bAP//AIEAAAU4BbYAJwI8Apb9twAnAhcCUAAAAQYAe/0AAAmzAQACGAA/NTUA//8ANQAABWsFtgAnAHQCov23ACYAe68AAQcCFwIEAAAAB7IAARgAPzUA//8ARwAABX8FyQAnAjwC0/23ACYAddoAAQcCFwKkAAAACbMBAAIYAD81NQAAAgAA/m0CyQRGABsAJQAnQBMIGxsRJCQfUVkkDw0REQtQWREjAD8rEQAzGD8rERIAORgvOTEwAQcGBgcOAhUUFjMyNxcGBiMiJjU0Njc+AjcTFAYjIjU0NjMyAoEGHGZudnI7g3eNpyZVq2aft4ydVWExFaQzLEEyKkQCzR1/klFUe4RLan1kVjE5qZCF13E9YF5fAS84QUg4QwD///+RAAAD0wdzAiYAJAAAAQcAQwAxAVIACLMCEAUmACs1////kQAABD0HcwImACQAAAEHAHYAWAFSAAizAhgFJgArNf///5EAAAPvB3MCJgAkAAABBwFLADEBUgAIswIWBSYAKzX///+RAAAEVgcXAiYAJAAAAQcBUgBQAVIACLMCGQUmACs1////kQAAA/IHEwImACQAAAEHAGoAKwFSAAq0AwIhBSYAKzU1////kQAAA9MHAAImACQAAAEHAVD/6gCYABdADgMCfxKPEgI/EgEPEgESABFdXXE1NQAAAv+LAAAGsAW2AA8AEwA0QB0JEwYTSVkQA0lZCg1JWRAKEAoBBgMFAQEOSVkBEgA/KxEAMxg/Ejk5Ly8rKysRADMxMCEhEyEBIwEhByEDIQchAyEBIRMjBXv9KW7+RP64gwOyA3MU/Y91Ak4U/bSHAnL8CQGRnFgCCv32BbZe/dde/Y0CFQLl//8Aqv4UBPQFywImACYAAAAHAHoCKwAA//8AZgAABHMHcwImACgAAAEHAEMAfQFSAAizAQ0FJgArNf//AGYAAARzB3MCJgAoAAABBwB2AEoBUgAIswEVBSYAKzX//wBmAAAEcwdzAiYAKAAAAQcBSwBOAVIACLMBEwUmACs1//8AZgAABHMHEwImACgAAAEHAGoAQgFSAAq0AgEeBSYAKzU1////2wAAArIHcwImACwAAAEHAEP/RQFSAAizAQ0FJgArNf///9sAAAM+B3MCJgAsAAABBwB2/1kBUgAIswEVBSYAKzX////bAAAC9gdzAiYALAAAAQcBS/84AVIACLMBEwUmACs1////2wAAAv0HEwImACwAAAEHAGr/NgFSAAq0AgEeBSYAKzU1AAIAWgAABQgFtgANABoALUAXGQcIB0lZFggIBQoKFUlZCgMFGklZBRIAPysAGD8rERIAORgvMysRADMxMAEUAgQjIRMjNzMTISAAATIkEjUQISMDIQchAwUI2/6C//62kJwVm5IBMQEaASH8puIBUbn+JM6BAXoU/oV9A2/9/l/RAqRgArL+2fvLvQFq5wHy/apg/bYA//8AZgAABWIHFwImADEAAAEHAVIA5wFSAAizARoFJgArNf//AKz/7AV7B3MCJgAyAAABBwBDAN8BUgAIswIdBSYAKzX//wCs/+wFewdzAiYAMgAAAQcAdgEIAVIACLMCJQUmACs1//8ArP/sBXsHcwImADIAAAEHAUsA1QFSAAizAiMFJgArNf//AKz/7AV7BxcCJgAyAAABBwFSAPYBUgAIswImBSYAKzX//wCs/+wFewcTAiYAMgAAAQcAagDDAVIACrQDAi4FJgArNTUAAQDdAUQD/gRkAAsAErYJAwIKCAQCAC8zLzMSOTkxMAEBNwEBFwEBBwEBJwIn/rZGAUoBTUT+tAFMRP6z/rZEAtMBTEX+twFJQ/6y/rRDAUn+uUMAAwCL/7IFqAX6ABcAIgAsAC5AGiEmJyAEKRgSFQcKBAUQEBhJWRAEBSlJWQUTAD8rABg/KxESABc5ERIXOTEwARQCBgQjIicHJzcmNRASJDMyFzcXBxYWASIGBgIVFBYXASYTNCYnARYzMiQSBXtouf77odeFi0KScbwBRdDbhYVGkS03/fSG3J1cKyMDOmvdIxr8y2u6qgEGnQOPu/6b/IdwqkCslfwBBwGx5HmoNbcz3AFud93+xqJprDQECHH+GFWuKvv6ZMgBiQD//wCw/+wFcwdzAiYAOAAAAQcAQwC0AVIACLMBFQUmACs1//8AsP/sBXMHcwImADgAAAEHAHYBAgFSAAizAR0FJgArNf//ALD/7AVzB3MCJgA4AAABBwFLAL4BUgAIswEbBSYAKzX//wCw/+wFcwcTAiYAOAAAAQcAagC6AVIACrQCASYFJgArNTX//wDBAAAEgwdzAiYAPAAAAQcAdv/vAVIACLMBEgUmACs1AAIAZgAABD8FtgAMABQAH0ARCRRJWQ0ESVkJDQkNBgcDBhIAPz8SOTkvLysrMTABFAQhIwMjATMDMzIWATMgNjUQISMEP/7O/tDJR2cBNmY51cjZ/Oa+AQDw/rbTA0T3/f6wBbb+9rn9ucXMARMAAf7n/hQEAgYfADwAL0AbMw4sFBomBh0LCzZGWQsAHSNHWR0WAAVHWQAbAD8rABg/KwAYPysREgAXOTEwAyInNRYzMjY3ARIhMhYVFAYHBgYVFBYXFhYVFAYjIic1FhYzMjY1NCYnJiY1NDY2NzY2NTQmIyIGBwEGBqJJLjU+T1gWATFQAUWJnFl6a0VEO2BU1bSPWy2HPoSZP05SSipPYmU9bl+BmCD+3SGN/hQXWhhlZwWBAWV7cUuDU0xhOjNLJj+NX6rGQW0kLo58S2w2OmlFOVxVR0ZcN0ZQmJn6n5iJ//8AZv/sBDcGIQImAEQAAAEGAEMrAAAIswIjESYAKzX//wBm/+wENwYhAiYARAAAAQYAdgYAAAizAisRJgArNf//AGb/7AQ3BiMCJgBEAAABBgFL/QIACLMCKREmACs1//8AZv/sBDcFxQImAEQAAAEGAVIbAAAIswIsESYAKzX//wBm/+wENwXBAiYARAAAAQYAav8AAAq0AwI0ESYAKzU1//8AZv/sBDcGaAImAEQAAAEGAVDYAAAKtAMCJREmACs1NQADAGb/7AYfBFAALAA8AEYAREAlBwMVGAQKEUAhRllAQAoRFg8FFT02ETZGWRoRECYtCi1HWQAKFgA/MysRADMYPzMrEQAzGD8/ERI5LysREgAXOTEwBSImJwcjNyMGBiMiJjU0EjYzMhYXMzczBzYzMhYVFAQhIwYVFBYzMjY3FQYGJTI+AzU0JiMiBgIVFBYBIgYHMyA2NTQmBIN7sB0nTSkJXr5xeHyN9JhqeA4KO0Iji9Nwfv7D/sgnCIuURYFCUIb8pUOPfVcoYlx7yHFVBAN34jswAQfwTRR4ac3+joS8sM4BZcVxZMC6z3tvs7kzLaGzKh9eJSBaVJe+0D12iKz+zLqWhAO058GGiEdT//8AZv4UA4kEUAImAEYAAAAHAHoBeQAA//8AZv/sA30GIQImAEgAAAEGAEPxAAAIswIiESYAKzX//wBm/+wDtQYhAiYASAAAAQYAdtAAAAizAioRJgArNf//AGb/7AOIBiECJgBIAAABBgFLygAACLMCKBEmACs1//8AZv/sA48FwQImAEgAAAEGAGrIAAAKtAMCMxEmACs1Nf//AEwAAAHGBiECJgDzAAABBwBD/sgAAAAIswEFESYAKzX//wBMAAACvQYhAiYA8wAAAQcAdv7YAAAACLMBDREmACs1//8ATAAAAoIGIQImAPMAAAEHAUv+xAAAAAizAQsRJgArNf//AEwAAAKGBcECJgDzAAABBwBq/r8AAAAKtAIBFhEmACs1NQACAGb/7ARMBiMAHwAuADhAHQYJAB0EHgcZDx4eFgMWKEdZFhYPBwMBDyBHWQ8WAD8rABg/MxI5LysREgA5GC8RORESFzkxMAEmJzcWFhclFwUWEhUQACEiJjU0EjYzMhYXMzQCJwUnEzI2NjU0JiYjIgYGFRQWAsk2aDsgYjMBCif/AFdZ/uX+/rHIfueTa6IoBVZI/tknPXa1a0aCW3yzYJMFVDxPRBpQNpZKjXT+wK/+nf5w1byqAQeQY12LASxdo0n7jnr7kU2CSXvYjJmmAP//AEwAAAQxBcUCJgBRAAABBgFSKwAACLMBIxEmACs1//8AYv/sBAIGIQImAFIAAAEGAEPqAAAIswIcESYAKzX//wBi/+wEAgYhAiYAUgAAAQYAdvkAAAizAiQRJgArNf//AGL/7AQCBiECJgBSAAABBgFL7wAACLMCIhEmACs1//8AYv/sBA4FxQImAFIAAAEGAVIIAAAIswIlESYAKzX//wBi/+wEAgXBAiYAUgAAAQYAaugAAAq0AwItESYAKzU1AAMAqAEKBC8EmgADAA0AFwAoQBQWEBABBgAMEAwCCQMMDAEBAFNZAQAvKxEAMxgvX15dMxEzLzMxMBM1IRUBNDMyFhUUBiMiETQzMhYVFAYjIqgDh/3bYDAzOilgYC41OilgAqBkZP7VajczOTIDJWs3NDkxAAADAC3/uAQxBIcAFQAeACcANEAdJiUZGAQbHwgLABMEBhQRCQYGH0ZZBhARG0ZZERYAPysAGD8rEQAzETMSFzkREhc5MTA3JjU0EjYzMhc3FwcWFRQCBiMiJwcnATQnARYzMjYSASIGAhUUFwEmpEKS+J2WZG1BdUaP+KKjW25AA28j/aBDh3/Fdf7lfMZ2IAJdSn9qqr8BTrRShTWPaZ7F/qm0U4c2AtBlTv0aSZsBLQH0nf7bpH1IAuNI//8Abf/wBCsGIQImAFgAAAEGAEMIAAAIswEaESYAKzX//wBt//AEKwYhAiYAWAAAAQYAdi8AAAizASIRJgArNf//AG3/8AQrBiECJgBYAAABBgFL/wAACLMBIBEmACs1//8Abf/wBCsFwQImAFgAAAEGAGr3AAAKtAIBKxEmACs1Nf///yf+FAPwBiECJgBcAAABBgB2tQAACLMBIREmACs1AAL/3/4UBBsGFAAUACIAJ0AUCgMADgcABhsOFUdZDhAAHUZZABYAPysAGD8rABg/PxESOTkxMAUiJyMGAyMBMwIHMzY2MzIWFRQCBhMiDgIVFBYzMjYSNRAB8uYxBA2IYwGyY3IyBl3UfYWSkPtcVq2YR3trfMp+ENtI/ZEIAP3p2JyTub7D/qDKBApz4PxRfZeoAT+mASf///8n/hQD8AXBAiYAXAAAAQcAav92AAAACrQCASoRJgArNTX///+RAAAD/AaHAiYAJAAAAQcBTQBOAVIACLMCEgUmACs1//8AZv/sBDcFNQImAEQAAAEGAU0jAAAIswIlESYAKzX///+RAAAEEwcbAiYAJAAAAQcBTgAjAVIACLMCEgUmACs1//8AZv/sBDcFyQImAEQAAAEGAU4MAAAIswIlESYAKzX///+R/mID0wW8AiYAJAAAAAcBUQMZAAD//wBm/mIENwRQAiYARAAAAAcBUQKuAAD//wCq/+wE+QdzAiYAJgAAAQcAdgEUAVIACLMBIgUmACs1//8AZv/sA+IGIQImAEYAAAEGAHb9AAAIswEiESYAKzX//wCq/+wE9AdzAiYAJgAAAQcBSwDVAVIACLMBIAUmACs1//8AZv/sA4wGIQImAEYAAAEGAUvOAAAIswEgESYAKzX//wCq/+wE9AchAiYAJgAAAQcBTwIKAVIACLMBIQUmACs1//8AZv/sA4kFzwImAEYAAAEHAU8BPQAAAAizASERJgArNf//AKr/7AT0B3MCJgAmAAABBwFMAKYBUgAIswElBSYAKzX//wBm/+wDwwYhAiYARgAAAQYBTL8AAAizASURJgArNf//AGYAAAUIB3MCJgAnAAABBwFMAF4BUgAIswIfBSYAKzX//wBm/+wF6QYUAiYARwAAAQcCOALVAAAAB7ICIwAAPzUA//8AWgAABQgFtgIGAJIAAAACAGb/7AUOBhQAGQAnAEVAJxECFAAOBgcGRlkLDwcfBy8HAwkDBwcACQAQFQAiRlkAEBQaR1kUFgA/KwAYPysAGD8/EjkvX15dMysRADMREjk5MTABMhczNhMhNyE3MwczByMBIxMjAiMgETQSNgMyPgI1NCYjIgYCFRACj+M0BAdL/mwVAZErYyudFJr+8lItBq37/ueP/FtZs41Ie2t8yIAEUNsqAVlUyMhU+wgBEv7aAXbBAWLL+/Z90/tUfpem/sGo/tkA//8AZgAABHMGhwImACgAAAEHAU0AbQFSAAizAQ8FJgArNf//AGb/7AOfBTUCJgBIAAABBgFN8QAACLMCJBEmACs1//8AZgAABHMHGwImACgAAAEHAU4AUAFSAAizAQ8FJgArNf//AGb/7AOyBckCJgBIAAABBgFOwgAACLMCJBEmACs1//8AZgAABHMHBAImACgAAAEHAU8BmAE1AAizARQFJgArNf//AGb/7AN9Bc8CJgBIAAABBwFPAPgAAAAIswIpESYAKzX//wBm/mIEcwW2AiYAKAAAAAcBUQJMAAD//wBm/oEDfQRQAiYASAAAAAcBUQIhAB///wBmAAAEcwdzAiYAKAAAAQcBTABEAVIACLMBGAUmACs1//8AZv/sA78GIQImAEgAAAEGAUy7AAAIswItESYAKzX//wCq/+wFPQdzAiYAKgAAAQcBSwDbAVIACLMBJQUmACs1////qP4UBEwGIQImAEoAAAEGAUvEAAAIswNNESYAKzX//wCq/+wFPQcbAiYAKgAAAQcBTgDRAVIACLMBIQUmACs1////qP4UBEwFyQImAEoAAAEGAU6pAAAIswNJESYAKzX//wCq/+wFPQchAiYAKgAAAQcBTwIfAVIACLMBJgUmACs1////qP4UBEwFzwImAEoAAAEHAU8BFwAAAAizA04RJgArNf//AKr+OwU9BcsCJgAqAAAABwI5ASEAAP///6j+FARMBiECJgBKAAABBgI6OQAACLMDShEmACs1//8AZgAABVwHcwImACsAAAEHAUsAvgFSAAizARMFJgArNf//AEwAAAQKB6oCJgBLAAABBwFLACkBiQAIswEjAiYAKzUAAgBmAAAF5wW2ABMAFwAxQBkDFgsMC0lZABAMFwdJWQwXDBcJEg4DBQkSAD8zPzMSOTkvLysRADMzKxEAMzMxMAEzByMDIxMhAyMTIzczEzMDIRMzAxMhAwUhxhTF52SX/QiVZ+jBFb48ZjsC9Txk7Tv9CDsEoFr7ugLP/TEERloBFv7qARb9dwEZ/ucAAAEATAAABAoGFAAhADtAIRcLGxUNDg1IWRIPDh8OLw4DCQMODhsQAAALFRsGRlkbEAA/KwAYPzM/EjkvX15dMysRADMREjkxMCETNjU0JiMiAgcDIwEjNzM3MwchByECBzM2NjMyFhUUBwMC+JkVYFar/zRkYgEQjxCQKWIpAXUR/otEGgpdxHWBiRaWArplN1FT/uX+/h8FAk7ExE7+xV18anx4Pmz9TgD////bAAADWwcXAiYALAAAAQcBUv9VAVIACLMBFgUmACs1//8AQgAAAu4FxQImAPMAAAEHAVL+6AAAAAizAQ4RJgArNf///9sAAAMHBocCJgAsAAABBwFN/1kBUgAIswEPBSYAKzX//wBMAAACkgU1AiYA8wAAAQcBTf7kAAAACLMBBxEmACs1////2wAAAxgHGwImACwAAAEHAU7/KAFSAAizAQ8FJgArNf//AEwAAAKhBckCJgDzAAABBwFO/rEAAAAIswEHESYAKzX////b/mICsgW2AiYALAAAAAcBUQCaAAD///+N/mIB6QXPAiYATAAAAAYBURQA////2wAAArIHIQImACwAAAEHAU8AhwFSAAizARQFJgArNQABAEwAAAGTBD8AAwAKswIPARUAPz8xMDMjEzOuYudgBD/////j/pgEOgW2ACYALAgAAAcALQJGAAD//wBJ/hQDwAXPACYATP0AAAcATQHXAAD///68/pgC1gdzAiYALQAAAQcBS/8YAVIACLMBFQUmACs1///+6f4UAnEGIQImAjcAAAEHAUv+swAAAAizARURJgArNf//AGb+OwUbBbYCJgAuAAAABgI5fQD//wBM/jsD7AYUAiYATgAAAAYCOS0AAAEATAAAA+wEPwANABhADA0DBgcECQEKDwUJFQA/Mz8zEhc5MTABATMBASMBBwMjEzMDAwEOAmF9/iYBKWr++M1QYOVgQUYB3QJi/iv9lgIvvP6NBD/+yf7V//8AZgAAA04HcwImAC8AAAEHAHb/WwFSAAizAQ8FJgArNf//AEwAAAM0B6wCJgBPAAABBwB2/08BiwAIswENAiYAKzX//wBm/jsDTgW2AiYALwAAAAYCOXcA////r/47AfgGFAImAE8AAAAH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AAAEBggTAiYAJAAAAQcDfATjAVIACrQDAhIFJgArNTX//wBm/+wENwbBAiYARAAAAQcDfATLAAAACrQDAiURJgArNTX///+RAAAEBghWAiYAJAAAAQcDfQTjAVIACrQDAhIFJgArNTX//wBm/+wENwcEAiYARAAAAQcDfQTLAAAACrQDAiURJgArNTX///+RAAAEgQhpAiYAJAAAAQcDfgTjAVIACrQDAhIFJgArNTX//wBm/+wEaQcXAiYARAAAAQcDfgTLAAAACrQDAiURJgArNTX///+R/scEIwcbAiYAJAAAACcBTgAzAVIBBwJnBI0AAAAIswISBSYAKzX//wBm/scENwXJAiYARAAAACYBTgIAAQcCZwSJAAAACLMCJREmACs1//8AZv7HBHMFtgImACgAAAAHAmcEqwAA//8AZv7HA30EUAImAEgAAAAHAmcEggAA//8AZgAABHMH0wImACgAAAEHAmYE8AFSAAizARAFJgArNf//AGb/7AOLBoECJgBIAAABBwJmBIMAAAAIswIlESYAKzX//wBmAAAEcwcXAiYAKAAAAQcBUgBYAVIACLMBFgUmACs1//8AZv/sA+AFxQImAEgAAAEGAVLaAAAIswIrESYAKzX//wBmAAAFBwfRAiYAKAAAAQcDdwTsAVIACrQCARoFJgArNTX//wBm/+wEogZ/AiYASAAAAQcDdwSHAAAACrQDAi8RJgArNTX//wBmAAAEcwfPAiYAKAAAAQcDeATwAVIACrQCASQFJgArNTX//wBm/+wDlwZ9AiYASAAAAQcDeASHAAAACrQDAjkRJgArNTX//wBmAAAE0QglAiYAKAAAAQcDeQTsAVIACrQCARoFJgArNTX//wBm/+wEbAbTAiYASAAAAQcDeQSHAAAACrQDAi8RJgArNTX//wBmAAAEvQhpAiYAKAAAAQcDegTwAVIACrQCARoFJgArNTX//wBm/+wEVAcXAiYASAAAAQcDegSHAAAACrQDAi8RJgArNTX//wBm/scEcwdzAiYAKAAAACcBSwBGAVIBBwJnBKsAAAAIswETBSYAKzX//wBm/scDjgYhAiYASAAAACYBS9AAAQcCZwSPAAAACLMCKBEmACs1////2wAAAxIH0wImACwAAAEHAmYECgFSAAizARAFJgArNf//AEwAAAKXBoECJgDzAAABBwJm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VJVUlVSVVJVUlVSVVJVUlVSVVJVUlVSVVapV/FYNVhVWj1bGVyZXN1dIV1RXYFdtV6FX01ffV+tYPliKWMxZFVkeWSdZMFlWWW1ZflmPWZ9Zr1oeWllao1r7W1Rbp1vhXBhcZVyvXQZdWl3AXiNewF9dX2VfbV/GYBVgS2B9YI9goWCtYLlhMGGoYm9jJGO0ZA9kSGSAZLlk3mUMZS1lUGYkZptm7GdLZ5Rn7Gg9aKFo0WkAaUpplGnXalBqXGpoappqzGsMa1Brk2vabApsOmxubKJs1G0DbVFtn24kbptup26zbt5vTm9Wb31vtW/scCJwV3CNcOVxJnFscb5yEHJHcoNy6nNJc7p0I3QrdDx0TXSWdNt1G3VgdZ912nYOdkJ2g3bJdwp3TXdVd2Z3dneId5l3oXepd7p3yngYeF94cXiCeJR4pni4eMp5C3lLeVx5bHl+eY95oXmyebp5wnnUeeV593oJehp6Kno8ek56YHpxeoN6lHq6euB68nsEe057l3vZfBt8WHyTfMZ8zn0ofYl97X5Ifpt+7H8/f5Z/34AmgHGAvID7gTiBiIGQgd6CL4I7gkeCWIJpgnuCjYKfgrGCw4LVgueC+YMOgyKDNINGg1iDaoN8g46DoIOyg8eD24Png/OEBIQVhCaENoRIhFqEbIR+hJCEooS0hMaE24TvhQCFEYUdhSmFNYVBhVKFY4V1hYeFmYWrhb2Fz4XhhfOGCIYchi2GPYZOhl6Gb4aAhpGGoYathrmGxYbRhuKG84cEhxSHJYc1h0aHV4doh3iHhIeQh5yHqIe5h8qH24frh/eIIIhbiJeI44k3iW6JpYnvij+KXopniqGKwIr8i06Lh4vNi9WL9Iv8jE+MxI0mjTKNPo2cjayNvI3Njd2N8I4BjhKOI441jkaOV45ojnOOhI6QjqKOqo68jsSO1o7ejuaO948DAAAAAQAAAAEZ21w1JKRfDzz1AAkIAAAAAADJY0kKAAAAANUrzNX70/32Ca4IaQACAAkAAgAAAAAAAATNAMEAAAAABBQAAAIUAAAB9gBQAtEA+AUrAFIEaACNBhQAkQUzAE4BkwD+Ag4AaAIO/2QEcQDpBGgAogHD/6YCdQBSAeUAUgKB/5wEaACLBGgBYgRoACcEaAA3BGgAFwRoAFgEaACqBGgA9ARoAGIEaABzAeUAZgHl/8sEaACJBGgAqARoAKoDHwCqBrwAfQQj/5EEsgBmBJEAqgVGAGYEKwBmA9UAZgVeAKoFVgBmAkb/2wHd/rwEYgBmA6oAZgaFAG0FXABmBbgArAR5AGYFuACsBHkAZgP8ACUD2QDBBVoAsAQ3AMkGpgDuA8v/eQPFAMEEaP/0Ahn/xwKBANECGf9QBBcARgMh/0oEbwHnBG0AZgR/AEwDdwBmBG0AZgOgAGYCQv8XBBD/qAR3AEwB2wBMAdv+6QOwAEwB2wBMBtcASAR3AEwEZABiBH3/3wSFAGIC8ABIAzsAGQJoAHEEdwBtA38AaAVxAHkDmv+4A5j/JwN3/+MCxQA7BGgCSALF/9cEaAB/AhQAAAH2AAQEaAD6BGj//ARoAM8EaACmBGgCQgPjAGYEbwHsBqgAkwKDAKoDXAA9BGgAfQJ1AE0GqACWAo8BXANtAPIEaAB/AoMAUgKDAG0EbwJEBJP/4wU9ANcB5QDPAaT/UgKDAP4CjwC+A1wAIQXJAIEFsgA1BbIARwMfAAAEI/+RBCP/kQQj/5EEI/+RBCP/kQQj/5EGaP+LBJEAqgQrAGYEKwBmBCsAZgQrAGYCRv/bAkb/2wJG/9sCRv/bBUgAWgVcAGYFuACsBbgArAW4AKwFuACsBbgArARoAN0FuACLBVoAsAVaALAFWgCwBVoAsAPFAMEEeQBmBEb+5wRtAGYEbQBmBG0AZgRtAGYEbQBmBG0AZgZCAGYDdwBmA6AAZgOgAGYDoABmA6AAZgHbAEwB2wBMAdsATAHbAEwEZABmBHcATARkAGIEZABiBGQAYgRkAGIEZABiBGgAqARkAC0EdwBtBHcAbQR3AG0EdwBtA5j/JwSL/98DmP8nBCP/kQRtAGYEI/+RBG0AZgQj/5EEbQBmBJEAqgN3AGYEkQCqA3cAZgSRAKoDdwBmBJEAqgN3AGYFRgBmBG0AZgVIAFoEiwBmBCsAZgOgAGYEKwBmA6AAZgQrAGYDoABmBCsAZgOgAGYEKwBmA6AAZgVeAKoEEP+oBV4AqgQQ/6gFXgCqBBD/qAVeAKoEEP+oBVYAZgR3AEwFVgBmBIEATAJG/9sB2wBCAkb/2wHbAEwCRv/bAdsATAJG/9sB2/+NAkb/2wHbAEwEI//jA7YASQHd/rwB2/7pBGIAZgOwAEwDsABMA6oAZgHbAEwDqgBmAdv/rwOqAGYB2wBMA6oAZgGiAEUDmgAnAa4ACgVcAGYEdwBMBVwAZgR3AEwFXABmBHcATAUCAIcFZABmBIEATAW4AKwEZABiBbgArARkAGIFuACsBGQAYgbnAKwGuABiBHkAZgLwAEgEeQBmAvD/qQR5AGYC8ABIA/wAJQM7ABkD/AAlAzsAGQP8ACUDOwAZA/wAJQM7ABkD2QChAmgASwPZAMECaABxA9kApAI9AC0FWgCwBHcAbQVaALAEdwBtBVoAsAR3AG0FWgCwBHcAbQVaALAEdwBtBVoAsAR3AG0GpgDuBXEAeQPFAMEDmP8nA8UAwQRo//QDd//jBGj/9AN3/+MEaP/0A3f/4wHZ/uEEaAACBCP/kQRtAGYGaP+LBkIAZgW4AIsEZAAtA/wAJQM7ABkEbwG8BG8CAgRIAaAEbwHuAbgBRgSeAjEBXP95BG8BWgRvAc0EiwKLBIsBPwQj/5EB5QDPBEoAWQX2AFkDOwB8BfAAZwTPAFkGLwBlAi8AeQQj/5EEsgBmA9UAZgRE/9MEKwBmBGj/9AVWAGYFuACsAkb/2wRiAGYETP+PBoUAbQVcAGYEIf/uBbgArAVeAGYEeQBmBBT/6QPZAMEDxQDBBaYAnAPL/3kFiwDRBecAGwJG/9sDxQDBBHEAZgNIADsEgQBMAi8AcARzAI0EcQBmBH//4QNzAHcESABOA0gAOwOJAHUEgQBMBDcAewIvAHkDsABMA3//jQST/+MDqAB5A2oAOwRkAGIEUgBaBHH/3wOWAGYEcQBoAwIASARzAI0E+gA7A+H/KQVUAJoFVABEAi8AeQRzAI0EZABiBHMAjQVUAEQEKwBmBQwAxQPVAGYEkQCqA/wAJQJG/9sCRv/bAd3+vAcZ/6wHZgBmBSEAxQRSAGYEef/pBV4AZgQj/5EEWABmBLIAZgPVAGYEjf9cBCsAZgXT/6gD/P/hBVgAZgVYAGYEUgBmBPL/rAaFAG0FVgBmBbgArAVeAGYEeQBmBJEAqgPZAMEEef/pBaYAnAPL/3kFjwBmBKgAzQdxAGYHsgBmBO4AwQYAAGYEXgBmBJEADgfpAGYEXv/NBG0AZgQlAGIEKQBoA5EATgRYAGYDoABmBi3/zQMf/+4EdwBtBHcAbQOkAEgEBP+aBRkALQS4AEoEZABiBHcATASL/98DdwBmBtcASAOY/ycE4QBiA5r/uASRAG0ESACcBtcAdQbyAHUEcwBSBW0AjQPjAI0DiQAKBgYASgQO/9sDoABmBIEATAORAE4DfwBiAzsAGQHbAEwB2wBMAdv+6QXV/5oGOwBKBIEATAOkAEgDmP8nBHcAbQOyAGYCugBIBqYA7gVxAHkGpgDuBXEAeQamAO4FcQB5A8UAwQOY/ycD1wBCB64ARAeuAEQDIf80ASsAgQErAIEBw/+cASsAzQJ3AIECdwCBAwj/iQPuALQD7gAjAxkA+AXRAEUIzwCRAZMA/gLRAPgCGQBWAhkAJQOBADIBEv4xAt0AvARoAD8EaP/8BUIAPQRoAFAGSgD6BAAAcwd5AE4F/gCuBecAGwT0AIkFogA5Bl4AUwZOAFMFmAA9BKYAjwRE/9MF3QDPBPgAVgRoAKgEZAAlBZoAewLpAC0EaAB/BJEAbwSRAIkEkQCoBKQAdwQQ/wYEEv8GBIsBagHb/ukDugIUA7oArAO6AgoCgwBzAoMANQKDAFoCgwCLAoMAmgKDAG0CgwBzBAAAAAgAAAAEAAAACAAAAAKqAAACAAAAAVYAAAR5AAACDAAAAZoAAADNAAAAAAAAAAAAAAgAAFQIAABUAdv+6QErAIEEDAAMA88AwQW4AHMGhQBtBtcASAQj/5EEbQBmBjv/pwKq/8sEDgGLBlD/BgZa/wYFuACsBIMAYgXRALAFBABtAAD9TgAA/eMAAPzQAAD9tgAA/NYEKwBmBVgAZgOgAGYEdwBtB1QAqgVIAHME7gCyA/4ASAbHAGYFTABKBIf/kQPp/7oGbwBmBT0ATAUj/8ME3/+eByMAZgZOAEoD/P+sA0L/jwWLANEFVACaBbgArARkAGIESADJA20AaARIAMkDbQBoCVYArAe2AGQFuACsBGQAYgdUAKoFwwBtB1QAqgVIAHMEkQCqA3cAZgTfAKgElgF1BL4BkwS+Ao8EvgKuB+kAKQemACkFlgBmBJEAbQReAGYD4wCNBHkAZgR9/98DpABmAroAFwSPAFYDlgBIBjf/qAZi/80D/P/hAx//7gSoAGYDyQBIBFIAZgNWAEgENwBmA3MATATVAMEELwBSBY8AZgTTAEoF/ABmBWoASgfRAGYGWgBGBbgArAS8AGYEkQCqA3cAZgPZAMEG+ABIA8UAwQN/AHEDxQCDA38AGwP2/3kDrv+4BnsAwQVCAFQE4QDNBGQAnASoAM0ESgCcBPoAZAR9AEgGEACDBHcAZAYQAIMEdwBkAkb/2wXT/6gGLf/NBLQAZgOuAEgFLf+sBCP/mgVWAGYEuABKBY8AZgTTAEoEqADNBEoAnAaqAG0FWAAtAkb/2wQj/5EEbQBmBCP/kQRtAGYGaP+LBmAAZgQrAGYDoABmBUwAXgOgAD0FTABeA6AAPQXT/6gGLf/NA/z/4QMf/+4EFAAKA0T/XAVYAGYEdwBtBVgAZgR3AG0FuACsBGQAYgW4AKwEZABiBbgArARkAGIEkQAOA4kACgR5/+kDmP8nBHn/6QOY/ycEef/pA5j/JwSoAM0ESACcA7IAZgK6AEgGAABmBW0AjQOyAEgCugAXBAr/eQOw/7gDy/95A5r/uARoAFwEbQBmBo8AXAaBAGYGewDnBW0AogRaAOcDpgCiBvz/rAXj/48HdwBmBpoASgVoAKoEiwBiBRAAwQRYAFQEGwCTA0gAOwUt/6wEI/+aBCP/kQRtAGYEI/+RBG0AZgQj/5EEbQBmBCP/kQRtAGYEI/+RBG0AZgQj/5EEbQBmBCP/kQRtAGYEI/+RBG0AZgQj/5EEbQBmBCP/kQRtAGYEI/+RBG0AZgQj/5EEbQBmBCsAZgOgAGYEKwBmA6AAZgQrAGYDoABmBCsAZgOgAGYEKwBmA6AAZgQrAGYDoABmBCsAZgOgAGYEKwBmA6AAZgJG/9sB2wBMAkb/2wHbABIFuACsBGQAYgW4AKwEZABiBbgArARkAGIFuACsBGQAYgW4AKwEZABiBbgArARkAGIFuACsBGQAYgW4AKwEgwBiBbgArASDAGIFuACsBIMAYgW4AKwEgwBiBbgArASDAGIFWgCwBHcAbQVaALAEdwBtBdEAsAUEAG0F0QCwBQQAbQXRALAFBABtBdEAsAUEAG0F0QCwBQQAbQPFAMEDmP8nA8UAwQOY/ycDxQDBA5j/JwSL//QAAPvTAAD9AgAA/G0AAP0CAAD9AgAA/SEAAP0hAAD9IQAA/N0Bov9zAo8AiARSAGgCYgAvA4f/zwOk/4IERv+4A+X/6AQUAGwDff/1BCkAVwQG//8Eg/8XBjUAKQPZAHkCaAA3BG0ARgRtAEYEbQBGBG0ARgRtAEYB+ABmAfgAZgH4AGYB+ABmAfgAZgH4AGYB+ABmAfgAZgH4/6gB+ABmA+UAZgKTAG0B+ABmAGYAZgBmAGYAZgBm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AGEAdABhACAAYwBvAHAAeQByAGkAZwBoAHQAIACpACAAMgAwADEAMAAtADIAMAAxADEALAAgAEcAbwBvAGcAbABlACAAQwBvAHIAcABvAHIAYQB0AGkAbwBuAC4ATwBwAGUAbgAgAFMAYQBuAHMAIABMAGkAZwBoAHQASQB0AGEAbABpAGMAMQAuADEAMAA7ADEAQQBTAEMAOwBPAHAAZQBuAFMAYQBuAHMALQBMAGkAZwBoAHQASQB0AGEAbABpAGMATwBwAGUAbgAgAFMAYQBuAHMAIABMAGkAZwBoAHQAIABJAHQAYQBsAGkAYwBWAGUAcgBzAGkAbwBuACAAMQAuADEAMABPAHAAZQBuAFMAYQBuAHMALQBMAGkAZwBoAHQASQB0AGEAbABpAGMAaAB0AHQAcAA6AC8ALwB3AHcAdwAuAGEAcABhAGMAaABlAC4AbwByAGcALwBsAGkAYwBlAG4AcwBlAHMALwBMAEkAQwBFAE4AUwBFAC0AMgAuADAAAAACAAD/9AAA/2YAZgAAAAAAAAAAAAAAAAAAAAAAAAAAA6gAAAECAAIAAwAEAAUABgAHAAgACQAKAAsADAANAA4ADwAQABEAEgATABQAFQAWABcAGAAZABoAGwAcAB0AHgAfACAAIQAiACMAJAAlACYAJwAoACkAKgArAQMALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADsAPAA9AD4APwBAAEEAQgBDAEQARQBGAEcASABJAEoASwBMAE0ATgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwAXQBeAF8AYABhAKwAowCEAIUAvQCWAOgAhgCOAIsAnQCpAKQBBACKAQUAgwCTAPIA8wCNAJcAiADDAN4A8QCeAKoA9QD0APYAogCtAMkAxwCuAGIAYwCQAGQAywBlAMgAygEGAQcBCAEJAOkAZgDTANAA0QCvAGcA8ACRANYA1ADVAGgA6wDtAIkAagBpAGsAbQBsAG4AoABvAHEAcAByAHMAdQB0AHYAdwDqAHgAegB5AHsAfQB8ALgAoQB/AH4AgACBAOwA7gC6AQoBCwEMAQ0BDgEPAP0A/gEQAREBEgETAP8BAAEUARUBFgEBARcBGAEZARoBGwEcAR0BHgEfASABIQEiAPgA+QEjASQBJQEmAScBKAEpASoBKwEsAS0BLgEvATABMQEyATMA1wE0ATUBNgE3ATgBOQE6ATsBPAE9AT4BPwFAAUEBQgDiAOMBQwFEAUUBRgFHAUgBSQFKAUsBTAFNAU4BTwFQAVEAsACxAVIBUwFUAVUBVgFXAVgBWQFaAVsA+wD8AOQA5QFcAV0BXgFfAWABYQFiAWMBZAFlAWYBZwFoAWkBagFrAWwBbQFuAW8BcAFxALsBcgFzAXQBdQDmAOcBdgCmAXcBeAF5AXoBewF8AX0BfgDYAOEA2gDbANwA3QDgANkA3wF/AYABgQGCAYMBhAGFAYYBhwGIAYkBigGLAYwBjQGOAY8BkAGRAZIBkwGUAZUBlgGXAZgBmQGaAZsBnAGdAZ4BnwGgAaEBogGjAaQBpQGmAacBqAGpAaoBqwGsAa0BrgGvAbABsQGyAbMBtAG1AbYBtwCbAbgBuQG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHGAccByAHJAcoBywHMAc0BzgHPAdAB0QHSAdMB1AHVAdYB1wHYAdkB2gHbAdwB3QHeAd8B4AHhAeIB4wHkAeUB5gHnAegB6QHqAesB7AHtAe4B7wHwAfEB8gHzAfQB9QH2AfcB+AH5AfoB+wH8Af0B/gH/AgACAQICAgMCBAIFAgYCBwIIAgkCCgILAgwCDQIOAg8CEAIRAhICEwIUAhUCFgIXAhgCGQIaAhsCHAIdAh4CHwIgAiECIgIjAiQCJQImAicCKAIpAioCKwCyALMCLAItALYAtwDEAi4AtAC1AMUAggDCAIcAqwDGAi8CMAC+AL8CMQC8AjIA9wIzAjQCNQI2AjcCOACMAJ8COQI6AjsCPAI9AJgAqACaAJkA7wClAJIAnACnAI8AlACVALkCPgI/AkACQQJCAkMCRAJFAkYCRwJIAkkCSgJLAkwCTQJOAk8CUAJRAlICUwJUAlUCVgJXAlgCWQJaAlsCXAJdAl4CXwJgAmECYgJjAmQCZQJmAmcCaAJpAmoCawJsAm0CbgJvAnACcQJyAnMCdAJ1AnYCdwJ4AnkCegJ7AnwCfQJ+An8CgAKBAoICgwKEAoUChgKHAogCiQKKAosCjAKNAo4CjwKQApECkgKTApQClQKWApcCmAKZApoCmwKcAp0CngKfAqACoQKiAqMCpAKlAqYCpwKoAqkCqgKrAqwCrQKuAq8CsAKxArICswK0ArUCtgK3ArgCuQK6ArsCvAK9Ar4CvwLAAsECwgLDAsQCxQLGAscCyALJAsoCywLMAs0CzgLPAtAC0QLSAtMC1ALVAtYC1wLYAtkC2gLbAtwC3QLeAt8C4ALhAuIC4wLkAuUC5gLnAugC6QLqAusC7ALtAu4C7wLwAvEC8gLzAvQC9QL2AvcC+AL5AvoC+wL8Av0C/gL/AwADAQMCAwMDBAMFAwYDBwMIAwkDCgMLAwwDDQMOAw8DEAMRAxIDEwMUAxUDFgMXAxgDGQMaAxsDHAMdAx4DHwMgAyEDIgMjAyQDJQMmAycDKAMpAyoDKwMsAy0DLgMvAzADMQMyAzMDNAM1AzYDNwM4AzkDOgM7AzwDPQM+Az8DQANBA0IDQwNEA0UDRgNHA0gDSQNKA0sDTANNA04DTwNQA1EDUgNTA1QDVQNWA1cDWANZA1oDWwNcA10DXgNfA2ADYQNiA2MDZANlA2YDZwNoA2kDagNrA2wDbQNuA28DcANxA3IDcwN0A3UDdgN3A3gDeQN6A3sDfAN9A34DfwOAA4EDggODA4QDhQOGA4cDiAOJA4oDiwOMA40DjgOPA5ADkQOSA5MDlAOVA5YDlwOYA5kDmgObA5wDnQAsAM8AzADNAM4DngOfA6ADoQD6A6IDowOkA6UDpgOnA6gDqQOqA6sEbnVsbAVJLmFsdAd1bmkwMEFECW92ZXJzY29yZQpJZ3JhdmUuYWx0CklhY3V0ZS5hbHQPSWNpcmN1bWZsZXguYWx0DUlkaWVyZXNpcy5hbHQHQW1hY3JvbgdhbWFjcm9uBkFicmV2ZQZhYnJldmUHQW9nb25lawdhb2dvbmVrC0NjaXJjdW1mbGV4C2NjaXJjdW1mbGV4BENkb3QEY2RvdAZEY2Fyb24GZGNhcm9uBkRjcm9hdAdFbWFjcm9uB2VtYWNyb24GRWJyZXZlBmVicmV2ZQpFZG90YWNjZW50CmVkb3RhY2NlbnQHRW9nb25lawdlb2dvbmVrBkVjYXJvbgZlY2Fyb24LR2NpcmN1bWZsZXgLZ2NpcmN1bWZsZXgER2RvdARnZG90DEdjb21tYWFjY2VudAxnY29tbWFhY2NlbnQLSGNpcmN1bWZsZXgLaGNpcmN1bWZsZXgESGJhcgRoYmFyCkl0aWxkZS5hbHQGaXRpbGRlC0ltYWNyb24uYWx0B2ltYWNyb24KSWJyZXZlLmFsdAZpYnJldmULSW9nb25lay5hbHQHaW9nb25law5JZG90YWNjZW50LmFsdAZJSi5hbHQCaWoLSmNpcmN1bWZsZXgLamNpcmN1bWZsZXgMS2NvbW1hYWNjZW50DGtjb21tYWFjY2VudAxrZ3JlZW5sYW5kaWMGTGFjdXRlBmxhY3V0ZQxMY29tbWFhY2NlbnQMbGNvbW1hYWNjZW50BkxjYXJvbgZsY2Fyb24ETGRvdARsZG90Bk5hY3V0ZQZuYWN1dGUMTmNvbW1hYWNjZW50DG5jb21tYWFjY2VudAZOY2Fyb24GbmNhcm9uC25hcG9zdHJvcGhlA0VuZwNlbmcHT21hY3JvbgdvbWFjcm9uBk9icmV2ZQZvYnJldmUNT2h1bmdhcnVtbGF1dA1vaHVuZ2FydW1sYXV0BlJhY3V0ZQZyYWN1dGUMUmNvbW1hYWNjZW50DHJjb21tYWFjY2VudAZSY2Fyb24GcmNhcm9uBlNhY3V0ZQZzYWN1dGULU2NpcmN1bWZsZXgLc2NpcmN1bWZsZXgMVGNvbW1hYWNjZW50DHRjb21tYWFjY2VudAZUY2Fyb24GdGNhcm9uBFRiYXIEdGJhcgZVdGlsZGUGdXRpbGRlB1VtYWNyb24HdW1hY3JvbgZVYnJldmUGdWJyZXZlBVVyaW5nBXVyaW5nDVVodW5nYXJ1bWxhdXQNdWh1bmdhcnVtbGF1dAdVb2dvbmVrB3VvZ29uZWsLV2NpcmN1bWZsZXgLd2NpcmN1bWZsZXgLWWNpcmN1bWZsZXgLeWNpcmN1bWZsZXgGWmFjdXRlBnphY3V0ZQpaZG90YWNjZW50Cnpkb3RhY2NlbnQFbG9uZ3MKQXJpbmdhY3V0ZQphcmluZ2FjdXRlB0FFYWN1dGUHYWVhY3V0ZQtPc2xhc2hhY3V0ZQtvc2xhc2hhY3V0ZQxTY29tbWFhY2NlbnQMc2NvbW1hYWNjZW50BXRvbm9zDWRpZXJlc2lzdG9ub3MKQWxwaGF0b25vcwlhbm90ZWxlaWEMRXBzaWxvbnRvbm9zCEV0YXRvbm9zDUlvdGF0b25vcy5hbHQMT21pY3JvbnRvbm9zDFVwc2lsb250b25vcwpPbWVnYXRvbm9zEWlvdGFkaWVyZXNpc3Rvbm9zBUFscGhhBEJldGEFR2FtbWEHdW5pMDM5NAdFcHNpbG9uBFpldGEDRXRhBVRoZXRhCElvdGEuYWx0BUthcHBhBkxhbWJkYQJNdQJOdQJYaQdPbWljcm9uAlBpA1JobwVTaWdtYQNUYXUHVXBzaWxvbgNQaGkDQ2hpA1BzaQd1bmkwM0E5EElvdGFkaWVyZXNpcy5hbHQPVXBzaWxvbmRpZXJlc2lzCmFscGhhdG9ub3MMZXBzaWxvbnRvbm9zCGV0YXRvbm9zCWlvdGF0b25vcxR1cHNpbG9uZGllcmVzaXN0b25vcwVhbHBoYQRiZXRhBWdhbW1hBWRlbHRhB2Vwc2lsb24EemV0YQNldGEFdGhldGEEaW90YQVrYXBwYQZsYW1iZGEHdW5pMDNCQwJudQJ4aQdvbWljcm9uA3JobwZzaWdtYTEFc2lnbWEDdGF1B3Vwc2lsb24DcGhpA2NoaQNwc2kFb21lZ2EMaW90YWRpZXJlc2lzD3Vwc2lsb25kaWVyZXNpcwxvbWljcm9udG9ub3MMdXBzaWxvbnRvbm9zCm9tZWdhdG9ub3MJYWZpaTEwMDIzCWFmaWkxMDA1MQlhZmlpMTAwNTIJYWZpaTEwMDUzCWFmaWkxMDA1NA1hZmlpMTAwNTUuYWx0DWFmaWkxMDA1Ni5hbHQJYWZpaTEwMDU3CWFmaWkxMDA1OAlhZmlpMTAwNTkJYWZpaTEwMDYwCWFmaWkxMDA2MQlhZmlpMTAwNjIJYWZpaTEwMTQ1CWFmaWkxMDAxNwlhZmlpMTAwMTgJYWZpaTEwMDE5CWFmaWkxMDAyMAlhZmlpMTAwMjEJYWZpaTEwMDIyCWFmaWkxMDAyNAlhZmlpMTAwMjUJYWZpaTEwMDI2CWFmaWkxMDAyNwlhZmlpMTAwMjgJYWZpaTEwMDI5CWFmaWkxMDAzMAlhZmlpMTAwMzEJYWZpaTEwMDMyCWFmaWkxMDAzMwlhZmlpMTAwMzQJYWZpaTEwMDM1CWFmaWkxMDAzNglhZmlpMTAwMzcJYWZpaTEwMDM4CWFmaWkxMDAzOQlhZmlpMTAwNDAJYWZpaTEwMDQxCWFmaWkxMDA0MglhZmlpMTAwNDMJYWZpaTEwMDQ0CWFmaWkxMDA0NQlhZmlpMTAwNDYJYWZpaTEwMDQ3CWFmaWkxMDA0OAlhZmlpMTAwNDkJYWZpaTEwMDY1CWFmaWkxMDA2NglhZmlpMTAwNjcJYWZpaTEwMDY4CWFmaWkxMDA2OQlhZmlpMTAwNzAJYWZpaTEwMDcyCWFmaWkxMDA3MwlhZmlpMTAwNzQJYWZpaTEwMDc1CWFmaWkxMDA3NglhZmlpMTAwNzcJYWZpaTEwMDc4CWFmaWkxMDA3OQlhZmlpMTAwODAJYWZpaTEwMDgxCWFmaWkxMDA4MglhZmlpMTAwODMJYWZpaTEwMDg0CWFmaWkxMDA4NQlhZmlpMTAwODYJYWZpaTEwMDg3CWFmaWkxMDA4OAlhZmlpMTAwODkJYWZpaTEwMDkwCWFmaWkxMDA5MQlhZmlpMTAwOTIJYWZpaTEwMDkzCWFmaWkxMDA5NAlhZmlpMTAwOTUJYWZpaTEwMDk2CWFmaWkxMDA5NwlhZmlpMTAwNzEJYWZpaTEwMDk5CWFmaWkxMDEwMAlhZmlpMTAxMDEJYWZpaTEwMTAyCWFmaWkxMDEwMwlhZmlpMTAxMDQJYWZpaTEwMTA1CWFmaWkxMDEwNglhZmlpMTAxMDcJYWZpaTEwMTA4CWFmaWkxMDEwOQlhZmlpMTAxMTAJYWZpaTEwMTkzCWFmaWkxMDA1MAlhZmlpMTAwOTgGV2dyYXZlBndncmF2ZQZXYWN1dGUGd2FjdXRlCVdkaWVyZXNpcwl3ZGllcmVzaXMGWWdyYXZlBnlncmF2ZQlhZmlpMDAyMDgNdW5kZXJzY29yZWRibA1xdW90ZXJldmVyc2VkBm1pbnV0ZQZzZWNvbmQJZXhjbGFtZGJsCW5zdXBlcmlvcglhZmlpMDg5NDEGcGVzZXRhBEV1cm8JYWZpaTYxMjQ4CWFmaWk2MTI4OQlhZmlpNjEzNTIJZXN0aW1hdGVkCW9uZWVpZ2h0aAx0aHJlZWVpZ2h0aHMLZml2ZWVpZ2h0aHMMc2V2ZW5laWdodGhzB3VuaUZCMDEHdW5pRkIwMg1jeXJpbGxpY2JyZXZlCGRvdGxlc3NqEGNhcm9uY29tbWFhY2NlbnQLY29tbWFhY2NlbnQRY29tbWFhY2NlbnRyb3RhdGUMemVyb3N1cGVyaW9yDGZvdXJzdXBlcmlvcgxmaXZlc3VwZXJpb3ILc2l4c3VwZXJpb3INc2V2ZW5zdXBlcmlvcg1laWdodHN1cGVyaW9yDG5pbmVzdXBlcmlvcgd1bmkyMDAwB3VuaTIwMDEHdW5pMjAwMgd1bmkyMDAzB3VuaTIwMDQHdW5pMjAwNQd1bmkyMDA2B3VuaTIwMDcHdW5pMjAwOAd1bmkyMDA5B3VuaTIwMEEHdW5pMjAwQgd1bmlGRUZGB3VuaUZGRkMHdW5pRkZGRAd1bmkwMUYwB3VuaTAyQkMHdW5pMDNEMQd1bmkwM0QyB3VuaTAzRDYHdW5pMUUzRQd1bmkxRTNGB3VuaTFFMDAHdW5pMUUwMQd1bmkxRjREB3VuaTAyRjMJZGFzaWFveGlhB3VuaUZCMDMHdW5pRkIwNAVPaG9ybgVvaG9ybgVVaG9ybgV1aG9ybgd1bmkwMzAwB3VuaTAzMDEHdW5pMDMwMwRob29rCGRvdGJlbG93B3VuaTA0MDAHdW5pMDQwRAd1bmkwNDUwB3VuaTA0NUQHdW5pMDQ2MAd1bmkwNDYxB3VuaTA0NjIHdW5pMDQ2Mwd1bmkwNDY0B3VuaTA0NjUHdW5pMDQ2Ngd1bmkwNDY3B3VuaTA0NjgHdW5pMDQ2OQd1bmkwNDZBB3VuaTA0NkIHdW5pMDQ2Qwd1bmkwNDZEB3VuaTA0NkUHdW5pMDQ2Rgd1bmkwNDcwB3VuaTA0NzEHdW5pMDQ3Mgd1bmkwNDczB3VuaTA0NzQHdW5pMDQ3NQd1bmkwNDc2B3VuaTA0NzcHdW5pMDQ3OAd1bmkwNDc5B3VuaTA0N0EHdW5pMDQ3Qgd1bmkwNDdDB3VuaTA0N0QHdW5pMDQ3RQd1bmkwNDdGB3VuaTA0ODAHdW5pMDQ4MQd1bmkwNDgyB3VuaTA0ODMHdW5pMDQ4NAd1bmkwNDg1B3VuaTA0ODYHdW5pMDQ4OAd1bmkwNDg5B3VuaTA0OEEHdW5pMDQ4Qgd1bmkwNDhDB3VuaTA0OEQHdW5pMDQ4RQd1bmkwNDhGB3VuaTA0OTIHdW5pMDQ5Mwd1bmkwNDk0B3VuaTA0OTUHdW5pMDQ5Ngd1bmkwNDk3B3VuaTA0OTgHdW5pMDQ5OQd1bmkwNDlBB3VuaTA0OUIHdW5pMDQ5Qwd1bmkwNDlEB3VuaTA0OUUHdW5pMDQ5Rgd1bmkwNEEwB3VuaTA0QTEHdW5pMDRBMgd1bmkwNEEzB3VuaTA0QTQHdW5pMDRBNQd1bmkwNEE2B3VuaTA0QTcHdW5pMDRBOAd1bmkwNEE5B3VuaTA0QUEHdW5pMDRBQgd1bmkwNEFDB3VuaTA0QUQHdW5pMDRBRQd1bmkwNEFGB3VuaTA0QjAHdW5pMDRCMQd1bmkwNEIyB3VuaTA0QjMHdW5pMDRCNAd1bmkwNEI1B3VuaTA0QjYHdW5pMDRCNwd1bmkwNEI4B3VuaTA0QjkHdW5pMDRCQQd1bmkwNEJCB3VuaTA0QkMHdW5pMDRCRAd1bmkwNEJFB3VuaTA0QkYLdW5pMDRDMC5hbHQHdW5pMDRDMQd1bmkwNEMyB3VuaTA0QzMHdW5pMDRDNAd1bmkwNEM1B3VuaTA0QzYHdW5pMDRDNwd1bmkwNEM4B3VuaTA0QzkHdW5pMDRDQQd1bmkwNENCB3VuaTA0Q0MHdW5pMDRDRAd1bmkwNENFC3VuaTA0Q0YuYWx0B3VuaTA0RDAHdW5pMDREMQd1bmkwNEQyB3VuaTA0RDMHdW5pMDRENAd1bmkwNEQ1B3VuaTA0RDYHdW5pMDRENwd1bmkwNEQ4B3VuaTA0RDkHdW5pMDREQQd1bmkwNERCB3VuaTA0REMHdW5pMDRERAd1bmkwNERFB3VuaTA0REYHdW5pMDRFMAd1bmkwNEUxB3VuaTA0RTIHdW5pMDRFMwd1bmkwNEU0B3VuaTA0RTUHdW5pMDRFNgd1bmkwNEU3B3VuaTA0RTgHdW5pMDRFOQd1bmkwNEVBB3VuaTA0RUIHdW5pMDRFQwd1bmkwNEVEB3VuaTA0RUUHdW5pMDRFRgd1bmkwNEYwB3VuaTA0RjEHdW5pMDRGMgd1bmkwNEYzB3VuaTA0RjQHdW5pMDRGNQd1bmkwNEY2B3VuaTA0RjcHdW5pMDRGOAd1bmkwNEY5B3VuaTA0RkEHdW5pMDRGQgd1bmkwNEZDB3VuaTA0RkQHdW5pMDRGRQd1bmkwNEZGB3VuaTA1MDAHdW5pMDUwMQd1bmkwNTAyB3VuaTA1MDMHdW5pMDUwNAd1bmkwNTA1B3VuaTA1MDYHdW5pMDUwNwd1bmkwNTA4B3VuaTA1MDkHdW5pMDUwQQd1bmkwNTBCB3VuaTA1MEMHdW5pMDUwRAd1bmkwNTBFB3VuaTA1MEYHdW5pMDUxMAd1bmkwNTExB3VuaTA1MTIHdW5pMDUxMwd1bmkxRUEwB3VuaTFFQTEHdW5pMUVBMgd1bmkxRUEzB3VuaTFFQTQHdW5pMUVBNQd1bmkxRUE2B3VuaTFFQTcHdW5pMUVBOAd1bmkxRUE5B3VuaTFFQUEHdW5pMUVBQgd1bmkxRUFDB3VuaTFFQUQHdW5pMUVBRQd1bmkxRUFGB3VuaTFFQjAHdW5pMUVCMQd1bmkxRUIyB3VuaTFFQjMHdW5pMUVCNAd1bmkxRUI1B3VuaTFFQjYHdW5pMUVCNwd1bmkxRUI4B3VuaTFFQjkHdW5pMUVCQQd1bmkxRUJCB3VuaTFFQkMHdW5pMUVCRAd1bmkxRUJFB3VuaTFFQkYHdW5pMUVDMAd1bmkxRUMxB3VuaTFFQzIHdW5pMUVDMwd1bmkxRUM0B3VuaTFFQzUHdW5pMUVDNgd1bmkxRUM3C3VuaTFFQzguYWx0B3VuaTFFQzkLdW5pMUVDQS5hbHQHdW5pMUVDQgd1bmkxRUNDB3VuaTFFQ0QHdW5pMUVDRQd1bmkxRUNGB3VuaTFFRDAHdW5pMUVEMQd1bmkxRUQyB3VuaTFFRDMHdW5pMUVENAd1bmkxRUQ1B3VuaTFFRDYHdW5pMUVENwd1bmkxRUQ4B3VuaTFFRDkHdW5pMUVEQQd1bmkxRURCB3VuaTFFREMHdW5pMUVERAd1bmkxRURFB3VuaTFFREYHdW5pMUVFMAd1bmkxRUUxB3VuaTFFRTIHdW5pMUVFMwd1bmkxRUU0B3VuaTFFRTUHdW5pMUVFNgd1bmkxRUU3B3VuaTFFRTgHdW5pMUVFOQd1bmkxRUVBB3VuaTFFRUIHdW5pMUVFQwd1bmkxRUVEB3VuaTFFRUUHdW5pMUVFRgd1bmkxRUYwB3VuaTFFRjEHdW5pMUVGNAd1bmkxRUY1B3VuaTFFRjYHdW5pMUVGNwd1bmkxRUY4B3VuaTFFRjkHdW5pMjBBQgd1bmkwMzBGE2NpcmN1bWZsZXhhY3V0ZWNvbWITY2lyY3VtZmxleGdyYXZlY29tYhJjaXJjdW1mbGV4aG9va2NvbWITY2lyY3VtZmxleHRpbGRlY29tYg5icmV2ZWFjdXRlY29tYg5icmV2ZWdyYXZlY29tYg1icmV2ZWhvb2tjb21iDmJyZXZldGlsZGVjb21iEGN5cmlsbGljaG9va2xlZnQIb25lLnBudW0HemVyby5vcwZvbmUub3MGdHdvLm9zCHRocmVlLm9zB2ZvdXIub3MHZml2ZS5vcwZzaXgub3MIc2V2ZW4ub3MIZWlnaHQub3MHbmluZS5vcwJmZgd1bmkyMTIwCFRjZWRpbGxhCHRjZWRpbGxhBWcuYWx0D2djaXJjdW1mbGV4LmFsdApnYnJldmUuYWx0CGdkb3QuYWx0EGdjb21tYWFjY2VudC5hbHQGSXRpbGRlB0ltYWNyb24GSWJyZXZlB0lvZ29uZWsCSUoJSW90YXRvbm9zBElvdGEMSW90YWRpZXJlc2lzCWFmaWkxMDA1NQlhZmlpMTAwNTYHdW5pMDRDMAd1bmkwNENGB3VuaTFFQzgHdW5pMUVDQQAAAQADAAgACgAWAAf//wAPAAEAAAAMAAAAAAAAAAIABQAAAjUAAQI3AjcAAQI7AlsAAQJdA3YAAQOAA6cAAQAAAAEAAAAKAAwADgAAAAAAAAABAAAACgBuAVoAAWxhdG4ACAAQAAJNT0wgAChST00gAEIAAP//AAkAAwAIAAsAAAAOABEAFAAXABoAAP//AAoABAAGAAkADAABAA8AEgAVABgAGwAA//8ACgAFAAcACgANAAIAEAATABYAGQAcAB1saWdhALBsaWdhALBsaWdhALBsbnVtALZsbnVtALZsbnVtALZsb2NsALxsb2NsALxvbnVtAMJvbnVtAMJvbnVtAMJwbnVtAMpwbnVtAMpwbnVtAMpzYWx0ANBzYWx0ANBzYWx0ANBzczAxANBzczAxANBzczAxANBzczAyANhzczAyANhzczAyANhzczAzAN5zczAzAN5zczAzAN50bnVtAOR0bnVtAOR0bnVtAOQAAAABAAkAAAABAAcAAAABAAgAAAACAAIAAwAAAAEABAAAAAIAAAABAAAAAQAAAAAAAQABAAAAAgAFAAYACgAWADwAfACUAMwA4ADuAQIBLgFQAAEAAAABAAgAAgAQAAUDjwOQA5EDkgOTAAEABQBKAN8A4QDjAOUAAQAAAAEACAACAC4AFAAsAI4AjwCQAJEA6gDsAO4A8ADyAPQBWgFnAXcBoQGiAskC2ANFA0cAAgABA5QDpwAAAAEAAAABAAgAAQAGA24AAgABABMAHAAAAAEAAAABAAgAAgAaAAoDgQODA4QDhQOGA4cDiAOJA4oDggACAAMAEwATAAAAFQAcAAEDgAOAAAkAAQAAAAEACAABAAYDbAABAAEAFAABAAAAAQAIAAEAPPySAAEAAAABAAgAAQAG/JQAAQABA4AAAQAAAAEACAACABoACgATA4AAFQAWABcAGAAZABoAGwAcAAIAAQOBA4oAAAABAAAAAQAIAAIADgAEA40DjgEgASEAAQAEASQBJQFJAUoABAAAAAEACAABADYAAQAIAAUADAAUABwAIgAoAl4AAwBJAE8CXQADAEkATAOLAAIASQI1AAIATwI0AAIATAABAAEASQAA";

var openSansSemiBold = "data:font/ttf;base64,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siXKtQGBvrv//wAA/hQESgXsAiYAXAAAAQYAasoAAAq0AgEqESYAKzU1//8AAAAABUoG2QImACQAAAEHAU0ATAFSAAizAhMFJgArNf//AFr/7AQEBYcCJgBEAAABBgFNAAAACLMCKhEmACs1//8AAAAABUoHWgImACQAAAEHAU4APwFSAAizAhAFJgArNf//AFr/7AQEBggCJgBEAAABBgFO+QAACLMCJxEmACs1//8AAP4rBUoFvAImACQAAAAHAVEDjQAA//8AWv4rBCUEZgImAEQAAAAHAVECngAA//8Aef/sBM8HcwImACYAAAEHAHYBCAFSAAizASIFJgArNf//AGb/7AO0BiECJgBGAAABBgB2WAAACLMBHxEmACs1//8Aef/sBM8HcwImACYAAAEHAUsAqgFSAAizASUFJgArNf//AGb/7APHBiECJgBGAAABBgFL4gAACLMBIhEmACs1//8Aef/sBM8HTAImACYAAAEHAU8B+gFSAAizASIFJgArNf//AGb/7AO0BfoCJgBGAAABBwFPAUYAAAAIswEfESYAKzX//wB5/+wEzwdzAiYAJgAAAQcBTAC2AVIACLMBHgUmACs1//8AZv/sA+AGIQImAEYAAAEGAUz7AAAIswEbESYAKzX//wDBAAAFZgdzAiYAJwAAAQcBTABgAVIACLMCFQUmACs1//8AZv/sBdMGFAImAEcAAAAHAjgDPQAA//8ALwAABV4FtgIGAJIAAAACAGb/7ATwBhQAGwAnAHBAQgkQGSAEDRMNFiYDAw4VFgQpKAkaAAYWDg8OSVkTDw8fDy8PAxMDDw8GEQAYFQYjRlkABhAGIAYDCQMGDwAcRlkAFgA/KwAYP19eXSsAGD8/EjkvX15dMysRADMREjk5ERIBFzkRMxEzMxEXMzEwBSICERASMzIXMyYmNTUhNSE1MxUzFSMRIycjBicyNjU1NCYjIgYVEAIZzuXd2t5yDAMO/oEBf+ycnMErCmyQjoOBmH17FAEnAQQBFQEcogqKLF2jrq6j+z2Rpb6frSHMpLHC/pYA//8AwQAAA/wG2QImACgAAAEHAU0ABAFSAAizAQ8FJgArNf//AGb/7AQ5BYcCJgBIAAABBgFNAgAACLMCHxEmACs1//8AwQAAA/wHWgImACgAAAEHAU7//wFSAAizAQwFJgArNf//AGb/7AQ5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DkxZCwMJFUxZCQQBE0xZARMDG0xZAxIAPysAGD8rABg/KwAYPysREgA5GC8rERIBFzkRMxEzETMRMzEwISEGIyAAERAAITIXIRUhESEVIREhASICERASMzI3ESYHG/zMZm3+wP6lAVgBP3NeAzr9wAIb/eUCQPv+0NbU0IFUUBQBiQFqAWgBhhfK/nLI/jUENf7q/vP+8/7oIwQAJQAAAwBm/+wHTARmAB0AKQAwAG9APQ0CJC0UFCQuEx4HBxMaJAQyMQ0CBAotFEhZDC0cLQIQAy0tBAoPKkhZDwoKJ0ZZChAAF0dZAAQEIUZZBBYAPysRADMrABg/KxEAMysREgA5GC9fXl0rERIAOTkREgEXOREzETMRMxEzEjk5MTAFICcGISIAERAAMzIWFzYzMgAVFSEWFjMyNjcVBgYBFBYzMjY1NCYjIgYlIgYHITQmBZ7+54uE/vTs/ugBEvV5zEKD+N0BAP0eC5WaZqpgVK/7R4OSjYOEkY+BBBluhwsB8X4UwsIBNgEJARABK2Jgwv716H+kqiUrvygjAj+9wr+8wL++zIuLhpAA//8AwQAABQoHcwImADUAAAEHAHYAhQFSAAizAh8FJgArNf//AKgAAANOBiECJgBVAAABBgB28wAACLMBGhEmACs1//8Awf47BQoFtgImADUAAAAHAjkAmAAA//8AYf47A04EZgImAFUAAAAHAjn++wAA//8AwQAABQoHcwImADUAAAEHAUwAJwFSAAizAhsFJgArNf//AGsAAANtBiECJgBVAAABBgFMiAAACLMBFhEmACs1//8AZP/sBAwHcwImADYAAAEHAHYATgFSAAizAS4FJgArNf//AGL/7AOPBiECJgBWAAABBgB2+wAACLMBKxEmACs1//8AZP/sBAwHcwImADYAAAEHAUv/6gFSAAizATEFJgArNf//AGL/7AOPBiECJgBWAAABBgFLnQAACLMBLhEmACs1//8AZP4UBAwFywImADYAAAAHAHoBRAAA//8AYv4UA48EZgImAFYAAAAHAHoBAAAA//8AZP/sBAwHcwImADYAAAEHAUz/6AFSAAizASoFJgArNf//AGL/7AOPBiECJgBWAAABBgFMowAACLMBJxEmACs1//8AHf47BGgFtgImADcAAAAGAjkhAP//ACf+OwLwBUgCJgBXAAAABgI5qQD//wAd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gwQIDzavagGQAnd/f7HQ/gwEw6OurqNrHVFdV1H+awD//wCoAAAEfwYhAiYB1AAAAQYAdnEAAAizARQRJgArNf//AAD+FARKBiUCJgBcAAABBgI22gAACLMBFREmACs1AAEAqP57BIMEUgALADBAGAgLBAcDAAAHCwMNDAUBDwoiAANHWQgAFQA/MisAGD8/MxESARc5ETMRMxEzMTAzETMRIREzESERIxGo6wIF6/6D2wRS/GgDmPuu/nsBhQABAMEAAARCBucABwAvQBcDBgABBgEJCAESDwQBCgMEAgIHTFkCAwA/KwAYEMZfXl0/ERIBOTkRMxEzMTAhIxEhETMRIQGw7wKp2P1uBbYBMf4CAAABAKgAAAOJBYsABwAnQBIDBgABBgEJCAQCARUCB0hZAg8APysAGD8QxhESATk5ETMRMzEwISMRIREzESEBk+sCBN3+CgRSATn+FQD//wAMAAAHgwdzAiYAOgAAAQcAQwEIAVIACLMBJgUmACs1//8AFAAABnMGIQImAFoAAAEGAEN9AAAIswEnESYAKzX//wAMAAAHgwdzAiYAOgAAAQcAdgG0AVIACLMBJgUmACs1//8AFAAABnMGIQImAFoAAAEHAHYBPwAAAAizAScRJgArNf//AAwAAAeDBz4CJgA6AAABBwBqAWgBUgAKtAIBMgUmACs1Nf//ABQAAAZzBewCJgBaAAABBwBqAOUAAAAKtAIBMxEmACs1Nf//AAAAAAS8B3MCJgA8AAABBwBD/4gBUgAIswESBSYAKzX//wAA/hQESgYhAiYAXAAAAQcAQ/9dAAAACLMBHhEmACs1AAEAUgHHA64ChQADABG1AwAFBAABAC8zERIBOTkxMBM1IRVSA1wBx76+AAEAUgHHB64ChQADABG1AwAFBAABAC8zERIBOTkxMBM1IRVSB1wBx76+AAEAUgHHB64ChQADABG1AwAFBAABAC8zERIBOTkxMBM1IRVSB1wBx76+AAL//P4xA07/0wADAAcAMEALBwMJBgIIAoABAQG4/8C1CQxIAQUGuP/Asw0WSAYALyszxitdMhEBMzMRMzMxMAEhNSE1ITUhA078rgNS/K4DUv4xi4yLAAABABkDwQFzBbYABwAXQAkBBwcFCQgABAMAP80REgE5OREzMTATJzYSNzMCByUMFGY2qkAlA8EWUwEacv8A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RTFFYkWfRdBGC0ZPRplG10ciR4JHzUfVSDFIkEiwSPlJAUlPSapJ4knySihKX0qnStlK4UsHSw9LF0s8S0RLp0uvS+BMHUxNTIhMzE0RTU5NnE35TkNOVE7HTtdPJU8tTzVPR09PT6lP/FBeUG5QflCtUNdQ/VEOUR5RL1FAUVJRZFF1UYZRm1GwUcVR8VIRUjBSUVJxUqJS0lMFU0FTolPCVA9UsVS5VMFU41UGVRJVL1VkVapWGlaKVv9Xa1fJWDtYjViVWOVY/FkTWSpZQVmbWdhZ/lo8WlVaglrmWxlbmVvoXBZcRFx7XIdck1y/XOZdB10pXUtdgF3AXgReVV54Xt9fMV8xXzFfMV8xXzFfMV8xXzFfMV8xXzFfMV8xYG5gzmDfYOdhbGGtYhNiJGI1YkFiTWJZYphi1mLmYvZjTmOqY/hkTWRWZF9kaGSMZKZkt2TIZNhk6GViZbdmE2ZkZsVnH2drZ7FoGGh0aN1pSGnDaj1q6muEa4xrlGvpbD1sgWzDbNVs521jbdpuT268b3FwG3CxcShxaXGqcflyI3JWcoJyrnPEdGF01nVDdZd17nZOdr129Hcsd4J30HgseIh4lHigeOV5J3ltebp6B3paepp62HsXe1d7knvNfCd8en0FfY19mX2lfdZ+CH4QfkR+in7OfxZ/Xn+bf9mAJIBugMiBIIFdgZeCBIJ1guyDY4Nrg3yDjYPlhDWEgITIhQ2FU4WWhdmGI4ZthsaHIYcphzqHSodch22HdYd9h46HnoftiDyITohfiHGIg4iViKaI9olHiViJaIl6iYuJnYmuigOKV4ppinqKjIqdiq6KvorQiuGK84sEixaLJ4tTi3+LkYuji6+Lu4vHi9OMIoxsjKiMsI0NjXiN3o4/jpiO7I9Ej5eP5pA1kIOQ0ZERkVCRrJH/kguSF5Ijki+SQJJRkmOSdZKHkpmSq5K9ks+S4ZL2kwqTHJMuk0CTUpNkk3aTiJOak6+Tw5PPk9uT7JP9lA6UHpQwlEKUVJRmlHiUipSclK6Uw5TXlOiU+ZUFlRGVHZUplTqVS5VdlW+VgZWTlaWVt5XJlduV8JYElhWWJZY2lkaWV5ZolnmWiZaVlqGWrZa5lsqW25bslv2XDpcely+XQJdRl2GXbZd5l4WXkZeil7OXxJfUl+CYC5g9mHCYsZkPmUSZdpm9mhqaSJpvmpaavpr/myebaZvEnAqcWZxhnIqckpzxnP2dfZ2JnZWd9p4GnhaeJ543nkyeXZ5unn+ekZ6inrOexJ7PnuCe7J75nwGfE58bny2fNZ89n06fWgAAAAEAAAABGdsC+H+SXw889QAJCAAAAAAAyUzqfQAAAADVK8zV+1T9vgoXCGQAAAAJAAIAAAAAAAAEzQDBAAAAAAQUAAACFAAAAjUAhQN9AIUFKwAvBJEAbwblAFQF7ABgAfIAhQKJAFICiQA9BGIASgSRAGACIwA/ApMASAIzAIUDHwAQBJEAWASRAJoEkQBaBJEAVgSRACcEkQB1BJEAXgSRAEoEkQBYBJEAVgIzAIUCOQA/BJEAYASRAGYEkQBgA6AAEAcvAG8FSgAABUgAwQUSAHkF3wDBBHcAwQRCAMEFzwB5BgIAwQLjAEoCZP9kBR0AwQRWAMEHYgDBBkQAwQZMAHkE7ADBBkwAeQUdAMEEZgBkBIcAHQXwALQE+gAAB5EADAT6AAQEvAAABJoAQgKkAJoDHwAQAqQAMwRMAB0Db//8BLwBagSkAFoE/ACoA/YAZgT8AGYEnABmAucAIwRzABcFFACoAjsAmgI7/4cEkwCoAjsAqAemAKgFFACoBOMAZgT8AKgE/ABmA3MAqAPlAGIDJQAnBRQAngRIAAAGiQAUBGgAGQRKAAAD0wBEAxcALQRoAdkC+AAtBJEAYAIUAAACNQCFBJEApgSRAEgEkQB1BJEAEgRoAdkEAgBzBLwBJQaoAGQC8gA5BHMAUgSRAGACkwBIBqgAZAQA//oDbQBtBJEAYALnADMC5wAtBLwBagUdAKgFPQBxAjMAhQG6AAAC5wBUAwwAPQRzAFAGpAA8BqQALgakADcDoAA3BUoAAAVKAAAFSgAABUoAAAVKAAAFSgAAB0z//gUSAHkEdwDBBHcAwQR3AMEEdwDBAuMANALjAEoC4//uAuMAOgXZAC8GRADBBkwAeQZMAHkGTAB5BkwAeQZMAHkEkQCDBkwAeQXwALQF8AC0BfAAtAXwALQEvAAABPQAwQVUAKgEpABaBKQAWgSkAFoEpABaBKQAWgSkAFoHGQBaA/YAZgScAGYEnABmBJwAZgScAGYCO/+7AjsAnAI7/5wCO//nBNsAZgUUAKgE4wBmBOMAZgTjAGYE4wBmBOMAZgSRAGAE4wBmBRQAngUUAJ4FFACeBRQAngRKAAAE/ACoBEoAAAVKAAAEpABaBUoAAASkAFoFSgAABKQAWgUSAHkD9gBmBRIAeQP2AGYFEgB5A/YAZgUSAHkD9gBmBd8AwQT8AGYF2QAvBQwAZgR3AMEEnABmBHcAwQScAGYEdwDBBJwAZgR3AMEEnABmBHcAwQScAGYFzwB5BHMAFwXPAHkEcwAXBc8AeQRzABcFzwB5BHMAFwYCAMEFFACoBgIAAAUUAAwC4//rAjv/lwLjADQCO//gAuMAEwI7/70C4wBKAjsAMALjAEoCOwCoBUgASgRiAJoCZP9kAjv/hwUdAMEEkwCoBI0AqARWAMECOwCoBFYAwQI7AF0EVgDBAjsAqARWAMEC+ACoBFoADgJc//4GRADBBRQAqAZEAMEFFACoBkQAwQUUAKgF1wADBkQAwQUUAKgGTAB5BOMAZgZMAHkE4wBmBkwAeQTjAGYHlgB5B64AZgUdAMEDcwCoBR0AwQNzAGEFHQDBA3MAawRmAGQD5QBiBGYAZAPlAGIEZgBkA+UAYgRmAGQD5QBiBIcAHQMlACcEhwAdAyUAJwSHAB0DJQAnBfAAtAUUAJ4F8AC0BRQAngXwALQFFACeBfAAtAUUAJ4F8AC0BRQAngXwALQFFACeB5EADAaJABQEvAAABEoAAAS8AAAEmgBCA9MARASaAEID0wBEBJoAQgPTAEQCzwCoBJgAwwVMAAAEpABaB0z//gcZAFoGTAB5BOMAZgRmAGQD5QBiBMsA4wTLAOMExwEjBMsBBAI7AJoEngFgAZwAFwTLAOwEqADBBJ4B6QSeAOkFSv/yAjMAhQT+/7kGlv+5A9f/wQaY/9YF0f+vBmT/1gL8/9gFSgAABUgAwQRSAMEE7AAvBHcAwQSaAEIGAgDBBkwAeQLjAEoFHQDBBQIAAAdiAMEGRADBBH8ATAZMAHkF5QDBBOwAwQSkAEwEhwAdBLwAAAaiAGIE+gAEBrAAbQZGAEQC4wA6BLwAAAUIAGYEHwBUBRQAqAL8AKQFBACaBQgAZgUnAKgEUgAGBMsAZgQfAFQD7ABmBRQAqATXAGYC/ACkBI0AqASY//wFHQCoBIsAAgPjAGYE4wBmBY0AGQTjAI8D7ABmBRAAZgQKAB0FBACaBgoAZgSN/90GXACaBosAbwL8AAkFBACaBOMAZgUEAJoGiwBvBHcAwQYnAB0EUgDBBUQAeQRmAGQC4wBKAuMAOgJk/2QHtgAIB9EAwQYnAB0FIwDBBRkADAXlAMEFSgAABQAAwQVIAMEEUgDBBckADAR3AMEHJQAABOkAWAZWAMEGVgDBBSMAwQXLAAgHYgDBBgIAwQZMAHkF5QDBBOwAwQUSAHkEhwAdBRkADAaiAGIE+gAEBhIAwQWwAIsIcQDBCJYAwQWoAAgHCADBBR8AwQUrAEIIewDBBTMAFASkAFoE3wBoBNUAqAOgAKgE8gAjBJwAZgZvAAIEJwBIBWoAqAVqAKgEjQCoBN0ACAZQAKgFLwCoBOMAZgUXAKgE/ACoA/YAZgQUACsESgAABh0AZgRoABkFQgCoBQ4AiwdvAKgHhwCoBZ4AFAZ7AKgE0wCoBAQAQgbVAKgEmAASBJwAZgUUAAwDoACoBBAAZgPlAGICOwCaAjv/6QI7/4cG5QAIBxkAqAUUAAwEjQCoBEoAAAUrAKgEbwDBA8MAqAeRAAwGiQAUB5EADAaJABQHkQAMBokAFAS8AAAESgAABAAAUggAAFIIAABSA0r//AGLABkBiwAZAiUAPwGLABkDLQAZAy0AGQOwACsEEgB7BCUAewMCAIMGjQCFCe4AUgHyAIUDfQCFArAAUgKwAFAEaACFAQr+dwNEAGgEkQBCBJEASgaeAKgEpAA/BnkAZgQpAFAILwCoBhkAGwZGAEQE9ABmBqQAQQakAC0GpABQBqQAVgSmAFAE7AAvBewAtgUMADkEkQBgBGQAJQWmAHMDLwAGBJEAXASRAGAEkQBeBJEAYASqAGIFIwAjBSMAIwSeAKICO/+HBAABcwQAAWYEAAFmAucAJwLnABAC5wBIAucAKwLnADkC5wAvAucAJwQAAAAIAAAABAAAAAgAAAACqgAAAgAAAAFWAAAEeQAAAjMAAAGaAAAAzQAAAAAAAAAAAAAIAABUCAAAVAI7/4cBiQAQBWoAGQTJAAAHWgAjB2IAwQemAKgFSgAABKQAWgaB/qcCqgBmApoAhwgKACMICgAjBmoAeQUnAGYGnAC0BbIAngAA/DQAAPzuAAD7/QAA/PAAAP0KBHcAwQZWAMEEnABmBWoAqAhkAH0G0QACBWQACgUtAAoHeQDBBiUAqAWiAAAE0QAEB7QAwQasAKgGGQAfBQ4AEAgvAMEG5wCoBNsAMwQnABsGsABtBlwAmgZOAHkE4wBmBV4AAARxAAAFXgAABHEAAAodAHkI0wBmBp4AeQVYAGYIWAB5BssAZghKAGoG0QACBUQAeQQMAGYE3wBoBHUAvgSeAPYEngHVBJ4B1wfpACkHpgApBr4AwQXHAKgE6QAvBNMADAT0AMEE/ACoBFgALwOsAAoFgQDBBIEAqAesAAAG4wACBOkAWAQnAEgFqgDBBNcAqAUdAMEEhwCoBR0ALwSLAAwFsAAIBT0AFAZYAMEFjwCoBpYAwQX6AKgIxQDBBwQAqAY5AHkFLwBmBRIAeQP2AGYEhwAdBBAAKwS8AAAETAAABLwAAARMAAAFcwAEBLoAGQcjAB0GCAArBfwAiwVWAIsFsACLBQYAiwWwAMEFAACoByUAHwV/ABkHJQAfBX8AGQLjAEoHJQAABm8AAgXLAMEE1wCoBi0ACAUxAAgF+ADBBR0AqAZoAMEFlgCoBbAAiwUOAIsHwwDBBqYAqALjAEoFSgAABKQAWgVKAAAEpABaB0z//gcZAFoEdwCwBJwAZgYvAIsEpABgBi8AiwSkAGAHJQAABm8AAgTpAFgEJwBIBLIAQgRIACkGVgDBBWoAqAZWAMEFagCoBkwAeQTjAGYGTgB5BOMAZgZOAHkE4wBmBSsAQgQEAEIFGQAMBEoAAAUZAAwESgAABRkADARKAAAFsACLBQ4AiwRaAMEDoACoBwgAwQZ7AKgEWAAvA6wACgVoAAQEvAAZBPoAAgRoABkFAABvBPwAZgdMAG8HRgBmB0QAMwawAEQFTgAzBLwATggOAAgHJQAICDcAwQd1AKgGOQB5BTUAZgXfAB0FhQArBOwAYgQfAFQGEgAIBS0ACAVKAAAEpABaBUoAAASkAFoFSgAABKQAWgVKAAAEpAAABUoAAASkAFoFSgAABKQAWgVKAAAEpABaBUoAAASkAFoFSgAABKQAWgVKAAAEpABaBUoAAASkAFoFSgAABKQAWgR3AMEEnABmBHcAwQScAGYEdwDBBJwAZgR3AMEEnABmBHcAFQScABUEdwDBBJwAZgR3AMEEnABmBHcAwQScAGYC4wBKAjsAdwLjAEoCOwCXBkwAeQTjAGYGTAB5BOMAZgZMAHkE4wBmBkwAeQTjACEGTAB5BOMAZgZMAHkE4wBmBkwAeQTjAGYGagB5BScAZgZqAHkFJwBmBmoAeQUnAGYGagB5BScAZgZqAHkFJwBmBfAAtAUUAJ4F8AC0BRQAngacALQFsgCeBpwAtAWyAJ4GnAC0BbIAngacALQFsgCeBpwAtAWyAJ4EvAAABEoAAAS8AAAESgAABLwAAARKAAAFDABmAAD7sgAA/E4AAPtUAAD8TgAA/FIAAPxUAAD8VAAA/FQAAPxUAaQAHQH8ABQB/AAUA4MALwS0AG0DcQA1BFIANQSRAFYEjwAXBJEAdQSRAF4EkQBKBJEAWASRAFYFzwAjBh0AVgSHAB0DJQAnBPwAZgT8AGYE/ABmBPwAZgT8AGYCcQDBAnH/+gJxALMCcf+1AnEAAQJx/7ICcf/7AnH/2gJxAEwCcQCzBNUAwQMQ/8ECcQDBAAEAwQABAMEAwQCSALIAAAABAAAIjf2oAAAKHftU/nsKFwABAAAAAAAAAAAAAAAAAAADowADBOICWAAFAAAFmgUzAAABHwWaBTMAAAPRAGYB9gAAAgsHBgMIBAICBOAAAu9AACBbAAAAKAAAAAAxQVNDAEAAIP/9Bh/+FACECI0CWCAAAZ8AAAAABFIFtgAAACAAAwAAAAEAAwABAAAADAAEA3wAAADGAIAABgBGAEgASQB+AMsAzwEnATIBYQFjAX8BkgGhAbAB8AH/AhsCNwK8AscCyQLdAvMDAQMDAwkDDwMjA4kDigOMA5gDmQOhA6kDqgPOA9ID1gQNBE8EUARcBF8EhgSPBJEEvwTABM4EzwUTHgEePx6FHsceyh7xHvMe+R9NIAsgFSAeICIgJiAwIDMgOiA8IEQgcCB5IH8gpCCnIKwhBSETIRYhICEiISYhLiFeIgIiBiIPIhIiGiIeIisiSCJgImUlyvsE/v///f//AAAAIABJAEoAoADMANABKAEzAWIBZAGSAaABrwHwAfoCGAI3ArwCxgLJAtgC8wMAAwMDCQMPAyMDhAOKA4wDjgOZA5oDowOqA6sD0QPWBAAEDgRQBFEEXQRgBIgEkASSBMAEwQTPBNAeAB4+HoAeoB7IHsse8h70H00gACATIBcgICAmIDAgMiA5IDwgRCBwIHQgfyCjIKcgqyEFIRMhFiEgISIhJiEuIVsiAiIGIg8iESIaIh4iKyJIImAiZCXK+wD+///8////4wNN/+P/wgLL/8IAAP/CAi3/wv+wAL8AsgBh/0kAAAAA/5b+hf6E/nb/aP9j/2L/XQBn/0T90AAX/c/9zgAJ/c79zf/5/c3+gv5/AAD9mv4a/ZkAAP4M/gv9aP4J/ub+Cf7Y/gnkWOQY43rkfQAA5H3jDuR74w3iQuHv4e7h7eHq4eHh4OHb4drh0+HL4cjhmeF24XQAAOEY4QvhCeJu4P7g++D04MjgJeAi4BrgGeAS4A/gA9/n39DfzdxpAAADTwJTAAEAAAAAAAAAAAAAAAAAugAAAAAAAAAAAAAAAAAAAAAAvgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJgAAAAAAAAArAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFIAAAAAAAADmwDrA5wA7QOdAO8DngDxA58A8wOgAUkBSgEkASUCaAGcAZ0BngGfAaADpAOlAaMBpAGlAaYBpwJpAmsB9gH3A6gDRgOpA3UCHAONAjQCNQJdAl5AR1taWVhVVFNSUVBPTk1MS0pJSEdGRURDQkFAPz49PDs6OTg3NjUxMC8uLSwoJyYlJCMiIR8YFBEQDw4NCwoJCAcGBQQDAgEALCCwAWBFsAMlIBFGYSNFI2FILSwgRRhoRC0sRSNGYLAgYSCwRmCwBCYjSEgtLEUjRiNhsCBgILAmYbAgYbAEJiNISC0sRSNGYLBAYSCwZmCwBCYjSEgtLEUjRiNhsEBgILAmYbBAYbAEJiNISC0sARAgPAA8LSwgRSMgsM1EIyC4AVpRWCMgsI1EI1kgsO1RWCMgsE1EI1kgsAQmUVgjILANRCNZISEtLCAgRRhoRCCwAWAgRbBGdmiKRWBELSwBsQsKQyNDZQotLACxCgtDI0MLLSwAsCgjcLEBKD4BsCgjcLECKEU6sQIACA0tLCBFsAMlRWFksFBRWEVEGyEhWS0sSbAOI0QtLCBFsABDYEQtLAGwBkOwB0NlCi0sIGmwQGGwAIsgsSzAioy4EABiYCsMZCNkYVxYsANhWS0sigNFioqHsBErsCkjRLApeuQYLSxFZbAsI0RFsCsjRC0sS1JYRUQbISFZLSxLUVhFRBshIVktLAGwBSUQIyCK9QCwAWAj7ewtLAGwBSUQIyCK9QCwAWEj7ewtLAGwBiUQ9QDt7C0ssAJDsAFSWCEhISEhG0YjRmCKikYjIEaKYIphuP+AYiMgECOKsQwMinBFYCCwAFBYsAFhuP+6ixuwRoxZsBBgaAE6WS0sIEWwAyVGUkuwE1FbWLACJUYgaGGwAyWwAyU/IyE4GyERWS0sIEWwAyVGUFiwAiVGIGhhsAMlsAMlPyMhOBshEVktLACwB0OwBkMLLSwhIQxkI2SLuEAAYi0sIbCAUVgMZCNki7ggAGIbsgBALytZsAJgLSwhsMBRWAxkI2SLuBVVYhuyAIAvK1mwAmAtLAxkI2SLuEAAYmAjIS0sS1NYirAEJUlkI0VpsECLYbCAYrAgYWqwDiNEIxCwDvYbISOKEhEgOS9ZLSxLU1ggsAMlSWRpILAFJrAGJUlkI2GwgGKwIGFqsA4jRLAEJhCwDvaKELAOI0SwDvawDiNEsA7tG4qwBCYREiA5IyA5Ly9ZLSxFI0VgI0VgI0VgI3ZoGLCAYiAtLLBIKy0sIEWwAFRYsEBEIEWwQGFEGyEhWS0sRbEwL0UjRWFgsAFgaUQtLEtRWLAvI3CwFCNCGyEhWS0sS1FYILADJUVpU1hEGyEhWRshIVktLEWwFEOwAGBjsAFgaUQtLLAvRUQtLEUjIEWKYEQtLEUjRWBELSxLI1FYuQAz/+CxNCAbszMANABZREQtLLAWQ1iwAyZFilhkZrAfYBtksCBgZiBYGyGwQFmwAWFZI1hlWbApI0QjELAp4BshISEhIVktLLACQ1RYS1MjS1FaWDgbISFZGyEhISFZLSywFkNYsAQlRWSwIGBmIFgbIbBAWbABYSNYG2VZsCkjRLAFJbAIJQggWAIbA1mwBCUQsAUlIEawBCUjQjywBCWwByUIsAclELAGJSBGsAQlsAFgI0I8IFgBGwBZsAQlELAFJbAp4LApIEVlRLAHJRCwBiWwKeCwBSWwCCUIIFgCGwNZsAUlsAMlQ0iwBCWwByUIsAYlsAMlsAFgQ0gbIVkhISEhISEhLSwCsAQlICBGsAQlI0KwBSUIsAMlRUghISEhLSwCsAMlILAEJQiwAiVDSCEhIS0sRSMgRRggsABQIFgjZSNZI2ggsEBQWCGwQFkjWGVZimBELSxLUyNLUVpYIEWKYEQbISFZLSxLVFggRYpgRBshIVktLEtTI0tRWlg4GyEhWS0ssAAhS1RYOBshIVktLLACQ1RYsEYrGyEhISFZLSywAkNUWLBHKxshISFZLSywAkNUWLBIKxshISEhWS0ssAJDVFiwSSsbISEhWS0sIIoII0tTiktRWlgjOBshIVktLACwAiVJsABTWCCwQDgRGyFZLSwBRiNGYCNGYSMgECBGimG4/4BiirFAQIpwRWBoOi0sIIojSWSKI1NYPBshWS0sS1JYfRt6WS0ssBIASwFLVEItLLECAEKxIwGIUbFAAYhTWli5EAAAIIhUWLICAQJDYEJZsSQBiFFYuSAAAECIVFiyAgICQ2BCsSQBiFRYsgIgAkNgQgBLAUtSWLICCAJDYEJZG7lAAACAiFRYsgIEAkNgQlm5QAAAgGO4AQCIVFiyAggCQ2BCWblAAAEAY7gCAIhUWLICEAJDYEJZsSYBiFFYuUAAAgBjuAQAiFRYsgJAAkNgQlm5QAAEAGO4CACIVFiyAoACQ2BCWVlZWVlZsQACQ1RYQAoFQAhACUAMAg0CG7EBAkNUWLIFQAi6AQAACQEAswwBDQEbsYACQ1JYsgVACLgBgLEJQBuyBUAIugGAAAkBQFm5QAAAgIhVuUAAAgBjuAQAiFVaWLMMAA0BG7MMAA0BWVlZQkJCQkItLEUYaCNLUVgjIEUgZLBAUFh8WWiKYFlELSywABawAiWwAiUBsAEjPgCwAiM+sQECBgywCiNlQrALI0IBsAEjPwCwAiM/sQECBgywBiNlQrAHI0KwARYBLSywgLACQ1CwAbACQ1RbWCEjELAgGskbihDtWS0ssFkrLSyKEOUtQKUJIUggVSABHlUfSB5VHx4BDx4/Hq8eA09GHB9OTRsfTUYaHyY0EFUlJEgfGRP/HwcE/x8GA/8fTEscH0tGGx8TMxJVBQEDVQQzA1UfAwEPAz8DrwMDy0rbSutKA8tJAUhGEh9HRhIfSUYBI0giVRwzG1UWMxVVEQEPVRAzD1XPDwEfDwEPD98P/w8DBgIBAFUBMwBVbwB/AK8A7wAEEAABgBYBBQG4AZCxVFMrK0u4B/9SS7AJUFuwAYiwJVOwAYiwQFFasAaIsABVWltYsQEBjlmFjY0AQh1LsDJTWLAgHVlLsGRTWLAQHbEWAEJZc3MrK15zdHQrKysrK3QrK3Nzc3QrKysrKysrKysrKysrc3QrKysYXgYUABcATgW2ABcAdQW2Bc0AAAAAAAAAAAAAAAAAAARSABQAhgAA/+wAAAAA/+wAAAAA/+wAAP4U/+wAAAW2ABn8lP/t/nv/8v6o/p4AFwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAMAAuACwAKMAlADAAM0AxQDPALoAmgExALIAAAAAAAgAZgADAAEECQAAAGgAAAADAAEECQABACQAaAADAAEECQACAA4AjAADAAEECQADADYAmgADAAEECQAEACQAaAADAAEECQAFABgA0AADAAEECQAGACIA6AADAAEECQAOAFQBCgBEAGkAZwBpAHQAaQB6AGUAZAAgAGQAYQB0AGEAIABjAG8AcAB5AHIAaQBnAGgAdAAgAKkAIAAyADAAMQAxACwAIABHAG8AbwBnAGwAZQAgAEMAbwByAHAAbwByAGEAdABpAG8AbgAuAE8AcABlAG4AIABTAGEAbgBzACAAUwBlAG0AaQBCAG8AbABkAFIAZQBnAHUAbABhAHIAMQAuADEAMAA7ADEAQQBTAEMAOwBPAHAAZQBuAFMAYQBuAHMALQBTAGUAbQBpAEIAbwBsAGQAVgBlAHIAcwBpAG8AbgAgADEALgAxADAATwBwAGUAbgBTAGEAbgBzAC0AUwBlAG0AaQBCAG8AbABkAGgAdAB0AHAAOgAvAC8AdwB3AHcALgBhAHAAYQBjAGgAZQAuAG8AcgBnAC8AbABpAGMAZQBuAHMAZQBzAC8ATABJAEMARQBOAFMARQAtADIALgAwAAIAAAAAAAD/ZgBmAAAAAAAAAAAAAAAAAAAAAAAAAAADqgAAAQIAAgADAAQABQAGAAcACAAJAAoACwAMAA0ADgAPABAAEQASABMAFAAVABYAFwAYABkAGgAbABwAHQAeAB8AIAAhACIAIwAkACUAJgAnACgAKQAqACsBAwAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5ADoAOwA8AD0APgA/AEAAQQBCAEMARABFAEYARwBIAEkASgBLAEwATQBOAE8AUABRAFIAUwBUAFUAVgBXAFgAWQBaAFsAXABdAF4AXwBgAGEArACjAIQAhQC9AJYA6ACGAI4AiwCdAKkApAEEAIoBBQCDAJMA8gDzAI0AlwCIAMMA3gDxAJ4AqgD1APQA9gCiAK0AyQDHAK4AYgBjAJAAZADLAGUAyADKAQYBBwEIAQkA6QBmANMA0ADRAK8AZwDwAJEA1gDUANUAaADrAO0AiQBqAGkAawBtAGwAbgCgAG8AcQBwAHIAcwB1AHQAdgB3AOoAeAB6AHkAewB9AHwAuAChAH8AfgCAAIEA7ADuALoBCgELAQwBDQEOAQ8A/QD+ARABEQESARMA/wEAARQBFQEWAQEBFwEYARkBGgEbARwBHQEeAR8BIAEhASIA+AD5ASMBJAElASYBJwEoASkBKgErASwBLQEuAS8BMAExATIBMwDXATQBNQE2ATcBOAE5AToBOwE8AT0BPgE/AUABQQFCAOIA4wFDAUQBRQFGAUcBSAFJAUoBSwFMAU0BTgFPAVABUQCwALEBUgFTAVQBVQFWAVcBWAFZAVoBWwD7APwA5ADlAVwBXQFeAV8BYAFhAWIBYwFkAWUBZgFnAWgBaQFqAWsBbAFtAW4BbwFwAXEAuwFyAXMBdAF1AOYA5wF2AKYBdwF4AXkBegF7AXwBfQF+ANgA4QDaANsA3ADdAOAA2QDfAX8BgAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AJsBuAG5AboBuwG8Ab0BvgG/AcABwQHCAcMBxAHFAcYBxwHIAckBygHLAcwBzQHOAc8B0AHRAdIB0wHUAdUB1gHXAdgB2QHaAdsB3AHdAd4B3wHgAeEB4gHjAeQB5QHmAecB6AHpAeoB6wHsAe0B7gHvAfAB8QHyAfMB9AH1AfYB9wH4AfkB+gH7AfwB/QH+Af8CAAIBAgICAwIEAgUCBgIHAggCCQIKAgsCDAINAg4CDwIQAhECEgITAhQCFQIWAhcCGAIZAhoCGwIcAh0CHgIfAiACIQIiAiMCJAIlAiYCJwIoAikCKgIrALIAswIsAi0AtgC3AMQCLgC0ALUAxQCCAMIAhwCrAMYCLwIwAL4AvwIxALwCMgD3AjMCNAI1AjYCNwI4AIwAnwI5AjoCOwI8Aj0AmACoAJoAmQDvAKUAkgCcAKcAjwCUAJUAuQI+Aj8CQAJBAkICQwJEAkUCRgJHAkgCSQJKAksCTAJNAk4CTwJQAlECUgJTAlQCVQJWAlcCWAJZAloCWwJcAl0CXgJfAmACYQJiAmMCZAJlAmYCZwJoAmkCagJrAmwCbQJuAm8CcAJxAnICcwJ0AnUCdgJ3AngCeQJ6AnsCfAJ9An4CfwKAAoECggKDAoQChQKGAocCiAKJAooCiwKMAo0CjgKPApACkQKSApMClAKVApYClwKYApkCmgKbApwCnQKeAp8CoAKhAqICowKkAqUCpgKnAqgCqQKqAqsCrAKtAq4CrwKwArECsgKzArQCtQK2ArcCuAK5AroCuwK8Ar0CvgK/AsACwQLCAsMCxALFAsYCxwLIAskCygLLAswCzQLOAs8C0ALRAtIC0wLUAtUC1gLXAtgC2QLaAtsC3ALdAt4C3wLgAuEC4gLjAuQC5QLmAucC6ALpAuoC6wLsAu0C7gLvAvAC8QLyAvMC9AL1AvYC9wL4AvkC+gL7AvwC/QL+Av8DAAMBAwIDAwMEAwUDBgMHAwgDCQMKAwsDDAMNAw4DDwMQAxEDEgMTAxQDFQMWAxcDGAMZAxoDGwMcAx0DHgMfAyADIQMiAyMDJAMlAyYDJwMoAykDKgMrAywDLQMuAy8DMAMxAzIDMwM0AzUDNgM3AzgDOQM6AzsDPAM9Az4DPwNAA0EDQgNDA0QDRQNGA0cDSANJA0oDSwNMA00DTgNPA1ADUQNSA1MDVANVA1YDVwNYA1kDWgNbA1wDXQNeA18DYANhA2IDYwNkA2UDZgNnA2gDaQNqA2sDbANtA24DbwNwA3EDcgNzA3QDdQN2A3cDeAN5A3oDewN8A30DfgN/A4ADgQOCA4MDhAOFA4YDhwOIA4kDigOLA4wDjQOOA48DkAORA5IDkwOUA5UDlgOXA5gDmQOaA5sDnAOdA54DnwAsAM8AzADNAM4DoAOhA6IDowD6A6QDpQOmA6cDqAOpA6oDqwOsA60EbnVsbAVJLmFsdAd1bmkwMEFECW92ZXJzY29yZQpJZ3JhdmUuYWx0CklhY3V0ZS5hbHQPSWNpcmN1bWZsZXguYWx0DUlkaWVyZXNpcy5hbHQHQW1hY3JvbgdhbWFjcm9uBkFicmV2ZQZhYnJldmUHQW9nb25lawdhb2dvbmVrC0NjaXJjdW1mbGV4C2NjaXJjdW1mbGV4BENkb3QEY2RvdAZEY2Fyb24GZGNhcm9uBkRjcm9hdAdFbWFjcm9uB2VtYWNyb24GRWJyZXZlBmVicmV2ZQpFZG90YWNjZW50CmVkb3RhY2NlbnQHRW9nb25lawdlb2dvbmVrBkVjYXJvbgZlY2Fyb24LR2NpcmN1bWZsZXgLZ2NpcmN1bWZsZXgER2RvdARnZG90DEdjb21tYWFjY2VudAxnY29tbWFhY2NlbnQLSGNpcmN1bWZsZXgLaGNpcmN1bWZsZXgESGJhcgRoYmFyCkl0aWxkZS5hbHQGaXRpbGRlC0ltYWNyb24uYWx0B2ltYWNyb24KSWJyZXZlLmFsdAZpYnJldmULSW9nb25lay5hbHQHaW9nb25law5JZG90YWNjZW50LmFsdAZJSi5hbHQCaWoLSmNpcmN1bWZsZXgLamNpcmN1bWZsZXgMS2NvbW1hYWNjZW50DGtjb21tYWFjY2VudAxrZ3JlZW5sYW5kaWMGTGFjdXRlBmxhY3V0ZQxMY29tbWFhY2NlbnQMbGNvbW1hYWNjZW50BkxjYXJvbgZsY2Fyb24ETGRvdARsZG90Bk5hY3V0ZQZuYWN1dGUMTmNvbW1hYWNjZW50DG5jb21tYWFjY2VudAZOY2Fyb24GbmNhcm9uC25hcG9zdHJvcGhlA0VuZwNlbmcHT21hY3JvbgdvbWFjcm9uBk9icmV2ZQZvYnJldmUNT2h1bmdhcnVtbGF1dA1vaHVuZ2FydW1sYXV0BlJhY3V0ZQZyYWN1dGUMUmNvbW1hYWNjZW50DHJjb21tYWFjY2VudAZSY2Fyb24GcmNhcm9uBlNhY3V0ZQZzYWN1dGULU2NpcmN1bWZsZXgLc2NpcmN1bWZsZXgMVGNvbW1hYWNjZW50DHRjb21tYWFjY2VudAZUY2Fyb24GdGNhcm9uBFRiYXIEdGJhcgZVdGlsZGUGdXRpbGRlB1VtYWNyb24HdW1hY3JvbgZVYnJldmUGdWJyZXZlBVVyaW5nBXVyaW5nDVVodW5nYXJ1bWxhdXQNdWh1bmdhcnVtbGF1dAdVb2dvbmVrB3VvZ29uZWsLV2NpcmN1bWZsZXgLd2NpcmN1bWZsZXgLWWNpcmN1bWZsZXgLeWNpcmN1bWZsZXgGWmFjdXRlBnphY3V0ZQpaZG90YWNjZW50Cnpkb3RhY2NlbnQFbG9uZ3MKQXJpbmdhY3V0ZQphcmluZ2FjdXRlB0FFYWN1dGUHYWVhY3V0ZQtPc2xhc2hhY3V0ZQtvc2xhc2hhY3V0ZQxTY29tbWFhY2NlbnQMc2NvbW1hYWNjZW50BXRvbm9zDWRpZXJlc2lzdG9ub3MKQWxwaGF0b25vcwlhbm90ZWxlaWEMRXBzaWxvbnRvbm9zCEV0YXRvbm9zDUlvdGF0b25vcy5hbHQMT21pY3JvbnRvbm9zDFVwc2lsb250b25vcwpPbWVnYXRvbm9zEWlvdGFkaWVyZXNpc3Rvbm9zBUFscGhhBEJldGEFR2FtbWEHdW5pMDM5NAdFcHNpbG9uBFpldGEDRXRhBVRoZXRhCElvdGEuYWx0BUthcHBhBkxhbWJkYQJNdQJOdQJYaQdPbWljcm9uAlBpA1JobwVTaWdtYQNUYXUHVXBzaWxvbgNQaGkDQ2hpA1BzaQd1bmkwM0E5EElvdGFkaWVyZXNpcy5hbHQPVXBzaWxvbmRpZXJlc2lzCmFscGhhdG9ub3MMZXBzaWxvbnRvbm9zCGV0YXRvbm9zCWlvdGF0b25vcxR1cHNpbG9uZGllcmVzaXN0b25vcwVhbHBoYQRiZXRhBWdhbW1hBWRlbHRhB2Vwc2lsb24EemV0YQNldGEFdGhldGEEaW90YQVrYXBwYQZsYW1iZGEHdW5pMDNCQwJudQJ4aQdvbWljcm9uA3JobwZzaWdtYTEFc2lnbWEDdGF1B3Vwc2lsb24DcGhpA2NoaQNwc2kFb21lZ2EMaW90YWRpZXJlc2lzD3Vwc2lsb25kaWVyZXNpcwxvbWljcm9udG9ub3MMdXBzaWxvbnRvbm9zCm9tZWdhdG9ub3MJYWZpaTEwMDIzCWFmaWkxMDA1MQlhZmlpMTAwNTIJYWZpaTEwMDUzCWFmaWkxMDA1NA1hZmlpMTAwNTUuYWx0DWFmaWkxMDA1Ni5hbHQJYWZpaTEwMDU3CWFmaWkxMDA1OAlhZmlpMTAwNTkJYWZpaTEwMDYwCWFmaWkxMDA2MQlhZmlpMTAwNjIJYWZpaTEwMTQ1CWFmaWkxMDAxNwlhZmlpMTAwMTgJYWZpaTEwMDE5CWFmaWkxMDAyMAlhZmlpMTAwMjEJYWZpaTEwMDIyCWFmaWkxMDAyNAlhZmlpMTAwMjUJYWZpaTEwMDI2CWFmaWkxMDAyNwlhZmlpMTAwMjgJYWZpaTEwMDI5CWFmaWkxMDAzMAlhZmlpMTAwMzEJYWZpaTEwMDMyCWFmaWkxMDAzMwlhZmlpMTAwMzQJYWZpaTEwMDM1CWFmaWkxMDAzNglhZmlpMTAwMzcJYWZpaTEwMDM4CWFmaWkxMDAzOQlhZmlpMTAwNDAJYWZpaTEwMDQxCWFmaWkxMDA0MglhZmlpMTAwNDMJYWZpaTEwMDQ0CWFmaWkxMDA0NQlhZmlpMTAwNDYJYWZpaTEwMDQ3CWFmaWkxMDA0OAlhZmlpMTAwNDkJYWZpaTEwMDY1CWFmaWkxMDA2NglhZmlpMTAwNjcJYWZpaTEwMDY4CWFmaWkxMDA2OQlhZmlpMTAwNzAJYWZpaTEwMDcyCWFmaWkxMDA3MwlhZmlpMTAwNzQJYWZpaTEwMDc1CWFmaWkxMDA3NglhZmlpMTAwNzcJYWZpaTEwMDc4CWFmaWkxMDA3OQlhZmlpMTAwODAJYWZpaTEwMDgxCWFmaWkxMDA4MglhZmlpMTAwODMJYWZpaTEwMDg0CWFmaWkxMDA4NQlhZmlpMTAwODYJYWZpaTEwMDg3CWFmaWkxMDA4OAlhZmlpMTAwODkJYWZpaTEwMDkwCWFmaWkxMDA5MQlhZmlpMTAwOTIJYWZpaTEwMDkzCWFmaWkxMDA5NAlhZmlpMTAwOTUJYWZpaTEwMDk2CWFmaWkxMDA5NwlhZmlpMTAwNzEJYWZpaTEwMDk5CWFmaWkxMDEwMAlhZmlpMTAxMDEJYWZpaTEwMTAyCWFmaWkxMDEwMwlhZmlpMTAxMDQJYWZpaTEwMTA1CWFmaWkxMDEwNglhZmlpMTAxMDcJYWZpaTEwMTA4CWFmaWkxMDEwOQlhZmlpMTAxMTAJYWZpaTEwMTkzCWFmaWkxMDA1MAlhZmlpMTAwOTgGV2dyYXZlBndncmF2ZQZXYWN1dGUGd2FjdXRlCVdkaWVyZXNpcwl3ZGllcmVzaXMGWWdyYXZlBnlncmF2ZQlhZmlpMDAyMDgNdW5kZXJzY29yZWRibA1xdW90ZXJldmVyc2VkBm1pbnV0ZQZzZWNvbmQJZXhjbGFtZGJsCW5zdXBlcmlvcglhZmlpMDg5NDEGcGVzZXRhBEV1cm8JYWZpaTYxMjQ4CWFmaWk2MTI4OQlhZmlpNjEzNTIJZXN0aW1hdGVkCW9uZWVpZ2h0aAx0aHJlZWVpZ2h0aHMLZml2ZWVpZ2h0aHMMc2V2ZW5laWdodGhzB3VuaUZCMDEHdW5pRkIwMg1jeXJpbGxpY2JyZXZlCGRvdGxlc3NqEGNhcm9uY29tbWFhY2NlbnQLY29tbWFhY2NlbnQRY29tbWFhY2NlbnRyb3RhdGUMemVyb3N1cGVyaW9yDGZvdXJzdXBlcmlvcgxmaXZlc3VwZXJpb3ILc2l4c3VwZXJpb3INc2V2ZW5zdXBlcmlvcg1laWdodHN1cGVyaW9yDG5pbmVzdXBlcmlvcgd1bmkyMDAwB3VuaTIwMDEHdW5pMjAwMgd1bmkyMDAzB3VuaTIwMDQHdW5pMjAwNQd1bmkyMDA2B3VuaTIwMDcHdW5pMjAwOAd1bmkyMDA5B3VuaTIwMEEHdW5pMjAwQgd1bmlGRUZGB3VuaUZGRkMHdW5pRkZGRAd1bmkwMUYwB3VuaTAyQkMHdW5pMDNEMQd1bmkwM0QyB3VuaTAzRDYHdW5pMUUzRQd1bmkxRTNGB3VuaTFFMDAHdW5pMUUwMQd1bmkxRjREB3VuaTAyRjMJZGFzaWFveGlhB3VuaUZCMDMHdW5pRkIwNAVPaG9ybgVvaG9ybgVVaG9ybgV1aG9ybgd1bmkwMzAwB3VuaTAzMDEHdW5pMDMwMwRob29rCGRvdGJlbG93B3VuaTA0MDAHdW5pMDQwRAd1bmkwNDUwB3VuaTA0NUQHdW5pMDQ2MAd1bmkwNDYxB3VuaTA0NjIHdW5pMDQ2Mwd1bmkwNDY0B3VuaTA0NjUHdW5pMDQ2Ngd1bmkwNDY3B3VuaTA0NjgHdW5pMDQ2OQd1bmkwNDZBB3VuaTA0NkIHdW5pMDQ2Qwd1bmkwNDZEB3VuaTA0NkUHdW5pMDQ2Rgd1bmkwNDcwB3VuaTA0NzEHdW5pMDQ3Mgd1bmkwNDczB3VuaTA0NzQHdW5pMDQ3NQd1bmkwNDc2B3VuaTA0NzcHdW5pMDQ3OAd1bmkwNDc5B3VuaTA0N0EHdW5pMDQ3Qgd1bmkwNDdDB3VuaTA0N0QHdW5pMDQ3RQd1bmkwNDdGB3VuaTA0ODAHdW5pMDQ4MQd1bmkwNDgyB3VuaTA0ODMHdW5pMDQ4NAd1bmkwNDg1B3VuaTA0ODYHdW5pMDQ4OAd1bmkwNDg5B3VuaTA0OEEHdW5pMDQ4Qgd1bmkwNDhDB3VuaTA0OEQHdW5pMDQ4RQd1bmkwNDhGB3VuaTA0OTIHdW5pMDQ5Mwd1bmkwNDk0B3VuaTA0OTUHdW5pMDQ5Ngd1bmkwNDk3B3VuaTA0OTgHdW5pMDQ5OQd1bmkwNDlBB3VuaTA0OUIHdW5pMDQ5Qwd1bmkwNDlEB3VuaTA0OUUHdW5pMDQ5Rgd1bmkwNEEwB3VuaTA0QTEHdW5pMDRBMgd1bmkwNEEzB3VuaTA0QTQHdW5pMDRBNQd1bmkwNEE2B3VuaTA0QTcHdW5pMDRBOAd1bmkwNEE5B3VuaTA0QUEHdW5pMDRBQgd1bmkwNEFDB3VuaTA0QUQHdW5pMDRBRQd1bmkwNEFGB3VuaTA0QjAHdW5pMDRCMQd1bmkwNEIyB3VuaTA0QjMHdW5pMDRCNAd1bmkwNEI1B3VuaTA0QjYHdW5pMDRCNwd1bmkwNEI4B3VuaTA0QjkHdW5pMDRCQQd1bmkwNEJCB3VuaTA0QkMHdW5pMDRCRAd1bmkwNEJFB3VuaTA0QkYLdW5pMDRDMC5hbHQHdW5pMDRDMQd1bmkwNEMyB3VuaTA0QzMHdW5pMDRDNAd1bmkwNEM1B3VuaTA0QzYHdW5pMDRDNwd1bmkwNEM4B3VuaTA0QzkHdW5pMDRDQQd1bmkwNENCB3VuaTA0Q0MHdW5pMDRDRAd1bmkwNENFC3VuaTA0Q0YuYWx0B3VuaTA0RDAHdW5pMDREMQd1bmkwNEQyB3VuaTA0RDMHdW5pMDRENAd1bmkwNEQ1B3VuaTA0RDYHdW5pMDRENwd1bmkwNEQ4B3VuaTA0RDkHdW5pMDREQQd1bmkwNERCB3VuaTA0REMHdW5pMDRERAd1bmkwNERFB3VuaTA0REYHdW5pMDRFMAd1bmkwNEUxB3VuaTA0RTIHdW5pMDRFMwd1bmkwNEU0B3VuaTA0RTUHdW5pMDRFNgd1bmkwNEU3B3VuaTA0RTgHdW5pMDRFOQd1bmkwNEVBB3VuaTA0RUIHdW5pMDRFQwd1bmkwNEVEB3VuaTA0RUUHdW5pMDRFRgd1bmkwNEYwB3VuaTA0RjEHdW5pMDRGMgd1bmkwNEYzB3VuaTA0RjQHdW5pMDRGNQd1bmkwNEY2B3VuaTA0RjcHdW5pMDRGOAd1bmkwNEY5B3VuaTA0RkEHdW5pMDRGQgd1bmkwNEZDB3VuaTA0RkQHdW5pMDRGRQd1bmkwNEZGB3VuaTA1MDAHdW5pMDUwMQd1bmkwNTAyB3VuaTA1MDMHdW5pMDUwNAd1bmkwNTA1B3VuaTA1MDYHdW5pMDUwNwd1bmkwNTA4B3VuaTA1MDkHdW5pMDUwQQd1bmkwNTBCB3VuaTA1MEMHdW5pMDUwRAd1bmkwNTBFB3VuaTA1MEYHdW5pMDUxMAd1bmkwNTExB3VuaTA1MTIHdW5pMDUxMwd1bmkxRUEwB3VuaTFFQTEHdW5pMUVBMgd1bmkxRUEzB3VuaTFFQTQHdW5pMUVBNQd1bmkxRUE2B3VuaTFFQTcHdW5pMUVBOAd1bmkxRUE5B3VuaTFFQUEHdW5pMUVBQgd1bmkxRUFDB3VuaTFFQUQHdW5pMUVBRQd1bmkxRUFGB3VuaTFFQjAHdW5pMUVCMQd1bmkxRUIyB3VuaTFFQjMHdW5pMUVCNAd1bmkxRUI1B3VuaTFFQjYHdW5pMUVCNwd1bmkxRUI4B3VuaTFFQjkHdW5pMUVCQQd1bmkxRUJCB3VuaTFFQkMHdW5pMUVCRAd1bmkxRUJFB3VuaTFFQkYHdW5pMUVDMAd1bmkxRUMxB3VuaTFFQzIHdW5pMUVDMwd1bmkxRUM0B3VuaTFFQzUHdW5pMUVDNgd1bmkxRUM3C3VuaTFFQzguYWx0B3VuaTFFQzkLdW5pMUVDQS5hbHQHdW5pMUVDQgd1bmkxRUNDB3VuaTFFQ0QHdW5pMUVDRQd1bmkxRUNGB3VuaTFFRDAHdW5pMUVEMQd1bmkxRUQyB3VuaTFFRDMHdW5pMUVENAd1bmkxRUQ1B3VuaTFFRDYHdW5pMUVENwd1bmkxRUQ4B3VuaTFFRDkHdW5pMUVEQQd1bmkxRURCB3VuaTFFREMHdW5pMUVERAd1bmkxRURFB3VuaTFFREYHdW5pMUVFMAd1bmkxRUUxB3VuaTFFRTIHdW5pMUVFMwd1bmkxRUU0B3VuaTFFRTUHdW5pMUVFNgd1bmkxRUU3B3VuaTFFRTgHdW5pMUVFOQd1bmkxRUVBB3VuaTFFRUIHdW5pMUVFQwd1bmkxRUVEB3VuaTFFRUUHdW5pMUVFRgd1bmkxRUYwB3VuaTFFRjEHdW5pMUVGNAd1bmkxRUY1B3VuaTFFRjYHdW5pMUVGNwd1bmkxRUY4B3VuaTFFRjkHdW5pMjBBQgd1bmkwMzBGE2NpcmN1bWZsZXhhY3V0ZWNvbWITY2lyY3VtZmxleGdyYXZlY29tYhJjaXJjdW1mbGV4aG9va2NvbWITY2lyY3VtZmxleHRpbGRlY29tYg5icmV2ZWFjdXRlY29tYg5icmV2ZWdyYXZlY29tYg1icmV2ZWhvb2tjb21iDmJyZXZldGlsZGVjb21iEGN5cmlsbGljaG9va2xlZnQRY3lyaWxsaWNiaWdob29rVUMRY3lyaWxsaWNiaWdob29rTEMIb25lLnBudW0HemVyby5vcwZvbmUub3MGdHdvLm9zCHRocmVlLm9zB2ZvdXIub3MHZml2ZS5vcwZzaXgub3MIc2V2ZW4ub3MIZWlnaHQub3MHbmluZS5vcwJmZgd1bmkyMTIwCFRjZWRpbGxhCHRjZWRpbGxhBWcuYWx0D2djaXJjdW1mbGV4LmFsdApnYnJldmUuYWx0CGdkb3QuYWx0EGdjb21tYWFjY2VudC5hbHQGSXRpbGRlB0ltYWNyb24GSWJyZXZlB0lvZ29uZWsCSUoJSW90YXRvbm9zBElvdGEMSW90YWRpZXJlc2lzCWFmaWkxMDA1NQlhZmlpMTAwNTYHdW5pMDRDMAd1bmkwNENGB3VuaTFFQzgHdW5pMUVDQQAAAQACAAgACv//AA8AAQAAAAwAAAAAAAAAAgAFAAACNQABAjcCNwABAjsCWwABAl0DdgABA4IDqQABAAAAAQAAAAoADAAOAAAAAAAAAAEAAAAKAG4BWgABbGF0bgAIABAAAk1PTCAAKFJPTSAAQgAA//8ACQADAAgACwAAAA4AEQAUABcAGgAA//8ACgAEAAYACQAMAAEADwASABUAGAAbAAD//wAKAAUABwAKAA0AAgAQABMAFgAZABwAHWxpZ2EAsGxpZ2EAsGxpZ2EAsGxudW0AtmxudW0AtmxudW0AtmxvY2wAvGxvY2wAvG9udW0Awm9udW0Awm9udW0AwnBudW0AynBudW0AynBudW0AynNhbHQA0HNhbHQA0HNhbHQA0HNzMDEA0HNzMDEA0HNzMDEA0HNzMDIA2HNzMDIA2HNzMDIA2HNzMDMA3nNzMDMA3nNzMDMA3nRudW0A5HRudW0A5HRudW0A5AAAAAEACQAAAAEABwAAAAEACAAAAAIAAgADAAAAAQAEAAAAAgAAAAEAAAABAAAAAAABAAEAAAACAAUABgAKABYAPAB8AJQAzADgAO4BAgEuAVAAAQAAAAEACAACABAABQORA5IDkwOUA5UAAQAFAEoA3wDhAOMA5QABAAAAAQAIAAIALgAUACwAjgCPAJAAkQDqAOwA7gDwAPIA9AFaAWcBdwGhAaICyQLYA0UDRwACAAEDlgOpAAAAAQAAAAEACAABAAYDcAACAAEAEwAcAAAAAQAAAAEACAACABoACgODA4UDhgOHA4gDiQOKA4sDjAOEAAIAAwATABMAAAAVABwAAQOCA4IACQABAAAAAQAIAAEABgNuAAEAAQAUAAEAAAABAAgAAQA8/JAAAQAAAAEACAABAAb8kgABAAEDggABAAAAAQAIAAIAGgAKABMDggAVABYAFwAYABkAGgAbABwAAgABA4MDjAAAAAEAAAABAAgAAgAOAAQDjwOQASABIQABAAQBJAElAUkBSgAEAAAAAQAIAAEANgABAAgABQAMABQAHAAiACgCXgADAEkATwJdAAMASQBMA40AAgBJAjUAAgBPAjQAAgBMAAEAAQBJAAA=";

var openSansSemiBoldItalic = "data:font/ttf;base64,AAEAAAARAQAABAAQR0RFRgt6DNIAAWKkAAAALkdQT1MAGQAMAAFi1AAAABBHU1VC450pmgABYuQAAALuT1MvMqIQl3IAATRIAAAAYGNtYXCuofXtAAE0qAAAA4hjdnQgEJAY9gABQPwAAACmZnBnbX5hthEAATgwAAAHtGdhc3AACAAbAAFimAAAAAxnbHlmdW/KuwAAARwAARzIaGVhZAPmemcAASVYAAAANmhoZWEQexD/AAE0JAAAACRobXR4b0Su5QABJZAAAA6SbG9jYf57tlsAAR4EAAAHUm1heHAFTQGyAAEd5AAAACBuYW1lLK5HAgABQaQAAAIWcG9zdOiicnUAAUO8AAAe23ByZXB4rJwlAAE/5AAAARgAAgDBAAAECgW2AAMABwAMswQDBwAALzIvMzEwEyERITchESHBA0n8t2gCef2HBbb6SmgE5gAAAgAh/+UCWAW2AAMADwAYQAsBAQ0CAw0HUVkNEwA/KwAYPxI5LzEwASMTIQE0NjMyFhUUBiMiJgFQsKgBEP3JW1U5RF5MPkUBvAP6+qpQZEE9T2JDAAACANUDpgN9BbYAAwAHAA20BgIHAwMAPzPNMjEwAQMjEyEDIxMCBJeYSAJgmJlKBbb98AIQ/fACEAAAAgAzAAAFNwW2ABsAHwAzQBgAHxAQGRURBAgMDAEcDRENEQoXEwMGChIAPzM/MxI5OS8vMzMzETMzETMzMxEzMzEwAQMhByEDIxMjAyMTIzchEyE3IRMzAzMTMwMzBwEzEyMEDFQBDw/+0Xm0e/h5rnX6EQEYVP74EAEnebJ5/HmuefwO/OX6UvoDaP7iqP5eAaL+XgGiqAEeqAGm/loBpv5aqP7iAR4AAwA9/4kESAYSAB8AJQArAEFAIhVADxJIHCUNAysrEwQGQCAMBgxPWQMGFRNAGyYTJk1ZFhMALzMrEQAzGhgQzS8zKxEAMxoYEM0SOREXMysxMAEUBgcHIzcmJzUWFhcTJiY1NDY3NzMHFhcHJicDHgIBNjY1NCcDBgYVFBcD2+/aLYctxYlOy1xUnIftziWHI6GAVoZuUIB1OP5gVmVzDllZbgHurNIU09MNQ9EqOAIBgzildafJEaOlEEK5Qgj+jTNYcv7hC2JNZSwCRAtdTGIpAAAFAI3/7AZGBcsACwAZAB0AKQA3ACdAEx41BhA1EDUQHB0DHBIAFwckLhMAPzM/Mz8/Ejk5Ly8RMxEzMTABIgYGFRQzMjY2NTQXFAIGIyImNTQSNjMyFiUBIwETIgYGFRQzMjY2NTQXFAIGIyImNTQSNjMyFgISN1g1UDRXO8FvtnN8hGqzd3+FAsL7w8MEPgw0VzlRNFg7wW+2cX+FarN2f4gFI3rgZ4d062aDgaD+zZqelaYBJ5aYg/pKBbb9JXPjbIZ16GiDf6H+y5qZkqsBKpWWAAMAQv/sBVoFzQAKABQAMQA0QB0FGCMPBC8dJA4pLAQmJh0rEh0AS1kdBC8LS1kvEwA/KwAYPysAGD8SORIXORESFzkxMAEiBhUUFzY2NTQmATI2NwEGBhUUFiU0NjcmNTQ2MzIWFRQGBxM2NzMCBxMhJwYGIyImAuxXXj6TaUj+002MSv74hWFw/qGryVjhuaC4s8zrbUjpcbjN/uteatJ8vtMFEmxYbVxLdURCR/ueNjcBfUqHVlZtrpPWYpeEtNWiiYHKW/66cLf+8rj+6YNQR8MAAQDVA6YCBAW2AAMACbICAwMAP80xMAEDIxMCBJeYSAW2/fACEAABAE7+vAMXBbYACgAKswknAwMAPz8xMBMQEhMzABEQEyMCTvn/0f4Oc7eTARQBVwJDAQj93P1+/rf+9QEFAAH/Zv68Ai8FtgAKAAqzBCcIAwA/PzEwARACASMAERADMxICL/b+/tEB8nO3kwNc/qr9wf71AiQCggFHAQ3+9wABAMECVgSDBh8ADgAJsgYOAAA/zTEwAQMlByUTBwMDJwElNwUTA2R0AZMM/pGqzWbjogEl/qJHAWIlBfT+kRfNLf6XPQFz/siQAQpkw7IBfwAAAQB1AQAEHQSoAAsAErcJAQIBUlkGAgAvMysRADMxMAEhNSERMxEhFSERIwHw/oUBe7QBef6HtAJ3tAF9/oO0/okAAf+a/vgBVgDuAAYACLEEAAAvzTEwJRcCByM2EwFOCH2Nsmlf7hf+/NvuAQgAAAEALwG+AlICiQADAAu0AQBMWQEALysxMBM3IQcvLQH2LQG+y8sAAQAh/+MBTgEUAAsADLUJA1FZCRMAPysxMDc0NjMyFhUUBiMiJiFeVDhDX01CP15TYz89TmdHAAAB/6QAAAO4BbYAAwAKswMDAhIAPz8xMAEBIwEDuPzV6QMrBbb6SgW2AAACAFz/7ARMBc0ADQAaABdADAsOTVkLBwQVTVkEGQA/KwAYPysxMAEQAgQjIiY1EBIkMzIWJSIGAhUUFjMyNhI1EARMnv7oucK/pgEXtrvC/nBhpmtOWmSlYwP0/s7+H/X/7AEcAeT27Sjg/m/Cj5bjAZbTAQwAAQDyAAADtAW2AAoAELYHBAEJBgEYAD8/Ejk5MTAhIxM2NwYHBycBMwJ97r0cNjlOu2oB/MYDZpauNy91qgE9AAH/7gAABD8FywAbAB1ADxEKTVkRBwIaAQEaTlkBGAA/KxESADkYPysxMCEhNwE+AjU0JiMiBgcnNjYzMhYVFAYGBwEVIQOP/F8kAdewfThjWkaKZXN43nW11k6oyP7JAm60AaafkHtGVWM8T6BhU7qebLrDq/74CAAAAQAf/+wEPwXLACgALUAXAxcYGBdPWRgYCyYmH01ZJgcLEU1ZCxkAPysAGD8rERIAORgvKxESADkxMAEUBgcVFhYVFAYEIyInNRYWMzI2NTQhIzczMjY1NCYjIgYHJzY2MzIWBD/Gqn+LiP7/sOGgVMtenbD+6oUlaqTPY1pIlVhoeNN5t84EgZ7UHwcYpHuFz3JP1zE1j33bt5V9T1szO6FRQbEAAAL//AAABEIFugAKABIAKUAXAQUSBU1ZCQ8SHxICUBIBEhIDDwcGAxgAPz8zEjkvXV0zKxEAMzEwASMDIxMhNwEzAzMhEzY3IwYHAQQXyUTlRf2SJQMj/snJ/lFEH0UIM1T+WgE9/sMBPcUDuPxIATWI8VZk/gwAAAEANf/sBFgFtgAbACZAFAAST1kAAAcWFhlOWRYGBwxNWQcZAD8rABg/KxESADkYLysxMAEyFhUUBgQjIic1FjMyNjU0JiMiBycTIQchAzYCYrXXjP70vtaNp6+twnx+X4JYyALJLf4Gal0Di8+2ofSFT9lkppNpfyNEAsTR/pQSAAACAG//7ARtBcsAGQAoAC1AFw0XEBAgT1kQEBcFBQpNWQUHFxpNWRcZAD8rABg/KxESADkYLysREgA5MTATNBISJDMyFwcmIyIAAzM2MzIWFRQCBiMiJgUyNjY1NCMiDgMXFBZvedEBJcR1VitIbc3++EEGfcmcr4nqmcLRAaNRfESyM1lFMB4CYwG+zQGSARySGcIW/v3++arGraL+6o/wLmGsZsgmOkddQ26GAAABAH0AAAScBbYABgAYQAsAGAUCAwMCTlkDBgA/KxESADkYPzEwMwEhNyEHAX0C8v1eKwOkIf0KBOnNqPryAAMATP/sBF4FzQAXACMALwApQBQGEhgYKioNAAAkT1kABw0eT1kNGQA/KwAYPysREgA5GC8zEjk5MTABMhYVFAYHFhYVFAYGIyImNRAlJiY1NDYTBgYVFBYzMjY1NCYTIgYVFBYXNjY1NCYC27PQnql4aXvkncvlAXBbT/5ClYZ2Y3OLYRpdck5Bc31gBc2yloTDQk6vcnm/acioASmHRpZXs9v80zaRaF1wgGdbhQKpcFxTbCcrfF9RWwAAAgBc/+wENwXLABkAJgAtQBcOEBcQIU9ZEBAFFxcaTVkXBwUKTVkFGQA/KwAYPysREgA5GC8rERIAOTEwARQCAgQjIic1FjMyNhMjBiMiJjU0EjYzMhYlIgYGFRQWMzI2NTQmBDd0vf75s4VreXO87DsGccCltYbvm8DN/mFSf0RcWHWiYAP6zf5d/umHIM8r9gEKoMy6nAEKj+8sXqZgaW68kmyBAAIAIf/jAfoEagALABcAF0AMAwlRWQMQFQ9RWRUWAD8rABg/KzEwEzQ2MzIWFRQGIyImAzQ2MzIWFRQGIyImzV5UOENhTUI9rF5UOENfTUI/A7RTYz89T2ZH/N5TYz89TmdHAAAC/5z++AH6BGoABgASABVACQRABgoQUVkKEAA/KwAYLxrOMTAlFwIHIzYTEzQ2MzIWFRQGIyImAU4IfY2wX2drXlQ4Q2FNQj3uF/7829YBIALGU2M/PU9mRwABAHMA3QQbBOwABgAIsQADAC/GMTAlATUBFQEBBBv8WAOo/UcCud0BrnkB6MP+qP7RAAIAdQGuBB0D8gADAAcAH0ARBAVSWQQBAQBSWQ8BAZABAQEAL11dKwAYEMYrMTATNSEVATUhFXUDqPxYA6gDP7Oz/m+0tAABAHMA3QQbBOwABgAIsQYDAC/GMTATAQE1ARUBcwK2/UoDqPxYAaIBLwFYw/4Yef5SAAIAov/lA8MFywAZACUAJUASBxAAACMQIx1RWSMWEApNWRAEAD8rABg/KxESADkYLxI5MTABNjY3PgI1NCYjIgYHJzYzMhYVFAYHBgYHATQ2MzIWFRQGIyImAQQSa3trTyVVUU2STk7Py6vEf6hoXA/+2V5UOENiTEI9AbyFr1pNUFEwRlg3JbBxq514w3dKdlX+olNjPz1PZEUAAAIAZP9GBqoFtAA4AEQALEAUBwo5EREoNQQKGj8/CgotITUDKC0ALzM/MxI5LzMRMxEzERI5LzMSOTEwARQCBiMiJicjBiMiJjU0EjYzMhYWFwMGFRQzMjY2NTQkIyIEAhUQADMyNxUGIyIkAjUQEiQhMgQSBSIGBhUUMzI2NzcmBqp31oRiaQwGZbB7hYfxjzRVSlxlHk9IfEf+/+vW/qq/ARn7yObb69L+xqn1AbkBEcgBJJv9M1aRUnBSdylANQNOsP7bplxKpp2MlwEBlQoQH/54ci1chdh65O/H/pTg/v3+5FabWqcBONEBDgG2+pX+6HZrtWedkJTwEAAAAv+HAAAETgW4AAcADgAaQA0OAUxZDg4EBwMSCwQDAD8zPzMSOS8rMTABIQMjASETIwMCJjUGBwMDO/4b0f4DDwESpuo5KAs3V6wBlv5qBbj6SAJmAaCvNIuo/rAAAAMARgAABMsFtgAPABcAIAAtQBcGIBAQIEtZEBAODw8XTFkPAw4YTFkOEgA/KwAYPysREgA5GC8rERIAOTEwATIWFRQGBxUWFhUUBCEhARMzMjY1NCMjAzMyNjU0JiMjAwre462ZbHf+1P71/hUBNW7Hi5jftePfk6d4dMgFtqikksIeCByXbNn4Bbb9pHlvrPvbiH5iZwAAAQCH/+wFIQXLABgAF0AMEwBMWRMEDAdMWQwTAD8rABg/KzEwASIGAhUUFjMyNxUGIyIAERASJDMyFwcmJgOcmvKRpaGNvLTC+P7n0wFg4tmsXj+OBP6y/qvMtL9EzUMBKQEMAQQBvuhcwyIwAAACAEYAAAUfBbYACQATABdADAYSTFkGAwUTTFkFEgA/KwAYPysxMAEQAgQhIQEhIAABMiQSNTQmIyMDBR/I/oL+/v5vATUBcQEPAST8xLEBCI2wqJLjA33+8f5s2gW2/t78NawBOMi4wfvbAAABAEYAAASDBbYACwAmQBQGCUxZBgYBAgIFTFkCAwEKTFkBEgA/KwAYPysREgA5GC8rMTAhIQEhByEDIQchAyEDTvz4ATUDCCv95VQB9in+CGACGwW2zf51y/44AAEARgAABIEFtgAJAB1ADwYJTFkGBgIBEgIFTFkCAwA/KwAYPxI5LysxMCEjASEHIQMhByEBM+0BNQMGK/3nYAH2Lf4MBbbN/jrLAAABAIf/7AVcBcsAHQAmQBQAHUxZAAAFDAwSTFkMBAUZTFkFEwA/KwAYPysREgA5GC8rMTABIQMGBiMgABEQEiQzMhYXByYjIgQCFRQWMzI3EyEDEgIAnXDVhP77/uDNAXfvb8xnWq6gnv7+lbKkbWpQ/usDGf0gKCUBJAELAQgBtvIpMctWtf6xzbe8IQFzAAABAEYAAAWLBbYACwAaQA0IA0xZCAgFCgYDAQUSAD8zPzMSOS8rMTAhIxMhAyMBMwMhEzMEVu6M/cqL7QE17X8CNn/tApP9bQW2/aoCVgAB/88AAAM/BbYACwAgQBAJBAYES1kGAwoDAQNLWQESAD8rEQAzGD8rEQAzMTAhITc3Eyc3IQcHAxcCCv3FGrXjmh0COxq25p6FPAQzO4eHO/vNPAAB/r7+aAJzBbYADAARtwgDAAVMWQAjAD8rABg/MTADIic3FjMyNwEzAQYGmGhCBVRFyTUBK+7+zy7n/mgZyRX6BYf6WtnPAAABAEYAAAVmBbYADAAVQAkIAgUKBgMBBRIAPzM/MxI5OTEwISEDBwMjATMDNwEhAQQ//vr8lXXtATXtl40B7AEc/ZgCj2T91QW2/T6mAhz9YwAAAQBGAAADeQW2AAUAEbcBAwADTFkAEgA/KwAYPzEwMwEzASEHRgE17f72AhsrBbb7F80AAAEARAAABuUFtgATABtADBECAgkGCwcDAA4GEgA/MzM/MxI5OREzMTAhAyMGBwMjASETMwEhASMTNjcjAQKHcwYJLrjbATUBQ20GAl4BWP7P47YnLwb9fQS+dt78lgW2+4MEffpKA2i6nPtCAAEARAAABd0FtgARABVACQMLCBAJAwEIEgA/Mz8zEjk5MTAhIQEjBwYGAyMBIQEzNhI3EzMEqP78/mYGChgXrNsBNQEMAY8HBjIPoNsEi0WVf/zOBbb7gzYBFUEC8QACAIf/7AWNBc0ADQAbABdADAsOTFkLBAQVTFkEEwA/KwAYPysxMAEQAgQjIAAREBIkMzIAJSIGAhUUFjMyNhI1NCYFjb7+s9z+/f7kxQFW2fsBF/3biuB/o5KK3XueA5r+6f5M4wErAQgBCwG56v7WXcD+q8qtvL8BU86qvgACAEYAAASWBbYACAATAB1ADw0ATFkNDRAPEhAITFkQAwA/KwAYPxI5LysxMAEzMjY1NCYjIwUUACEjAyMBITIWAdFessN1eXcCV/6t/tFuc+0BNQFO5egC7J+SbWTJ+P72/d0FtskAAAIAh/6kBY0FzQAQAB4AI0ARBQcOEUxZDgQDGAcHGExZBxMAPysREgA5GD8rABgQxjEwARAABwEhAyMgABEQEiQzMgAlIgYCFRQWMzI2EjU0JgWN/vzhAQj+38of/v3+5MUBVtn7ARf924rgf6OSit17ngOa/r7+Hlv+iQFIASsBCAELAbnq/tZdwP6ryq28vAFT0aq+AAIARgAABJoFtgANABYAJkATCgAODgBLWQ4OAwwCEgMWTFkDAwA/KwAYPzMSOS8rERIAOTEwAQMjASEyFhUUBgcTIQMnMzI2NTQmIyMBrnvtATUBUt/urav5/vzPj3uqqHZ8dwJI/bgFtr3EpeM0/YcCSMaWg2lcAAEAJ//sBDsFywAkACBAEAseAxYWG0xZFgQDCExZAxMAPysAGD8rERIAOTkxMAEUBCMiJzUWMzI2NTQmJy4CNTQ2NjMyFwcmIyIGFRQWFhcWFgOi/t/+0oqtsYmeUoNpZDV74Y3NsFahhm2EHj9nm3YBrNLuS+BhdWhFa1NDboNPgMZsXL9OdV4vRz1BYbUAAAEAsAAABMMFtgAHABZACgESBwMEA0xZBAMAPysRADMYPzEwISMBITchByECEO0BCP6FLQPmK/6DBOnNzQAAAQCY/+wFiwW2ABUAFEAJFQoDBBFMWQQTAD8rABg/MzEwAQMCACMiJjU0NxMzAwYVFBYzMjY3EwWLyjj+0PvZ7RTB7cAVd3mRqifHBbb8RP71/v3Ux1NXA4X8d1hGZnGhtQOoAAEAugAABUgFtgAMABC2DAYDBwMGEgA/PzMSOTEwJTY3ATMBIQMzExYXBwH6RkMBx/79BP7+kOhKCQIB+LKDA4n6SgW2/HdngkwAAQDLAAAHtAW2ABwAG0AMFw4FDgkbEgoDAQkSAD8zPzMzEjk5ETMxMCEhAyc3IwYHASEDMxMUBzM2NwEzExcHMzY2NwEzBSX+/iUGBAYvRv5//wA15RMNBlM7AYPhHwMDCBxUEwFm9gNKuWqQk/y2Bbb8rojS3YYDSfy5qbxY2ysDTgAAAf+RAAAFJQW2AAsAFUAJAggECQYDAQQSAD8zPzMSOTkxMCEhAwEhAQMzEwEhAQQQ/wDA/kr+9wJK+vayAZIBCv3ZAlD9sAMCArT95AIc/ToAAAEAugAABQAFtgAIABC2AAUBBwMFEgA/PzMSOTEwAQEhAQMjEwMzAkYBsAEK/ZFy7nfu8gMZAp38b/3bAikDjQAB/9kAAASiBbYACQAgQBAHBAUETFkFAwIIAQhMWQESAD8rEQAzGD8rEQAzMTAhITcBITchBwEhA4X8VCEDUv2qKwOBI/ysAoWoBD/PrPvDAAH/5f68AxAFtgAHAA61BQIDBgEnAD8zPzMxMAEhASEHIwEzAZP+UgF9Aa4n3f7R3f68Bvqw+mcAAQDdAAAChwW2AAMACrMDAwISAD8/MTABEyMDAazb0dkFtvpKBbYAAAH/cf68ApoFtgAHAA61AwQDAAcnAD8zPzMxMAczASM3IQEhatsBMd0nAa7+g/5UkwWZsPkGAAEAJQIZBBQFvgAGAA60BQIABAIALy8zEjkxMBMBMwEjAwElAmB/ARC4vP5OAhkDpfxbArL9TgAAAf9E/rwCk/9IAAMACLEBAgAvMzEwASE3IQJ1/M8eAzH+vIwAAQIdBNkDlgYhAAgACrIGgAEALxrNMTABIyYmJzUzFhcDlpBBhiL1L1UE2T+xQxWalQACAF7/7AR/BGYAEgAgACdAFAsRAAcMDwcaRlkHEA8VABNGWQAWAD8rABg/PysAGD8REjk5MTAFIiY1NBI2MzIWFzM3MwMjNyMGJzI2EjU0JiMiBgIVFBYBj42ki/SSYYwnCj607LYVBp5pUp5mXkxVllpRFMu4ygFgzVtXnvuusMS+mwEEmlhrmv73jmZlAAACAC//7ARQBhQAFgAjACdAFAQMABAHAAYVEBdGWRAQAB5GWQAWAD8rABg/KwAYPz8REjk5MTAFIiYnIwcjATMDBgYHMzY2MzIWFRQCBgMiBgIVFBYzMjYSNTQCQmKNKApAsgFK60cNMg8IWpZWkaKL8gxRomNdVVWUVhRaVpwGFP6zP7svcVfPtsr+ncgDuqD++4xga50BB4/JAAABAF7/7APNBGYAFwAXQAwHDEZZBxAAEkZZABYAPysAGD8rMTAFIiY1NBIkMzIXByYjIgIVFBYzMjY3FQYB+sTYkwEKqaSFRnpjlshwY0qBQYwU1MXPAVO/Pbg1/s3ib3gsIMNHAAACAF7/7ATdBhQAFAAhAC5AGAMLDgAGAAAcRlkAEAkKSFkJFQ4VRlkOFgA/KwAYPysAGD8rABg/ERI5OTEwATIXMzY3EzMBIzcjBgYjIiY1NBI2EzI2EjU0JiMiBgIVFAJvs1kIDRhM6f62uBMHWKRcj6KP8AxSoWFXWVWUWARmspJoAWb57LBqWsu6zQFkxPxEpAEIh1tumv70i8sAAAIAXv/sA/oEZgAJACMAJkAUAxhIWQMDChERAEhZERAKHUdZChYAPysAGD8rERIAORgvKzEwASIGBzMyNjU0JgMiJjU0EiQzMhYVFAQhIwcVFBYzMjY3FQYGAphgqSUdvNRA18XdmwEJpKGz/rP+zCsCcXBIjmFgoQOyrI1rYjM5/Drex8YBVbqRhbbNHx1vfiYuuywlAAH/H/4UA64GHwAeAClAFg8URlkPAAgbCxgYG0hZGA8ABUZZABsAPysAGD8rEQAzETMYPysxMAMiJzUWMzI3EyM/AjY2MzIXByYjIgYHBzMHIwMGBkxaO0AyhivZsxXCFSy1pnNgPUo+RVMWEuUl5d8otv4UF74UzQP+akxcxqcrsBxWYlay++O9sgAAA/+H/hQEdwRmACcANABBAEhAKBsoKA5GWQc8SlkEIAkDByUoBygHFSUnAkhZJw8lNUlZJRAVLklZFRsAPysAGD8rABg/KxESADk5GC8vERIXOSsrEQAzMTABBwcWFRQGIyInBhUUFhcXFhYVFAQhIiY1NDY3JjU0NjcmNTQ2MzIXAQYGFRQWMzI2NTQmJxMiBgYVFBYzMjY2NTQEdx/AHO7INChvPzx/sJj+0v7qy9+LmkxdZIf1yVBQ/kxweG9yo7hacYVBYjZHQkFfNQRSiSE6T8HjCChAJhwIEBaDesTWloNnljQtUkVlL1GrxPAU+8ASak5BTWxlMzoMA8VNhU9HTU6IUY4AAQAvAAAESgYUABoAHEAOEAoUFAVGWRQQCwAAChUAPzM/PysREgA5MTAhEzY1NCMiBgcDIwEzAwYHBzM2NjMyFhUUBwMCvo4SgXDDLWLsAUrrORsuEwhUqV2IkReLAqBaJYf62f4tBhT++n6nS2pem5BMYv1zAAIALwAAAlYF+gALAA8AJUAaCR8DLwMCXwNvA38DnwOvA98D7wMHAw4PDRUAPz8vXXHNMTABNDYzMhYVFAYjIiYDIxMzAUpORzVCUEE1Ri/s7OsFYkRUNTZHUjT61gRSAAL++v4UAlYF+gAMABgAMEAgFkAPEB8QLxBPEF8QjxCfEM8Q3xAJDgMQCA8ABUZZABsAPysAGD8vX15dGs0xMAMiJzUWMzI3ATMBBgYBNDYzMhYVFAYjIiZxWjtANYMnAQTp/vYmswEpTEc2QVBBNUT+FBe+FLoEw/shtaoHTkRUNTZHUjMAAQAvAAAEhwYUAA4AGUANAg0FBgQICQAADwQIFQA/Mz8/ERc5MTABIQEBIQMHAyMBMwIGBzMDdwEQ/h0BI/760YhN7AFK64cxIwQEUv4b/ZMB12D+iQYU/Y3NfAABAC8AAAJkBhQAAwAKswIAARUAPz8xMCEjATMBGeoBSusGFAABAC8AAAauBGYAJgAlQBIDJAAXDSEVEhwAHEZZBgAQIg8APz8yKxEAMxg/MzMSOTkxMAEyFzM2NjMyFhUUBwMjEzY1NCMiBgcDIxM2NTQjIgYHAyMTMwczNgMn3CIIS79nhYsWjOuPE3lsuytl648RdW67LWLs7LgVCZQEZut0d5mLQHX9cwKgXyaB+M3+HwKgUi2H/tP+KwRSzeEAAAEALwAABEoEZgAYABxADg4LEhIFRlkSEAwPAAsVAD8zPz8rERIAOTEwIRM2NTQjIgYGBwMjEzMHMzY2MzIWFRQHAwK+jhKBSIxwHGLs7LgVCVOwZ4aTF4kCoFopg3LXiP4rBFLNdmuYjEVw/XMAAgBe/+4ENwRkAA0AGwAXQAwZA0ZZGRASCkZZEhYAPysAGD8rMTABNCYjIgYGFRQWMzI2NjcUAgYjIiY1NBIkMzIWA0piW12TUWNhWpBQ7ZL/psDijwECqcPcAr5reY/1i292iPWJyv61seXFxwFMuegAAv/J/hQEUARmABMAIAAmQBQDCgANDRRGWQ0QCA8HGwAbRlkAFgA/KwAYPz8/KxESADk5MTAFIicjBgcDIwEzBzM2MzIWFRQCBgMiBgIVFBYzMjYSNTQCQrVYCgcSYOkBUrgVCZ27j6KM8QxRoGVdVVWUVhSwYVj+MQY+vNDOt8z+ncYDup/++oxga50BB4/JAAACAF7+FAR/BGYAFQAiACdAFAwDDwAEDwcbAB1GWQAQDxZGWQ8WAD8rABg/KwAYPz8REjk5MTABMhczNzMBIxM2NjcjBgYjIiY1NBI2EzI2EjU0JiMiBgIVFAJxt1sKQLL+rOlLDD8HCFSgWougku8NUJ5hW1FWlFkEZrKe+cIBXTj4EWxazbbQAWbB/ESiAQiJXmub/viOywAAAQAvAAADiQRmABAAFEAJBQ0KABAKFQsPAD8/PxE5MjEwATIXByYjIgYHAyMTMwczNjYDHT4uMzYwfsYnauzsuBUJU6YEZgzbDuK3/gwEUs14aQAAAQAO/+wDcQRmACIAIEAQCxwDFBQZR1kUEAMISFkDFgA/KwAYPysREgA5OTEwARQGIyInNRYzMjY1NCYnJiY1NDYzMhcHJiMiBhUUFhceAgMO7NK+hJmfYXhFa31n1rbElkyMfklbQmZpWC4BVK27Q8taUEUzST1Di1+bsFSwTEI7LUY3O1RjAAEAXP/sAyUFSAAZACdAEw8RQAsUDhERFEhZEQ8GAEZZBhYAPysAGD8rEQAzETMaGBDNMTAlMjcVBgYjIDU0NxMjPwIzByEHIQMGFRQWAcdEUyN4PP7uEHmiFb6BkjQBFyf+63oNMqofshEa9zlKAjpuUuj2sv3ENyUrMwABAG//7ASHBFIAGQAbQA0PEgoZDw0VEgVGWRIWAD8rABg/PzMSOTEwAQMGFRQzMjY2NxMzAyM3IwYGIyImNTQ2NxMB+oEff0iObh5j6em5FQhSsmeGkhgMewRS/Z6NNIVy044B1fuuzXRtmI4/ez4CSAABAGQAAARQBFIADAAOtQUKAQ8AFQA/PzMyMTAzAzMTFhUzNjY3ATMB54PoNw4HHFQXATf6/aoEUv2qn4pKtikCVvuuAAEAeQAABl4EUgAbAB1ADRQMAwwHEBAZCA8ABxUAPzM/MzMREjk5ETMxMCEDJzcGBgEhAzMTBgczNjcBMxMXBzM+AhMzAQNMEwEDGTX+wf76L90NAgkGQisBFv4TAQMGEVAv5PT9+gJzRsg+fv07BFL9eleesGACa/2kNeoy2W4CAvuuAAH/qgAABFQEUgALABVACQAGAgcEDwsCFQA/Mz8zEjk5MTABASEBAzMTASEBEyMB6f7P/vIB2+f1kAEfARL+M/j2AYP+fQI5Ahn+iwF1/dv90wAB/1b+FARSBFIAFwAYQAsFDgkADw4TRlkOGwA/KwAYPzMSOTEwEzMTFhYVMzY3ATMBBgYjIic1FjMyNjc3ZOg/CQ4GVjEBJf79UFrUj0xDSzJKeEAzBFL97T7hRddiAj77AKWZE7wQV3BcAAAB/9kAAAOiBFIACQAkQBIHBAUFBEhZBQ8CCAEBCEhZARUAPysREgA5GD8rERIAOTEwISE3ASE3IQcBIQLP/QodAnv+SScCwSX9kQHmkwMNsqr9CgABAAj+vANKBbYAJwAgQBAbCQmvCr8KAgoKEyYnFBMDAD8zLzMSOS9dMxI5MTABIDU0Nzc2NTQjNzI2NxM+AjMzByIGBwMGBgcVFhUUBwcGFRQWMxUByf7EES0O0Sd4jxY7HFqWezwpYFcSRhh+dKAQKwtBTf687D1IyUEhjbtVZQEThoc8uERS/stsfREGLaomU8IwGjMvuQAAAQHy/h8CpAYQAAMACbIAAAMALz8xMAEzESMB8rKyBhD4DwAAAf+o/rwC0QW2ACYAIEAQGgoKrwm/CQIJCSYTEiUmAwA/My8zEjkvXTMSOTEwASAVFAcHBhUUMwciBgcDBgYjIzU2NjcTNjY3NSY1NDc3NjU0JiM3AQ4BPhEtDtEneY4WPyKztB1qXRJGGH50nhErClZOIwW26z1Iy0EhjrpUZP7OpYa3AkVQATVtehEGMKc3QsUsHjoouAABAG8COwQrA2gAFwAfQA4PBgMSEgxSWRIGAFJZBgAvKwAYLysAEBjEEMYxMAEiBgc1NjMyFhcWFjMyNjcVBiMiJicmJgFYM3o8ZJVAbVxGWjEyfTpnkz96TUxXArQ+O79sGCceGT46vm8hISAXAAL/0/6LAgoEXgADAA8AF0AKAAANAw0HUVkNEAA/KwAYLxI5LzEwEzMDIQEUBiMiJjU0NjMyFt2upv7uAjdeUDtEYk5BPAKF/AYFVlBkPzxSZEcAAAEAw//sBDEFywAeACRAEgIeHhhNWR4BGQkMDBFPWQwKBgA/zSsRADMYP8UrEQAzMTAFIzcmJjU0EjY3NzMHFhcHJiMiBgYVFBYzMjY3FQYHAkKcLYSMf+WTI5wlfGFFfWFjollwY0qBQYWgFNUiyZ6+AULHFqSkDC25NY/2j294KyDCRQUAAf/uAAAEuAXLABwAMUAZCxcYF09ZCBgYEgAABU1ZAAcTDxIPTlkSGAA/KxEAMxg/KxESADkYLzMrEQAzMTABMhcHJiMiBwMhByEHBgYHIQchNzY3NyM3MxM2NgNYvKRYj3O5KjkBTSL+sCEVX1MCsi38NCbIMiPEJMU9JuYFy1a3Ss3+6qyYYoYqz8Et56SsASu5wgAAAgCNAQ4EGQSYABsAJwAYQA0JDBATFxoCBQgfFSUHAC8zxDIXOTEwEzQ3JzcXNjMyFzcXBxYVFAcXBycGIyInByc3JjcUFjMyNjU0JiMiBtE9gXd/ZmlsY395gT09f3d/X3B4V391fz2ofVxbgoJbXH0C025fgXd/PT+BdYFjbHJffXd/Ozt9d31fcFt+fF1dfoAAAAEAagAABPoFtgAWAD1AIQoODw5QWQcPBhITElBZAwATFQ8THxMCDxMPEwwBFQYMGAA/PzMSOTkvL10REjkyKxEAMxEzKxEAMzEwAQEzATMHIQchByEHIzchNyE3ITczAzMCUgGw+P362SP+7h8BEiH+8DXdM/7vIQERHv7wI9PH6AMZAp39CJuUm/T0m5SbAvgAAgHy/h8CpAYQAAMABwATtwMEAwQHAAAHAC8/ETk5Ly8xMAEzESMRMxEjAfKysrKyBhD85v5F/OQAAAIAJ//yA/QGIwAsADgAJUAVAi0UMxopBh8ICA5JWQgBHyRJWR8WAD8rABg/KxESABc5MTATNDcmJjU0NjMyFwcmJiMiBhUUFhcWFhUUBgcWFRQGIyInNRYzMjY1NCYnJiYBBgYVFBYXNjY1NCai2y8+37mymkQ+h01WYUlwf3dpbGb2z7x/mKd0dE5mgnYBXEVTXX8+S2MC/Lx3IGRBiqVOnh0rRTwrQzI4j2Bcnj1MdZ2wQ7tdUUcrSTA8jwFBGmo+PVc5JG08PFkAAAIBqgUCBBcF7AALABcADLMPAxUJAC8zzTIxMAE0NjMyFhUUBiMiJiU0NjMyFhUUBiMiJgGqRj8wOUc6Lz4Bf0Y/MDlHOi8+BWQ8TC8wQUovMzxMLzBBSi8AAAMAg//sBmIFywAVACUANQAvQBsFCw8LHwufCwMAEQAREBECCxELESIyGgQqIhMAPzM/MxI5OS8vXREzXREzMTABIgYVEDMyNjcVBiMiJjU0NjMyFwcmATQSJDMyBBIVFAIEIyIkAjcUEgQzMiQSNTQCJCMiBAIDonF97i+CLHV7xdTjx4qARGr8h8gBXsrHAV3Lxf6kzs/+osN7pgEkq60BJaKk/t2tqP7bqAQKmJv+0yATnjP31Nj5QpM3/tHIAV7Kxv6fycf+pMzPAVrGqP7frK4BIaalASOtqf7bAAIAoAMCAzsFxwASAB0AH0AQBwgDEwAMEAwCDAAEHhkAHwA/Mj8Q1F0yOTnEMTABMhczNzMDIzcjBgYjIiY1NDY2EzI2NjU0IyIGFRQB8nE1Bid2k3sKBDJgPVtpXpcHMl87ZlJxBcdnWv1UaT43hHKA3XL9umCfT3fDhX0AAAIAUABkBBID4wAGAA0ADLMMBQgBAC8zxDIxMBMBFwETBwMlARcBEwcDUAGLh/7gmbLZAbgBgYn+6JO00QI/AaR2/rT+j0wBxQIBsnD+of6iTAGuAAEAdQEABB0DKwAFABG2AgUFBFJZBQAvKwAYEMQxMAERIxEhNQQds/0LAyv91QF3tAD//wAvAb4CUgKJAgYAEAAAAAQAg//sBmIFywAPAB8ALAA1ADNAHSUpDykfKQI1KgAqECoCJy0pKiopLQMMHAQEFAwTAD8zPzMSFzkvLy8zXREzXREzMTATNBIkMzIEEhUUAgQjIiQCNxQSBDMyJBI1NAIkIyIEAiUUBgcTIwMjESMRISABMzI2NTQmIyODyAFeyscBXcvF/qTOz/6iw3umASSrrQEloqT+3a2o/tuoA8BbVdPIrFuyAQ0BUf5USFRaW1NIAtvIAV7Kxv6fycf+pMzPAVrGqP7frK4BIaalASOtqf7bCVN8JP6LAUX+uwNu/mdIP0k4AAABAG8GFAQlBroAAwAIsQECAC8zMTABITchA/z8cycDjwYUpgACALwDOwNOBcsADAAYAAyzEAkWAwAvM8QyMTATNDYzMhYVFAYjIiYmNxQWMzI2NTQmIyIGvMKIiMDAiFiaWJhoSkhoZ0lKaASBiMLCiIm9WJZYRmhoRkpoZwACAHUAAAQdBMMACwAPACRAFAwNUlkMQgkBAgFSWQYQAgFwAgECAC9dcTMrEQAzGD8rMTABITUhETMRIRUhESMBNSEVAfD+hQF7tAF5/oe0/oUDqAKRtQF9/oO1/or+5bS0AAEATgJKAxAFyQAZABK3ChAfAhgYASAAPzMSOT8zMTABITclPgI1NCYjIgcnNjYzMhYVFAYGBwchAqr9pBwBDW9LIzgwW2RQRJVec4kvZXauAXMCSoffX1JIJi40UHs2N3hfRW9uW44AAQBoAjkDEAXJACMAJ0AWAxUVDxYfFgIPFh8WAhYWChwhHw8KIQA/Mz8zEjkvXXEzEjkxMAEUBgcVFhYVFAYjIic1FjMyNjU0IyM3MzI2NTQjIgcnNjMyFgMQbWhOSseqinB+elpjkmwcXVlrdVxgRH6lfIoE+Fp2GgQSYkKBmjifR0pFcYVEQWRBeVpvAAEB/ATZA+UGIQAIAAqyA4AIAC8azTEwATY3IRUGBgcjAfxhgAEINtBHnATybMMTQr80AAAB/8n+FASTBFIAGgAgQBASDAoHFw8WGwoVDwNGWQ8WAD8rABg/Pz8zEjk5MTABFBYzMjY3EzMDIzcjBgYjIicjBgcDIwEzAwYBZkI/ccEtZufruBYKS5xXbC8ICR5C6QFS640TATNBSPvUAdn7rr5vY1FJov7CBj79YlQAAQCs/vwEtAYUAA8AE7cICAEDDgAFAQAvMz8zEjkvMTABIxEjESMRBiMiJjUQNjMhBLSLvIw+U9jM2ukCRf78Bmb5mgMzEvr7AQT+//8AlgI5AcMDagAHABEAdQJWAAH/RP4UAOwAAAASABpADQ0QQAsOSBAQDwgDGw8ALz8zEjkvKzMxMBMUBiMiJzUWMzI1NCYnNzMHFhbspI5ANi8xiUZFYpIySED++Gp6D4cOYCgrCahgGVQAAAEAwQJKArYFtgAKAA61CQMgBgAeAD8yPzkxMAEzAyMTNjcGBgcnAhSiur9jESgVOX1NBbb8lAHNT4oULlCBAAACAKQDAgMIBccADQAXABRAChMABBAEAgQOCx8APzPEXTIxMAEUBgYjIiY1NDY2MzIWJSIGFRQzMjY1NAMIVJ5ueopYo2t8gv72UWdwTWUEtn7GcJKDesdvjwqvgY2vhIoAAAIACgBcA88D2wAGAA0ADrQIAQEMBQAvM8QvMjEwAQEnAQM3EwUBJwEDNxMDz/5zhgEfmbTZ/kj+f4wBGZKz0wH+/l53AUoBckz+OQL+UHEBXAFgTP5QAP//AJUAAAXFBbYAJwIXApMAAAAmAHvWAAEHAjwCwf23AAmzAwIRGAA/NTUA//8AeQAABh4FtgAnAhcCdwAAACYAe7kAAQcAdAMO/bcAB7ICEBgAPzUA//8AbAAABi8FyQAnAhcDIQAAACcCPAMr/bcBBgB1BAAACbMCAQYYAD81NQAAAv/d/nUC/gRaABkAJQAtQBgHABkQGQILAxkZECMjHVFZIxAQCk1ZECIAPysAGD8rERIAORgvX15dOTEwAQYGBw4CFRQWMzI2NxcGIyImNTQ2NzY2NwEUBiMiJjU0NjMyFgKcGW10a00lVFFMk09Lzcyuv4CnXWAWASdgUjhDXU9CPwKDkqpTT05QMEdXNyaxcKuceMZ1QHVfAV5VY0E8TmZEAP///4cAAAROB3MCJgAkAAABBwBD//0BUgAKtAIQEAUmACsRNf///4cAAASsB3MCJgAkAAABBwB2AMcBUgAKtAIXFwUmACsRNf///4cAAASFB3MCJgAkAAABBwFLAFoBUgAKtAIVFQUmACsRNf///4cAAATLB0gCJgAkAAABBwFSAHMBUgAKtAIYGAUmACsRNf///4cAAARzBz4CJgAkAAABBwBqAFwBUgAMtQMCJCQFJgArETU1////hwAABE4HBwImACQAAAEGAVAbbQAJswMCJAMAPzU1AAAC/4cAAAclBbYADwATADxAIAoNTFkKCgEGEwNMWRMTAQYFEgkSBhJMWQYDAQ5MWQESAD8rABg/KxEAMxg/ERI5LysREgA5GC8rMTAhIRMhASEBIQchAyEHIQMhARMjAQXw/PdW/lD/AP76A6ID/Cv95VQB+Cv+CmICG/1NilL+cAGW/moFts3+dcj+NQGbAoP9fQD//wCH/hQFIQXLAiYAJgAAAAcAegIrAAD//wBGAAAEgwdzAiYAKAAAAQcAQ//xAVIACrQBDQ0FJgArETX//wBGAAAEgwdzAiYAKAAAAQcAdgB9AVIACrQBFBQFJgArETX//wBGAAAEgwdzAiYAKAAAAQcBSwA/AVIACrQBEhIFJgArETX//wBGAAAEgwc+AiYAKAAAAQcAagA1AVIADLUCASEhBSYAKxE1Nf///88AAAM/B3MCJgAsAAABBwBD/wkBUgAKtAENDQUmACsRNf///88AAAOxB3MCJgAsAAABBwB2/8wBUgAKtAEUFAUmACsRNf///88AAAOOB3MCJgAsAAABBwFL/2MBUgAKtAESEgUmACsRNf///88AAAN+Bz4CJgAsAAABBwBq/2cBUgAMtQIBISEFJgArETU1AAIANQAABR8FtgANABsALUAXGgcIB0xZFwgIBQoKFkxZCgMFG0xZBRIAPysAGD8rERIAORgvMysRADMxMAEQAgQhIRMjNzMTISAAATIkEjU0JiMjAyEHIQMFH8j+gv7+/m+Bki2QiQFxAQ8BJPzEsQEIjbCokl4BHS3+5VoDff7x/mzaAm/IAn/+3vw1rAE4yLjB/knI/lr//wBEAAAF3QdIAiYAMQAAAQcBUgEAAVIACrQBGxsFJgArETX//wCH/+wFjQdzAiYAMgAAAQcAQwBvAVIACrQCHR0FJgArETX//wCH/+wFjQdzAiYAMgAAAQcAdgEXAVIACrQCJCQFJgArETX//wCH/+wFjQdzAiYAMgAAAQcBSwDJAVIACrQCIiIFJgArETX//wCH/+wFjQdIAiYAMgAAAQcBUgDZAVIACrQCJSUFJgArETX//wCH/+wFjQc+AiYAMgAAAQcAagDFAVIADLUDAjExBSYAKxE1NQABAJMBHwQABIcACwAWQAoDAAYJBAIKCAQCAC8zLzMSFzkxMAEBNwEBFwEBBwEBJwHJ/sp9ATgBOX/+xQE3e/7H/sh6AtMBN33+ywE1e/7H/sd7ATX+zXsAAwBt/6oFtAYEABUAHgAnAC5AGh0hHCIEJBYRFAkGBAQPDxZMWQ8EBCRMWQQTAD8rABg/KxESABc5ERIXOTEwARACBCMiJwcnNyY1EBIkMzIXNxcHFiUiBgIVFBcBJhM0JwEWMzI2EgWNvv6z3MF9doWBZ8UBVtm9gHeFhV79243gghgCnFC/E/1rS3eL33wDmv7p/kzjU5VooIrjAQsBuepelWimgo66/qjPWEwDREH+llg3/Mc4vwFSAP//AJj/7AWLB3MCJgA4AAABBwBDAE4BUgAKtAEXFwUmACsRNf//AJj/7AWLB3MCJgA4AAABBwB2ARsBUgAKtAEeHgUmACsRNf//AJj/7AWLB3MCJgA4AAABBwFLALYBUgAKtAEcHAUmACsRNf//AJj/7AWLBz4CJgA4AAABBwBqALABUgAMtQIBKysFJgArETU1//8AugAABQAHcwImADwAAAEHAHYAZgFSAAq0ARERBSYAKxE1AAIARgAABGQFtgAMABUAH0ARCRVMWQ0ETFkJDQkNBgcDBhIAPz8SOTkvLysrMTABFAAhIwMjATMHMzIWATMyNjU0JiMjBGT+s/7KbELtATXtM2Hj6/06YLDFd3l5AzHz/vP+zwW288r+AZ2UbWIAAf7+/hQEtgYbADkALEAYMRQlAx0MDDRHWQwAHSJIWR0WAAVGWQAbAD8rABg/KwAYPysREgAXOTEwAyInNRYzMjY3ATY2MzIWFRQHBgYVFBceAhUUBiMiJzUWMzI2NTQmJyYmNTQ2NzY2NTQmIyIHAQYGdUVIPTRBUxYBBjD64LzRs3Y9SmtIJujGtmV+fml2L1hSTllbYlFeVdI0/vgquf4UF8EVV2gE0ufMoIepgldBIyw5VFZjPKzIQclWWFAwSkZAc0VLgDxCXDRBSO/7FMWuAP//AF7/7AR/BiECJgBEAAABBgBDuQAACrQCIiIRJgArETX//wBe/+wEfwYhAiYARAAAAQYAdloAAAq0AikpESYAKxE1//8AXv/sBH8GIQImAEQAAAEGAUv9AAAKtAInJxEmACsRNf//AF7/7AR/BfYCJgBEAAABBgFSEgAACrQCKioRJgArETX//wBe/+wEfwXsAiYARAAAAQYAav8AAAy1AwI2NhEmACsRNTX//wBe/+wEfwaaAiYARAAAAQYBUOgAAAy1AwIkJBEmACsRNTUAAwBe/+wGjwRmACkANwBBAD9AIzshSFk7OwYCFBcECRAVDzgxEDFGWRoQEAQVJSoJKkZZAAkWAD8zKxEAMxg/PzMrEQAzGD8REhc5OS8rMTAFIicHIzcjBgYjIiY1NBI2MzIWFzM3Mwc2NjMyFhUUBCEjBxQWMzI3FQYlMjYSNTQmIyIGAhUUFgEiBgczMjY1NCYEot5TF5cUCFWhXoaXiu+NWIAsCT+UGTOgZIyh/rP+zC0EeXN9tK/8hlWbYE1LVZVTSgOfZ6slH7vURBSJdbBqWs61yQFizFdbnnU/Spl9ts08dXhUvU++oQEOhFtuoP76i2liAwisjWtgOjQA//8AXv4UA80EZgImAEYAAAAHAHoBgQAA//8AXv/sA/oGIQImAEgAAAEGAEOXAAAKtAIlJREmACsRNf//AF7/7AQWBiECJgBIAAABBgB2MQAACrQCLCwRJgArETX//wBe/+wECQYhAiYASAAAAQYBS94AAAq0AioqESYAKxE1//8AXv/sA/oF7AImAEgAAAEGAGraAAAMtQMCOTkRJgArETU1//8ALwAAAhgGIQImAPMAAAEHAEP+ggAAAAq0AQUFESYAKxE1//8ALwAAAx0GIQImAPMAAAEHAHb/OAAAAAq0AQwMESYAKxE1//8ALwAAAwkGIQImAPMAAAEHAUv+3gAAAAq0AQoKESYAKxE1//8ALwAAAvsF7AImAPMAAAEHAGr+5AAAAAy1AgEZGREmACsRNTUAAgBQ/+wEewYlAB0AKwA2QBwFCAAbBAYcHAMZDhUVJUdZFRUOBgMBDh5HWQ4WAD8rABg/MxI5LysREgA5EjkYLxIXOTEwASYnNxYXNxcHFhEUAgQjIiY1NBI2MzIWFzMmJwcnEzI2NjU0JiMiBgYVFBYChyxbaoFQ+kbZm5L++rXF24Puk2CQKQYKe/pIUFyLTmhcW4tKYgUtKTeYSEqKf3nN/s3//oW/1sOiARKcTUbzjI6B++53x2phdHDDc2hvAP//AC8AAAR9BfYCJgBRAAABBgFSJQAACrQBIiIRJgArETX//wBe/+4ENwYhAiYAUgAAAQYAQ58AAAq0Ah0dESYAKxE1//8AXv/uBDcGIQImAFIAAAEGAHZIAAAKtAIkJBEmACsRNf//AF7/7gQ3BiECJgBSAAABBgFL8wAACrQCIiIRJgArETX//wBe/+4EWgX2AiYAUgAAAQYBUgIAAAq0AiUlESYAKxE1//8AXv/uBDcF7AImAFIAAAEGAGrvAAAMtQMCMTERJgArETU1AAMAdQDsBB0EtgADAA8AGwAcQAwHDRkTDRMBAQBSWQEALysRADMzGC8zLzMxMBM1IRUBNDYzMhYVFAYjIiYRNDYzMhYVFAYjIiZ1A6j9rj8+PkFFOjpDPz4+QUU6OkMCd7S0/v5AR0g/QElHAvxAR0g/QElHAAADADP/pgRaBJMAFQAdACYALkAaHCQbJQQeFhEUCQYEBA8PFkdZDxAEHkdZBBYAPysAGD8rERIAFzkREhc5MTABFAIGIyInByc3JjU0EiQzMhc3FwcWJSICFRQXASYDMjY2NTQnARYENZT9ooliaXtzRo0BAqmIZ1Z9ZD/+WI28CAG6LclZlFUG/kwpArzQ/rCuO4NgjWidyAFKuj1sYHVkTv7d2ycjAiUj/QCF64wtFv3iIf//AG//7ASHBiECJgBYAAABBgBDoQAACrQBGxsRJgArETX//wBv/+wEhwYhAiYAWAAAAQYAdnMAAAq0ASIiESYAKxE1//8Ab//sBIcGIQImAFgAAAEGAUsQAAAKtAEgIBEmACsRNf//AG//7ASHBewCJgBYAAABBgBqBgAADLUCAS8vESYAKxE1Nf///1b+FARSBiECJgBcAAABBgB2+QAACrQBICARJgArETUAAv/J/hQEUAYUABYAJAAnQBQEDQAQCQAIGxAXRlkQEAAeRlkAFgA/KwAYPysAGD8/ERI5OTEwBSImJyMGBwMjATMGBgczNjMyFhUUAgYDIgYCFRQWMzI2EjU0JgJKXo4rCAcSYOkBsOswMjMIm62QoYjpHFSeYFxWVpNWUhRbVVte/jEIAN/or8jMucz+ncYDuqL+94ZiaZoBCJFkZf///1b+FARSBewCJgBcAAABBgBqmQAADLUCAS0tESYAKxE1Nf///4cAAARxBtsCJgAkAAABBwFNAHsBUgAKtAISEgUmACsRNf//AF7/7AR/BYkCJgBEAAABBgFNIwAACrQCJCQRJgArETX///+HAAAEkgdaAiYAJAAAAQcBTgBIAVIACrQCEhIFJgArETX//wBe/+wEfwYIAiYARAAAAQYBTvkAAAq0AiQkESYAKxE1////h/4tBE4FuAImACQAAAAHAVEDMQAA//8AXv4tBH8EZgImAEQAAAAHAVECpAAA//8Ah//sBSEHcwImACYAAAEHAHYBGwFSAAq0ASEhBSYAKxE1//8AXv/sBBQGIQImAEYAAAEGAHYvAAAKtAEgIBEmACsRNf//AIf/7AUhB3MCJgAmAAABBwFLAMEBUgAKtAEfHwUmACsRNf//AF7/7AP1BiECJgBGAAABBgFLygAACrQBHh4RJgArETX//wCH/+wFIQdMAiYAJgAAAQcBTwHbAVIACrQBIiIFJgArETX//wBe/+wDzQX6AiYARgAAAQcBTwD0AAAACrQBISERJgArETX//wCH/+wFIQdzAiYAJgAAAQcBTACYAVIACrQBJCQFJgArETX//wBe/+wEKgYhAiYARgAAAQYBTL0AAAq0ASMjESYAKxE1//8ARgAABR8HcwImACcAAAEHAUwAXAFSAAq0Ah8fBSYAKxE1//8AXv/sBl4GFAImAEcAAAEHAjgC/gAAAAeyAiQAAD81AP//ADUAAAUfBbYCBgCSAAAAAgBe/+wFUAYUABwAKQBRQDATAxEADwcIB0lZDA8IHwgvCAMTAwgIAAoAACRGWQAAEAAgAAMJAwAPERUWHUZZFhYAPysAGD8/X15dKwAYPxI5L19eXTMrEQAzERI5OTEwATIXMzY3NyE3ITczBzMHIwEjNyMGBiMiJjU0EjYTMjYSNTQmIyIGBhUUAma3WggFEhb+siEBUCXpJZgjl/79uBMHUqVdkqOG7BxQm2RUXFeTVQRMqktpbaOurqP7PbBnXdC1wAFYw/xemgEAhVdrk/qJy///AEYAAASDBtsCJgAoAAABBwFNAFgBUgAKtAEPDwUmACsRNf//AF7/7AP6BYkCJgBIAAABBgFNBAAACrQCJycRJgArETX//wBGAAAEgwdaAiYAKAAAAQcBTgAtAVIACrQBDw8FJgArETX//wBe/+wEKAYIAiYASAAAAQYBTt4AAAq0AicnESYAKxE1//8ARgAABIMHLwImACgAAAEHAU8BRAE1AAq0ARUVBSYAKxE1//8AXv/sA/oF+gImAEgAAAEHAU8A/gAAAAq0Ai0tESYAKxE1//8ARv4tBIMFtgImACgAAAAHAVECLwAA//8AXv5GA/oEZgImAEgAAAAHAVEB8AAZ//8ARgAABJoHcwImACgAAAEHAUwALQFSAAq0ARcXBSYAKxE1//8AXv/sBEcGIQImAEgAAAEGAUzaAAAKtAIvLxEmACsRNf//AIf/7AVcB3MCJgAqAAABBwFLAMUBUgAKtAEkJAUmACsRNf///4f+FAR3BiECJgBKAAABBgFLAgAACrQDSEgRJgArETX//wCH/+wFXAdaAiYAKgAAAQcBTgCqAVIACrQBISEFJgArETX///+H/hQEdwYIAiYASgAAAQYBTt4AAAq0A0VFESYAKxE1//8Ah//sBVwHTAImACoAAAEHAU8B4wFSAAq0AScnBSYAKxE1////h/4UBHcF+gImAEoAAAEHAU8BIQAAAAq0A0tLESYAKxE1//8Ah/47BVwFywImACoAAAAHAjkBIwAA////h/4UBHcGIQImAEoAAAEGAjp1AAAKtANFRREmACsRNf//AEYAAAWLB3MCJgArAAABBwFLALgBUgAKtAESEgUmACsRNf//AC8AAARxB6oCJgBLAAABBwFLAEYBiQAKtAEhIQImACsRNQACAEYAAAYUBbYAEwAXADBAFwMWCwsAEAwMCQ4XB0xZFxcJEg4DBQkSAD8zPzMSOS8rERIAORgvMzMzETMzMTABMwcjAyMTIQMjEyM3MzczByE3MwE3IQcFXrYiueHwjP3Ki+3htiW2L+0vAjYv7/6SK/3KKwTXqvvTApP9bQQtqt/f3/2qzc0AAQAvAAAEPwYUAB8APEAhFgsaFQ0ODUlZEg4OGhAaBUZZABoQGiAaAxoaCxAAAAsVAD8zPxI5L10rERIAORgvMysRADMREjkxMCETNjU0IyIGBgcDIwEjNzM3MwchByEDMzY2MyARFAcDAr6IEHlJk3EbWuwBBJ0kmiXrJQFEI/69VAhTqF0BFhSDAntHOINz0Yn+UATDo66uo/64al3+xjho/ZgA////zwAAA9oHSAImACwAAAEHAVL/ggFSAAq0ARUVBSYAKxE1//8ALwAAA00F9gImAPMAAAEHAVL+9QAAAAq0AQ0NESYAKxE1////zwAAA3oG2wImACwAAAEHAU3/hAFSAAq0AQ8PBSYAKxE1//8ALwAAAusFiQImAPMAAAEHAU3+9QAAAAq0AQcHESYAKxE1////zwAAA5sHWgImACwAAAEHAU7/UQFSAAq0AQ8PBSYAKxE1//8ALwAAAxYGCAImAPMAAAEHAU7+zAAAAAq0AQcHESYAKxE1////z/4tAz8FtgImACwAAAAHAVEApAAA////pv4tAlYF+gImAEwAAAAGAVFGAP///88AAAM/B0wCJgAsAAABBwFPAHsBUgAKtAEVFQUmACsRNQABAC8AAAIGBFIAAwAKswIPARUAPz8xMCEjEzMBG+zs6wRSAP///8/+aAVABbYAJgAsAAAABwAtAs0AAP//AC/+FASJBfoAJgBMAAAABwBNAjMAAP///r7+aANpB3MCJgAtAAABBwFL/z4BUgAKtAETEwUmACsRNf///vz+FAMBBiECJgI3AAABBwFL/tYAAAAKtAETExEmACsRNf//AEb+OwVmBbYCJgAuAAAABwI5AKIAAP//AC/+OwSHBhQCJgBOAAAABgI5YAAAAQAvAAAEhwRSAA4AGEAMDgMGBwQJAQoPBQkVAD8zPzMSFzkxMAEBIQEBIQMHAyMTMwMGBwGLAewBEP4dASP++tGITezq6zkNNwJWAfz+G/2TAddg/okEUv76NcEA//8ARgAAA44HcwImAC8AAAEHAHb/qQFSAAq0AQ4OBSYAKxE1//8ALwAAA3UHrAImAE8AAAEHAHb/kAGLAAq0AQwMAiYAKxE1//8ARv47A3kFtgImAC8AAAAGAjlvAP///57+OwJkBhQCJgBPAAAABwI5/xMAAP//AEYAAARkBbcCJgAvAAABBwI4AQT/owAHsgEJAwA/NQD//wAvAAAD4wYUAiYATwAAAQcCOACDAAAACrQBBgYAJgArETX//wBGAAADvQW2AiYALwAAAAcBTwFv/Wv//wAvAAADMwYUACYATwAAAAcBTwDl/V0AAQAKAAADeQW2AA0AI0ASBwoEAQQCQAgIAAUDAAtMWQASAD8rABg/EjkvGs0XOTEwMxMHJzcTMwM3FwUDIQdGalRS1ZztfLxU/r5cAhsrAe4wnHUC5/2ua5yy/kzNAAEAAgAAApEGFAALAChAGgADCQYEAQ8HHwcvB08HXwefBwYHBwUKAAUVAD8/EjkvXc0XOTEwATcXBwMjEwcnNxMzAeNfT9+P6nFYUNes6AOHN5l//VoCEjOaewMgAP//AEQAAAXdB3MCJgAxAAABBwB2AVABUgAKtAEaGgUmACsRNf//AC8AAARWBiECJgBRAAABBgB2cQAACrQBISERJgArETX//wBE/jsF3QW2AiYAMQAAAAcCOQDyAAD//wAv/jsESgRmAiYAUQAAAAYCOWQA//8ARAAABd0HcwImADEAAAEHAUwA1QFSAAq0AR0dBSYAKxE1//8ALwAABG0GIQImAFEAAAEGAUwAAAAKtAEkJBEmACsRNf//AC4AAATdBbYAJwBRAJMAAAAGAge7AAABAET+agXdBbYAGAAdQA4RCQ0UDgMNEgAFTFkAIwA/KwAYPz8zEjk5MTABIic3FjMyNwEjAgcDIwEhATM2NxMzAQYGAtFsQARXQ842/kMGLRud2wE1AQABogYaMpXb/ssr7P5qGcsXyQSL/tt9/RcFtvu0qeECwvpKyM4AAQAv/hQESgRmACIAI0ASFRkSFRkMRlkZEBMPAAVGWQAbAD8rABg/PysAGD8SOTEwASInNRYzMjcTNjU0IyIGBgcDIxMzBzM2NjMyFhUUBwMOAgIdTEg9OIEnphKBSIxwHGLs7LgVCVOwZ4aTF5siXJL+FBfBF7wDD1opg3LXiP4rBFLNdmuYjDp7/RufolP//wCH/+wFjQbbAiYAMgAAAQcBTQDpAVIACrQCHx8FJgArETX//wBe/+4ENwWJAiYAUgAAAQYBTQgAAAq0Ah8fESYAKxE1//8Ah//sBY0HWgImADIAAAEHAU4AqgFSAAq0Ah8fBSYAKxE1//8AXv/uBDcGCAImAFIAAAEGAU7YAAAKtAIfHxEmACsRNf//AIf/7AXLB3MCJgAyAAABBwFTATMBUgAMtQMCLi4FJgArETU1//8AXv/uBNMGIQImAFIAAAEGAVM7AAAMtQMCLi4RJgArETU1AAIAh//sB1IFzQAVACEAOkAgEBNMWRAQAQwMD0xZDAMKG0xZCgQBFExZARIDFkxZAxMAPysAGD8rABg/KwAYPysREgA5GC8rMTAhIQYjIAAREBIkMzIXIQchAyEHIQMhBTI3EyYjIgYCFRQWBh39M1RW/v3+5MUBVtmRTgL4K/3lVAH4K/4IYAIb/GxKQd5EcYrgf6MUASsBCAELAbnqF83+dcj+NRMbBA4fwP6ryq28AAADAF7/7AbDBGYAIgAvADkAO0AeDgMFDDMYSFkzMwUMMCMMI0ZZEQwQHCoFKkZZAAUWAD8zKxEAMxg/MysRADMREjkYLysREgA5OTEwBSImJwYjIiY1NBI2MzIXNjYzMhYVFAQhIwcUFjMyNjcVBgYBIgYGFRQWMzISNTQmJSIGBzMyNjU0JgTJeLkwie262pP/pu1iScp9n6/+tf7OLwNxcUWDb1uo/V1XjVdhW4+tYwKJaa4iH73SPBRcXLbnxc4BTa/AW2eVgbfMPG9+IzG9KyQDtoD1kXR6ASXrb3UQq45sZTA4//8ARgAABJoHcwImADUAAAEHAHYAmgFSAAq0Ah8fBSYAKxE1//8ALwAAA8sGIQImAFUAAAEGAHbmAAAKtAEZGREmACsRNf//AEb+OwSaBbYCJgA1AAAABwI5AKYAAP///5z+OwOJBGYCJgBVAAAABwI5/xEAAP//AEYAAASmB3MCJgA1AAABBwFMADkBUgAKtAIiIgUmACsRNf//AC8AAAPvBiECJgBVAAABBgFMggAACrQBHBwRJgArETX//wAn/+wETwdzAiYANgAAAQcAdgBqAVIACrQBLS0FJgArETX//wAO/+wDuwYhAiYAVgAAAQYAdtYAAAq0ASsrESYAKxE1//8AJ//sBDsHcwImADYAAAEHAUsAAgFSAAq0ASsrBSYAKxE1//8ADv/sA5QGIQImAFYAAAEHAUv/aQAAAAq0ASkpESYAKxE1//8AJ/4UBDsFywImADYAAAAHAHoBVAAA//8ADv4UA3EEZgImAFYAAAAHAHoBFwAA//8AJ//sBE8HcwImADYAAAEHAUz/4gFSAAq0ATAwBSYAKxE1//8ADv/sA9IGIQImAFYAAAEHAUz/ZQAAAAq0AS4uESYAKxE1//8AiP47BMMFtgImADcAAAAGAjn9AP//ADr+OwMlBUgCJgBXAAAABgI5rwD//wCwAAAEwwdzAiYANwAAAQcBTAAKAVIACrQBExMFJgArETX//wBc/+wEIwYcAiYAVwAAAQcCOADDAAgAB7IBHAAAPzUAAAEAqAAABMMFtgAPAChAFAMHCAdLWQAICAwFEg8LDAtMWQwDAD8rEQAzGD8SOS8zKxEAMzEwASEHIQMjEyE3MxMhNyEHIQLBAQgp/viI7YX/ACv+Wv6FLQPmK/6DAz/C/YMCfcIBqs3NAAABACX/7AMlBUgAIQA6QB0TFUAcDA0MSVkZDQ0GFRAYFRhIWRIVDwYARlkGFgA/KwAYPzMrEQAzERI5GC8zKxEAMxoYEM0xMCUyNxUGBiMgNTQ2NyM3MzcjPwIzByEHIQczByMHBhUUFgHHRFMjeDz+7ggvhyGHMaIVvoGSNAEXJ/7rMfAj7ycNMqofshEa9xxC3KTfblLo9rLfpLk3JSszAP//AJj/7AWLB0gCJgA4AAABBwFSANUBUgAKtAEfHwUmACsRNf//AG//7ASJBfYCJgBYAAABBgFSMQAACrQBIyMRJgArETX//wCY/+wFiwbbAiYAOAAAAQcBTQDbAVIACrQBGRkFJgArETX//wBv/+wEhwWJAiYAWAAAAQYBTTMAAAq0AR0dESYAKxE1//8AmP/sBYsHWgImADgAAAEHAU4ApgFSAAq0ARkZBSYAKxE1//8Ab//sBIcGCAImAFgAAAEGAU4AAAAKtAEdHREmACsRNf//AJj/7AWLB+wCJgA4AAABBwFQAJgBUgAMtQIBGRkFJgArETU1//8Ab//sBIcGmgImAFgAAAEGAVDvAAAMtQIBHR0RJgArETU1//8AmP/sBb0HcwImADgAAAEHAVMBJQFSAAy1AgEoKAUmACsRNTX//wBv/+wFAAYhAiYAWAAAAQYBU2gAAAy1AgEsLBEmACsRNTX//wCY/i0FiwW2AiYAOAAAAAcBUQJxAAD//wBv/i0EhwRSAiYAWAAAAAcBUQKuAAD//wDLAAAHtAdzAiYAOgAAAQcBSwF9AVIACrQBIyMFJgArETX//wB5AAAGXgYhAiYAWgAAAQcBSwCiAAAACrQBIiIRJgArETX//wC6AAAFAAdzAiYAPAAAAQcBSwACAVIACrQBDw8FJgArETX///9W/hQEUgYhAiYAXAAAAQYBS4wAAAq0AR4eESYAKxE1//8AugAABQAHPgImADwAAAEHAGoADgFSAAy1AgEeHgUmACsRNTX////ZAAAEogdzAiYAPQAAAQcAdgB/AVIACrQBEhIFJgArETX////ZAAAD3gYhAiYAXQAAAQYAdvkAAAq0ARISESYAKxE1////2QAABKIHTAImAD0AAAEHAU8BMQFSAAq0ARMTBSYAKxE1////2QAAA6IF+gImAF0AAAEHAU8AmgAAAAq0ARMTESYAKxE1////2QAABKIHcwImAD0AAAEHAUwAFwFSAAq0ARUVBSYAKxE1////2QAAA/EGIQImAF0AAAEGAUyEAAAKtAEVFREmACsRNQAB/wL+FAORBh8AFwAXQAwMEUZZDAAABUZZABsAPysAGD8rMTADIic1FjMyNjcBNjYzMhcHJiMiBgcBBgZoWztAMz5cFgESKbSodWA9Sj1FVBX+6Si1/hQXvhRkaQUQwK0rsBxVY/rbv7AAAf/y/hQEbwXLAB8AKEAVEBVGWQocGRxIWQwZGRAAAAVGWQAbAD8rABgQxDkvMysRADMrMTATIic1FjMyNjcTIz8CNjYzMhcHJiMiBgcHMwcjAwYGh1o7QDI+XRXBshTFFiW5qnNiPko9R1MUF+Ql48krtf4UF74UZGkDk21Hdb6vK7AcVWNtsvxOwK8AAAT/iQAABMUHqgAQABoAJgAuAE1AFioGTFkuCQIkHhpADRNIGg4ADhAOAg64/8BAFw0QSCokDg4kKgMIDxQBFEANE0gUBAgSAD8zLytdEhc5Ly8vK10QxiszETMzMysxMAEUBxMjAyEDIwEmNTQ2MzIWJTY2NyEVBgYHIxM0JiMiBhUUFjMyNgcGBgMhAiYnBAZUnOor/h3R/ALJI4NnaIX+zyuKJgEVNb9Wpqw6Li88NjUuOqAWMdcBZiYJBAWmckL7DgGN/nMFIzBRZ3p6wiSKLw4xgTD+6jE5OTEyNzfYM2j+XQFrjEcAAAUAXv/sBI0HqgAJABUAIQA0AEIAUUAtCAgTDwNfAwIMAxkAEwEQEx8PDQEiAw0pQDIsIikuDyk8RlkpEDEVIjVGWSIWAD8rABg/PysAGD8REjk5GhDeX15dMsReXTLEXl0ROS8xMAE2NjchFQYGByMBFAYjIiY1NDYzMhYHNCYjIgYVFBYzMjYBIiY1NBI2MzIWFzM3MwMjNyMGJzI2EjU0JiMiBgIVFBYCnjCGJQEUKsBfpgErgmxqf4JnaIaDPC8uOjQ0Lzz+SY2ki/SSYYwnCj607LYVBp5pUp5mXkxVllpRBs0piCwOKYQ1/tVme3lmZ3t5aTI5OTIwODj6j8u4ygFgzVtXnvuusMS+mwEEmlhrmv73jmZl////hwAAByUHcwImAIgAAAEHAHYCbQFSAAq0AhwcBSYAKxE1//8AXv/sBo8GIQImAKgAAAEHAHYBqgAAAAq0A0pKESYAKxE1//8Abf+qBbQHcwImAJoAAAEHAHYBEgFSAAq0AzAwBSYAKxE1//8AM/+mBFoGIQImALoAAAEGAHY/AAAKtAMvLxEmACsRNf//ACf+OwQ7BcsCJgA2AAAABgI5GwD//wAO/jsDcQRmAiYAVgAAAAYCOdoAAAEBYgTZBCsGIQANAA60AwuABgEALzMazTIxMAEjJicGByM1NjY3MxYXBCuYTFWDaaSKfhv4JogE2T9zbkQZgIcoY8wAAQGmBNkEbQYhAA0ADrQFAYADCwAvMxrNMjEwATMWFzY3MxUGBgcjJicBppVFXX1xolCyIfgsgAYhOnhpSRtHty9uvwABAYsE2QP2BYkAAwAIsQADAC8zMTABIQchAbACRiX9ugWJsAABAcUE2QRKBggADwAStwh/AAEAgAwDAC8zGs1dMjEwAQYGIyImNTQ3MxQWMzI2NwRKH7KYhZcEh0lXWF8PBgiblIR0JBM/Pj4/AAEBQgT2Ak4F+gALAAixAwkAL80xMAE0NjMyFhUUBiMiJgFCTkc1QlFBNEYFYkRUNTZHUjQAAAICHQTXA/QGmgALABcAGUAODw8JHwkvCQNwCQEJFQMALzPMXV0yMTABFAYjIiY1NDYzMhYHNCYjIgYVFBYzMjYD9IRqan+CZ2iGgzwvLTs1My88Bbpoe3pnZ3t5aTI5OTIxNzcAAAH/YP4tANUAAAARAA61BmALAQsAAC8vXTMxMDMGBhUUFjMyNxUGIyImNTQ2N9VvTyIdJjZBSFtuX3hYczMgIQ6NFV5UUYZKAAEBRgTXBFgF9gAVACFAEBAABQsACwALfxSPFAIUgAkALxrMXTk5Ly8RMxEzMTABIi4CIyIGByMSMzIeAjMyNjczAgNULUtEPyAmMhKJOccuTkM8HSgyF4lCBNkiKSI3OAEdIykjNTz+4wACAVIE2QSYBiEACQASAA60DASAEgkALzMazTIxMAE2NjczFQYGByMlNjczFQYGByMBUkKFHvAn40iDAXF3cO401UeFBPJKtDETM9ExGYWqE0DCMwABAlIE2QPfBmgACAAKsgOACAAvGs0xMAE2NzMVBgYHIwJSXkbpI5VIjQT2trwaRdpWAAMBiwUCBEgGtAALABcAIAAfQBAAIBAgICADDwMgAyADGxUJAC8zzDk5Ly8RM10xMAE0NjMyFhUUBiMiJiU0NjMyFhUUBiMiJic2NzMVBgcHIwGLQjstNUI2LDsB3UM6LTZDNis82Wsd5S+IR28FZDxMLzBBSi8zPEwvMEFKL1bWVxRLmFD///+HAAAETgX/AiYAJAAAAQcBVP4a/5cAB7ICEQAAPzUA//8AlgI5AcMDagAHABEAdQJW//8ANAAABQgF/wAnACgAhQAAAQcBVP3i/5cAB7IBDgAAPzUA//8ANAAABiEF/wAnACsAlgAAAQcBVP3i/5cAB7IBDgAAPzUA//8AQQAABD0F/wAnACwA/gAAAQcBVP3v/5cAB7IBDgAAPzUA//8ATf/sBe0F/wAmADJgAAEHAVT9+/+XAAeyAh4AAD81AP//ADQAAAYnBf8AJwA8AScAAAEHAVT94v+XAAeyAQsAAD81AP//AFcAAAYMBf8AJgF2fwABBwFU/gX/lwAHsgElAAA/NQD//wBk/+wDJAa0AiYBhgAAAQcBVf7cAAAADrYDAgEmJhEmACsRNTU1////hwAABE4FuAIGACQAAP//AEYAAATLBbYCBgAlAAAAAQBGAAAEgQW2AAUAEbcBEgIFTFkCAwA/KwAYPzEwISMBIQchATHrATUDBiv95QW2zf///8kAAAQpBbgCBgIoAAD//wBGAAAEgwW2AgYAKAAA////2QAABKIFtgIGAD0AAP//AEYAAAWLBbYCBgArAAAAAwCH/+wFmgXNAAMAEQAfACZAFAMCTFkDAwgPDxJMWQ8ECBlMWQgTAD8rABg/KxESADkYLysxMAEHITclEAIEIyAAERASJDMyACUiBgIVFBYzMjYSNTQmBBkr/hgpA2uw/q/l/vj+28MBV97+AR391ZLifKiVjN19pANMyck9/vf+WOwBMAELAQkBtOn+zmW9/rHPqcS0AVXQrcL////PAAADPwW2AgYALAAA//8ARgAABWYFtgIGAC4AAAAB/4cAAAQ1BbgACwAOtQcBAwQAEgA/Mj8zMTAjASETIwMmJw4CAXkDBgEEpOdWDwQXVjz+SQW4+kgDdYjMO8F2/KkA//8ARAAABuUFtgIGADAAAP//AEQAAAXdBbYCBgAxAAAAA//dAAAEagW2AAMABwALACZAFAADTFkAAAoEBAdMWQQDCgtMWQoSAD8rABg/KxESADkYLysxMAEhByETIQchAQchNwEMAo4p/XBYAzEr/M8CeSv8gSkDXsgDIM374svLAP//AIf/7AWNBc0CBgAyAAAAAQBGAAAFiQW2AAcAFEAJAQUSBgNMWQYDAD8rABg/MzEwISMBIQEjASEEVPABC/3O/vbtATUEDgTp+xcFtv//AEYAAASWBbYCBgAzAAAAAf/bAAAEjQW2AAsAKkAVAggIAAQBCQQHTFkEAwMHAAlMWQASAD8rEQAzGD8rEQAzERI5ETMxMCM3AQE3IQchAQEhByUnAhn+2ScDciv9mAEj/ggClyu+AjICDLrN/fb97MsA//8AsAAABMMFtgIGADcAAP//ALoAAAUABbYCBgA8AAAAAwCH/+wF/gXLABIAGQAgAD9AIxkaCgcHGktZAAcQBwIQAxEBEyABIEtZYAEBBwEHAQgAEwgEAD8/Ejk5Ly9dKxEAMxEzX15dKxEAMxEzMTAFNyYmNRAAJTczBxYWFRQCBAcHEzY2NTQmJyMGBhUUFhcCKzHh9AFxAU4k5iXi8aT+xd0yWsfdjX/nxOCHhRTfEfbSAR8BSAy0tBHzzbr+5qAF4QGhC+XCfpIDBOTCf5cF////kQAABSUFtgIGADsAAAABALwAAAaLBbYAHwAjQBEBBBYTBBNMWQQEAxsUCwMDEgA/PzMzEjkvKxEAMxEzMTABIwMjEyMiJjU0NxMzAwYVFBYzMxMzAzMyNjcTMwMCBAOTHF7mXg7Z7hda7F8Sf4MQruauEKq4I2fvbDf+uwG4/kgBuNO7U3cBpv4+YDZ1agM3/MmorAHj/gT++fsAAf/ZAAAFjQXNACIAIUASEgBMWRIEGQcdAwoJCkxZHAkSAD8zKxEAFzMYPysxMAEiBgIVFBYXByE3ISYmNTQSJDMyFhYVFAIHIQchNzYSNTQmA1yEz3pWYyv9vCkBaGZquQFF1ar1gdXVAW0r/Y0r2uGkBQCQ/uunn+hiy81V/53hAWrEhPmk6f6Ifs3LgAFu5aq4////zwAAA5MHPgImACwAAAEHAGr/fAFSAAy1AgEhIQUmACsRNTX//wC6AAAFAAc+AiYAPAAAAQcAagAjAVIADLUCAR4eBSYAKxE1Nf//AF7/7ASwBmgCJgF+AAABBgFUJwAACrQCNjYRJgArETX//wAz/+wD5QZoAiYBggAAAQYBVNwAAAq0ASwsESYAKxE1//8AL/4UBEoGaAImAYQAAAEGAVQlAAAKtAEhIREmACsRNf//AGT/7ALYBmgCJgGGAAABBwFU/vkAAAAKtAEZGREmACsRNf//AH3/7ARvBrQCJgGSAAABBgFV+wAADrYDAgEoKBEmACsRNTU1AAIAXv/sBLAEZgAgAC0AK0AXFgIaAAYPAChGWQAQFA9GWRohRlkUGhYAPzMrKwAYPysAGD8REjk5MTABMhczNzY3MwYHAwYVFBYzMjcVBiMiJyMGBiMiJjU0EjYTMjYSNTQmIyIGAhUUAm+9VQgUKifCXTBQECIdHCY+UsAVBlSdXY6fiPIPVJlfV09Wk1gEZrQnUie7yP6oRD8iJAyyHLpmVM220wFfxfxEpwEMgFtulv7+k9EAAv/J/hQEpgYfABQAKQA2QBwPDAAFIiMjIkZZIyMMABEbABVGWQAADBxGWQwWAD8rABg/KwAYPxESOS8rERIAORESOTEwATIWFRAFFhYVFAYGIyImJwMjATY2FyIGBwMWFjMyNjU0IyM3MzI2NTQmAxu40/6ifYd33ptRjlJ36wFUMvy9ZHsjtid/Q4We/DkpQY6XWAYfuKT+sEYbroWP44EnN/3KBkjs172Gnfy1ICqriuy+mI1QZAAAAQBI/hQETgRSABAAErcDCAENBA8BGwA/PzMSOTkxMAEjNhMDMxMWFTM2NjcBMwECAT/3K4ua6DsTBBdhIQEb/P3Jnf4U7AEMBEb936WrQNE9AiP77f7lAAIAP//sBJwGHwAfACoAJEASEgAlJRkFBQxHWQUAGSBGWRkWAD8rABg/KxESADkRMzMxMAEmNTQ2MzIWFwcmJiMiBhUUFhcWFhUUAgYjIiYmNTQAEzI2NTQnBgYVFBYCM6bcuGC5Yl0/j1BUWjxyfXaI/6iCvmYBAMGBoHuqyWcDqIWkl7c1PqgoPE5FNVdbZtuCqv76j2G0ctEBJf1D1qWxYy7jm2x3AAEAM//sA+UEZgAjAC1AFxEBIiIBSFkiIgwYGB1HWRgQDAdHWQwWAD8rABg/KxESADkYLysREgA5MTABIyIGFRQWMzI3FQYjIiY1ECU1JiY1NDYzMhcHJiMiBhUUMzMCxYOHll1np6+f3brWATpOUunH1JRNi4huc8SBAeVZV0FOWsNRmIYBAzcGH3FLlqtPsUhSSHwAAAEAXv5xBFgGFAAhACBADxEfHwgZIwoHCAgHR1kIAAA/KxESADkYPxI5ETMxMBM0EgAlBiMjNyEHBAACFRQWFx4CFRQGByM2NjU0JicmJl6MARkBGGR83SkC0SP+zv7akVhobl4yTWX2aFdCYpiHAZyXASQBMt8MuJ39/sr+9n5ccC0wSl5BS5FdX300KDkqQboAAQAv/hQESgRmABgAHEAODhILFQAbEgVGWRIQDA8APz8rABg/PxI5MTABEzY1NCMiBgYHAyMTMwczNjYzMhYVFAcDAlT4EoFIjHAcYuzsuBUJU7BnhpMX9P4UBIxaKYNy14j+KwRSzXZrmIxFcPuHAAMAYv/sBF4GKwAPABgAIAAmQBQcFEdZHBwACAgZR1kIAQAQR1kAFgA/KwAYPysREgA5GC8rMTAFIiY1NDcSADMyFhUUAgIGJzISEyEGFRQWASIGAyE2NTQBy7K3MV0BJ+Wwsm2n6IF1oD/+Mx5JAVJtqD8ByR0U39fB3AGPAV3j4L7+F/7InbYBDQENpoN5eATT+f77mXnsAAABAGT/7AJKBFIAEAARtwsPBgBGWQYWAD8rABg/MTAlMjcVBgYjIDU0NxMzAwYVFAG0QVUjdz/+8xWZ7JwOqh+yERr3M2cC1f0fRCVeAP//AC8AAASHBFICBgD6AAAAAf+Y/+wD2wYhACAAIEAQGwkgFQkERlkJARUQRlkVFgA/KwAYPysAGD8SOTEwAScmJiMiByc2MzIWFxMWFjMyNxUGIyImJyYmJwYGBwEjAgAOCz9EOiwdSVuamRVuCysnHyQ9WGRsDhgbAho0Iv7Q+wQtd11ZCrwVnrL8dVNFDLQab37X64I8fj792////8n+FASTBFICBgB3AAAAAQBkAAAEOwRSAAwADrUHAA8EDBUAPzM/MjEwEzMTFhc2EhMzAgAHI2ToQwoJmctI7Uf+2/brBFL9k1q6mwGiAUT+k/3z2AAAAQBW/nMEEAYUAC8ANEAaBxQUDiUbAS4uAUhZLi4lDiMnJCUlJEdZJQAAPysREgA5GD8SOS8rERIAORESOREzMTABIyIGFRQWFxYWFRQGByM2NjU0JicmJjU0Njc1JiY1NDY3BiMjNyEHIyIGBhUUITMDREzG7lR0j2lUXvhzSj9nkYrLwmRvr5mMUzcmAqgkD4befQEKYgLXpI9QYjE/gFZQmFFrcTIqNyw8sIek4S0GG3tab6knDLisSIZbvAD//wBe/+4ENwRkAgYAUgAAAAEAVP/sBWgEUgAZACJAEQ4VFQwQEhBHWRIPBQBHWQUWAD8rABg/KxEAMzMYPzEwJTI3FQYjIiY1NDcTIQMjEyM3NyEHIwMGFRQEIzY0UmxwcxB7/rDF7cbnFMUEOybgfQqoGbEkbmQ5SwJW/GgDmGpQuv2hKiNEAAL/yf4UBEoEZgAQAB0AIkARBgQOChsOEUZZDhAEF0ZZBBYAPysAGD8rABg/ERI5MTABFAIGIyInBgYDIxMSNjMyFiUiBgcDFjMyNhI1NCYESojtmKVzChdS6es4+tLA0v5gaIAmRk98VotaVgK0x/6ztHxHhP53BFkBDO3iIp+3/r5khgEBh29/AAEAXv5qA80EZgAfABpADAMQEBcKIxccRlkXEAA/KwAYPxI5ETMxMAEUFhcWFhUUBgcjNjY1NCYnJiY1NBIkMzIXByYjIgYGAUxXdotoU1/4V2ZBW52InwEIo56HRnplXZxjAc9mezI6f1tPl1hShj8tOSVB0JW/AUqrPbg1d+IAAgBe/+4E/gRSABAAGwAcQA4PEQwRR1kMDwUWRlkFFgA/KwAYPysRADMxMAEUDgIjIiY1NBIkMyEHIRYlIgIVEDMyEjU0JwQjUpDIecnZlwEkygIbJf7sXv6wuc7Ei6I5AlJ176dZ6dfPATGkuIiI/vzk/vwBCt6XbQABAFT/7APdBFIAFgAcQA4RDA4MR1kODwYARlkGFgA/KwAYPysRADMxMCUyNxUGBiMgNTQ3EyE3NyEHIQMGFRQWAkpEUyN3Pf7uFHH+1xTDArIn/rJyETKqH7IRGvc9XQIbalC6/eFELSszAAABAH3/7ARvBFIAEgAUQAkPBg8ADEZZABYAPysAGD8zMTAFIiY1NDcTMwMGFRQzMhIRMxAAAgi/zBl46nkXs7G37P7MFMCwR3YCOf3HZ0jAAdsBzf21/eUAAgBe/hQFXgRqABoAJAAnQBQGEBobER1HWREQDCEAGBghRlkYFgA/KxEAMxEzGD8rABg/PzEwBSYmNTQSNxcGAhUUFxM+AjMyFhUUAgQHAyMBNCMiBgcDPgIB5bfQorqWiH7CaSVlnHGgsqH+1Mxj4wLybztIF3p5rV0OFu+9yQFHpomG/vyU9iEB8rG7XNG80/6xvwz+KATPy2Fs/csPmvkAAf8K/hQEnAReAB8AJUATBBQQBQ8WGwAbRlkAEBALRlkQGwA/KwAYPysAGD8/Ejk5MTABMhYXEwEzARMWFjMyNxUGIyImJwMBIQEDJiYjIgcnNgEUcHcTIwFt/v3ORgs0OC0tTFZzexQr/lz+/AJxOQsvLRgtKVAEXoKU/vUCFfzy/iBLQg62G4iZAUb9mQNfAZdOQA+0IQABAIP+FAXBBhIAGgAgQBAZAAMRDwobABgLGEdZCAsWAD8zKxEAMxg/PzM/MTAlNhIRMxACBAcDIxMmJjU0NxMzAwYVFBYXATMDJeDQ7Jf+x/Vk5GXIzgqB6ncSbWYBJOSqHAG3AdX+cP4q7RP+KAHYEciqPUACZv3NXT9mcAcFbAAAAQBe/+wF1QRSACcAJEARJQYQEAAcBg8WDAAMR1kjABYAPzIrEQAzGD8zEjkvETkxMAUiJjU0EjczBgIVFDMyNjcTMwYGFxQzMjYSNTQnMxYVFAIGIyInBgYBmJOnhHrwfoqBT10cQOEoLARzUYNNHeEfheiZxzc+lhTItrIBfri8/oesyYd9AS28zxmNoQEtq6KPjpX2/nnGvGRYAP//AGT/7AL9BewCJgGGAAABBwBq/uYAAAAMtQIBJiYRJgArETU1//8Aff/sBG8F7AImAZIAAAEGAGr/AAAMtQIBKCgRJgArETU1//8AXv/uBDcGaAImAFIAAAEGAVQQAAAKtAIkJBEmACsRNf//AH3/7ARvBmgCJgGSAAABBgFUEAAACrQBGxsRJgArETX//wBe/+wF1QZoAiYBlgAAAQcBVADhAAAACrQBMDARJgArETX//wBGAAAEgwc+AiYAKAAAAQcAagA9AVIADLUCASEhBSYAKxE1NQABALD/7AUXBbYAHwArQBcYD0xZGBgUERIXExQTTFkUAwAFTFkAEwA/KwAYPysRADMYPxI5LysxMAUiJzUWMzI2NzY2NTQmIyEDIwEhNyEHIQMzMhYVFAIGA2RiRD9LVVoVFQZPXf8Alu8BDP6uLQO2K/6ISvq7vEy6FBzLHVxlZEEXR0n9PQTpzc3+pqiVYP6epAD//wBGAAAEgQdzAiYBYQAAAQcAdgB9AVIACrQBDg4FJgArETUAAQCH/+wFIQXLABwAJkAUAwZMWQMDERgYAExZGAQRC0xZERMAPysAGD8rERIAORgvKzEwASIEByEHIQYVFBYzMjcVBgYjIgAREBIkMzIXByYDnK3+/D8CQin9wAakoo28V69w/v7t0wFg4teuXpgE/t7Kyx9Lr7pEzSEiASoBCwEEAb7oXMNS//8AJ//sBDsFywIGADYAAP///88AAAM/BbYCBgAsAAD////PAAADkwc+AiYALAAAAQcAav98AVIADLUCASEhBSYAKxE1Nf///r7+aAJzBbYCBgAtAAAAAv/B/+wG8gW2ABsAIwAwQBoSIkxZEhIaEBojTFkaEhAATFkQAwUKTFkFEwA/KwAYPysAGD8rERIAORgvKzEwAQcCAgYjIic1FjMyNjYSEhMhAzMyFhUUBCEhARMyNjU0IyMDAwQ8i57Cl0o7PChEWFNqjkYC9H1Y4u/+zP7i/oMBCJacoeN9ZQTn4f3//oGaFskVP5ABMgHzAQz9rr667f8E5/vgjIq//isAAAIARgAABukFtgASABoAKUAVGQwRDExZAhERCgAPAw4SChpMWQoSAD8rABg/PzMSOS8zKxEAMzEwATMDMzIWFRQEISETIQMjATMDIRMyNjU0IyMDBFDtfGLg5v7Q/uX+fY3+GY7tATXtfAHl65yg5HxlBbb9sL667/8CnP1kBbb9sP1hjIjB/isAAAEAsAAABRQFtgAWACNAEg0ETFkNDQkUBhIMCAkITFkJAwA/KxEAMxg/MxI5LysxMAE0JiMjAyMBITchByEDMyARFAcDIxM2BCdXXfiW7wEM/q4tA7Yr/ohK+gF0FlTyYQ4CMUxG/T0E6c3N/qb+u0Ro/mIBuksA//8ARgAABVgHcwImAbQAAAEHAHYAzwFSAAq0ARMTBSYAKxE1//8ADP/sBWoHeQImAb0AAAEHAjYAUAFSAAq0ARkZBSYAKxE1AAEARv5tBYkFtgALABlADAQAAwkjCwJMWQcLEgA/MysAGD8/MzEwATMBIQEzASEDIxMhAXvv/vYCMQEL7f7L/m1X51b+bQW2+xcE6fpK/m0Bk////4cAAAROBbgCBgAkAAAAAgBIAAAEhQW2AAwAFAAmQBQME0xZDAwHCAgLTFkIAwcUTFkHEgA/KwAYPysREgA5GC8rMTABMhYVFAQhIQEhByEDEzI2NTQjIwMCWObr/sv+4/5xATUDCCv941EEo6Tjk2UDZMG+6vsFts3+e/1ji4XF/isA//8ARgAABMsFtgIGACUAAP//AEYAAASBBbYCBgFhAAAAAv9K/m8FNQW2AA0AEwAkQBIABCMJD0xZCQMLEgUCBUxZAhIAPysRADMzGD8rABg/MzEwARMhAyMTMxIAEyEBMwMDIwYAByEDe1b8slbjf3K3AUNhAp/+9rqBS+JQ/u6PAfH+bwGR/m8CXgEBAqMBRfsX/aIGePT9sNYA//8ARgAABIMFtgIGACgAAAAB/48AAAdCBbYAEQAhQBEDDwYMCQUAABEHBAEDDgsREgA/MzM/MzMSOREXMzEwAQEzARMzAwEhAQEjAQMjEwEhAhv+vvQBOZTlkwJLAQv9jQFO/P7Al+aY/ab+7QMGArD9TAK0/UwCtP0n/SMC1f0rAtP9LQAAAQAQ/+wEagXLACgALUAXAxgZGRhLWRkZCiYmIEtZJgQKEUtZChMAPysAGD8rERIAORgvKxESADkxMAEUBgcVFhYVFAQhIiYnNRYWMzI2NTQmIyM3MzI2NTQmIyIHJzY2MzIWBGrQuYme/rz+5ITCUlTTba3Bp5qyKaS+y25jrbhafeyLtdwEf6DOGQQSqoTW8iYp1S42koBzZb6IeFpaeaZSRLYAAAEARgAABdkFtgAPABVACQ0EDwYAAwkPEgA/Mz8yETk5MTABMwIGBzMBIQEjEhI3IwEhAXvdtzQNCANUAR3+y9twew0H/Kr+4gW2/KHcLQRo+koCFAJOG/uD//8ARgAABdkHeQImAbIAAAEHAjYA6QFSAAq0ARMTBSYAKxE1AAEARgAABVgFtgAKABlACwIHCgoECAUDAQQSAD8zPzMSOREzMzEwISEBAyMBMwMBIQEERP71/pKY7QE17ZUCbwEW/W0C0f0vBbb9RgK6/SkAAf/B/+kFZAW2ABMAHEAOEhIPAExZDwMECUxZBBMAPysAGD8rABg/MTABAgIGIyInNRYzMjY2EhITIQEjAQMEh7nOsFE0Ny1EWFNqjkYDEv7J7gENBOf9+P3d0xnJFT+QATIB8wEM+koE5wD//wBEAAAG5QW2AgYAMAAA//8ARgAABYsFtgIGACsAAP//AIf/7AWNBc0CBgAyAAD//wBGAAAFiQW2AgYBbgAA//8ARgAABJYFtgIGADMAAP//AIf/7AUhBcsCBgAmAAD//wCwAAAEwwW2AgYANwAAAAEADP/sBWoFtgAVABxADQgNDQAQCQMABUxZABMAPysAGD8zEjkRMzEwFyInNRYzMjY3ATMTFhc2NwEhAQ4CyW5PUmVVhVH+1++mJwoyLwF2AQj9fWuZqhQe2SdihgQS/YOgPXZRApP71bKkSQD//wCH/+wF/gXLAgYBcwAA////kQAABSUFtgIGADsAAAABAET+bQV5BbYACwAbQA0JBQMCIwsHBAdMWQQSAD8rEQAzGD8/MzEwJQMjEyEBMwEhATMBBSmB6lb8MAE17/72AiMBCu7+9Mn9pAGTBbb7FwTp+xMAAAEA2QAABUoFtgAUAB1ADgEDCQMPTFkDAxIJAwASAD8/MzkvKxESADkxMCETBiMiJjU0NxMzAwYVFDMyNxMzAQMle7y5orAQb+5rEKiZv4/w/soCRFadjj1QAhD+AkQqkEwCsPpKAAEARAAAB98FtgALABpADAkFAQMHAwADTFkAEgA/KxEAMxg/MzMxMDMBMwEhATMBIQEzAUQBNfT+8wHJAQr0/vYBxgEL8f7LBbb7FwTp+xcE6fpKAAEARP5tB98FtgAPAB9ADw0JBQMCIw8LBwQHTFkEEgA/KxEAMzMYPz8zMzEwJQMjEyEBMwEhATMBIQEzAQePgedW+ccBNfT+8wHJAQr0/vYBxgEL8f72yf2kAZMFtvsXBOn7FwTp+xMAAgCwAAAE1wW2AAwAFQAmQBQMFExZDAwHCgoJTFkKAwcVTFkHEgA/KwAYPysREgA5GC8rMTABMhYVFAQhIQEhNyEDAzI2NTQmIyMDAwbk7f7N/uH+cwEK/q4tAkB/AqOkdG+LZQNkwb7p/ATpzf2u/WOLhWlc/isAAwBGAAAGmgW2AAMADgAXACJAEgUWTFkFBQ0CDgMBEg0XTFkNEgA/KwAYPz8zEjkvKzEwISMBMyEDMzIWFRQEISEBEzI2NTQmIyMDBWTxATXy+858WOPt/s3+4v6DATVeoqZ1b3xlBbb9rsC/6fwFtvsRioZoXf4rAAACAEYAAAQjBbYACgASAB1ADwERTFkBAQkKAwkSTFkJEgA/KwAYPxI5LysxMAEDMzIWFRQEISEBEzI2NTQjIwMCaHxm5uv+y/7j/nUBNW6ipuONZQW2/a7Bvur7Bbb7EYqGxf4rAAABABf/7ASJBcsAHAAmQBQEA0xZBAQWDw8JTFkPBBYATFkWEwA/KwAYPysREgA5GC8rMTAlIBMhNyE3NCYjIgYHJzYzMgAREAIEIyImJzUWFgF9AYxq/bwpAjkCnpNHkGo+yNT7AQ/A/qjqbbNQWqu4AdPLSKq2HijDUP7g/vX+4/5J4CQt2i8wAAACAEb/7AewBc0AFQAjACpAFw8KTFkPDwwNAwwSExZMWRMEBB1MWQQTAD8rABg/KwAYPz8SOS8rMTABEAIEIyIAETQ3IQMjATMDIRIAMzIAJSIGAhUUFjMyNhI1NCYHsLL+xNT5/vAH/tKL7QE17X8BI0cBbfzrAQn98oDQdZeIgMh2lAOa/uj+T+UBKgEJQTP9bQW2/aoBIQFM/tdcv/6ry6+6tgFS2K27AAL/nAAABMUFtgANABYAJEASAwAVAEtZFRUJDAISCQ9MWQkDAD8rABg/MxI5LysRADMxMAEBIQEmJjU0JCEhASMTEyMiBhUUFjMzAm/+Sf7kAgJoWwEpAQ4Bs/7K7XuRoJyfgXOBAkr9tgKYPaBq3/j6SgJKAqSJgGZvAP//AF7/7AR/BGYCBgBEAAAAAgBo/+wExwYfABoAJwAkQBINGBERIUdZEREYBwAYG0ZZGBYAPysAGD8SOS8rERIAOTEwEzQSEjc2JDcXBwQGBgczNjYzMhYVFAIGIyImBTI2NjU0IyIGBwYVEGiG45FDAVqtG2r+sc+LJwJKt2CPoIv3o8TOAaZRgFKRS6s9FwHD3gG3AR40G0QWxxAxY8iYWFq8tMb+waXxMXflfclvWHFc/vIAAAMAXv/sBDUEZgASAB4AKAAtQBcFEyIiE0hZIiIMAAAfSFkAEAwYSFkMFgA/KwAYPysREgA5GC8rERIAOTEwATIWFRQFFRYVFAYGIyImNTQSJAMHFRQWMzI2NTQmIxMiBgczMjY1NCYCtLfK/vzBbdCS3OmUARC2AnFwaXZxfpV3qifVhYxPBGaWitw7BDSxZJxa6dvHAT+w/XUbHICIX09JSAHXno1cUDhHAAABACX/7AOHBGYAIwAgQBALHxUCAiFHWQIQFQ5HWRUWAD8rABg/KxESADk5MTATNjMyFhUUBgcGBhUUFjMyNjcVBgYjIiY1NDY2NzY2NTQjIge4vbymsI+wsn1XUVWgSmOpXq/CT5jHZ2CKfp4EElSOhnWiQzthQzo9NCK9LiGajFiGZEklUjRmSgACAF7/7ARgBikAGgAnAC1AFw4ECwshR1kLCwQZGRNGWRkBBBtGWQQWAD8rABg/KxESADkYLysREgA5MTABEAIEIyImNTQSNjMyFzM3NTQmIyIHJzY2MyABMhI3JiYjIgYGFRQWBGCj/uS6u85+5Y+/XgYCg4xrZTY/oUcB2f2aerUpGnJNU4xOXAOq/vL+O+vdxLMBLq2zIhzo2i21Gx76gwEM6lpofduDanP//wBe/+wD+gRmAgYASAAAAAH/4//sB1QEZgA7AD1AIDkBGgFJWR4aGjscDzsVJxAVEEZZIhUQLgkECUZZMwQWAD8zKxEAMxg/MysRADMYPz8SOS8zKxEAMzEwASMGACMiJzcWMzI2NjU0JiMiBzU2MzIWFRQHMxMzAzM2ADMyFwcmIyIGBhUUFjMyNxUGIyImNTU3IwMjAxmeNv7kxUQ9JTAqX5ZVWVE4PUxSrcAFqGXdZp83ARvDUzYpLDJak1lVUzJDRlaswAKqZdsB1eP++g68DI72inV5Fb8W3swbJgHX/inlAQYOvAqD+ZBzfRfBFNnOISH+KwABAAr/7AOgBGYAJQAtQBcQJCUlJEhZJSUXCgoFR1kKEBcdR1kXFgA/KwAYPysREgA5GC8rERIAOTEwATI2NTQjIgcnNjMyFhUUBgcVFhYVFAQjIiYnNRYzMjY1NCYjIzcBpJKApHytPcTJq7yHe1pi/vXxXLdBqq6Aj11koicCmFBRdUquVIx+bo8bBxd0Wq6+JiHLWF9TSEWzAP//AG//7ASHBFICBgBYAAD//wBv/+wErgYnAiYAWAAAAQYCNh8AAAq0AR0dESYAKxE1AAEALwAABIsEUgAKABlACwUKAgIHAAgPBAcVAD8zPzMSOREzMzEwASEBASEBAyMTMwMDdQEW/f4BRv7y/sxy7OzpbgRS/dn91QIh/d8EUv30AAAB/7L/7gRiBGAAHAAcQA4BFRoERlkaEAwRRlkMFgA/KwAYPysAGD8xMCEjEyYjIgYGBw4CIyInNRYzMjY2Nz4DMzIXA3/sxSUhSF5RSldqimFAMyQoMUpFREljeKJznIsDmAhAltr7sVYUxQ9BhcTRtWcxKwAAAQApAAAFvARSABMAG0AMAAcNBwkQCg8TBAkVAD8zMz8zEjk5ETMxMAEGBgEjAyYnAyMTIRMXNjcBIQMjBKoCA/4wsGIMBbLX6wEpXxA9NgFkATnr2wNMAwf8vgKgTV/8tARS/VqwjlkCb/uuAAABAC8AAASqBFIACwAaQA0BCEdZAQEKAwsPBgoVAD8zPzMSOS8rMTABAyETMwMjEyEDIxMCBl4Bul/p6exk/khm7O4EUv5EAbz7rgHd/iMEUgD//wBe/+4ENwRkAgYAUgAA//8ALwAABEoEZgIGAFEAAP///8n+FARQBGYCBgBTAAD//wBe/+wDzQRmAgYARgAA//8ALwAABq4EZgIGAFAAAP///1b+FARSBFICBgBcAAAAAwBe/hQFWAYUABMAGwAjACtAFhIACRsjGBEYR1kAERAcFwoXR1kHChYAPzMrEQAzGD8zKxEAMxg/PzEwARYWFRQCBAcDIxMmJjU0EiQ3EzMBFBYXEw4CAT4CNTQmJwPBxNOk/ty/ZN5nwtakASPAXd39L25hoW+kXQGsbaNebmAEXhrzwr7+0KgL/iYB3hf1xbwBMKcIAbb7u3+XCwL2B3bZ/mAKd9qAfI4N////qgAABFQEUgIGAFsAAAABAG3+eQSHBFIAIQAhQBAZGwkhDxQiEAUbBUZZFRsVAD8zKxEAMxg/PzMSOTEwAQMGFRQzMjY3EzMDBhUUFjMyNwMjEyYmJyMGIyImNTQ3EwH6kBB/cMUtY+miDCQiITN94lk7OgYGk9KGlBqHBFL9Xkw1hf/UAdX9ADoiIiYO/b0BfxVhUNKYjkR9An8AAQCgAAAEaARSABoAH0APEg0aFAZGWRQUDQoaDw0VAD8/MxI5LysREgA5MTABAwYVFBYzMjY3NzMDIxM2NjcjBiMiJjU0NzcB2zsTSj16pDIb6evsQAwhDAiHv4uRGjYEUv7rVjVHQtXdd/uuATE8czCmnJBPdfgAAQBt/+wG7ARSACcAJ0ATDRQUDCcJHQ8MFQUjFyNGWRAXFgA/MysRADMYPz8zMxI5ETMxMAEDBhUUMzI2NxMzAyM3IwYjIiYnIwYGIyImNTQ3EzMDBhUUMzI2NxMEc5AQdW65L2Ls7LgUCJTMcn0PCEu/Z4WLFovskBJ5bLosZARS/WBQL4f81QHV+67N4X1udHeZi0B1Ao39YForgfnMAeEAAQBt/nkG7ARSADIAK0AVGR8fIjIKKA8VIgYRLiIuRlkbFiIVAD8zMysRADMzGD8/MzMSOREzMTABAwYVFBYzMjY3EzMDBhUUFjMyNwMjEyYnIwYjIiYnIwYGIyImNTQ3EzMDBhUUMzI2NxMEc5AQNz5uuS9i7KQLJiAkMH3hWHMMBJPHcn0PCEu+aIWLFovskBJ5a7wrZARS/V5MMURD/NUB1f0AOSMjJQ79vQF/KKHVfW50d5mLO3oCjf1eVS6B+M0B4QAAAgBY/+wElgRSABIAHgAtQBcACQICE0hZAgIJEREQR1kRDwkZSFkJFgA/KwAYPysREgA5GC8rERIAOTEwATYzMhYVFAYGIyImNTQ3EyE3IRMiBwYVFDMyNjU0JgJia3CktXHXlr28GVz+pCcCSC9PaBaqY3ZYAn8ZnYx0r2Col01vAbG6/ZUUaDKdZVdKRQAAAwB1/+wF5wRSAA8AHgAiAClAFQEJAwMQSFkDAwkhDw8gFQkZSFkJFgA/KwAYPz8zEjkvKxESADkxMAEDNjMyFhUUBiMiJjU0NxMBIgcOAxUUMzI2NTQmASMTMwH8ZH1VmKzz1Ly2FoUBC0hgBgkEApxdblYCjerq6wRS/i0ZnImz1KiXVmgCaf2VFB0rJB8Rm2dXTUD+GQRSAAIAdf/sA9kEUgAQAB0AJEASAAkCAhFIWQICCQ8PCRhIWQkWAD8rABg/EjkvKxESADkxMAE2MzIWFRQGBiMiJjU0NxMzEyIHBgYVFDMyNjU0JgGWb3ips3TbmMK7FoXsPVtrDgmyanhbAn8ZnYxzr2GpmFhiAmv9lRRDNCOdZVdKRQABABn/7ANiBGYAGwA0QB8SEUhZDBIcEjwSTBIEEAMSEgcAABZGWQAQBw1GWQcWAD8rABg/KxESADkYL19eXSsxMAEyFhUUAgQjIiYnNRYzMjY3ITchNTQjIgYHJzYBycXUiv74t0+HKoZ4fKsg/lYjAZ7RPmw3Qp8EZuXZ0f7CrR0Wyj2VmrAh+iEYrksAAgAv/+4GFwRkABQAIgAqQBcOCUdZDg4LDA8LFRIVRlkSEAQcRlkEFgA/KwAYPysAGD8/EjkvKzEwARQCBiMiJjU3IwMjEzMDMzYkMzIWJSIGBhUUFjMyNjY1NCYGF4j1or7UAudm7O7pXt09AQu6vdP+ZFSGUVpeUIVMXQK0yv63s+PFR/4jBFL+RN3x5SOH/opqe4n0k252AAL/3//wBDsEUgAbACQALkAYEgAiIgBIWSIiFxoVFxxIWRcPBwxGWQcWAD8rABg/KwAYPxI5LysREgA5MTABIgYHDgIjIic1FjMyNjc2NjcmNTQ2MyEDIxMDIgYVFBYzMxMCYD9ZJEtVaUlHLCQcLD4lMlY0rvPUAbjp6l1SXm1hU41EAahCSJJqMhK/DTZJXlIRO7iow/uuAagB9mBVS0YBRgD//wBe/+wD+gXsAiYASAAAAQYAatYAAAy1AwI5OREmACsRNTUAAQAv/hQEPwYUACkAUkAxBiMJAyUmJUlZACYmCSgJHkZZrwm/Ce8J/wkEAAkQCSAJAwkDCQkjKAAjFRIXRlkSGwA/KwAYPz8SOS9fXl1dKxESADkYLzMrEQAzERI5MTABIQchBwYHMzYzMhYVFAcDBgYjIic1FjMyNxM2NTQjIgYHAyMBIzczNzMCPwFEI/6/ERUyCJXDiJAWnia1k142OzqBJ5wSf3DDLVrsAQKbJJol6wVmo0pwmsadkExg/Rm3qhfBF7wC3k8wh/rZ/l4Ew6OuAP//ACX/7APrBiECJgHNAAABBgB2BgAACrQBLCwRJgArETUAAQBe/+wDzQRmABwAJkAUDxJIWQ8PAAcHDEZZBxAAF0ZZABYAPysAGD8rERIAORgvKzEwBSImNTQSJDMyFwcmIyIGByEHIQcVFBYzMjY3FQYB+sXXlgEFq6SFRnpjcKQnAaMm/mICamk6eFqMFNbFzwFatj24NZeEsCQman0fLcNH//8ADv/sA3EEZgIGAFYAAP//AC8AAAJWBfoCBgBMAAD//wAvAAAC+wXsAiYA8wAAAQcAav7kAAAADLUCARkZESYAKxE1Nf///vr+FAJWBfoCBgBNAAAAAv+y/+wGCARgACkANQA3QB0ACQICKkhZAgIZJycRRlknEBkeRlkZFgkwSFkJFgA/KwAYPysAGD8rERIAORgvKxESADkxMAE2MzIWFRQGBiMiJjU0NxMmIyIGBgcOAiMiJzUWMzI2Njc+AzMyFxMiBwYVFDMyNjU0JgPVgFujtXHXlb28GVwhFD1SSE5RaoxjPjMiKjBJQUZMXHCWYqOAN05oFqpjdlkCfxmcjXSvYKiXTW8BswY8i+n2s1kUxQ89fdDgrGMvLf20FGgynWVXSkUAAgA1/+wGOwRSABcAIwA0QBwACQICGEhZFA9HWRQUEgICERYSDxEVCR5IWQkWAD8rABg/PzMSOS8ROS8rKxESADkxMAE2MzIWFRQGBiMiJjU0NyEDIxMzAyETMxMiBwYVFDMyNjU0JgQIg1ijtXHXlb28F/6LZuzu6V4Bd17qL09oFqpjdlgCfxmcjXSvYKiXP3P+IwRS/kQBvP2VFGgynWVXSkUA//8ALwAABD8GFAIGAOkAAP//AC8AAASLBiECJgHUAAABBgB2ZAAACrQBExMRJgArETX///9W/hQEUgYnAiYAXAAAAQYCNq0AAAq0ARsbESYAKxE1AAIAbf4UBIcEUgAEABwAKEAUEhYcAAADFg4cDwMbERUWCkZZFhYAPysAGD8/PzMREjkvERI5MTAFMwMjExMDBhUUMzI2NxMzAyM3IwYGIyImNTQ3EwIzLV7hUImQEH9wxS1j6em5FQhSsmeGlBqHOf5NAWcE1/1eTDWF/9QB1fuuzXRtmI5EfQJ/AAEARgAABLwG5QAHABZACgEHBhIHBExZBwMAPysAGD8QxjEwARMzAyEBIwEDokHZav3p/vbrATUFtgEv/gT7FwW2AAEALwAAA+wFiwAHABZACgYEAxUEAUdZBA8APysAGD8QxjEwASEDIxMhEzMDgf5cwuzsAaxD4gOY/GgEUgE5AP//AMsAAAe0B3MCJgA6AAABBwBDARIBUgAKtAEeHgUmACsRNf//AHkAAAZeBiECJgBaAAABBgBDRgAACrQBHR0RJgArETX//wDLAAAHtAdzAiYAOgAAAQcAdgHbAVIACrQBJSUFJgArETX//wB5AAAGXgYhAiYAWgAAAQcAdgEUAAAACrQBJCQRJgArETX//wDLAAAHtAc+AiYAOgAAAQcAagF1AVIADLUCATIyBSYAKxE1Nf//AHkAAAZeBewCJgBaAAABBwBqAJwAAAAMtQIBMTERJgArETU1//8AugAABQAHcwImADwAAAEHAEP/mwFSAAq0AQoKBSYAKxE1////Vv4UBFIGIQImAFwAAAEHAEP/LAAAAAq0ARkZESYAKxE1AAEALwHFA6AChwADAAixAAEALzMxMBM3IQcvKwNGKwHFwsIAAAEALwHFB3cChwADAAixAAEALzMxMBM3IQcvKwcdKwHFwsIA//8ALwHFB3cChwIGAgMAAP///yz+MgKy/9MAJwBC/+j/dgAHAEIAHwCLAAEAdwPBAjEFtgAHAAmyAAQDAD/NMTATJzYSNzMCB30GIpFXsHpNA8EWTAEKif7i1wAAAQBzA8ECLwW2AAgACbIFCAMAP84xMAEXBgIHIzYSNwInCCWTUrIrfh0FthZT/vN/XwFAVgAAAf+a/vgBVgDuAAYACLEEAAAvzTEwJRcGByM2EwFOCGyesmlf7hfp9u4BCAABAOEDwQHVBbYACAAJsgQIAwA/zTEwAQcUFyMmAic3AckBDaQZLgkPBbZv2qxaAQl8FgAAAgB3A8EDyQW2AAYADgANtAAHAwsDAD8zzTIxMAEnNhMzAgchJzYSNzMCBwIXCVS3sHpN/XsGIpFXsHpNA8EWvgEh/uLXFkwBCon+4tcAAgBzA8EDxwW2AAgAEAANtA0FEAgDAD8zzjIxMAEXBgIHIzYSNyEXBgMjNhI3AicIJZNSsit+HQKFCWKrsDN0IAW2FlP+839fAUBWFtz+/XIBJl0AAv+a/vgC7gDuAAYADQAMswsEDQAALzLNMjEwJRcGByM2EyEXBgMjEjcBTghsnrJpXwKDCVyvsHhP7hfp9u4BCBfO/u8BGd0AAQDLAAAD7AYUAAsAJ0ASAAUFCwYGBwEEBAoHBwgDEggAAD8/EjkvMzMRMxE5ETMzETMxMAElAyMBBTcFEzMDJQPB/sae9QEI/s8rASci9o8BRgPBHvwhA98e0B4Bof5fHgABAEQAAAQEBhQAFQBFQCEUCwsRDgEIAggHAAkJAwcFBhMMDBINDQ8OBg4GBQ8ABRIAPz8SOTkvLxI5ETMzETMREjkzMxEzETMzETMRMzMRMzEwASUHJQMjEwU3BRM3BTcFEzMDJQclBwIzAUYt/sYa9oX+vS0BNwpg/r0tATcb9oYBRi3+yQgCCh/PHf6JAXcdzx8BCPYf0R4BeP6IHtEf9gABAJgBzQKkBAgACwAIsQkDAC8vMTATNDYzMhYVFAYjIiaYp4xkdaSRZnECrJzAbXKcwHP//wEl/+MEbwEUACcAEQMhAAAAJwARAjEAAAAHABEBBAAAAAcAjf/sCQQFywALABkAHQApADcAQwBRADNAGR44ODVPBhBPEE8QHB0DHBIAFwckPj4uSBMAPzMzETM/Mz8/Ejk5Ly8RMxEzMxEzMTABIgYGFRQzMjY2NTQXFAIGIyImNTQSNjMyFiUBIwEBIgYGFRQzMjY2NTQXFAIGIyImNTQSNjMyFgUiBgYVFDMyNjY1NBcUAgYjIiY1NBI2MzIWAhI3WDVQNFc7wW+2c3yEarN3f4UCwvvDwwQ+Ass1VjpSNlg5wG+zc3+GarR2f4f8LTRXOVE0WDvBb7Zxf4Vqs3Z/iAUjeuBnh3TrZoOBoP7Nmp6VpgEnlpiD+koFtv0lcuBwhnroY4N/of7LmpmSrAEplZYQc+NshnXoaIN/of7LmpmSqwEqlZb//wDVA6YCBAW2AgYACgAA//8A1QOmA30FtgIGAAUAAAABAFAAZAJiA+MABgAIsQUBAC/EMTATARcBEwcDUAGLh/7gmbLZAj0Bpnb+sv6RTAHBAAEACgBcAh0D2wAGAAixAQUAL8QxMAEBJwEDNxMCHf50hwEhmrPZAgL+WncBTgFuTP5AAP//////5QR3BbYAJwAEAh8AAAAGAATeAAAB/gIAAAMCBbYAAwAKswMDAhIAPz8xMAEBIwEDAvvFxQQ9Bbb6SgW2AAABAJYDDgM5BccAFQAVQAkNDwAKCwMFDwQAPzM/zTIRMzEwARM2NTQjIgYHAyMTMwc2MzIWFRQHAwIxVgxHRncaPqGRhxBkh1RcEFIDDgGIOh5NnXn+6QKqg5JfWDY+/nIAAAEAFwAABLAFtgARADFAGQ4RTlkODgUKAwcIB1BZAAgIBQoKDU5ZCgYAPysREgA5GC8zKxEAMxESORgvKzEwASEHIQMjEyM3MxMhByEDIQchAbwBER/+7jjnN50gnt0C/iv97F8B9C3+DgGgmv76AQaaBBbN/kzLAAH/8AAABLgFywAkAE9AKxEjJCNQWQ4kDyQfJAIJAxUfIB9QWRIgJCAkIBoEBApNWQQHGxcaF05ZGhgAPysRADMYPysREgA5ORgvLxEzKxEAM19eXREzKxEAMzEwATc2NjMyFwcmJiMiBgcHIQchByEHIQYHIQchNzY2NyM3MzcjNwFtHi/ivL6iWDiMPl5vFiMBTiH+sh4BTR7+sDmMArQt/DYkYXcgviHAHcUjA5OU28lWtx8rZWiomYucukrPwRmDdpyLmQAAAwA3/+wGMwW2AAcAEgAsADlAIB8nJCdQWQwATVkiJAwMJCIDDw4YDwdNWQ8GGBNPWRgZAD8rABg/KwAYPxIXOS8vLysrEQAzMTABMzI2NTQjIwUUACEjAyMBITIWEzI3FQYjIiY1NDcTIz8CMwczByMDBhUUFgG6Kay56DsCDv6//t9CdOQBOAEG2Ob8N1BWcHR6F0WDE6FvizHbI9tMDCwC7KeSybv7/uv93QW2yfuzIaorcGc9XAFIXGDL3ar+pj4cJioAAQAz/+wE2QXLACcAU0AvBhwdHFBZAx0LFxgXUFkIGA8dHx0CCQAYcBgCCwMdGB0YEyEhAE1ZIQcTDk5ZExkAPysAGD8rERIAOTkYLy9fXl1eXREzKxEAMxEzKxEAMzEwASIGByEHIQYHIQchFBYzMjcVBiMiAjUjNzM2NyM3MxIAMzIWFwcmJgORdsFBAYMh/m4SCgFUIf7BeYd4ioGx2OSiIYsPDIkglFwBR9BYmVBmNmoFAq6omkNIm6GTPMs9AQT8m18smgEEARssN7QiLAAABACi//QFqAXDAAMAEAAbADMAJUASLhwcAxEODgIDBgIYKCMHFgcZAD8zPzM/PxI5LzMROS8zMTABASMBExQGIyImNTQ2NjMyFiUiBhUUMzI2NjU0JSImNTQ2NjMyFwcmIyIGBhUUMzI2NxUGBaj7wMYEQ8PDpnuJV6NtfIr+7k1kaTRNLfzbf4lerXJYYi1OQTxfNHkvRSVQBbb6SgW2++bC5o17fchvkw6we4lQik+L2Y99eslwJ38gT4dMkhgRhSkAAAIAZP/sA6QFyQAdACYAI0AQGiQkCxADEAMQFAAHGSAUBwA/Mz8zETk5Ly8RMzMRMzEwJTI2NzMGBiMiJjU1Bgc1NjcRNDYzMhYVFAIHERQWEzQjIgYVETY2An9ATQaSCZ+WnKlUaT5/npmBlLG+RG5YLixeVJZpZcK2wra7GxuaDygBy6Gjp5Gu/vpg/uVlZwP1qElf/pg3rQAEACkAAAd1BbYADgASACAALAA0QBsJAgYHIR4nFw8XHxcCHhceFw8NBwMBBhIQDxIAPzM/Mz8zEjk5Ly9dETMRMxESOTkxMCEjAQYHAyMBMwE3NjcTMwM3IQcTFAYGIyImNTQ2NjMyFiUiBgYVFDMyNjY1NAQK9v7NJySY1QE1+AExDyQXnNKBIwIRI6ZXoHB5jVikbXiM/vE1UC1lNk4uBHPttf0vBbb7llbWZQLZ+kqkpAK+dMVzjIN5yXSaDVaLSINRiU2FAAIAcQLlBckFtgAHABgAJkARFA0QCAgBFgoKEQ4HAwMOBAMAPzMzETMRMzMRM8Q5LzMyMjEwASMRIzUhFSMBAyMXESMRMxMTMxEjETcjAwHHksQCHMYCP7IGBI3XqrbNkgQGuALlAlJ/f/2uAhtz/lgC0f3qAhb9LwGief3l////2QAABY0FzQIGAXYAAAACAHX/3QSaBEgAFwAfABdACQ0fHxEIEQAcCAAvMy8yERI5LzMxMAUiJgI1NDY2MzIWEhUhERYWMzI2NxcGBhMRJiYjIgcRAoed8oN/+pmY9Yb8xDGmUoS1Ukhi2ZMyo1iteiOTAQWdof+Wjv79pf6cNUZogimbfAKLARU1QnX+6QD//wCD/+oGJAW2ACcCFwKBAAAAJgB7xAABBwJAAxD9swANtAQDAhoZAD81NTUxMAD//wBX/+oGiQXJACcCFwMAAAAAJwJAA3X9swEGAHXvAAALtAMCAQ8ZAD81NTUA//8AZP/qBocFtgAnAhcC9AAAACYCPfEAAQcCQANz/bMAC7QEAwIqGQA/NTU1AP//AIH/6gYiBbYAJwIXAn8AAAAnAkADDv2zAQYCP/UAAAu0AwIBDxkAPzU1NQAAAgBg/+wEXAXHABkAJQAoQBUNBAsXEEZZCyBHWQsLFwQEGkZZBBYAPysAGBDEOS8rKxESADkxMAEQAgQjIiY1NBI2MzIXNCYjIgYHNTY2MzISATISNyYmIyIGBhUUBFyp/uS4uMeP6pijWYV5O41BQaFO2+v9kn3DJhhrQFiKVQOg/vT+P+fLyqwBNp11ur8oKssiKP7s+/kBGu5DU3LZdt0AAv/JAAAEKQW4AAUADAAWQAoGBAADBAlMWQQSAD8rABg/EjkxMAEhEwchNwEGBwEhAyYCkQEHkR/7vxwDAiRK/nsCUE4PBbj60YmNBDpqkP0AAvajAAABANv+IwVYBbYABwAStwAEBQJMWQUDAD8rABgvMzEwAREhESMRIREEZP1r9AR9/iMGxPk8B5P4bQAAAQCe/iMFVAW2AAsAI0ARAQkAAAlMWQADBwQEB0xZBAMAPysREgA5GC8rERIAOTEwEzUBATUhFSEBASEVngJc/bQEZvzgAhj90QN3/iOLA28DEInK/TX8zcsAAQB1AncEHQMrAAMAC7QBAFJZAQAvKzEwEzUhFXUDqAJ3tLQAAQBi//IFGQa6AAgAFLcGAQMEBAgBCAAvLxI5LzMSOTEwBSMBIzUhEwEzAsGc/u+yATbbAfWxDgL3r/2RBZEAAAMAjQGHBU4EFwAUACAAKwAkQBEQGCQFBAgOJhUVAwghGxsSDgAvMzMRMy8zMxEzERIXOTEwARQGIyInBgYjIiY1NDYzMhc2MzIWATI2NyYmIyIGFRQWASIGBxYzMjY1NCYFTq6DtX86mVOLq6+Hs3h8s4qn/H84XjAtXzxEVFMCiDZhMV1tQ1VXAs2IvslaabWRjLjHwLL+0U9VUVFdR0haAUBNVaRdSUZaAAABABL+FAMvBhQAFgAOtQwHHAASAAA/Mz8zMTABIgYVERQGIyInNRYzMjURNDYzMhcVJgKoREu2sVhISj6Vsq5iPj4FUmBc+ve6vxvFHbwFC7e/HMUfAAIAbwF5BCsEMQAXAC8AU0AtGyoqJFJZACoQKgIJAypAJx4eGFJZHgYDEhIMUlkAEhASAgkDEkAPBgYAUlkGAC8rABgQxhrNX15dKwAQGMQQxCsAGBDGGs1fXl0rABAYxDEwASIGBzU2MzIWFxYWMzI2NxUGIyImJyYmAyIGBzU2MzIWFxYWMzI2NxUGIyImJyYmAVgzejxmk0BtXFFULDV9N2eTQ25VTFcwNn80ZZRCbFtGWjEzfzdmlER2TFdQA30+O79sGCcjFUE4vm8eJCAX/nVENb5tGyUeGUA5v24gISUTAAEAdQCaBB0FDAATACdAExIRAQ4CAQJSWQ0FBgVSWQoIAQYAL8YzMysRADMrEQAzETMzMTABIzUhNyE1IRMXBzMVIQchFSEDJwFe6QE9Z/5cAfiDpmXs/sJoAab+BoGkAa603bMBGkfTs920/uxFAAACAHUAAAQfBQYAAwAKABpADAcPBAEMAwQAAVJZAAAvKwAYL19eXcYxMDM1IRU3ATUBFQEBdQOoAvxYA6j9RwK5tLT4Aa55AefC/qj+0AACAHUAAAQdBQYAAwAKABpADAcPCgEMAwoAAVJZAAAvKwAYL19eXcYxMDM1IRUJAjUBFQF1A6j8WAK4/UgDqPxYtLQBvAEwAVjC/hl5/lIAAAIAgwAABGYFwQAFAAkAFEAKBwMIBgAJBgUCBQAvLxIXOTEwAQEjAQEzEwkCBGb+Pl7+PQHDXuf+6v7pARcC3/0hAt8C4v0eAdP+Lf4t////H/4UBQoGHwAmAEkAAAAHAEwCtAAA////H/4UBRgGHwAmAEkAAAAHAE8CtAAAAAEBTATZBI8GJwAPAA60CACADAMALzMazTIxMAEGBiMiJjU0NzMHFDMyNjcEjyfly7G7CM0ErGpvFAYnrqCLihwdNYVZYQAB/vz+FAIGBFIADAARtwgPAAVGWQAbAD8rABg/MTADIic1FjMyNwEzAQYGcV02PjeDJwEC6f74JrX+FBe+FLoEw/shtqkAAQH6BM0DYAYUAAgACrIDgAgALxrNMTABNjczFQYGByMB+lA53SGINocE55CdFEW5NQABAIv+OwHw/4MACAAKsgiAAwAvGs0xMBM2NzMVBgYHI4tXMN4dgEGH/lackRRBr0QAAAEB5QTZA0wGIQAIAAqyCIADAC8azTEwAQYHIzU2NjczA0xhKN4ff0CJBga1eBU+sUQAAgB7AjUDEAXLAAoAGAAOtQAWHwYPIQA/Mz8zMTABIgYGFRQzMhI1NBcUAgYjIiY1NBI2MzIWAfwzWDpWWW68YrZ5fIhmsnOCiAUncdlzkwEerYWJsf7mnp6VrwEikpgAAgBGAkoDBAW8AAoAEAAlQBQNBwEFCQUGAw8QHxACEBADBx4DIAA/PxI5L10XMxEzETMxMAEjByM3ITcBMwMzITc3BgcHAud6J7cn/pAaAd3FeXv+zzQiIEK7AvqwsIkCOf3N3YEzUNsAAAEAcwI5AxsFtgAaABdAChEAAAYYFR4LBiEAPzM/MxI5LzMxMAEyFhUUBiMiJzUWMzI2NTQmIyIHJxMhByEHNgHZcYfOq4lcbnNlZFJCOks/eAHeIf6yNywEdYNtlrY0nUNgTD8+FTcBpJm1DQAAAgB/AjcDGwXFABgAJQAfQBAYHwACEAICAgIJFRAfGQkhAD8zPzMSOS9dMzkxMAE2MzIWFRQGBiMiJjU0EjYzMhcHJiMiBgcTMjY1NCYjIgYGFRQWAUpIeGV0VZtig4+J55xSPiU4T3eVH1ZDWDUzKUgvOQQlWn1qY6NbmZKuASiNE5UUkXv+omtVOD0lRUQ9SgABAJMCSgNMBbYABgAMtAAgAgMeAD8zPzEwEwEhNyEHAZMB0f5zHwJWGf4vAkoC15V7/Q8AAwBqAjcDFAXJABUAHwArABhADCYQBRYECyAAHxsLIQA/Mz8yERc5MTABMhYVFAcWFhUUBiMiJjU0NyYmNTQ2EwYVFBYzMjY1NAMiBhUUFhc2NjU0JgIOeI7EP0y7m4KZ5Dk0pzKbQTk6Ths2PTAgRjsxBcltYKJDJ2FLepN8ZrNPJ1s8aYf+AjVvMjlFOloBrz8uLTgWHEYuJTMAAgBzAjsDCAXHABYAIgAhQBEACR0PAx8DAgMDEBcJHxUQIQA/Mz8zEjkvXTMSOTEwAQYGIyImNTQ2MzIWFRQCBiMiJzUWMzIDIgYVFBYzMjY1NCYCRiNrO2V0u5eDj4jqmlI3RE/2DkVXNzNKVjoD2yczfWqYx5eOtf7ekBGbGgJsbVM2PV9PPEkAFgBU/oEHwQXuAAUACwARABcAGwAfACMAJwArAC8AMwA3ADsAPwBDAEcAUwBbAGsAdAB8AIkAokAhT4UBKkIpQUY+AUU9JjIlMQ8VDX1rS4B2ggNWVktwSwFLuP/AQDoLDkh1bE9sAXRaWlxRT1EBCgANS2yFUQAAUYVsSw0GARkdLRMEDw8SGBwsBAwgNDgGBAQEByE1OQQBAC8XMzMRFzMvFzMzERczEhc5Ly8vLy8vETNdETMzETNxETMrXREzERczETMzETMQxDLEMsQyEMYyxjLGMl0xMBMRIRUjFSU1IREjNQERMxUzFSE1MzUzESE1IRUhNSEVATUhFQEjETMRIxEzATUhFQEjETMBNSEVMzUhFQEjETM1IxEzASMRMwUUBiMiJjU0NjMyFgUUMzI1NCMiJTMyFhUUBgcVFhYVFAYjIxMzMjY1NCYjIxUVMzI2NTQjASInNRYzMjURMxEUBlQBL8AFzgEwbfkAb8AFDsNt/UkBEfvhAQ7+8gEOBLdtbW1t+8IBEPwwb28CwAEQdwER+qhvb29vBv5tbfufh39/h4d/foj+c4eHh4cB4axtcC4sOzBtXs97Qi4kKi87SjElWgFeNBwrGVZ9aQS+ATBvwcFv/tDB+QIBL8JtbcL+0W1tbW0G/m9v+qgBDgICAQ/6O21tAaYBDgRKb29vb/wvARB5AQ/9aAEQSZGcnJGSm5qTxcXEYUNTMUQIBA1EOFFZAWIiICId45orJUr++gpmCFYBkv5yX2MAAAMAVP7BB6oGFAADAB4AKgAdQA0oHhQOHiIODiIeAwIAAC8vFzkvLy8RMxEzMTAJAwU1NDY3NjY1NCYjIgYHFzYzMhYVFAYHBgYVFQMUFjMyNjU0JiMiBgP+A6z8VPxWA+ssQWdJu6VPukdSoFo/PjFIVDsbR0ZCSUhDSEUGFPxW/FcDqfsvMkExUn5Yh5o4KrJQOi81SzZEcEo7/u0/SEk+QElIAP///vz+FANFBiECJgI3AAABBwFM/tgAAAAKtAEYGBEmACsRNf//AHMDwQIvBbYCBgIHAAAAAgBS/+wFOQYpAC4AOQBAQCMsMgAhITJIWRQOR1kAFAESAyEUIRQEJyc3R1knAQQeR1kEFgA/KwAYPysREgA5ORgvL19eXSsrEQAzETMxMAECAgQjIiY1ND4CNTQjIgYHNzYzMhYVFA4CFRQzMhITJiQ1NDYzMhIVFAczBwEUFhc2NTQmIyIGBI0qu/70qqW6Gh4aNxQ2EgRhW1hjGyAbj4/SO/n+7dyzvMkEkyf9a5qhBlVOS1MDJf71/oi2mIQwXVdRIzoQC64nXlI3ZF1ZLIEBRQE4B82zrtH++fM2IrIBjWxtAihDl5pnAAABALoAAAUSBcMAEgAfQA8NEAAADxEDDxIECUtZBAQAPysAGD8/EjkRMzMxMAE2EjYzMhcHJiMiBgIDAyMTAzMCRHfVm2JIPS0oFTFk4KRy7nfs8AMZ4QFReBe2Cmj+oP7j/eUCKQONAAIAZP/sBxkEUgAWACsALUAWFAkjIwAJDBoHCQdHWQkPAB9HWRIAFgA/MisAGD8rEQAzMxESORgvETkxMAUiJjU0EjchNzchByMWFRQCBiMiJwYGATQnIQIVFBYzMjY3NzMHBhUUMzISAfCYpmFe/vMVxAXcJ/AXg9+QzjI2lALYDv0ptj8+TGIcI98eE3N4mBTCtoQBKIhqULpkfsP+rLPCW2cC815b/sz8XGSDgaCSTDmNAUn//wBEAAAG5Qd1AiYAMAAAAQcAdgG+AVQACrQBHBwFJgArETX//wAvAAAGrgYhAiYAUAAAAQcAdgGyAAAACrQBLy8RJgArETX///+H/cEETgW4AiYAJAAAAAcCWwE7AAD//wBe/cEEfwRmAiYARAAAAAcCWwE3AAD///8y/+wF/AXNACYAMm8AAAcCXP5lAAAAAv+q/cEBg/+DAAsAFwATQAkVAw8PCR8JAgkAL3EzzDIxMAEUBiMiJjU0NjMyFgc0JiMiBhUUFjMyNgGDgW9sfX9qaIiHOi8uPDY0Lzr+pGR/emdnenpnMTc3MTI5OQAAAgDNBGIDVgXHAAcAGAAPtRYHwAoCAwA/xhrcxDEwATY3MxUGByMlNCUHBgYVFB4CFRQGIyImAeNVP990kG/+6gElCUJHGBwYNzE1QgSFnZQYoJRpujpQEywfDxISGRclLzsAAAP/H/4UB6wGHwA5AD0ASQBLQCdHQEFBGA88DzsVCCk2GDZIWQsmGA8yBQAFRlktABsiFA8URlkdDwAAPzMrEQAzGD8zKxEAMxg/MzMrEQAzMxg/PxESOS8azTEwAyInNRYzMjcTIz8CNjYzMhcHJiMiBgcHITc2NjMyFwcmIyIGBwczByMDBgYjIic1FjMyNxMhAwYGASMTMwM0NjMyFhUUBiMiJkxaO0AyhSzZsxXCFSy1pnNgPUo+RVMWEgG2Fyyyp3VgPko9R1EWEuUn498rtZFfNjw2iCjX/krfKLYGKurs6bpORTZBT0IzRv4UF74UzQP+akxcxqcrsBxWYlZgxagrsBxWYlay++PArxe+FM0D/vvjvbIB7ARSARBEVDU2R1I0AAL/H/4UB7oGHwA5AD0AP0AhPAA7FSIUDxRGWR0PAAkpNhg2SFkLJhgPMgUABUZZLQAbAD8yKxEAMxg/MzMrEQAzMxg/MysRADMYPz8xMAMiJzUWMzI3EyM/AjY2MzIXByYjIgYHByE3NjYzMhcHJiMiBgcHMwcjAwYGIyInNRYzMjcTIQMGBgEjATNMWjtAMoUs2bMVwhUstaZzYD1KPkVTFhIBthcssqd1YD5KPUdRFhLlJ+PfK7WRXzY8Nogo1/5K3yi2BirsAUzp/hQXvhTNA/5qTFzGpyuwHFZiVmDFqCuwHFZiVrL748CvF74UzQP+++O9sgHsBhQAAAIAh//sBtUGFAAWACQAIkARFQ0ECwsXTFkQCwQEHkxZBBMAPysAGD/GKxESADk5MTABEAIEIyAAERASJDMgFzY2NzMXBgYHFiUiBgIVFBYzMjYSNTQmBY2+/rPc/v3+5MUBVtkBLopITQ/2CCmxjiD924rgf6OSit17ngOa/un+TOMBKwEIAQsBuerVJY1qGJi7OGb1wP6ryq28vwFTzqq+AAIAXv/uBY8E+gAWACQAIkARCgIQABAhRlkQFgAaRlkFABAAP8YrABg/KxESADk5MTABMhc2NjczFwYGBxYVFAIGIyImNTQSJAE0JiMiBgYVFBYzMjY2ApjbbkdYGO8IKKudGJL/psDijwECAVtiW12TUWNhWpBQBGSRHIiDF525OUdZyv61seXFxwFMuf5aa3mP9Ytvdoj1AAABAJj/7AcjBhQAHQAgQA8EEwkBAQ0dEwMNGUxZDRMAPysAGD8zEjkvMxDGMTABBzY2NzMXBgYHAwIAIyImNTQ3EzMDBhUUMzI2NxMFiylUXBP0Ci/4uoE5/tH52u4Uwe3AFfCTqiXHBbbAF4x7GLDZF/2e/vP+/9jFSGADhfx1Wjngp68DqAAAAQBt/+wGLwT6ACAALkAXDiAXGiALE0pZCwsVCSAPFRUaBUZZGhYAPysAGD8/MxI5LysREgA5GBDGMTABAwYVFDMyNjcTMwc2NjczFwYGBwMjNyMGBiMiJjU0NxMB+pAQf3DFLWPpGFBfFfQILPi9sLkVCFKyZ4aUGocEUv1eTDGJ/9QB1XcTiIQZrtgZ/L7NdG2Zj0J9An8A///9DgTZ/ocGIQAHAEP68QAA///9zATZ/7UGIQAHAHb70AAA///8mwTX/60F9gAHAVL7VQAAAAH9sAS8/zMGmAARAAqyCg8EAC/MMjEwAxQHByM3NjY1NCMiBzU2MzIWzcsWkRJbS1opRj1VcYAF7KA1W6YQNis9DoMTWQAB/If+ef2R/30ACwAIsQkDAC8zMTABNDYzMhYVFAYjIib8h05GNkBPQjNG/uVEVDU2R1I0AP//AEYAAASDB3MCJgAoAAABBwBD//EBUgAKtAENDQUmACsRNf//AEYAAAXZB3MCJgGyAAABBwBDAH0BUgAKtAEREQUmACsRNf//AF7/7AP6BiECJgBIAAABBwBD/24AAAAKtAIlJREmACsRNf//AG//7ASHBiECJgBYAAABBgBDmwAACrQBGxsRJgArETUAAQCL/+wHqAXJADgAMUAYEBorKxMaACAaIExZBhoEMicTJ0xZDhMTAD8zKxEAMxg/MysRADMREjkYLxE5MTABIgYHJzYzMhYVFAICBiMiJwYGIyICNRASJDMyFwcmJiMiBgIVFBYzMjY3NzMHBhUUFjMyNhI1NCYF9jVbNViTrcDPbcH0nexZPqp40ue1AR7BsHVtKVg3cLh2cHNndRw17ikSUVB/x4dhBQAqILJh9ejE/nf+2Iu0YFQBEf0BDAHW7WGwHSvM/o7CnKyDe/bLVjVKVMYBmdCNjAABAGYAAAZKBFIAFgAcQA0LBgcUFQ4IAQ8TFQAVAD8/PzMzOREzMjIxMDMDMxMWFxcBAzMTFzYSEzMCAAcjAyMD7ojqPwwEAwEpLeU2EJC5Su5G/uXp5y0F8wRS/Y9oZEoB7wGY/WbjoAGNAVD+l/3u1wGm/loAAgCHAAAEiwYUABIAGwAvQBgOBgcGS1kLBw8bTFkHDwcPCQQEE0xZBBIAPysAGBDEOTkvLysRADMrEQAzMTABFAQhIRMhNyE3MwchByEHMzIWATMyNjU0JiMjBIv+vf7R/pXu/usrARMz7zUBTCn+tDVo4u39OmyxtnV5gQHl6/oEYsHx8cH+wv4nj4NjXAAAAgBM/+wEJQUnABgAJAA4QBwCCwQVEwQZSFkEBAsTARITEkdZFxMPCx9IWQsWAD8rABg/MysRADMREjkYLysAGBDGERI5MTABIQM2MzIWFRQGBiMiJjU0NxMjNzM3MwchAyIHBhUUMzI2NTQmAz3+4j5teae3dt6Ww7oZXOcn6S3qLQEe4VprFrBqeVgDmP7nGZuOc7FfqpdNbwGvutXV/ZUUaDKdZlZHSAABAEb/7AdWBcsAJQAxQBoGGB0YTFkDHR0aGwMaEiEATFkhBBILTFkSEwA/KwAYPysAGD8/EjkvMysRADMxMAEiBAchByEGFRQWMzI2NxUGBiMiABE0NyEDIwEzAyESACEyFwcmBc+r/vw7AkAp/b4IppZVo15es2r3/uoH/vuL7QE17X8BAFMBhgEN17BglgT+37/KLkesvSUfzSQfASQBDUA2/W0Ftv2qASUBRlzDUgAAAQAv/+wF0QRmACQAMUAaGgUKBUdZFwoKBwgPBxUOFEZZDhAAH0ZZABYAPysAGD8rABg/PxI5LzMrEQAzMTAFIiY1NyMDIxMzAzM2JDMyFwcmJiMiBgchByEGFRQWMzI2NxUGA/zE1gTlZuzu6V7fQAEcw6KJRjBrQmeiLAGeJ/5iBHFkOn1VjBTUx1b+IwRS/kTc9D24FCGPgbsfK216ISvDRwAC/4cAAASoBbgACwATACVAEhAFBgsDEwNLWRMTBQYDCQEFEgA/MzM/EjkvKxEAMxESOTEwISMTIwEjASETIwMjNycmJicGBgcCkduOVv6T+gNCAQLd41hUORAIEgEZPHYCk/1tBbj6SAKTw3sxsSw5etYAAAL/kwAAA/gEUgALABAAJUASDgoLBAgQCEhZEBALBgIKFQsPAD8/MzMSOS8rEQAzERI5MTABEyMDIwMjEyMBIwETJicGBwM7vd9EQlrXaUT+/PACiqEfDjdxBFL7rgHL/jUBy/41BFL+JcF2bMsAAgBGAAAGogW4ABMAGgAtQBcXCQoTAwcMB0xZGgwMCQ4KAwEFEQMJEgA/FzM/MxI5LzMrEQAzMxESOTEwISMTIwEjASEDIwEzAyEBIRMjAyM3JiYnBgYHBIvbjVb+lvwBef7Ai+kBNel/AYgBVgEE2+RYVDofCAQcQW4Ck/1tApP9bQW2/aoCWPpIApPD6mBBQIXGAAIALwAABcMEUgATABYAMEAZFQ4TCAQMEQxHWRYREQ4TDw8CBgoDDhUTDwA/PxczPxESOS8zKxEAMzMREjkxMAETIwMjAyMTIwEjASEDIxMzAyEBEwMDBQa94EU8XtdrPP7y8gEZ/v5n3ezdXgFHAQaeJ5kEUvuuAd3+IwHd/iMB3f4jBFL+RAG8/kEBG/7lAAL/rAAABbwFtgAdACAAKEAUGBUZCh4ZAwUFBxcQABIHIExZBwMAPysAGD8zMxI5LxczETMzMTAjEz4CNwM3IQcBHgIXEyMDJiYjIwMjEyMiBgcDAQEhVOU9b5Bm7xwEXBz+OVtxOggd6xkHREsOifCMC1VpN80CZgFU/fIB7IGGTAsB4YuN/hsOV5WH/j0Bx3le/WICnl16/jkDZgGDAAAC/5YAAASyBFIAGgAdACpAFRMWBBZKWRsJBAQGFQ8AFQYdSFkGDwA/KwAYPzMzEjkvMzMrEQAzMTAjEzY2NwM3IQcBHgIXEyMDJiYnAyMTIgYHAwETIWq8SZ550xUDvhb+lUVWMA4r0yMJPEJm02pFWC2qAfj3/nMBb492EQFkaWn+mhFHcm/+tgFEV00E/hQB7EFX/qwClgEMAAACAEYAAAfDBbYAIQAkADNAGxkdBAkETFkPIgkJBgwHAxUbAAMGEgwkTFkMAwA/KwAYPxczPxESOS8zMysRADMzMTAhEzY3IQMjATMDIQM3IQcBHgISEyMDJiMjAyMTIyIGBwMBASEBsNVBPv66i+0BNe1/AkblHARdHf43XnA4EhPpFwmQDYvwjg1RZjrPAmQBVP3yAceKQv1tBbb9qgHLi43+GxNVlf7q/s8Bx9f9YgKeVn3+NQNmAYMAAAIALwAABoEEUgAgACMAM0AbHBkECQRHWQ8hCQkGDAcPFRsAAwYVDCNIWQwPAD8rABg/FzM/ERI5LzMzKxEAMzMxMCETNjchAyMTMwMhAzchBwEeAhcTIwMmJicDIxMiBgcDARMhAWS1LzH++mfd7N1eAd/LFQO+FP6TRVgxDSvTIwk9Q2bTakVWLaoB9fr+cwFcWif+IwRS/kQBU2lp/poSSHRr/rYBRFdNBP4UAew/W/6uApYBDAAB/7T+RARqBt0ASABNQCg6NEM4Dz4fPgIJAz40CiAgGgMnKCgnS1koKBpGNDQvS1k0BBoPS1kaAC8rABg/KxEAMxI5GC8rERIAORE5ETMYENRfXl3EMxI5MTABFAYHFRYWFRQEBQYGFRQzMjc2MzIXFSYjBwciJjU0NiU2NjU0JiMjNzMyNjU0JiMiByc2NyYnNTMWFz4CMzIXFSYjIgYHFhYEatC5iJ/+4v7Gomx9RF9fQ2tDQXOzu5WnzwEO2ainmrIppL7LbmOtuFq4uSZvj2otTlNTMTIoKBsiS1J9iQR/oM4ZBBKnh8vjHxExNE4FBSPGJgQEiXGamCIdgHZxYr6GelpaeaZ2GEqnGXQ+WUUkDoMIOmAeqQAB/6L+VgPVBVoARQBJQCcoPSBERUVESFk9RUU3CjctR1k3IhAKDRgTQAkMSBMKGwoKBUhZChAAPysRADMYENQrMsQROT8rERIAORgvOSsREgA5ETMxMAEyNjU0IyIHJzY3Jic1MxYXNjYzMhcVJiMiBgcWFRQGBxUWFhUUBgYHBgYVFDMyNjMyFxUmIwcHIiY1NDY3PgI1NCMjNwGylXqkfqlAj3EoXZBNSGR6QzEtHiYkTDrFh31dX23Q24NWfU6TSG85Q2Whq42euuGLeTzBoSQCmFBRdUquOw9NhBtSXnZMEIMKOEc4vmyRGwcYdlNvkVgdEjErTAonuicEBIFyg5MgFC1JOoOz//8AvAAABosFtgIGAXUAAP//AIP+FAXBBhICBgGVAAAAAwCH/+wFjQXNAA0AFgAfACZAFBoSTFkaGgQLCxdMWQsEBA5MWQQTAD8rABg/KxESADkYLysxMAEQAgQjIAAREBIkMzIAATI2NyEGFRQWASIGByE2NTQmBY2+/rPc/v3+5MUBVtn7ARf9J5vzNf0MBqQBR5jwOALrBaEDmv7p/kzjASsBCAELAbnq/tb8FfPaLDirvgRI5csjJam/AAADAF7/7gQ3BGQADQAWAB4AJkAUGhJIWRoaBAsLF0ZZCxAEDkdZBBYAPysAGD8rERIAORgvKzEwARQCBiMiJjU0EiQzMhYBMjY3IQYVFBYTIgYHITU0JgQ3lP6jwOSPAQKpwd792WKcI/4bBGfeYpgmAd9hArzM/q6w5sTHAUy54/0po4wbLW94AvyZgjNxdwABALoAAAWRBcMAFwAZQAwXERIDERIHDEtZBwQAPysAGD8/EjkxMCU2NxM+AjMyFxUmIyIGBwEhAzMTFhUHAfwzSvRiaXxWQkUvMz1cQP34/vyQ6EoLAfqWnQIEy4g/F8ASZn/75wW2/IOaX0YAAAEAYgAABGIEWgAWABlADAQWAA8WFQwRR1kMDwA/KwAYPz8SOTEwEzMTFhczNjcTPgIzMhcVJiMiBgcBIWLqNwkFBzFJlD9cb0o+KiQjMD0d/mv+6wRS/bZuw4uYATWDcjYSsgxEO/zdAP//ALoAAAWRB3MCJgKAAAABBwN2BQ4BUgAMtQIBIiIFJgArETU1//8AYgAABGIGIQImAoEAAAEHA3YEZAAAAAy1AgEhIREmACsRNTX//wCH/hQKGQXNACYAMgAAAAcAXAXHAAD//wBe/hQIqARkACYAUgAAAAcAXARWAAAAAgCH/4MFvAYxABkALQAsQBYdGiwEBwoKLExZIiQmESZMWQoXFBEEAD8zMy8rEQAzMysRADMzETMzMTABFAIEBwYGIyImJyYCNTQSJDc2NjMyFhcWEgEyFhc2EhEQJwYjIicGAhUUFhc2Bbyd/tjIEUU7PD8CxNalASnCEUY8O0ACv9b9FS09C6zTxTFYYheq1WZjMQN38P558ho7NkM4KgEw7OcBivMbOTU/OCn+1Py0KSUvAXkBAgEcVEtSM/6K+5O/JUgAAgBe/5EEeQS0ABgALQA1QBspKx8hHBAWFhxGWRMWJysJAwMrRlkGAxYQAxUAPz8RMysRADMRMxEzKxEAMxEzMxEzMTABEAIHBgYjIiYnJiY1NBI2NzY2MzIWFxYWBzQmJwYGIyInBgIVFBYXNjMyFzYSBHn82xBCNzM7A5uvdNyREEE1MDgGm6vwNjoXPCpTFmh/Pz4vTEUhZnkCoP7z/pEsNTI5MB7ps6sBIr8aMCoxKyLoplF6GighRS7+/KldexVBPSoBAgADAIv/7AeoCGAAEgAjAFQAV0AXM0xMNj0kQz1DTFkSAgIhAAoQCgIJAwq4/8BAFREUSAoWChYHDSo9BE5JNklMWTE2EwA/MysRADMYPzPEMjk5Ly8rX15dOTMvMysRADMREjkYLzMxMAEHIyIuAiMiByM2NjMyHgIzARQGBzc2NTQmJyYmNTQzMhYTIgYHJzYzMhYVEAIEIyInBgYjIgI1EBIkMzIXByYmIyIGAhUQMzI2NxYzMjYSNTQmBnshIUx3ZlswXBuhFJd1PXFvc0H+7I2SCH0UESYVbD9PrDVbNViTrcDPwP7O18iBV6Nf0OKsASXDsHVtKVg3c7d05VaySHSxjc58YQfpnSMqI3CLiSUtJf76Xn4VVCM9ERAIESAXUUf93yogsmH16P7s/g/7eEI2ART6AQoB0fRhsB0rzv6Qwv64XVOw4QGMwo2MAAADAF7/7AYCBykAKQA8AE4Ab7kAQP/AQD0MEEg8LElZPDdAQAs0NzFJWa83vzcCN0AJDEg3TDQLAg8XHxcCCQMXFwQLHhALEEdZIwsQGRUEFUdZAAQWAD8zKxEAMxg/MysRADMREjkYL19eXTMQ1tTEK10rERIAORgvEMQrACsxMAUiJwYjIiY1NBI2MzIXByYjIgIVFDMyNxYzMhI1NCMiByc2MzIWFRQCBhMHIyIuAiMiByM2NjMyHgIzARQGBzc2NTQmJyYmNTQ2MzIWA+GaaHmPtcSJ6Jl6ZkxFRn2otnGDXn+QsYVCWTN4g5+nivT5ISFMd2ZbMFwboRSXdT5xb3JB/vCMkwh9FBEXJDg1P04UU1Pbz80BWKs9rC3+0ODyb28BOfjRK6o9ycTh/qOvBsidIioicYyJJSsl/vhdfxZUJD8REAgKGyAoLEkAAgCL/+wHqAcfAA0ARgBFQCIFAQwNCUAeIQcDCyg5OSEoDi4oLkxZFCgEQDUhNUxZHCETAD8zKxEAMxg/MysRADMREjkYLxDWMjISORrdzTk5MzEwAQcHIycjByMnIwcjJzcBIgYHJzYzMhYVFAICBiMiJwYGIyICNRASJDMyFwcmJiMiBgIVFBYzMjY3NzMHBhUUFjMyNhI1NCYGcw10MRuiRjEaokYxKwwCuzVbNViTrcDPbcH0nexZPqp40ue1AR7BsHVtKVg3cLh2cHNndRw17ikSUVB/x4dhBx82rGdnZ2esNv3hKiCyYfXoxP53/tiLtGBUARH9AQwB1u1hsB0rzP6Owpysg3v2y1Y1SlTGAZnQjYwAAAIAZgAABkoFxQANACQAOEAeIRUVIyMODwUJCQwBAw1ACQ1IDQcDCxwWDw8ZFA4VAD8zMz8zM9YyMs0rFzkRMxESOREzPzEwAQcHIycjByMnIwcjJzcBAzMTFhcXAQMzExc2EhMzAgAHIwMjAwUtCnUzGaFGMxmiRzIoCv74iOo/DAQDASkt5TYQkLlK7kb+5ennLQXzBcU2rGdnZ2esNvo7BFL9j2hkSgHvAZj9ZuOgAY0BUP6X/e7XAab+WgABAIf+FAUhBcsAFwAcQA4LGxMATFkTBAwHTFkMEwA/KwAYPysAGD8xMAEiBgIVFBYzMjcDIxMmAjUQEiQzMhcHJgOcnPOOqJxdaZXwZuX+0wFh4deuXpgE/rb+ps2uuSH9OQHaDAEo+wEGAcHnXMNSAAABAF7+FAPNBGYAFwAcQA4AGwgNRlkIEAEURlkBFgA/KwAYPysAGD8xMAETJiY1NBIkMzIXByYjIgYGFRQWMzI3AwFkaazDmQEGp6SFRnpjY6FacWRmYJf+FAHaCNS31QFatj24NY74k2h1Lf03AAEAb//6BH8FCgATABVADAAJEA0CEggMCA4EEgA/zRc5MTABBQclAycTJTcFEyU3BRMXAwUHJQJSAR1I/uO0gbT+5kUBH8f+40gBHLd/twEfSv7mAbCme6T+x0oBO6R7pAFapH2kATlJ/sSke6QAAQE/BIUESgXBABEADLMCAAsIAC8zMzIxMAEGIyImNTQ2MyE2MzIWFRQGBwIOG1ctMEVFAbQXWi4uQkUE4143JTtGXy4mPEwCAAABAVoE3wRcBfIAFgASthYVDwWAFQsALzMazDIRMzEwATI3NjYzMhYVFAcjNzU0IyIOAiMjNwGLeJNQbC9ndAaaAlYqZHqSVx0hBX07HxtpYiMlFBFMIysjngABAmoEzQNtBkQAEAAKsgPADgAvGswxMAE0NjMyFhUUBgcGFRQXFSYmAmpYRjMyIx0vanmFBaxFUy8lHSEMEyA1IVAVdQAAAQJoBM0DhQZEABAACrIOwAIALxrMMTABFAU1NjU0JicmJjU0NjMyFgOF/uOEFhEXIzg1P04FvMYpUiQ+ERAIChwgKCxKAAgAKf7BB8EFkQAMABoAKAA2AEQAUgBfAG0AkrEEC7j/wEAQCQ9ICwAUDSIwMBssJh4DNLj/wEAPCQ9INClaZ2dTYElCOgNQuP/AQA8JD0hQRT5MTDdFY15WA2u4/8BAGgkPSGtgD2ABKWBFRWApAwANQAkPSA0RGAcAAC8yLzPNKxEXOS8vL10QzSsXMhEzMxEzEM0rFzIRMzMRMxDNKxcyMzMRMxEzEM0rMjEwATIWFyMmJiMiBgcjNhMyFhcjJiYjIgYHIzY2ATIWFyMmJiMiBgcjNjYhMhYXIyYmIyIGByM2NgEyFhcjJiYjIgYHIzY2ITIWFyMmJiMiBgcjNjYBMhYXIyYmIyIGByM2ITIWFyMmJiMiBgcjNjYD6V1xB08FPEVOMgVLC8VccwZPBTxFTjIFSwVkAqtccwZQBTxETjIFTAVl++ZccwZQBTxETjIFTAVlBOhccwZQBTxETjIFTAVl++ZccwZQBTxETjIFTAVlBadccwZQBTxETjMFSwv61FxzBlAFPEROMgVMBWUFkWVdLCwpL8L58mZcLCwpL1lpARdmXS0rJzFaaWZdLSsnMVppA9tmXS0rJzFaaWZdLSsnMVpp/hhoWiwsKDDCZlwtKycxWmgAAAgAKf5/B30F0wAHAA8AFwAgACgAMAA3AD8AZ0BCbykBTxhfGG8YjxgEMCVwJQIwLkAuAjA0cDQCDyhPKI8oAy8xAS4xNCkVHCglGAUJcD0BPRUNgDkBOQUHEAcQFQUVAC8vEjk5Ly8QxF0yEMRdMhDExsTEEMTExsRdXV1dXV1dMTAFFwYGByM2NwE3FhYXFSYnASc2NjczBgcBJiYnNxcWFhclBwYGByc2NwMnJiYnNxYXJRcGByc3NgEHJiYnNRYXBDcLEUYkYTURAnMOR8hB3YH9UgsTSR9hNBICIR+CJmIRHFwf/BkCN7pTRbF4KxElYhBDe0wEJUWxeGICfPvcDkK/T92BIw5Cv0/dgQKuCxNJH2E1EQJ1DkfIQdyC+rgywzRiAizHULoQIlYgRG5YAt4CPdguRsZj00RuWGIQSv1xCxFGJGE1EQAAAgBG/m0F2Qd3ABMAIwAuQBgTEgQRDQANCExZDRILIyMPHAEcIBcGAAMAPzLeMsVdMj8/KxESADk5GD8xMAEzAgYHMwEhATMBIRMjEzY3JwEhAQYGIyImNTQ3MwcUMzI2NwF73bc0DQgDVAEd/vbv/uj+7fzGny8qB/yq/uIFPSbkzbG8CcwErGhvFwW2/KHcLQRo+xv9nAGTAvTonwL7gwd3raOLiRshNYZWZQAAAgBt/nsEsAYnABsAKwAwQBkSFRsrJB8oSlkkQB8KGw8PIhEVFQVGWRUWAD8rABg/Pz8z1hrNKxEAMxESOTEwAQMGFRQzMjY2NxMzAzMDIxMjNyMGIyImNTQ3EwEGBiMiJjU0NzMHFDMyNjcB+pAQf0iObh5j6cLO+ezRpBcJmsiFlSZ7A6In5cuxuwjNBaxocBYEUv1eTDWFctOOAdX8Zv3DAYW+0pePTasCSAHVrqCLihwdNYVXYwAAAgBGAAAEIQW2ABIAGwAzQBoOBgcGTFkLBwcECQ8bTFkPDwQJAwQTTFkEEgA/KwAYPxI5LysREgA5GC8zKxEAMzEwARQEISETIzczNzMHIQchBzMyFgEzMjY1NCYjIwQh/r3+0v6W55crlSXtJAEULf7uLWjl6P07bbC2dXiBAeXr+gREyqioyuDE/imPg2NcAAACAHn/7APdBhQAGAAkADlAHQQNBgMUFRRJWQAVFQ0XBhlIWQYGDRcADR9IWQ0WAD8rABg/EjkvKxESADkYLzMrEQAzERI5MTABIQchAzYzMhYVFAYGIyImNTQ3EyM3MzczAyIHBhUUMzI2NTQmAisBHSP+425teqW3dNqZusMWkJojmjPpIVltF7Jrd1cFKaT9+hmbjnOwYKGgWGICnqTr+9MUZTWdaFRHSAAAAgBGAAAElgW2AA4AGwA7QCASFQIFBAQUBAgUCgsID0xZAAgBCQMICAsKEgsbTFkLAwA/KwAYPxI5L19eXSsREgA5ETMREhc5MTABEAcXBycGIyMDIwEhMhYBMzI3JzcXNjU0JiMjBJb2Q5dMaYNuc+0BNQFO5ej9O15MLzuVPmJ2encEJf7Who5JnRj93QW2yf3/CoFHg06UbWQAAv/J/hQEUARmABcAJwA8QCAIEgsjIAkGBAgiIgASGw4VCwAAGEZZABATDwsfRlkLFgA/KwAYPz8rERIAOTkYPxE5ERIXORESOTEwATIWFRQCBxcHJwYjIicjBgcDIwEzBzM2FyIGAhUUFjM3JzcXNhI1NAMfj6KfhEKYRi0it1gICxhW6QFSuBUJnWNUomBXUSJBlTxGUQRmzrfW/odbjUiSCLCFZ/5kBj680MCm/vuGYWoEjUiBUAEBiskAAAEANQAABH0FtgANACRAEgYKCwpMWQMLCw0IEg0CTFkNAwA/KwAYPxI5LzMrEQAzMTABByEDIQchAyMTIzczEwR9K/3pXAE+K/7Cg+uDlCuUhwW2zf5OyP2RAm/IAn8AAAEAAAAAA6oEUgANACRAEgwCAwJIWQkDAwUAFQUIRlkFDwA/KwAYPxI5LzMrEQAzMTAzEyM3MxMhByEDIQchAy9ikSWRZQKPK/5cOwEKJ/74YAHFtAHZw/7qtP47AAABAEb+AASBBbYAHQAuQBgJBAsLAExZCwsFBBIFCExZBQMSF0xZEhwAPysAGD8rABg/EjkvKxESADkxMAEiBwMjASEHIQM2MzIAFRQCBCMiJzUWMzI2EjU0JgIvVyh/6wE1AwYr/eViQFjpAQyh/tbEoXN/gYDDa6YCXgr9rAW2zf4wEP7X/t/+oMMv0TWLAQGdr7sAAQAv/goDrgRSABwALkAYGBMaGg9GWRoaFBMVFBdGWRQPBAlGWQQbAD8rABg/KwAYPxI5LysREgA5MTAlFAIGIyInNRYzMhI1NCYjIgcDIxMhByEDNjMyFgOcjf6pg1ZibZuzbmM9K1js7AKTKf5WPU43rsu6z/7AoS/VOQEB2IOJEP5WBFLD/t4S9QAB/4/+bQdCBbYAFQArQBcDEwYQBAAAFQcEAQMSFRINIw8KTFkPEgA/KwAYPz8zPzMzEjkRFzMxMAEBMwETMwMBIQETMwMjEyMBAyMTASECG/6+9AE5lOWTAksBC/2N9MSB51ZU/sCX5pj9pv7tAwYCsP1MArT9TAK0/Sf97P2kAZMC1f0rAtP9LQAB/+P+ewdUBGYAOwBCQCMkKAUoSVkJBQUmBw8mFR0iEjcAN0ZZDQAQHisZMCswRlkrFgA/KxEAMxEzGD8zKxEAMxg/Pz8SOS8zKxEAMzEwATIWFRQHMxMzAzM2ADMyFwcmIyIGBhUUFjMyNwMjEyYmNTU3IwMjEyMGACMiJzcWMzI2NjU0JiMiBzU2ASutwAWoZd1mnzcBG8NTNiksMlqTWVhUTkx93VSQmwKqZdtlnjb+5MVEPSUwKl+WVVlROD1MBGbezBsmAdf+KeUBBg68CoP5kHV7Hf20AXcS1bohIf4rAdXj/voOvAyO9op1eRW/FgD//wAQ/i0EagXLAiYBsQAAAAcDfwGNAAD//wAK/i0DoARmAiYB0QAAAAcDfwFQAAAAAQBE/m0FVgW2AA4AJEASBgsODggMCQMIEgMjBQBMWQUSAD8rABg/Pz8zEjkRMzMxMCUzAyMTIwEDIwEzAwEhAQPf4n/qWHf+kpjvATXvlQJvART9b8n9pAGTAtH9LwW2/UYCuv0pAAABAC/+eQSDBFIADgAkQBIJDgICCwAMDwsVBiIIA0ZZCBUAPysAGD8/PzMSOREzMzEwASEBEzMDIxMjAQMjEzMDA3UBDv3+2dN921hs/sxy7OzpbgRS/dv+lv22AYcCIf3fBFL9+AABAEQAAAVkBbYAEgAqQBUFDAQNBA0CDwQJBgsSEggQCQMBCBIAPzM/MxI5ETMzERc5ERI5OTEwISEDByMTBwMjATMDNxMzBwEhAQQ1/wC2I4tSe3XvATXvlY1Iix8BOgEW/YEBpqwBi1r91QW2/UagAVKOAVb9RgABAEgAAASsBFIAEwAsQBYSBREGEQYPCAQCEwQLDAsBCQIPDgEVAD8zPzMSOTkRMzMRFzkREjk5MTAhIxMzAzcTMwc3IQEHASEDByMTJwEx6ensb2lDgx/kAQr+CAwBOf78niSFSz0EUv34bAFAkOz9+j798gEUugFeawAAAQBGAAAFbQW2ABMAMkAcAhATAwQFCg8HCAdMWQyvCL8IAggIBREKAwEFEgA/Mz8zEjkvXTMrEQAzERIXOTEwISEDBwMjEyM3MzczBzMHIwMBIQEEP/76/JV17eeLK4sj7SKhK6FKAoEBG/2RAo9i/dMETMufn8v+qALC/V4AAQAvAAAEhwYUABYALUAYBxYAFklZBAAAAg4KERIEFAwCAAwPEBQVAD8zPz8REhc5EjkvMysRADMxMBMzNzMHIQchAwYHMwEhAQEhAwcDIwEjupol6ycBGyX+6EIoKAYB6AEQ/h0BI/760YhN7AECmwVmrq6j/sSxfAH4/hv9kwHXYP6JBMMAAAEAsAAABf4FtgAMACNAEQIJDAwEBwoDAQQSBwZMWQcDAD8rABg/Mz8REjkRMzMxMCEhAQMjASE3IQMBIQEE7P7z/pKY7QEK/rorAjOTAm4BFf1sAtH9LwTpzf1GArr9KQAAAQBMAAAFLwRSAAwAI0ARBQwCAgcKAA8EBxUKCUdZCg8APysAGD8zPxESOREzMzEwASEBASEBAyMTITchAwQhAQ79/AFK/vj+zHTqw/6uJwI9bgRS/dv90wIh/d8DmLr9+AABAEb+bQWLBbYADwAlQBQMB0xZDAwFDgoDCRIDIwUATFkFEgA/KwAYPz8/MxI5LysxMCUzAyMTIxMhAyMBMwMhEzMEf9+B51bkjP3Ki+0BNe1/AjZ/7cn9pAGTApP9bQW2/aoCVgABAC/+eQSqBFIADwAlQBQBDEdZAQEKAw8PDhUIIgoFRlkKFQA/KwAYPz8/MxI5LysxMAEDIRMzAzMDIxMjEyEDIxMCBl4Bul/pwbl94VjHZP5IZuzuBFL+RAG8/HH9tgGHAd3+IwRSAAEARgAABssFtgANACRAEwkETFkJCQYLBwMCBhILAExZCwMAPysAGD8zPxESOS8rMTABASMTIQMjATMDIRMhBwVg/vbujP3Ki+0BNe1/AjZ/Ai0pBOn7FwKT/W0Ftv2qAlbNAAABAC8AAAYEBFIADQAkQBMBCkdZAQEMAw0PCAwVAwZHWQMPAD8rABg/Mz8REjkvKzEwAQMhEyEHIQMjEyEDIxMCBl4Bul8CQyn+qMLsZP5IZuzuBFL+RAG8uvxoAd3+IwRSAAEARv4AB3EFtgAfADBAGQgFCgodTFkKCgYBBRIGA0xZBgMRFkxZERwAPysAGD8rABg/MxI5LysREgA5MTAhIwEhASMBIQM2MzIAERQCBCMiJzUWMzI2NjU0JiMiBwQ77wEK/ef+9u0BNQP2kEBa5QERpP7WwKR0foR9xWynm1MuBOn7FwW2/WMQ/tr+/9/+nsExzzOP/5muvAoAAAEAL/4KBiUEUgAeADBAGQAcAgIURlkCAh0YHBUdGkdZHQ8JDkZZCRsAPysAGD8rABg/MxI5LysREgA5MTABNjMyFhUUAgYjIic1FjMyNjU0JiMiBwMjEyEDIxMhBCNOO67LjfyqgVhnZ5q0a2Q+Lljsw/5kwuzuA24CbRL10M/+wKEv1zn/2IKKEP5WA5j8aARSAAACAIf/rAV/Bc0AKwA1AEtAKywjAwwEDikpMUtZACkQKWApAwkDKSkOFQoFTFkKDkAVGkxZFQQOIUxZDhMAPysAGD8rABoYEMwrERIAORgvX15dKxESABc5MTABFAIHFjMyNxUGIyInBiMiABEQEiQzMhcHJiMiBgIVFBYzMzcmNTQSNjMyFgE2EjU0IyICFRQFf6uXJThBSj5mqGZad/7+48MBWdqEdEZTX5Hqg6CRFxJMcs+Ak57+JW6IW1F7AyHH/ptuEhrIG14eASoBCwEKAbTuL8Ejuf6xz63GAojCtwErp7j9MVEBNamc/uvIkgACAF7/vgR7BGYALAA3AFNAEy0DDCQEDioqMkhZACoQKgIRAyq4/8BAGgkMSCoqDhUKBUhZCg5AFRtHWRUQDiJHWQ4WAD8rABg/KwAaGBDMKxESADkYLytfXl0rERIAFzkxMAEUAgcWMzI3FQYjIicGIyImNTQSJDMyFhcHJiMiBgYVFBYzMzcmJjU0NjMyFgE2NjU0IyIGFRQWBHuFbR8pNz5CUoJrXXDB2ZMBA6oybiQ1QEtmmFhpXxsVGSXJpH2L/odKXkQ+TRYCSIr/AEMMFK4XUCLw1sUBRaoRDbUXevWRfIoCKH1LzPaS/h81xmZiom41Yf//AIf+LQUhBcsCJgAmAAAABwN/AjsAAP//AF7+LQPNBGYCJgBGAAAABwN/AZ4AAAABALD+bQTDBbYACwAgQBADIwsHCAdMWQgDBQBMWQUSAD8rABg/KxEAMxg/MTAlMwMjEyMBITchByECO9yB6FbhAQj+hS0D5iv+g8n9pAGTBOnNzQABAC/+eQbhBGYAMwA0QBsCAzExACQuFRUiHykAKUZZBgAQLw8WEUdZFhUAPysAGD8/MysRADMYPz8zEjkRMzMxMAEyFzM2NjMyFhUUBwMGFRQWMzI3AyMTJjU0NzY2JzQjIgYHAyMTNjU0IyIGBwMjEzMHMzYDJ9wiCEu/Z4WLFkoIIh0qMnvhWIkOMDIDd2y7K2XrjxF1brstYuzsuBUJlARm63R3m5A3df6oIiEiJBP9uAF/J589ON7sJIX4zf4fAqBSLYf+0/4rBFLN4QD//wC6AAAFAAW2AgYAPAAAAAEAZP4UBFAEUgANABC2DQcDCQ8HGwA/PzMSOTEwJTY3ATMBAyMTAzMTFhcBnjNWAS/6/ZVo8GmS6DcIDf6AnQI3+6z+FgHqBFT90U7XAAEAXAAABQAFtgAQACVAEgAJDwcLDAtMWQQMDAkBDwMJEgA/PzMSOS8zKxEAMxESOTEwAQEhAQchByEDIxMhNyE3AzMCRgGwAQr9kQgBJSv+3UHuQv7pKwEZCO7yAxkCnfxvIc3+yQE3zSUDjQAAAf/T/hQEUARSABMAIUAQEw0DDw8KGwgMDQxIWQUNFQA/MysRADMYPz8zEjkxMCU2NwEzASEHIQMjEyM3MwMzExYXAZwoYwEv+v2VAQsn/vVB8EL8J/qQ6DcFDvxlugI3+66y/sYBOrIEUv3RLvkAAAH/kf5tBSUFtgAPACBAEAYMCA0KAwgSAyMFAExZBRIAPysAGD8/PzMSOTkxMCUzAyMTIwMBIQEDMxMBIQEDxdeB6FZ5wP5K/vcCSvr2sgGSAQr92cn9pAGTAlD9sAMCArT95AIc/ToAAf/H/nsEcQRSAA8AIEAQAAYCBwQPAhUNIg8KRlkPFQA/KwAYPz8/MxI5OTEwAQEhAQMzEwEhARMzAyMTIwII/s3+8gHb6PaPAR8BE/4zos583FhuAYP+fQI5Ahn+iwF1/dv+lv24AYUAAAEAsP5tBlYFtgAPACdAFA0DAiMKBgcGTFkHAw8LBAtMWQQSAD8rEQAzGD8rEQAzGD8/MTAlAyMTIQEhNyEHIQMhATMBBgaB6Vb8LwEK/oUrA9kr/pLeAiEBCu7+9tH9nAGTBOfPz/vmBOn7GwAAAQBa/nkFFARSACYALkAXGhwkFSIAIyQjR1kKJA8RBRwFRlkWHBUAPzMrEQAzGD8zKxEAMxg/ERI5MTABAwYVFDMyNjY3EzMDBhUUFjMyNwMjEyYmJyMGIyImNTQ3EyE3IQcCXmgRfUqMcB9i66oIIx0oNHvjWjw9CASayYaSGGH+5ycDGycDmP4YUTCFcNWOAdX85SIhICYT/bgBfxVhUNKXi1ZtAce6ugABANf+bwVKBbYAGgApQBUEAw0HE0xZBwcDFw0DASMDGUxZAxIAPysAGD8/MxI5LysREgA5MTABIxMjEwYGIyImNTQ3EzMDBhUUMzI2NxMzATMEmupW4Xt2q1Clsw5z7m8Mpl6kWI/w/vPe/m8BkQJEMCabjj9AAiD98DAyiioiArD7EwABAKD+ewRoBFIAGgApQBUSEBoUBkZZFBQQCRoPDiIQC0ZZEBUAPysAGD8/MxI5LysREgA5MTABAwYVFBYzMhM3MwMzAyMTIxMjBiMiJjU0NxMB2z0TRj/yYhvpwLh94VjJewiTt4aUGDgEUv7fTDNCRwGyd/xx/bgBhQIUqp6OTW8BAAABANcAAAVKBbYAGwAyQBgBDBQUDAUFAAwDBhYTBhNMWQYGGQwDABIAPz8zOS8rEQAzETMREjkYLxE5LxE5MTAhEwYHAyMTIiY1NDcTMwMGFRQWFxMzAzY3EzMBAyV7fFdEjUGruwx17nEKS1BIjUVbeo/w/soCRDQS/sUBK5qRMj4CLf3kLiZERQMBUP69DzACsPpKAAABAKAAAARxBFIAHwAyQBgGBhQfGBgOHxYZCAUZBUZZGRkOCx8PDhUAPz8zEjkvKxEAMxEzERI5GC8ROTkvMTABBgYXFBcTMwc2EzczAyMTPgI3IwYHAyM3IiY1NDcTAdsoKwNpN4U3pk4a6uzrPwMMJQcIUmg3gzGQmRg4BFK/zBV3EAEE9kgBWHn7rgExETCQEmsm/v7pmo9LdAEAAAEARAAABLYFtgAWAB9ADwAUAwMPTFkDAxQVAwoUEgA/Mz8SOS8rERIAOTEwATY2MzIWFRQHAyMTNjU0IyIGBwMjATMB7n+nSqexDHXtcguoXqRWku8BNe8DcTQknZA0Pf3VAhsvJ4kqIv1SBbYAAQAvAAAD+gRSABgAH0APDwoSEgZHWRISCgsPAAoVAD8zPxI5LysREgA5MTAhEzY3NCYjIgMHIxMzBgYHMzYzMhYVFAcHAr4+CgZEQfddGOzs7SssIgmRtoeUNxkBIzFOQUj+SnUEUsvOeqifiljwdgAAAgBe/+wGJQXNACUALwAzQBobCikKTFkAKSApICkWAwMmTFkDBBYPTFkWEwA/KwAYPysREgA5ORgvLxEzKxEAMzEwARIAITIWFRQEISMGFRQWMzI2NxUGBiMiABE0NyYmNTQ3MwYVFDMBIgQHMyAkNTQmAZpRAYkBDcfd/l7+VGgFqZ9WsXxyzW38/ugIhZo+yC9UAuyi/vw5SQEuASJkA0oBKgFZvar17hs3vbwlMdEuIwEpAQofSwJ0aWxRTTxSAbTqyoaQTlAAAAIAMf/sBM0EZgAkAC4AM0AaBRsoG0hZESgKKAooABQUJUhZFBAAH0dZABYAPysAGD8rERIAOTkYLy8RMysRADMxMAUiJjU1NyQ1NDY3MwYVFBYzMzYAMzIWFRQEISMHFBYzMjY3FQYDIgYHMzI2NTQmAtHF3QL/ABsatysiKRE6ASvEpbH+sv7NKwRwcUiKZ6olYaclH7nWRhTgxSEfEscoWiI/RB8x4gEJkYW1zjxvfiUvu1EDxq+KamM2NgACAF7+bQYlBc0ACQAxADpAHi8cAxxMWRIDDAMMAycVKSMVAExZFQQqJychTFknEwA/KxEAMxg/KwAYPxESOTkvLxEzKxEAMzEwASIEBzMgJDU0JgE0NzMGFRQzMxIAITIWFRQEISMGFRQWMzI2NxUGBwMjEyYCNTQ3JiYEdaL+/DlJAS4BImT7kz7IL1QRVAGHAQzH3f5Y/khWBamfVrF8pbdQ7Va0yQiFmgT+6sqGkE5Q/mpsUU08UgEsAVe9qvnqGze9vCUx0UUK/n8BjycBHOAfSwJ0AAACADH+eQTNBGYACQAxADpAHiYUAxRIWQoDKwMrAx4NICINAEhZDRAhHh4YR1keFgA/KxEAMxg/KwAYPxESOTkvLxEzKxEAMzEwASIGBzMyNjU0JgE2ADMyFhUUBCEjBxQWMzI2NxUGBwMjEyYmNTU3JDU0NjczBhUUFjMDaGGnJR+51kb9qzoBK8Slsf6y/s0rBHBxSIpnjpBM4VOCjgL/ABsatysiKQOyr4pqYzY2/sniAQmRhbXOPG9+JS+7RAv+iwGFI86iIR8SxyhaIj9EHzEA////zwAAAz8FtgIGACwAAP///48AAAdCB3kCJgGwAAABBwI2AWIBUgAKtAEVFQUmACsRNf///+P/7AdUBicCJgHQAAABBwI2AWIAAAAKtAE/PxEmACsRNQABAEb+AAVYBbYAHAApQBUHAAoKAEtZCgoECAUDBBIRFkxZERwAPysAGD8/MxI5LysREgA5MTABIgcDIwEzAwEhARYSFRQCBCMiJzUWMzI2NjU0JgJYWVd17QE17ZUCbwEW/Y/P5qH+1sWedn2DgMNrqgJMG/3PBbb9RgK6/VQX/u3m3P6iwC/RNYn9nayyAAABAC/+CgSDBFIAGwApQBUbFAICFElZAgIYABkPGBUJDkZZCRsAPysAGD8/MxI5LysREgA5MTABIQEWFhUUAgYjIic1FjMyNjU0JiMiBwMjEzMDA3UBDv4hnaSF/q6FWmJtnLiFc0lGVuzs6W4EUv4CHOGxxf7RqC/VOfPYgZUY/mIEUv34AAH/wf5tBWQFtgAXACZAFAQjFwhMWRcDDBFMWQwTBgFMWQYSAD8rABg/KwAYPysAGD8xMAEBMwEhEyMBIQICBiMiJzUWMzI2NhISEwVk/vbu/un+7vzcAQ3+uIe5zrBRNDctRFhTao5GBbb7G/2cAZME5/34/d3TGckVP5ABMgHzAQwAAAH/sv55BHcEYAAgACZAFAMiHghGWR4QEBVGWRAWBQBHWQUVAD8rABg/KwAYPysAGD8xMCUzAyMTIxMmIyIGBgcOAiMiJzUWMzI2Njc+AzMyFwOm0fzqz83FJSFIXlFKV2qKYUAzJCgxSkVESWN4onOci7j9wQGHA5gIQJba+7FWFMUPQYXE0bVnMSsAAQBG/gAFiwW2ABUAJEATDwpMWQ8PDA0ABUxZABwRDQMMEgA/PzM/KxESADkYLysxMAEiJzUWMzI2NxMhAyMBMwMhEzMBAgAB9KN0ioCrwTJv/cqL7QE17X8CNn/t/t1B/s7+ADHZM8ToAhD9bQW2/aoCVvqc/s3+4QABAC/+CgSqBFIAFQAiQBIBEkdZAQEUAxUPFBUIDUZZCBsAPysAGD8/MxI5LysxMAEDIRMzAwIGIyInNRYzMjY3EyEDIxMCBl4Bul/p5zzry4pkbHJzhCda/khm7O4EUv5EAbz7vv7t8zXTPaO5Aaz+IwRSAAEARv5tBYsFtgAPACVAFAwHTFkMDAUOCgMJEgMjBQBMWQUSAD8rABg/Pz8zEjkvKzEwJTMBIRMjEyEDIwEzAyETMwSB8v7n/vD63Iz9yovtATXtfwI2f+3R/ZwBkwKT/W0Ftv2qAlYAAQAv/nsEuARSAA8AJUAUAQxHWQEBCgMPDw4VCCIKBUdZChUAPysAGD8/PzMSOS8rMTABAyETMwMzAyMTIxMhAyMTAgZeAbpf6cPR+uvPzWT+SGbs7gRS/kQBvPxm/cMBhQHd/iMEUgABANf+bQVKBbYAGgApQBUFCA4IFExZCAgAGA4DAiMAA0xZABIAPysAGD8/MxI5LysREgA5MTAhAyMTMxMGBiMiJjU0NxMzAwYVFDMyNjcTMwEDM1bngdlQdqtQprIMde5xCqZepFaR8P7K/m0CXAF7MCadjjI+Ai395C4mjCoiArD6SgABALb+eQR/BFIAHAApQBUTHBYWBUZZFhYMCRwPDiIMD0ZZDBUAPysAGD8/MxI5LysREgA5MTABAwYVFDMyNjc3MwMjAyMTMzY2NyMGIyImNTQ2EwHyPhCDeq8tGenp01Lig78hHRQIi72Kkw5CBFL+31AvidzYdfuu/nkCSpp4N6KiiiRbAT0AAQBE/m0G5QW2ABgAJkATFwICCRILBwMABhIQIxINTFkSEgA/KwAYPz8zPzMSOTkRMzEwIQMjBgMDIwEhEzMBIQEzASETIxM2EjcjAQKHcwYQOabbATUBQ20GAl4BWP767v7p/vD6z6YVRwoG/X0Evp7+9PzsBbb7gwR9+xv9nAGTAxRhASci+0IAAQAp/nsFyQRSABcAKEAUDQoABwcXEAoPBAkVFSIXEkdZFxUAPysAGD8/Mz8zEjkRMxE5MTABBgYBIwMmJwMjEyETFzY3ASEDMwMjEyMEqgID/jCwYw0DstfrASlfEB1BAXkBOcTR+O7RvgNMAwf8vgKfU1r8tARS/VqwT3MClPxk/cUBhf///88AAAM/BbYCBgAsAAD///+HAAAFCAd5AiYAJAAAAQcCNgB5AVIACrQCEhIFJgArETX//wBe/+wEwAYnAiYARAAAAQYCNjEAAAq0AiQkESYAKxE1////hwAABG8HPgImACQAAAEHAGoAWAFSAAy1AwIkJAUmACsRNTX//wBe/+wEfwXsAiYARAAAAQYAagAAAAy1AwI2NhEmACsRNTX///+HAAAHJQW2AgYAiAAA//8AXv/sBo8EZgIGAKgAAP//AEYAAATbB3kCJgAoAAABBwI2AEwBUgAKtAEPDwUmACsRNf//AF7/7ASIBicCJgBIAAABBgI2+QAACrQCJycRJgArETUAAgBM/+wFBgXNABgAIgAmQBQTHUtZExMNBgYATFkGBA0ZTFkNEwA/KwAYPysREgA5GC8rMTABIgc1NjYzIAARFAIEIyImNTQkITM2NTQmATI2NyMgBBUUFgLRxsxryHoBAgEYzP6d2dHhAagBsGgGqv6Wpv5Dgf70/uphBP5W0S0n/tP+9v3+RvO8qPfsNCaxwPu639aHjkhYAAIAN//sA9MEZgAJACMAJkAUFwRIWRcXEQoKHUdZChARAEhZERYAPysAGD8rERIAORgvKzEwJTI2NyMiBhUUFhMyFhUUAgQjIiY1NCQhMzc1NCYjIgYHNTY2AZphqiIdvdJA1sXdm/73pKGzAU0BNCsCcHFGi2ZhpqCwiWxhMzkDxt7Hxv6rupGFts0fHW9+JDC6LiQA//8ATP/sBQYHPgImAuEAAAEHAGoAfwFSAAy1AwI4OAUmACsRNTX//wA3/+wD0wXsAiYC4gAAAQYAarMAAAy1AwI5OREmACsRNTX///+PAAAHQgc+AiYBsAAAAQcAagFUAVIADLUCAScnBSYAKxE1Nf///+P/7AdUBewCJgHQAAABBwBqAVgAAAAMtQIBUVERJgArETU1//8AEP/sBGoHPgImAbEAAAEHAGoAGQFSAAy1AgE+PgUmACsRNTX//wAK/+wDsAXsAiYB0QAAAQYAapkAAAy1AgE7OxEmACsRNTUAAQAG/+wEcQW2ABoAKEAUGhcYGBdMWRUAFBQGGAMGDUtZBhMAPysAGD8SOS8zMysREgA5MTABFhYVFAAhIiYnNRYWMzI2NTQmIyM3ASE3IQcCVrTL/r3+42PCSlDHVKzChYueJQG+/fYrAzwjAz8Kvqbh/vwnKNUtN5mGaWisAZ/PqAAAAf+N/hID2wRSABkAMUAZABMUFBNJWRQUBxkWFxcWR1kXDwcMRlkHGwA/KwAYPysREgA5EjkYLysREgA5MTABFhYVFAIEIyInNRYzMjY1NCYjIzcBITchBwHRp8eR/vGzyZagsK7Fm5JnIwG7/gApAxghAc8O0aqn/wCNTNNcwZ19g6QBv7yg//8ARgAABdkG2wImAbIAAAEHAU0A/gFSAAq0ARMTBSYAKxE1//8Ab//sBIcFiQImAFgAAAEGAU0vAAAKtAEdHREmACsRNf//AEYAAAXZBz4CJgGyAAABBwBqAN8BUgAMtQIBJSUFJgArETU1//8Ab//sBIcF7AImAFgAAAEGAGoGAAAMtQIBLy8RJgArETU1//8Ah//sBY0HPgImADIAAAEHAGoAxQFSAAy1AwIxMQUmACsRNTX//wBe/+4ENwXsAiYAUgAAAQYAauoAAAy1AwIxMREmACsRNTX//wCH/+wFjQXNAgYCfgAA//8AXv/uBDcEZAIGAn8AAP//AIf/7AWNBz4CJgJ+AAABBwBqAMUBUgAMtQQDNTUFJgArETU1//8AXv/uBDcF7AImAn8AAAEGAGrqAAAMtQQDNDQRJgArETU1//8AF//sBIkHPgImAccAAAEHAGr/+wFSAAy1AgEyMgUmACsRNTX//wAZ/+wDagXsAiYB5wAAAQcAav9TAAAADLUCATExESYAKxE1Nf//AAz/7AVqBtsCJgG9AAABBwFNAGQBUgAKtAEZGQUmACsRNf///1b+FARSBYkCJgBcAAABBgFNswAACrQBGxsRJgArETX//wAM/+wFagc+AiYBvQAAAQcAagA5AVIADLUCASsrBSYAKxE1Nf///1b+FARSBewCJgBcAAABBgBqlAAADLUCAS0tESYAKxE1Nf//AAz/7AVqB3MCJgG9AAABBwFTAKYBUgAMtQIBKCgFJgArETU1////Vv4UBH4GIQImAFwAAAEGAVPmAAAMtQIBKioRJgArETU1//8A2QAABUoHPgImAcEAAAEHAGoAiwFSAAy1AgEqKgUmACsRNTX//wCgAAAEaAXsAiYB4QAAAQYAau8AAAy1AgEwMBEmACsRNTUAAQBG/m0EgQW2AAkAHEAOBiMJAkxZCQMIA0xZCBIAPysAGD8rABg/MTABByEDMwMjEyMBBIEr/eXf24HnVt8BNQW2zfvg/aQBkwW2AAEAL/55A6gEUgAJABxADggiAQRGWQEPAAVGWQAVAD8rABg/KwAYPzEwMxMhByEDMwMjEy/sAo0p/lyXuHvjWARSw/00/bYBhwD//wBGAAAGmgc+AiYBxQAAAQcAagE7AVIADLUEAy0tBSYAKxE1Nf//AHX/7AXnBewCJgHlAAABBwBqAKoAAAAMtQQDODgRJgArETU1AAEAKf5EBH0FtgAaADRAHAAFS1kACQkWTFkVCwwLTFkSDAwOCRIOEUxZDgMAPysAGD8SOS8zKxEAMysAGBDEKzEwEyInNRYzMjc3IxMjNzMTIQchAyEHIQMzAwYGtlY3NzNoHhbpg5QrlIcDAiv96VwBPiv+wlTbSyGX/kQYvxWNbQJvyAJ/zf5OyP5y/pSekwAAAQAA/kQDqgRSABoAOEAdFQsMC0hZEgwMCQ4ABUZZAAkOEUZZDg8JFkZZCRUAPysAGD8rABgQxCsREgA5GC8zKxEAMzEwEyInNRYzMjc3IxMjNzMTIQchAyEHIQczAwYGnloyNDdlIBfqYpElkWUCjyv+XDsBCif++DfbRiGX/kQYvxWNbQHFtAHZw/7qtPz+rJ6TAAH/kf5EBSUFtgAYAChAFAoQDA4ABUtZAAwRDgMJFExZCQwSAD8zKwAYPzMQxCsREgA5OTEwASInNRYzMjc3IwMBIQEDMxMBIQETMwMGBgMSVjc3NGceFnvA/kr+9wJK+vayAZIBCv3ZvtxMIZf+RBi/FY1tAlD9sAMCArT95AIc/Tr98f6UnpMAAAH/qP5EBFQEUgAYAClAFQoQCQ4ABUZZAAkRDg8MFQkURlkJFQA/KwAYPz8zEMQrERIAOTkxMAEiJzUWMzI3NyMDASEBAzMTASEBEzMDBgYCgVk0NzNpHBdxoP7P/vAB3ef1kAEfARL+M6DZRiGW/kQYvxWNbQGD/n0COQIZ/osBdf3b/pz+rJ2UAAH/kQAABSUFtgARAClAFAMMBQoABwgHTFkPCAgFDQoDAgUSAD8zPzMSOS8zKxEAMxESOTkxMAETIQMBIQEjNyEDMxMBIQEhBwMf8f8AwP5K/vcB9v4rAQbZ9rIBkgEK/i0BAisCk/1tAlD9sAKTywJY/eQCHP2oywAAAf+qAAAEVARSABEAKUAUDQQPAgoRABFIWQcAAA8FAg8MDxUAPzM/MxI5LzMrEQAzERI5OTEwEzMDMxMBIQEzByMTIwMBIQEjf+PE9ZABHwES/oXlJu7V9qD+z/7yAY/hAo0Bxf6LAXX+O7D+IwGD/n0B3QACAE4AAASgBbYACgASAB1ADwMMS1kDAwgFAwgRTFkIEgA/KwAYPxI5LysxMBM0JCEzEzMBISImASMiBhUUMzNOAT0BHYt/7v7K/rfq6QK6fZ2v8nUBi977AlL6SswB0oeBzQD//wBe/+wE3QYUAgYARwAAAAIAUv/sBl4FtgAdACgAMUAYBxIdHQoSEB9MWRAQChIDGSUKJUxZBAoTAD8zKxEAMxg/EjkvKxESADkYLxE5MTABAwYGIyImJwYGIyImNTQAITMTMwMGFRQWMzI2NxMFIyIGFRQWMzI2NwZeZCnWvmqXJUuiZa/EAVEBIHZ97uMJTEJQYRdf/aFWtMBbUVh1FANQ/iHAxU5HT0S9q/MBGwJS+88kH0VHbG0BwbahlVNbZVwAAAIAXv/sBmoGFAAjADAALkAXBwcdEBIZIAAZK0ZZGRADJBIkRlkMEhYAPzMrEQAzGD8rABg/ERI5OTkvMTABFBYzMjY3EzMDBgYjIiYnIwYjIiY1NBI2MzIWFzM2NxMzAwYFMjYSNTQmIyIGAhUUA99KRltgGjvrQyzRt4ShHwqh2qGrh+yVWo8sCBAVTOnxDf4NVZ9dVlxWklcBP0VQeH4BHP7B075vW8rSucQBY8haWJxgAWT7kjTIpAEIh1tulv72kcsAAAEA3f/sBmAFywAtADZAGw8PFCsDHh8fHktZHx8UKysmS1krBBQLTFkUEwA/KwAYPysREgA5GC8rERIAORESORgvMTABFAYHFRYWFQcUFjMyNjcTMwMGBiMiJjU0NjU0JiMjNzMyNjU0JiMiByc2ITIWBDu/qXtuBkZMU2EbWu9kK9XDtr4KfYXXJ7SwxWhbma9e0AEHtNMEfZTUJQcbgG+NT01qgAGw/iHMuaWgI1IzYlu0joJVV26ljrgAAQCP/+wFwQRmACcANkAbBwcMICUUFRUUSFkVFQwgIBtHWSAQDANGWQwWAD8rABg/KxESADkYLysREgA5ERI5GC8xMAEVFDMyNjcTMwMGBiMiJjU3NCYjIzczMjY1NCMiByc2MzIWFRQFFRYDN4xaYBk/7EQp1sStuQJZcpkndouCpHeyQMHCsr3/ALYBaj+BcXQBLf7BzsOSjkJRRrNOUXdKrlSKgN09BR0AAAEAvP5tBHUFywAnADBAGR0ICQkIS1kJCQEWJyMWEEtZFgQBJExZARIAPysAGD8rABg/ERI5LysREgA5MTAhIxM2NTQmIyM3MzI2NTQmIyIHJzY2MzIWFhUUBgcVFhYVFAYHMwMjA2LlThB9fesprLXMaWCyult/6I14t2PUuIiNDSTbf+oBaFMeW2K+i3lVW3mmUkRUmGClxxkEEZFzG1Ct/aQAAQCk/nsD7gRmACQAMEAZIQ8QEA9IWRAQCBsGIhsWR1kbEAgDRlkIFQA/KwAYPysAGD8REjkvKxESADkxMAEUBgczAyMTIxM2NTQmIyM3MzI2NTQjIgcnNjMyFhUUBgcVFhYDTAUUu33gVsA7C2JbqidzjIKkc7Q/wcSyv4OBVmABbxkxYv24AYUBBDAoTD2zUE93Sq5UioBrkR4FFGcAAAH/wf/pBxAFtgAkACdAEwkJGSQkFUxZJAMFHhkeTFkOGRMAPzMrEQAzGD8rERIAORgvMTABAwYVFDMyNjcTMwMGBiMiJjU0NxMhAgIGIyInNRYzMjY2EhITBU7XE5BUZRpa72Yq1cKtxRik/tGHuc6wUTQ3LURYU2qORgW2/BFdK4ltfQGw/iPKvaWYTW8DAv34/d3TGckVP5ABMgHzAQwAAAH/sv/sBlQEYAAuACtAFgcHHCoqFEZZKhAcIUZZHBYMA0ZZDBYAPysAGD8rABg/KxESADkYLzEwARQWMzI2NxMzAwYGIyImNTQ3EyYjIgYGBw4CIyInNRYzMjY2Nz4DMzIXAwYDy0lEVF4hO+5GK9nAs7gPaiUhSF5RSldqimFAMyQoMUpFREljeKJznIuLDAE5R0hkkgEc/rXMuaWUPzwB+AhAltr7sVYUxQ9BhcTRtWcxK/1hNQABAEb/7AdQBbYAHAAsQBYGBhQVFxJMWRcXFBkVAxQSCwJMWQsTAD8rABg/PzMSOS8rERIAORgvMTABFDMyNjcTMwMGBiMiJjU0NzchAyMBMwMhEzMDBgSkkVZjGlruZC3Vv67HGSX9yovtATXtfwI2f+/bDgE/iXB6AbD+I865qpc/c7T9bQW2/aoCVvv0SwABAC//7AaTBFIAHQAsQBYTEwMEBgFHWQYGAwgEDwMVGA9GWRgWAD8rABg/PzMSOS8rERIAORgvMTABIQMjEzMDIRMzAwYVFBYzMjY3EzMDBgYjIiY1NDYDOf5IZuzu6V4Bul/pkw1MRlZgGzvrPTTcu7K6BQHd/iMEUv5EAbz9SjonRUZuggEc/uLqyKWUGTUAAAEAh//sBXcFywAeACZAFAAeTFkAAAYNDRNMWQ0EBhpMWQYTAD8rABg/KxESADkYLysxMAEhBwYCBCMgABEQEiQzMhcHJiYjIgQCFRQWMzI2NyEDEAJnHS6n/vLF/vj+3dEBcu7utlpml1Wf/v6QpKCkwyj+kwMQl/D+7osBLAEPAQYBrfFayzIku/60yLe+vs4AAQBe/+wEiQRmABsAJkAUABtHWQAABQwMEUZZDBAFF0dZBRYAPysAGD8rERIAORgvKzEwASEHAgQjIiY1NBIkMzIXByYjIgIVFBYzMjY3IQJ3AhIaOv7t9dn2owEux9mRVoaQw+V/cnyfG/7dAmp8/vn769XKAUGvVLRK/uvpfIaHgwAAAQCw/+wFBgW2ABkAJUASDg4TAQQAAQBMWQEDEwpMWRMTAD8rABg/KxEAMxESORgvMTATNyEHIQMGFRQWMzI2NxMzAwYGIyImNTQ3E7AtA+wt/n2xDklJU2McW+1kLdW/rsYWqgTpzc38wUsgQUhoggGw/iPOuaSZP2MDHgAAAQBa/+wEjwRSABkAJUASBwcMFBcTFBNHWRQPDANGWQwWAD8rABg/KxEAMxESORgvMTABFBYzMjY3EzMDBgYjIiY1NDcTITchByEDBgIGSURUXiE87UUr2sCyuBZl/sQlA2Qp/sNrDAE5R0hkkgEc/rXKu6eUQl4B0bq6/f41AAABAF7/7ATJBcsAJQAtQBcfDgsLDktZCwsYAAAGTFkABBgTS1kYEwA/KwAYPysREgA5GC8rERIAOTEwATIWFwcmIyIGFRQhMwcjIBEUFjMyNxUGIyImNTQ2NzUmJjU0NjYDF4DOZHOZq3aSAR+iKZj+ToyJt8G39eD719VvfIHlBctCTKxzemfPvv7tZmte0VPJra3TGgYimXB/vGMA//8AM//sA+UEZgIGAYIAAAAB/8H+RAVkBbYAIAAsQBgGDw8BTFkPEgYLS1kVGkxZFRMgEUxZIAMAPysAGD8rKwAYPysAGBDEMTABATMDBgYjIic1FjMyNzcjASECAgYjIic1FjMyNjYSEhMFZP743UsiloJZMjU1ZiAU7gEN/riHuc6wUTQ3LURYU2qORgW2+yv+lKGQGL8VjW0E5/34/d3TGckVP5ABMgHzAQwAAAH/sv5EBIMEYAApACxAGAUKRlkFDg4ARlkOFScRRlknEBkeRlkZFgA/KwAYPysAGD8rABgQxCsxMCUzAwYGIyInNRYzMjc3IxMmIyIGBgcOAiMiJzUWMzI2Njc+AzMyFwOo20Yhl4NZMjU1ZSAX6sUlIUheUUpXaophQDMkKDFKRURJY3iic5yLyf6snpMYvxWNbQOYCECW2vuxVhTFD0GFxNG1ZzEr////h/55BE4FuAImACQAAAAHAmcEywAA//8AXv55BH8EZgImAEQAAAAHAmcEtgAA////hwAABE4H6gImACQAAAEHAmYFDgFSAAq0AhMTBSYAKxE1//8AXv/sBH8GmAImAEQAAAEHAmYEugAAAAq0AiUlESYAKxE1////hwAABboH0QImACQAAAEHA3cFBAFSAAy1AwIZGQUmACsRNTX//wBe/+wFXgZ/AiYARAAAAQcDdwSoAAAADLUDAisrESYAKxE1Nf///4cAAARxB9ECJgAkAAABBwN4BQQBUgAMtQMCGRkFJgArETU1//8AXv/sBH8GfwImAEQAAAEHA3gEsgAAAAy1AwIrKxEmACsRNTX///+HAAAFYAg7AiYAJAAAAQcDeQUEAVIADLUDAhkZBSYAKxE1Nf//AF7/7AUMBukCJgBEAAABBwN5BLAAAAAMtQMCKysRJgArETU1////hwAABN0IYgImACQAAAEHA3oFBAFSAAy1AwIwMAUmACsRNTX//wBe/+wEhwcQAiYARAAAAQcDegSuAAAADLUDAkJCESYAKxE1Nf///4f+eQSFB3MCJgAkAAAAJwJnBMsAAAEHAUsAWgFSAAq0AxsbBSYAKxE1//8AXv55BH8GIQImAEQAAAAnAmcEtgAAAQYBS/kAAAq0Ay0tESYAKxE1////hwAABLIIEwImACQAAAEHA3sFHwFSAAy1AwIPDwUmACsRNTX//wBe/+wEfwbBAiYARAAAAQcDewS4AAAADLUDAiEhESYAKxE1Nf///4cAAASVCBMCJgAkAAABBwN8BQIBUgAMtQMCGBgFJgArETU1//8AXv/sBH8GwQImAEQAAAEHA3wEuAAAAAy1AwIqKhEmACsRNTX///+HAAAEkQhYAiYAJAAAAQcDfQT+AVIADLUDAiIiBSYAKxE1Nf//AF7/7AR/BwYCJgBEAAABBwN9BLYAAAAMtQMCNDQRJgArETU1////hwAABNEIYgImACQAAAEHA34E/gFSAAy1AwIkJAUmACsRNTX//wBe/+wEhwcQAiYARAAAAQcDfgS0AAAADLUDAjY2ESYAKxE1Nf///4f+eQSSB1oCJgAkAAAAJwFOAEgBUgEHAmcEywAAAAq0AhISBSYAKxE1//8AXv55BH8GCAImAEQAAAAmAU4EAAEHAmcEtgAAAAq0AiQkESYAKxE1//8ARv55BIMFtgImACgAAAAHAmcEmAAA//8AXv55A/oEZgImAEgAAAAHAmcElgAA//8ARgAABIMH6gImACgAAAEHAmYE4QFSAAq0ARAQBSYAKxE1//8AXv/sA/oGmAImAEgAAAEHAmYEjQAAAAq0AigoESYAKxE1//8ARgAABKgHSAImACgAAAEHAVIAUAFSAAq0ARUVBSYAKxE1//8AXv/sBEsF9gImAEgAAAEGAVLzAAAKtAItLREmACsRNf//AEYAAAWdB9ECJgAoAAABBwN3BOcBUgAMtQIBFhYFJgArETU1//8AXv/sBUEGfwImAEgAAAEHA3cEiwAAAAy1AwIuLhEmACsRNTX//wBGAAAEgwfRAiYAKAAAAQcDeATnAVIADLUCARYWBSYAKxE1Nf//AF7/7AP6Bn8CJgBIAAABBwN4BIsAAAAMtQMCLi4RJgArETU1//8ARgAABUMIOwImACgAAAEHA3kE5wFSAAy1AgEWFgUmACsRNTX//wBe/+wE5wbpAiYASAAAAQcDeQSLAAAADLUDAi4uESYAKxE1Nf//AEYAAATACGICJgAoAAABBwN6BOcBUgAMtQIBLS0FJgArETU1//8AXv/sBGQHEAImAEgAAAEHA3oEiwAAAAy1AwJFRREmACsRNTX//wBG/nkEgwdzAiYAKAAAACcCZwSYAAABBwFLAD8BUgAKtAIYGAUmACsRNf//AF7+eQQHBiECJgBIAAAAJwJnBJYAAAEGAUvcAAAKtAMwMBEmACsRNf///88AAANFB+oCJgAsAAABBwJmBBIBUgAKtAEQEAUmACsRNf//AC8AAALEBpgCJgDzAAABBwJmA5EAAAAKtAEICBEmACsRNf///8/+eQM/BbYCJgAsAAAABwJnA7YAAP///+v+eQJWBfoCJgBMAAAABwJnA2QAAP//AIf+eQWNBc0CJgAyAAAABwJnBUIAAP//AF7+eQQ3BGQCJgBSAAAABwJnBMEAAP//AIf/7AWNB+oCJgAyAAABBwJmBZMBUgAKtAIgIAUmACsRNf//AF7/7gQ3BpgCJgBSAAABBwJmBJ4AAAAKtAIgIBEmACsRNf//AIf/7AYnB9ECJgAyAAABBwN3BXEBUgAMtQMCJiYFJgArETU1//8AXv/uBU4GfwImAFIAAAEHA3cEmAAAAAy1AwImJhEmACsRNTX//wCH/+wFjQfRAiYAMgAAAQcDeAVvAVIADLUDAiYmBSYAKxE1Nf//AF7/7gQ3Bn8CJgBSAAABBwN4BJgAAAAMtQMCJiYRJgArETU1//8Ah//sBcsIOwImADIAAAEHA3kFbwFSAAy1AwImJgUmACsRNTX//wBe/+4E9AbpAiYAUgAAAQcDeQSYAAAADLUDAiYmESYAKxE1Nf//AIf/7AWNCGICJgAyAAABBwN6BW8BUgAMtQMCPT0FJgArETU1//8AXv/uBHEHEAImAFIAAAEHA3oEmAAAAAy1AwI9PREmACsRNTX//wCH/nkFjQdzAiYAMgAAACcCZwVCAAABBwFLAMUBUgAKtAMoKAUmACsRNf//AF7+eQQ3BiECJgBSAAAAJwJnBMEAAAEGAUvzAAAKtAMoKBEmACsRNf//AIf/7AbVB3MCJgJfAAABBwB2ARIBUgAKtAItLQUmACsRNf//AF7/7gWPBiECJgJgAAABBgB2PwAACrQCLCwRJgArETX//wCH/+wG1QdzAiYCXwAAAQcAQwBvAVIACrQCJiYFJgArETX//wBe/+4FjwYhAiYCYAAAAQYAQ5IAAAq0AiUlESYAKxE1//8Ah//sBtUH6gImAl8AAAEHAmYFkwFSAAq0AigoBSYAKxE1//8AXv/uBY8GmAImAmAAAAEHAmYEngAAAAq0AigoESYAKxE1//8Ah//sBtUHSAImAl8AAAEHAVIA2QFSAAq0Ai4uBSYAKxE1//8AXv/uBY8F9gImAmAAAAEGAVL/AAAKtAItLREmACsRNf//AIf+eQbVBhQCJgJfAAAABwJnBUIAAP//AF7+eQWPBPoCJgJgAAAABwJnBMEAAP//AJj+eQWLBbYCJgA4AAAABwJnBSUAAP//AG/+eQSHBFICJgBYAAAABwJnBNcAAP//AJj/7AWLB+oCJgA4AAABBwJmBWYBUgAKtAEaGgUmACsRNf//AG//7ASHBpgCJgBYAAABBwJmBL4AAAAKtAEeHhEmACsRNf//AJj/7AcjB3MCJgJhAAABBwB2ARQBUgAKtAEmJgUmACsRNf//AG3/7AYvBiECJgJiAAABBgB2YgAACrQBKCgRJgArETX//wCY/+wHIwdzAiYCYQAAAQcAQwA/AVIACrQBHx8FJgArETX//wBt/+wGLwYhAiYCYgAAAQYAQ5sAAAq0ASEhESYAKxE1//8AmP/sByMH6gImAmEAAAEHAmYFaAFSAAq0ASEhBSYAKxE1//8Abf/sBi8GmAImAmIAAAEHAmYEwwAAAAq0ASQkESYAKxE1//8AmP/sByMHSAImAmEAAAEHAVIAzwFSAAq0AScnBSYAKxE1//8Abf/sBi8F9gImAmIAAAEGAVIxAAAKtAEpKREmACsRNf//AJj+eQcjBhQCJgJhAAAABwJnBSUAAP//AG3+eQYvBPoCJgJiAAAABwJnBNcAAP//ALr+eQUABbYCJgA8AAAABwJnBGoAAP///1b+FARSBFICJgBcAAAABwJnBawAAP//ALoAAAUAB+oCJgA8AAABBwJmBKwBUgAKtAENDQUmACsRNf///1b+FARSBpgCJgBcAAABBwJmBDsAAAAKtAEcHBEmACsRNf//ALoAAAUAB0gCJgA8AAABBwFSAB8BUgAKtAESEgUmACsRNf///1b+FARSBfYCJgBcAAABBgFSpwAACrQBISERJgArETX//wAd/rwFUAYUAiYA0wAAAAcAQgDZAAAAAvwzBNn/DAYhAAgAEQAOtA4GgAoBAC8zGs0yMTABIyYmJzUzFhcFIyYmJzUzFhf9oIU8iiLqKlkBbIVAhyDpKlkE2TyzRBWWmRlAs0AVlpkAAAL8yQTZALYGfwAMABUAGUAKBwAVABUAEMAKBQAvMxrMOTkvLxEzMTABMxYXByMmJwYHIzc2BTY3MxUGBgcj/dn2LXEFeFtRgXGJBNIBmmlD0SOaQ30GAHeZFz9jZjwZwwVuYRInfysAAvwfBNn/bQZ/AAwAFgAZQAoHAA0ADQASwAoFAC8zGsw5OS8vETMxMAEzFhcHIyYnBgcjNzYHJiYnNTMWFhcV/dn2LXEFeFtRgXGJBNLQMmYYuBE/FgYAd5kXP2NmPBnDGS59JhItfSUUAAL8yQTZAFwG6QAMAB4AKrkADf/AQBMKEUgHAA0ADQATGEAKDUgYwAoFAC8zGswrMjk5Ly8RMysxMAEzFhcHIyYnBgcjNzYFNzY2NTQjIgc1NjMyFhUUBwf92fYtcQV4W1GBcYkE0gGxCkY/Ry0hIUVPXZkPBgB3mRc/Y2Y8GcMVagcmIy0MZApCP3YjLwAC/MkE2f/ZBxAAFgAkAEpACQkAHhcRAAUMF7j/wLMfIkgXuP/AQBoRG0gXAAwMABcDHxUvFT8VAxVAFBdIFcAhHAAvMxrMK10XOS8vLysrETMRMxEzEMQxMAEiLgIjIgYHIzY2MzIeAjMyNjczBgUzFhcHIyYnBgcjNzc2/vYpSkU/HiksD3cZdVUnSkVBHiUvFHM5/jX2IoAFeFlYfm2LBECNBikbIRwxKXRzHCIcLDDnMVysFztdXTsZO38AAv0IBNn/kwbBAA0AFgAjQBIPFgEKBBYEFggRQAoOSBHACAAALzIazCsROTkvLzNdMTABIiY1NzMWFjMyNzMGBgM2NzMVBgYHI/4nh5gCfQpXTZ49gyO4wF5Mwh+pQGQE2ZSDEk1EkY+aARlYdxEiiicAAv0IBNn/kwbBAAgAFgAjQBIPAAETDQANABEFQAoOSAXAEQkALzMazCsROTkvLzNdMTABJiYnNzMWFwcDIiY1NzMWFjMyNzMGBv41NmgYArAdSgVsh5gCfQpXTZ49gyO4Bd0yeCcTVnkV/vyUgxJNRJGPmgAC/QgE2f+TBwYAEgAgADS0HwABHRe4/8BAGA8SSBcAFwAbBh8LLws/C28LfwsFC8AbEwAvMxrMXTIROTkvLyszXTEwATc2NjU0IyIHNTYzMhYVFAYPAiImNTczFhYzMjczBgb9+gg+PUIrHiQ8S1dKRg4vh5gCfQpXTZ49gyO4Bc1mCSQjJwpaDD43OlIPKfSUgxJNRJGPmgAAAv0EBNn/0wcQABQAIgA9QCMfGA8YAQgADwAFChgACgoAGAMcHxMvEz8TAxNAExdIE8AcFQAvMxrMK10RFzkvLy8RMxEzEMRdETMxMAEiLgIjIgcjNjMyHgIzMjY3MwYBIiY1MxYWMzI2NzMGBv7yJUtGQRxIHnUyryRMSEIbJiwUczr+joyVfQVXVldkHIMitwYxGyAbVt0cIhwuLt/+qI6HQTw/PoWQAAAB/2L+LQDZAAAADwAKsgALBgAvzDIxMAMyNjU0JzMWFRQGIyInNRY/MDhal3OEdEo1LP7BNjZcd3OBaXYVjxD//wB8AAADPgW2AAYAFIoAAAIAXv/sBCsEewAKABgAF0AMFgBNWRYmDwVNWQ8ZAD8rABg/KzEwASICFRQzMjYSNTQXFAIGIyImNTQSJDMyFgKFhrO+VopT7o/9pcTYkwEAosLWA7r+yujwhAEFnOnz1P6rsuvN1AFRsukAAAEANwAAAucEZgAKABVACQQJBwcBCRABGAA/PxI5LxE5MTAhIxISNwYHBycBMwH67FFWIixXsmsB7sIBbwGHbCw6d6IBPwAB/98AAAPHBHsAGQAdQA8QCU1ZECYCFwEBGE5ZARgAPysREgA5GD8rMTAhITcBNjY1NCYjIgYHJzY2MzIWFRQGBwUVIQNt/HIjAY3KfEVIT5pXcIjTdam2k7f+7QIuqAEZjo9ROUxPRJtuUaKRfM51tAYA////lf6fA7UEfgAHABb/dv6zAAL/x/6oBAAEZgAKABMAJUASDwMHAQUTBU9ZBgkTEwMHEAMkAD8/EjkvMzMrEQAzERI5MTAlIwMjEyE3ASEDMyE2NjcjBgYHAQPTvE7mTv2WJQMSAQLDv/5eJzFKCBZYHv5vG/6NAXOyA5n8b7bl+CR5If4rAP///+D+nwQDBGkABwAY/6v+s///AGb/7ARkBcsABgAZ9wD//////rMEHgRpAAcAGv+C/rP//wA//+wEUQXNAAYAG/MA//8AJv6hBAEEgAAHABz/yv61AAH/H/4UBlAGHwA5ADhAHSIUDxRGWR0PAAkpNhg2SFkLJhgPMgUABUZZLQAbAD8yKxEAMxg/MzMrEQAzMxg/MysRADMxMAMiJzUWMzI3EyM/AjY2MzIXByYjIgYHByE3NjYzMhcHJiMiBgcHMwcjAwYGIyInNRYzMjcTIQMGBkxaO0AyhSzZsxXCFSy1pnNgPUo+RVMWEgG2Fyyyp3VgPko9R1EWEuUn498rtZFfNjw2iCjX/krfKLb+FBe+FM0D/mpMXManK7AcVmJWYMWoK7AcVmJWsvvjwK8XvhTNA/77472yAAIAdwLdBZMFwQAgADEANkAbChsDEykhCAMDIS0DACYBJicYLyMjJxMTKicDAD8zMy8RMxEzzRDNXRcyL80RMxESOTkxMAEUBiMiJzUWMzI1NCYnJiY1NDYzMhcHJiMiBhUUFhcWFgEDIxcRIxEzExMzESMRNyMDAj2Ld3pKalx1L1ZiTH5rY2orV0YtODVMbkYBlLIGBI7VrLfMkQQGugO0ZHMlfy9aIy8lLGBHW3AubicqJiUvITNZ/uoCG2/+VALR/eoCFv0vAaJ5/eX//wCS/hQEwwW2AiYANwAAAAcAegFOAAD//wBc/hQDJQVIAiYAVwAAAAcAegEbAAAAAgAn/hQEfwRmAA0ALQAuQBgaKB0kKQ8kB0ZZJBAdAEZZHRYOFEZZDhsAPysAGD8rABg/KwAYPxESOTkxMCUyNhI1NCYjIgYCFRQWAyInNRYWMzI2PwIjBgYjIiY1NBI2MzIWFzM3MwMGBgHsU51fWFRWlFlUF9iKR7VUdZsZDjEIVKBajJ+J7ZJgjjEIQLL2L/uqogEKh2Fol/72kGZl/WpE1SgwcXJAumxaz7TNAWTGVlye+3/e3wD//wAn/hQEfwYhAiYDjwAAAQYBSxkAAAq0AjQ0ESYAKxE1//8AJ/4UBH8GCAImA48AAAEGAU4IAAAKtAIxMREmACsRNf//ACf+FAR/BfoCJgOPAAABBwFPASMAAAAKtAI3NxEmACsRNf//ACf+FAR/BiECJgOPAAABBgI6ewAACrQCMTERJgArETUAAQBGAAACaAW2AAMACrMBAwASAD8/MTAzATMBRgE36/7JBbb6Sv//AEYAAAJ2B3MCJgOUAAABBwBD/uABUgAKtAEFBQUmACsRNf//AEYAAAOIB3MCJgOUAAABBwB2/6MBUgAKtAEMDAUmACsRNf//AEYAAANpB3MCJgOUAAABBwFL/z4BUgAKtAEKCgUmACsRNf//AEYAAANgBz4CJgOUAAABBwBq/0kBUgAMtQIBGRkFJgArETU1//8ARgAAA6MHSAImA5QAAAEHAVL/SwFSAAq0AQ0NBSYAKxE1//8ARgAAA00G2wImA5QAAAEHAU3/VwFSAAq0AQcHBSYAKxE1//8ARgAAA3gHWgImA5QAAAEHAU7/LgFSAAq0AQcHBSYAKxE1////tP4tAmgFtgImA5QAAAAGAVFUAP//AEYAAAKsB0wCJgOUAAABBwFPAF4BUgAKtAENDQUmACsRNf//AEb+aATTBbYAJwAtAmAAAAAGA5QAAP//AEEAAAMMBf8AJwOUAKQAAAEHAVT97/+XAAeyAQYAAD81AP//AEYAAAJoBbYCBgOUAAD//wBGAAADXAc+AiYDlAAAAQcAav9FAVIADLUCARkZBSYAKxE1Nf//AEYAAAJoBbYCBgOUAAD//wBGAAADXAc+AiYDlAAAAQcAav9FAVIADLUCARkZBSYAKxE1Nf//AEYAAAJoBbYCBgOUAAD//wBGAAACaAW2AgYDlAAA//8ARgAAAyEH6gImA5QAAAEHAmYD7gFSAAq0AQgIBSYAKxE1//8AAv55AmgFtgImA5QAAAAHAmcDewAAAAEAAAOoAIoAFgBUAAUAAgAQAC8AXAAAARoAogADAAEAAAAbABsAGwAbAEYAYwC3ASEBiwH1AggCJwJHAnACkQKoArsC1wLsAycDRwOEA9cEEwRUBKsEygUoBXsFrQXaBfMGFgYvBn0G/AcrB3cHrgfkCBIIOAiACKcI0Qj1CR4JOAluCZ0J3AoQClsKlwrfCv4LMAtVC5cLwAvgDAgMJAw4DFMMbwyBDJoM4g0wDWMNsg39DkMOxw8CDzIPdQ+jD7UQBBA7EHQQvREKETQReBG2Ee8SERJTEnwSshLcEykTOxOHE74TvhPoFCsUdhTAFQkVJhWMFbkWKBZnFpEWqhayFyYXOBdlF5YXyhgRGCsYaRiPGJgYxRjlGRYZQhlYGW0ZgxnVGecZ+RoLGh0aMBpBGosalxqpGrsazRrgGvIbBBsWGykbdRuHG5kbqxu9G88b4hwOHGwcfhyQHKIctRzHHP4daB15HYodmx2sHb4d0B5QHlwebR5+Ho8eoR6zHsUe1x7qH0sfXB9tH34fjx+gH7If7SBHIFggaSB6IIwgnSDsIP4hECEhITMhRCFQIVwhbiF/IZEhoiG0IcYh2CHpIfsiDCIUIn4ikCKhIrMixCLWIugi9CMAIxIjIyM1I0YjWCNpI3sjjSOZI6ojvCPOJBIkZSR3JIkkmyStJL8k0STdJOgk+iUMJRglJCU2JUglVCVfJY4loCWyJb0lySXaJewl+CYEJjMmYiZ0JoUmkSacJq4mvybLJwknUSdjJ3QnhieXJ6onvCgVKIgomiirKLcowyjVKOYo+CkJKRspLSk5KUUpVylpKXQpfymRKaIp1yooKjoqSypdKm4qgCqRKqQqtirJKtsq5yrzKwUrFyspKzorTStfK3ArgiuUK6YrtyvsLDMsqC01LUctWS1rLXwthy2SLbQt1i3oLg0uKC5bLn8utC7eLvcvOi9LL1QvZi94L4ovmy+tL74v0i/aL+Iv+zADMAswEzAbMGkwcTB5MJswozCrMNww5DEDMQsxPTFFMU0xpjGuMfUyPzJSMmUydjKHMpgyqjK9MxgzdTOhM/U0QDSJNME1DjU1NT01gzWLNa82DzYXNlM2mDbYNxU3Szd3N8g4FDhVOKQ4tzjJONo46zj9ORA5WjlsObA5uDnAOdM52zoxOnY6sjrEOtY6/zsHO0I7SjtSO5A7mDvTPCY8UzxlPI08wzzLPNM82zzjPOs88zz7PTI9Oj1CPW09oD3KPf4+Oj53Pqo+7z9EP4I/ij/dQDNAeEDOQNZBSkGYQaBBsUHaQhVCTEJ1Qn1ChUKNQpVCnUKlQvtDA0NKQ4ZD10Q6RIJEz0UQRVdFpEX2RghGckaDRsRGzEbURudG70dYR6tHs0fER9VIGkg7SFtIbUh+SJBIoki1SMhI2kjsSP5JEEkYSSVJPklZSW9JiUmwSdpJ/kovSoBKmkqrSz9LR0tPS2hLgkuOS6NL1EwQTHRM101ATaJN705TTpJOmk7bTvNPCk8hTzhPiU+0T9FP/lAQUDBQhlCxUSNRW1GCUapR0VHdUelSDFIvUkhSYVJ6UqpS31MWU19TeVPHVAxUDFQMVAxUDFQMVAxUDFQMVAxUDFQMVAxUDFUrVX5VkFWYVg5WQladVq9WwVbNVtlW5VcVV0dX2lhYWKlY9lk6WYdZkFmZWaJZxVngWfJaBFoWWidalFrPWxdbbFvFXBdcUVyIXNJdGl1qXbheFl5yXv9fhF+MX5Rf42ArYGJgl2CqYL1gyWDVYThhnGJEYutjd2PWZA9kRmR9ZKJkz2TyZRVmAmaoZv9nXGelZ/toSWioaNhpB2lRaZdp3GpWamJqbmqiatVrEWtPa45r0mwDbDRsZ2ybbM1s/m1MbZZuDm6JbpVuoW7LbzNvO29ib5lv0XAFcDpwcXDGcQhxSnGVceRyG3JUcrlzGHOEc+5z9nQIdBp0YnSldOd1LXVqdaR12HYMdk52knbXdxp3Inc0d0V3WHdqd3J3eneMd5136ng1eEh4WnhteIB4k3ileOd5K3k9eU55YXlzeYZ5mHmgeah5u3nNeeB583oFehZ6KXo7ek56YHpzeoV6q3rQeuN69ns/e4l7znwTfFB8iny8fMR9Hn2Bfd9+NX6Hftd/KH+Ef8yAFYBegKCA34EfgW6BdoHFghmCJYIxgkOCVYJognuCjoKhgrSCx4Lagu2DA4MYgyuDPoNRg2SDd4OKg52DsIPGg9uD54PzhAWEF4QphDqETYRghHOEhoSZhKyEv4TShOiE/YUPhSGFLYU5hUWFUYVjhXWFiIWbha6FwYXUheeF+oYNhiOGOIZKhluGbYZ+hpCGooa0hsWG0YbdhumG9YcHhxmHK4c8h06HX4dxh4OHlYemh7KHvofKh9aH6If6iAyIHYgpiFKIhoi7iQKJYYmaidSKIYp2ipaKnorUiveLMYs6i3WLfouGi4+Ll4ugjBKMeYyFjJGM7oz/jRCNIo0zjUaNWI1qjXyNj42hjbONxY3QjeKN7o4AjgiOG44jjjaOPo5GjliOZAAAAAEAAAABGdt6Z3AWXw889QAJCAAAAAAAyWNIlgAAAADVK8zV/B/9wQoZCGIAAgAJAAIAAAAAAAAEzQDBAAAAAAQUAAACFAAAAi0AIQNaANUFKwAzBGgAPQaYAI0FgwBCAeMA1QJ/AE4Cf/9mBGIAwQRoAHUCEv+aAokALwInACEDFP+kBGgAXARoAPIEaP/uBGgAHwRo//wEaAA1BGgAbwRoAH0EaABMBGgAXAInACECJ/+cBGgAcwRoAHUEaABzA4sAogbPAGQEuv+HBN8ARgTJAIcFXgBGBDUARgQCAEYFdwCHBYMARgLN/88CZP6+BK4ARgP4AEYG3QBEBdMARAXNAIcElgBGBc0AhwS2AEYEIQAnBB0AsAV3AJgEjQC6BvwAywR//5EERAC6BET/2QJ3/+UDFADdAnf/cQQtACUDLf9EBG8CHQSiAF4EsAAvA7oAXgSuAF4EMwBeAr7/HwQr/4cEuAAvAjMALwIz/voEOQAvAjMALwcbAC8EuAAvBJYAXgSw/8kErgBeA0QALwOaAA4C8ABcBLgAbwPlAGQGBAB5BAj/qgPs/1YDmP/ZAtEACARoAfIC0f+oBGgAbwIUAAACLf/TBGgAwwRo/+4EaACNBGgAagRoAfID4wAnBG8BqgaoAIMC2QCgBB8AUARoAHUCiQAvBqgAgwOHAG8DbQC8BGgAdQLpAE4C6QBoBG8B/ATF/8kFPQCsAicAlgGk/0QC6QDBAtEApAQfAAoGfQCVBn0AeQaTAGwDi//dBLr/hwS6/4cEuv+HBLr/hwS6/4cEuv+HBtn/hwTJAIcENQBGBDUARgQ1AEYENQBGAs3/zwLN/88Czf/PAs3/zwVeADUF0wBEBc0AhwXNAIcFzQCHBc0AhwXNAIcEaACTBc0AbQV3AJgFdwCYBXcAmAV3AJgERAC6BJYARgTy/v4EogBeBKIAXgSiAF4EogBeBKIAXgSiAF4GvgBeA7oAXgQzAF4EMwBeBDMAXgQzAF4CMwAvAjMALwIzAC8CMwAvBJYAUAS4AC8ElgBeBJYAXgSWAF4ElgBeBJYAXgRoAHUElgAzBLgAbwS4AG8EuABvBLgAbwPs/1YEsP/JA+z/VgS6/4cEogBeBLr/hwSiAF4Euv+HBKIAXgTJAIcDugBeBMkAhwO6AF4EyQCHA7oAXgTJAIcDugBeBV4ARgSuAF4FXgA1BK4AXgQ1AEYEMwBeBDUARgQzAF4ENQBGBDMAXgQ1AEYEMwBeBDUARgQzAF4FdwCHBCv/hwV3AIcEK/+HBXcAhwQr/4cFdwCHBCv/hwWDAEYEuAAvBYMARgS4AC8Czf/PAjMALwLN/88CMwAvAs3/zwIzAC8Czf/PAjP/pgLN/88CMwAvBTH/zwRoAC8CZP6+AjP+/ASuAEYEOQAvBDkALwP4AEYCMwAvA/gARgIz/54D+ABGAjMALwP4AEYC3QAvA/gACgJOAAIF0wBEBLgALwXTAEQEuAAvBdMARAS4AC8FTgAuBdMARAS4AC8FzQCHBJYAXgXNAIcElgBeBc0AhwSWAF4HBgCHBvwAXgS2AEYDRAAvBLYARgNE/5wEtgBGA0QALwQhACcDmgAOBCEAJwOaAA4EIQAnA5oADgQhACcDmgAOBB0AiALwADoEHQCwAvAAXAQdAKgC8AAlBXcAmAS4AG8FdwCYBLgAbwV3AJgEuABvBXcAmAS4AG8FdwCYBLgAbwV3AJgEuABvBvwAywYEAHkERAC6A+z/VgREALoERP/ZA5j/2QRE/9kDmP/ZBET/2QOY/9kCh/8CBGj/8gS6/4kEngBeBtn/hwa+AF4FzQBtBJYAMwQhACcDmgAOBG8BYgRvAaYESAGLBG8BxQIpAUIEngIdAY3/YARvAUYEbwFSBHcCUgR3AYsEuv+HAicAlgTLADQGGwA0A8sAQQYtAE0FbQA0BlIAVwKwAGQEuv+HBN8ARgPpAEYEpv/JBDUARgRE/9kFgwBGBdkAhwLN/88ErgBGBKL/hwbdAEQF0wBEBCf/3QXNAIcFfwBGBJYARgRC/9sEHQCwBEQAugY9AIcEf/+RBjMAvAXT/9kCzf/PBEQAugSyAF4D1QAzBLgALwKwAGQExQB9BLIAXgTJ/8kD4QBIBI8APwPVADMDqgBeBLgALwSDAGICsABkBDkALwQ3/5gExf/JBCcAZAOiAFYElgBeBUIAVASq/8kDqgBeBMsAXgOqAFQExQB9BbwAXgQ3/woGFwCDBjMAXgKwAGQExQB9BJYAXgTFAH0GMwBeBDUARgWiALAD6QBGBMkAhwQhACcCzf/PAs3/zwJk/r4HYv/BB1wARgWiALAEngBGBK4ADAV/AEYEuv+HBKAASATfAEYD6QBGBVz/SgQ1AEYGkf+PBIMAEAXPAEYFzwBGBJ4ARgVa/8EG3QBEBYMARgXNAIcFfwBGBJYARgTJAIcEHQCwBK4ADAY9AIcEf/+RBZgARAU/ANkH1QBEB/4ARAVIALAGjwBGBJYARgTJABcH8ABGBLr/nASiAF4EgQBoBHEAXgO+ACUEqABeBDMAXgct/+MD1wAKBLgAbwS4AG8ENwAvBJz/sgXsACkE2wAvBJYAXgS4AC8EsP/JA7oAXgcbAC8D7P9WBbQAXgQI/6oE2wBtBJoAoAcbAG0HPQBtBRAAWAYZAHUEVAB1A8EAGQZ3AC8Eb//fBDMAXgS4AC8DvgAlA7oAXgOaAA4CMwAvAjMALwIz/voGf/+yBrIANQS4AC8ENwAvA+z/VgS4AG0D6QBGA2IALwb8AMsGBAB5BvwAywYEAHkG/ADLBgQAeQREALoD7P9WA9cALweuAC8HrgAvAy3/LAGJAHcBiQBzAhL/mgGJAOEDIwB3AyMAcwOq/5oD4wDLA/gARAL0AJgGYgElCVYAjQHjANUDWgDVAm0AUAJtAAoEKf//AQb+AgMEAJYEaAAXBGj/8AZSADcEaAAzBisAogQAAGQHtgApBf4AcQXT/9kE9AB1BokAgwbHAFcGzQBkBoUAgQSmAGAEpv/JBe4A2wUMAJ4EaAB1BGQAYgWoAI0DLwASBGgAbwRoAHUEaAB1BGgAdQSqAIME6f8fBOn/HwR3AUwCM/78A+cB+gPnAIsD5wHlAukAewLpAEYC6QBzAukAfwLpAJMC6QBqAukAcwQAAAAIAAAABAAAAAgAAAACqgAAAgAAAAFWAAAEeQAAAjMAAAGaAAAAzQAAAAAAAAAAAAAIAABUCAAAVAIz/vwBiQBzBQwAUgRWALoG7ABkBt0ARAcbAC8Euv+HBKIAXgY7/zICqv+qAqwAzQeL/x8Hi/8fBfIAhwTRAF4F/ACYBVAAbQAA/Q4AAP3MAAD8mwAA/bAAAPyHBDUARgXPAEYEMwBeBLgAbwfnAIsGMQBmBPwAhwSeAEwG/gBGBb4ALwUU/4cEb/+TBw4ARgY5AC8Fj/+sBLr/lgeaAEYGgwAvBIP/tAPh/6IGMwC8BhcAgwXNAIcElgBeBNUAugPyAGIE1QC6A/IAYgmyAIcIQgBeBfwAhwTXAF4H5wCLBmAAXgfnAIsGMQBmBMkAhwO6AF4E3wBvBGABPwSJAVoEiQJqBIkCaAfpACkHpgApBhkARgTVAG0EkwBGBFYAeQSWAEYEsP/JA+UANQNiAAAFEgBGBEIALwb2/48HMf/jBIMAEAPXAAoFJQBEBIcALwSeAEQEPwBIBK4ARgQvAC8FRACwBNUATAXFAEYFCAAvBhkARgWYAC8IHQBGBroALwXNAIcE2QBeBMkAhwO6AF4EHQCwBz0ALwREALoD5QBkBEQAXAPl/9MFCv+RBG//xwZ1ALAFWgBaBYkA1wS6AKAFPwDXBKIAoAU/AEQEuAAvBi0AXgUEADEGLQBeBQQAMQLN/88Gkf+PBy3/4wVIAEYEhwAvBaT/wQTH/7IFgwBGBNsALwXNAEYFCAAvBT8A1wSwALYHJwBEBhsAKQLN/88Euv+HBKIAXgS6/4cEogBeBtn/hwa+AF4ENQBGBDMAXgVIAEwEMwA3BUgATAQzADcGkf+PBy3/4wSDABAD1wAKBFIABgQC/40FzwBGBLgAbwXPAEYEuABvBc0AhwSWAF4FzQCHBJYAXgXNAIcElgBeBMkAFwPBABkErgAMA+z/VgSuAAwD7P9WBK4ADAPs/1YFPwDZBJoAoAPpAEYDYgAvBo8ARgYZAHUD5QApA2IAAATN/5EERv+oBH//kQQI/6oElgBOBK4AXgbHAFIG5QBeBssA3QY7AI8E5wC8BEoApAd//8EGz/+y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AC8ALwB3AHcAdwAuAGEAcABhAGMAaABlAC4AbwByAGcALwBsAGkAYwBlAG4AcwBlAHMALwBMAEkAQwBFAE4AUwBFAC0AMgAuADAAAAACAAD/9AAA/2YAZgAAAAAAAAAAAAAAAAAAAAAAAAAAA6gAAAECAAIAAwAEAAUABgAHAAgACQAKAAsADAANAA4ADwAQABEAEgATABQAFQAWABcAGAAZABoAGwAcAB0AHgAfACAAIQAiACMAJAAlACYAJwAoACkAKgArAQMALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADsAPAA9AD4APwBAAEEAQgBDAEQARQBGAEcASABJAEoASwBMAE0ATgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwAXQBeAF8AYABhAKwAowCEAIUAvQCWAOgAhgCOAIsAnQCpAKQBBACKAQUAgwCTAPIA8wCNAJcAiADDAN4A8QCeAKoA9QD0APYAogCtAMkAxwCuAGIAYwCQAGQAywBlAMgAygEGAQcBCAEJAOkAZgDTANAA0QCvAGcA8ACRANYA1ADVAGgA6wDtAIkAagBpAGsAbQBsAG4AoABvAHEAcAByAHMAdQB0AHYAdwDqAHgAegB5AHsAfQB8ALgAoQB/AH4AgACBAOwA7gC6AQoBCwEMAQ0BDgEPAP0A/gEQAREBEgETAP8BAAEUARUBFgEBARcBGAEZARoBGwEcAR0BHgEfASABIQEiAPgA+QEjASQBJQEmAScBKAEpASoBKwEsAS0BLgEvATABMQEyATMA1wE0ATUBNgE3ATgBOQE6ATsBPAE9AT4BPwFAAUEBQgDiAOMBQwFEAUUBRgFHAUgBSQFKAUsBTAFNAU4BTwFQAVEAsACxAVIBUwFUAVUBVgFXAVgBWQFaAVsA+wD8AOQA5QFcAV0BXgFfAWABYQFiAWMBZAFlAWYBZwFoAWkBagFrAWwBbQFuAW8BcAFxALsBcgFzAXQBdQDmAOcBdgCmAXcBeAF5AXoBewF8AX0BfgDYAOEA2gDbANwA3QDgANkA3wF/AYABgQGCAYMBhAGFAYYBhwGIAYkBigGLAYwBjQGOAY8BkAGRAZIBkwGUAZUBlgGXAZgBmQGaAZsBnAGdAZ4BnwGgAaEBogGjAaQBpQGmAacBqAGpAaoBqwGsAa0BrgGvAbABsQGyAbMBtAG1AbYBtwCbAbgBuQG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHGAccByAHJAcoBywHMAc0BzgHPAdAB0QHSAdMB1AHVAdYB1wHYAdkB2gHbAdwB3QHeAd8B4AHhAeIB4wHkAeUB5gHnAegB6QHqAesB7AHtAe4B7wHwAfEB8gHzAfQB9QH2AfcB+AH5AfoB+wH8Af0B/gH/AgACAQICAgMCBAIFAgYCBwIIAgkCCgILAgwCDQIOAg8CEAIRAhICEwIUAhUCFgIXAhgCGQIaAhsCHAIdAh4CHwIgAiECIgIjAiQCJQImAicCKAIpAioCKwCyALMCLAItALYAtwDEAi4AtAC1AMUAggDCAIcAqwDGAi8CMAC+AL8CMQC8AjIA9wIzAjQCNQI2AjcCOACMAJ8COQI6AjsCPAI9AJgAqACaAJkA7wClAJIAnACnAI8AlACVALkCPgI/AkACQQJCAkMCRAJFAkYCRwJIAkkCSgJLAkwCTQJOAk8CUAJRAlICUwJUAlUCVgJXAlgCWQJaAlsCXAJdAl4CXwJgAmECYgJjAmQCZQJmAmcCaAJpAmoCawJsAm0CbgJvAnACcQJyAnMCdAJ1AnYCdwJ4AnkCegJ7AnwCfQJ+An8CgAKBAoICgwKEAoUChgKHAogCiQKKAosCjAKNAo4CjwKQApECkgKTApQClQKWApcCmAKZApoCmwKcAp0CngKfAqACoQKiAqMCpAKlAqYCpwKoAqkCqgKrAqwCrQKuAq8CsAKxArICswK0ArUCtgK3ArgCuQK6ArsCvAK9Ar4CvwLAAsECwgLDAsQCxQLGAscCyALJAsoCywLMAs0CzgLPAtAC0QLSAtMC1ALVAtYC1wLYAtkC2gLbAtwC3QLeAt8C4ALhAuIC4wLkAuUC5gLnAugC6QLqAusC7ALtAu4C7wLwAvEC8gLzAvQC9QL2AvcC+AL5AvoC+wL8Av0C/gL/AwADAQMCAwMDBAMFAwYDBwMIAwkDCgMLAwwDDQMOAw8DEAMRAxIDEwMUAxUDFgMXAxgDGQMaAxsDHAMdAx4DHwMgAyEDIgMjAyQDJQMmAycDKAMpAyoDKwMsAy0DLgMvAzADMQMyAzMDNAM1AzYDNwM4AzkDOgM7AzwDPQM+Az8DQANBA0IDQwNEA0UDRgNHA0gDSQNKA0sDTANNA04DTwNQA1EDUgNTA1QDVQNWA1cDWANZA1oDWwNcA10DXgNfA2ADYQNiA2MDZANlA2YDZwNoA2kDagNrA2wDbQNuA28DcANxA3IDcwN0A3UDdgN3A3gDeQN6A3sDfAN9A34DfwOAA4EDggODA4QDhQOGA4cDiAOJA4oDiwOMA40DjgOPA5ADkQOSA5MDlAOVA5YDlwOYA5kDmgObA5wDnQAsAM8AzADNAM4DngOfA6ADoQD6A6IDowOkA6UDpgOnA6gDqQOqA6sEbnVsbAVJLmFsdAd1bmkwMEFECW92ZXJzY29yZQpJZ3JhdmUuYWx0CklhY3V0ZS5hbHQPSWNpcmN1bWZsZXguYWx0DUlkaWVyZXNpcy5hbHQHQW1hY3JvbgdhbWFjcm9uBkFicmV2ZQZhYnJldmUHQW9nb25lawdhb2dvbmVrC0NjaXJjdW1mbGV4C2NjaXJjdW1mbGV4BENkb3QEY2RvdAZEY2Fyb24GZGNhcm9uBkRjcm9hdAdFbWFjcm9uB2VtYWNyb24GRWJyZXZlBmVicmV2ZQpFZG90YWNjZW50CmVkb3RhY2NlbnQHRW9nb25lawdlb2dvbmVrBkVjYXJvbgZlY2Fyb24LR2NpcmN1bWZsZXgLZ2NpcmN1bWZsZXgER2RvdARnZG90DEdjb21tYWFjY2VudAxnY29tbWFhY2NlbnQLSGNpcmN1bWZsZXgLaGNpcmN1bWZsZXgESGJhcgRoYmFyCkl0aWxkZS5hbHQGaXRpbGRlC0ltYWNyb24uYWx0B2ltYWNyb24KSWJyZXZlLmFsdAZpYnJldmULSW9nb25lay5hbHQHaW9nb25law5JZG90YWNjZW50LmFsdAZJSi5hbHQCaWoLSmNpcmN1bWZsZXgLamNpcmN1bWZsZXgMS2NvbW1hYWNjZW50DGtjb21tYWFjY2VudAxrZ3JlZW5sYW5kaWMGTGFjdXRlBmxhY3V0ZQxMY29tbWFhY2NlbnQMbGNvbW1hYWNjZW50BkxjYXJvbgZsY2Fyb24ETGRvdARsZG90Bk5hY3V0ZQZuYWN1dGUMTmNvbW1hYWNjZW50DG5jb21tYWFjY2VudAZOY2Fyb24GbmNhcm9uC25hcG9zdHJvcGhlA0VuZwNlbmcHT21hY3JvbgdvbWFjcm9uBk9icmV2ZQZvYnJldmUNT2h1bmdhcnVtbGF1dA1vaHVuZ2FydW1sYXV0BlJhY3V0ZQZyYWN1dGUMUmNvbW1hYWNjZW50DHJjb21tYWFjY2VudAZSY2Fyb24GcmNhcm9uBlNhY3V0ZQZzYWN1dGULU2NpcmN1bWZsZXgLc2NpcmN1bWZsZXgMVGNvbW1hYWNjZW50DHRjb21tYWFjY2VudAZUY2Fyb24GdGNhcm9uBFRiYXIEdGJhcgZVdGlsZGUGdXRpbGRlB1VtYWNyb24HdW1hY3JvbgZVYnJldmUGdWJyZXZlBVVyaW5nBXVyaW5nDVVodW5nYXJ1bWxhdXQNdWh1bmdhcnVtbGF1dAdVb2dvbmVrB3VvZ29uZWsLV2NpcmN1bWZsZXgLd2NpcmN1bWZsZXgLWWNpcmN1bWZsZXgLeWNpcmN1bWZsZXgGWmFjdXRlBnphY3V0ZQpaZG90YWNjZW50Cnpkb3RhY2NlbnQFbG9uZ3MKQXJpbmdhY3V0ZQphcmluZ2FjdXRlB0FFYWN1dGUHYWVhY3V0ZQtPc2xhc2hhY3V0ZQtvc2xhc2hhY3V0ZQxTY29tbWFhY2NlbnQMc2NvbW1hYWNjZW50BXRvbm9zDWRpZXJlc2lzdG9ub3MKQWxwaGF0b25vcwlhbm90ZWxlaWEMRXBzaWxvbnRvbm9zCEV0YXRvbm9zDUlvdGF0b25vcy5hbHQMT21pY3JvbnRvbm9zDFVwc2lsb250b25vcwpPbWVnYXRvbm9zEWlvdGFkaWVyZXNpc3Rvbm9zBUFscGhhBEJldGEFR2FtbWEHdW5pMDM5NAdFcHNpbG9uBFpldGEDRXRhBVRoZXRhCElvdGEuYWx0BUthcHBhBkxhbWJkYQJNdQJOdQJYaQdPbWljcm9uAlBpA1JobwVTaWdtYQNUYXUHVXBzaWxvbgNQaGkDQ2hpA1BzaQd1bmkwM0E5EElvdGFkaWVyZXNpcy5hbHQPVXBzaWxvbmRpZXJlc2lzCmFscGhhdG9ub3MMZXBzaWxvbnRvbm9zCGV0YXRvbm9zCWlvdGF0b25vcxR1cHNpbG9uZGllcmVzaXN0b25vcwVhbHBoYQRiZXRhBWdhbW1hBWRlbHRhB2Vwc2lsb24EemV0YQNldGEFdGhldGEEaW90YQVrYXBwYQZsYW1iZGEHdW5pMDNCQwJudQJ4aQdvbWljcm9uA3JobwZzaWdtYTEFc2lnbWEDdGF1B3Vwc2lsb24DcGhpA2NoaQNwc2kFb21lZ2EMaW90YWRpZXJlc2lzD3Vwc2lsb25kaWVyZXNpcwxvbWljcm9udG9ub3MMdXBzaWxvbnRvbm9zCm9tZWdhdG9ub3MJYWZpaTEwMDIzCWFmaWkxMDA1MQlhZmlpMTAwNTIJYWZpaTEwMDUzCWFmaWkxMDA1NA1hZmlpMTAwNTUuYWx0DWFmaWkxMDA1Ni5hbHQJYWZpaTEwMDU3CWFmaWkxMDA1OAlhZmlpMTAwNTkJYWZpaTEwMDYwCWFmaWkxMDA2MQlhZmlpMTAwNjIJYWZpaTEwMTQ1CWFmaWkxMDAxNwlhZmlpMTAwMTgJYWZpaTEwMDE5CWFmaWkxMDAyMAlhZmlpMTAwMjEJYWZpaTEwMDIyCWFmaWkxMDAyNAlhZmlpMTAwMjUJYWZpaTEwMDI2CWFmaWkxMDAyNwlhZmlpMTAwMjgJYWZpaTEwMDI5CWFmaWkxMDAzMAlhZmlpMTAwMzEJYWZpaTEwMDMyCWFmaWkxMDAzMwlhZmlpMTAwMzQJYWZpaTEwMDM1CWFmaWkxMDAzNglhZmlpMTAwMzcJYWZpaTEwMDM4CWFmaWkxMDAzOQlhZmlpMTAwNDAJYWZpaTEwMDQxCWFmaWkxMDA0MglhZmlpMTAwNDMJYWZpaTEwMDQ0CWFmaWkxMDA0NQlhZmlpMTAwNDYJYWZpaTEwMDQ3CWFmaWkxMDA0OAlhZmlpMTAwNDkJYWZpaTEwMDY1CWFmaWkxMDA2NglhZmlpMTAwNjcJYWZpaTEwMDY4CWFmaWkxMDA2OQlhZmlpMTAwNzAJYWZpaTEwMDcyCWFmaWkxMDA3MwlhZmlpMTAwNzQJYWZpaTEwMDc1CWFmaWkxMDA3NglhZmlpMTAwNzcJYWZpaTEwMDc4CWFmaWkxMDA3OQlhZmlpMTAwODAJYWZpaTEwMDgxCWFmaWkxMDA4MglhZmlpMTAwODMJYWZpaTEwMDg0CWFmaWkxMDA4NQlhZmlpMTAwODYJYWZpaTEwMDg3CWFmaWkxMDA4OAlhZmlpMTAwODkJYWZpaTEwMDkwCWFmaWkxMDA5MQlhZmlpMTAwOTIJYWZpaTEwMDkzCWFmaWkxMDA5NAlhZmlpMTAwOTUJYWZpaTEwMDk2CWFmaWkxMDA5NwlhZmlpMTAwNzEJYWZpaTEwMDk5CWFmaWkxMDEwMAlhZmlpMTAxMDEJYWZpaTEwMTAyCWFmaWkxMDEwMwlhZmlpMTAxMDQJYWZpaTEwMTA1CWFmaWkxMDEwNglhZmlpMTAxMDcJYWZpaTEwMTA4CWFmaWkxMDEwOQlhZmlpMTAxMTAJYWZpaTEwMTkzCWFmaWkxMDA1MAlhZmlpMTAwOTgGV2dyYXZlBndncmF2ZQZXYWN1dGUGd2FjdXRlCVdkaWVyZXNpcwl3ZGllcmVzaXMGWWdyYXZlBnlncmF2ZQlhZmlpMDAyMDgNdW5kZXJzY29yZWRibA1xdW90ZXJldmVyc2VkBm1pbnV0ZQZzZWNvbmQJZXhjbGFtZGJsCW5zdXBlcmlvcglhZmlpMDg5NDEGcGVzZXRhBEV1cm8JYWZpaTYxMjQ4CWFmaWk2MTI4OQlhZmlpNjEzNTIJZXN0aW1hdGVkCW9uZWVpZ2h0aAx0aHJlZWVpZ2h0aHMLZml2ZWVpZ2h0aHMMc2V2ZW5laWdodGhzB3VuaUZCMDEHdW5pRkIwMg1jeXJpbGxpY2JyZXZlCGRvdGxlc3NqEGNhcm9uY29tbWFhY2NlbnQLY29tbWFhY2NlbnQRY29tbWFhY2NlbnRyb3RhdGUMemVyb3N1cGVyaW9yDGZvdXJzdXBlcmlvcgxmaXZlc3VwZXJpb3ILc2l4c3VwZXJpb3INc2V2ZW5zdXBlcmlvcg1laWdodHN1cGVyaW9yDG5pbmVzdXBlcmlvcgd1bmkyMDAwB3VuaTIwMDEHdW5pMjAwMgd1bmkyMDAzB3VuaTIwMDQHdW5pMjAwNQd1bmkyMDA2B3VuaTIwMDcHdW5pMjAwOAd1bmkyMDA5B3VuaTIwMEEHdW5pMjAwQgd1bmlGRUZGB3VuaUZGRkMHdW5pRkZGRAd1bmkwMUYwB3VuaTAyQkMHdW5pMDNEMQd1bmkwM0QyB3VuaTAzRDYHdW5pMUUzRQd1bmkxRTNGB3VuaTFFMDAHdW5pMUUwMQd1bmkxRjREB3VuaTAyRjMJZGFzaWFveGlhB3VuaUZCMDMHdW5pRkIwNAVPaG9ybgVvaG9ybgVVaG9ybgV1aG9ybgd1bmkwMzAwB3VuaTAzMDEHdW5pMDMwMwRob29rCGRvdGJlbG93B3VuaTA0MDAHdW5pMDQwRAd1bmkwNDUwB3VuaTA0NUQHdW5pMDQ2MAd1bmkwNDYxB3VuaTA0NjIHdW5pMDQ2Mwd1bmkwNDY0B3VuaTA0NjUHdW5pMDQ2Ngd1bmkwNDY3B3VuaTA0NjgHdW5pMDQ2OQd1bmkwNDZBB3VuaTA0NkIHdW5pMDQ2Qwd1bmkwNDZEB3VuaTA0NkUHdW5pMDQ2Rgd1bmkwNDcwB3VuaTA0NzEHdW5pMDQ3Mgd1bmkwNDczB3VuaTA0NzQHdW5pMDQ3NQd1bmkwNDc2B3VuaTA0NzcHdW5pMDQ3OAd1bmkwNDc5B3VuaTA0N0EHdW5pMDQ3Qgd1bmkwNDdDB3VuaTA0N0QHdW5pMDQ3RQd1bmkwNDdGB3VuaTA0ODAHdW5pMDQ4MQd1bmkwNDgyB3VuaTA0ODMHdW5pMDQ4NAd1bmkwNDg1B3VuaTA0ODYHdW5pMDQ4OAd1bmkwNDg5B3VuaTA0OEEHdW5pMDQ4Qgd1bmkwNDhDB3VuaTA0OEQHdW5pMDQ4RQd1bmkwNDhGB3VuaTA0OTIHdW5pMDQ5Mwd1bmkwNDk0B3VuaTA0OTUHdW5pMDQ5Ngd1bmkwNDk3B3VuaTA0OTgHdW5pMDQ5OQd1bmkwNDlBB3VuaTA0OUIHdW5pMDQ5Qwd1bmkwNDlEB3VuaTA0OUUHdW5pMDQ5Rgd1bmkwNEEwB3VuaTA0QTEHdW5pMDRBMgd1bmkwNEEzB3VuaTA0QTQHdW5pMDRBNQd1bmkwNEE2B3VuaTA0QTcHdW5pMDRBOAd1bmkwNEE5B3VuaTA0QUEHdW5pMDRBQgd1bmkwNEFDB3VuaTA0QUQHdW5pMDRBRQd1bmkwNEFGB3VuaTA0QjAHdW5pMDRCMQd1bmkwNEIyB3VuaTA0QjMHdW5pMDRCNAd1bmkwNEI1B3VuaTA0QjYHdW5pMDRCNwd1bmkwNEI4B3VuaTA0QjkHdW5pMDRCQQd1bmkwNEJCB3VuaTA0QkMHdW5pMDRCRAd1bmkwNEJFB3VuaTA0QkYLdW5pMDRDMC5hbHQHdW5pMDRDMQd1bmkwNEMyB3VuaTA0QzMHdW5pMDRDNAd1bmkwNEM1B3VuaTA0QzYHdW5pMDRDNwd1bmkwNEM4B3VuaTA0QzkHdW5pMDRDQQd1bmkwNENCB3VuaTA0Q0MHdW5pMDRDRAd1bmkwNENFC3VuaTA0Q0YuYWx0B3VuaTA0RDAHdW5pMDREMQd1bmkwNEQyB3VuaTA0RDMHdW5pMDRENAd1bmkwNEQ1B3VuaTA0RDYHdW5pMDRENwd1bmkwNEQ4B3VuaTA0RDkHdW5pMDREQQd1bmkwNERCB3VuaTA0REMHdW5pMDRERAd1bmkwNERFB3VuaTA0REYHdW5pMDRFMAd1bmkwNEUxB3VuaTA0RTIHdW5pMDRFMwd1bmkwNEU0B3VuaTA0RTUHdW5pMDRFNgd1bmkwNEU3B3VuaTA0RTgHdW5pMDRFOQd1bmkwNEVBB3VuaTA0RUIHdW5pMDRFQwd1bmkwNEVEB3VuaTA0RUUHdW5pMDRFRgd1bmkwNEYwB3VuaTA0RjEHdW5pMDRGMgd1bmkwNEYzB3VuaTA0RjQHdW5pMDRGNQd1bmkwNEY2B3VuaTA0RjcHdW5pMDRGOAd1bmkwNEY5B3VuaTA0RkEHdW5pMDRGQgd1bmkwNEZDB3VuaTA0RkQHdW5pMDRGRQd1bmkwNEZGB3VuaTA1MDAHdW5pMDUwMQd1bmkwNTAyB3VuaTA1MDMHdW5pMDUwNAd1bmkwNTA1B3VuaTA1MDYHdW5pMDUwNwd1bmkwNTA4B3VuaTA1MDkHdW5pMDUwQQd1bmkwNTBCB3VuaTA1MEMHdW5pMDUwRAd1bmkwNTBFB3VuaTA1MEYHdW5pMDUxMAd1bmkwNTExB3VuaTA1MTIHdW5pMDUxMwd1bmkxRUEwB3VuaTFFQTEHdW5pMUVBMgd1bmkxRUEzB3VuaTFFQTQHdW5pMUVBNQd1bmkxRUE2B3VuaTFFQTcHdW5pMUVBOAd1bmkxRUE5B3VuaTFFQUEHdW5pMUVBQgd1bmkxRUFDB3VuaTFFQUQHdW5pMUVBRQd1bmkxRUFGB3VuaTFFQjAHdW5pMUVCMQd1bmkxRUIyB3VuaTFFQjMHdW5pMUVCNAd1bmkxRUI1B3VuaTFFQjYHdW5pMUVCNwd1bmkxRUI4B3VuaTFFQjkHdW5pMUVCQQd1bmkxRUJCB3VuaTFFQkMHdW5pMUVCRAd1bmkxRUJFB3VuaTFFQkYHdW5pMUVDMAd1bmkxRUMxB3VuaTFFQzIHdW5pMUVDMwd1bmkxRUM0B3VuaTFFQzUHdW5pMUVDNgd1bmkxRUM3C3VuaTFFQzguYWx0B3VuaTFFQzkLdW5pMUVDQS5hbHQHdW5pMUVDQgd1bmkxRUNDB3VuaTFFQ0QHdW5pMUVDRQd1bmkxRUNGB3VuaTFFRDAHdW5pMUVEMQd1bmkxRUQyB3VuaTFFRDMHdW5pMUVENAd1bmkxRUQ1B3VuaTFFRDYHdW5pMUVENwd1bmkxRUQ4B3VuaTFFRDkHdW5pMUVEQQd1bmkxRURCB3VuaTFFREMHdW5pMUVERAd1bmkxRURFB3VuaTFFREYHdW5pMUVFMAd1bmkxRUUxB3VuaTFFRTIHdW5pMUVFMwd1bmkxRUU0B3VuaTFFRTUHdW5pMUVFNgd1bmkxRUU3B3VuaTFFRTgHdW5pMUVFOQd1bmkxRUVBB3VuaTFFRUIHdW5pMUVFQwd1bmkxRUVEB3VuaTFFRUUHdW5pMUVFRgd1bmkxRUYwB3VuaTFFRjEHdW5pMUVGNAd1bmkxRUY1B3VuaTFFRjYHdW5pMUVGNwd1bmkxRUY4B3VuaTFFRjkHdW5pMjBBQgd1bmkwMzBGE2NpcmN1bWZsZXhhY3V0ZWNvbWITY2lyY3VtZmxleGdyYXZlY29tYhJjaXJjdW1mbGV4aG9va2NvbWITY2lyY3VtZmxleHRpbGRlY29tYg5icmV2ZWFjdXRlY29tYg5icmV2ZWdyYXZlY29tYg1icmV2ZWhvb2tjb21iDmJyZXZldGlsZGVjb21iEGN5cmlsbGljaG9va2xlZnQIb25lLnBudW0HemVyby5vcwZvbmUub3MGdHdvLm9zCHRocmVlLm9zB2ZvdXIub3MHZml2ZS5vcwZzaXgub3MIc2V2ZW4ub3MIZWlnaHQub3MHbmluZS5vcwJmZgd1bmkyMTIwCFRjZWRpbGxhCHRjZWRpbGxhBWcuYWx0D2djaXJjdW1mbGV4LmFsdApnYnJldmUuYWx0CGdkb3QuYWx0EGdjb21tYWFjY2VudC5hbHQGSXRpbGRlB0ltYWNyb24GSWJyZXZlB0lvZ29uZWsCSUoJSW90YXRvbm9zBElvdGEMSW90YWRpZXJlc2lzCWFmaWkxMDA1NQlhZmlpMTAwNTYHdW5pMDRDMAd1bmkwNENGB3VuaTFFQzgHdW5pMUVDQQAAAQACAAgACv//AA8AAQAAAAwAAAAAAAAAAgAFAAACNQABAjcCNwABAjsCWwABAl0DdgABA4ADpwABAAAAAQAAAAoADAAOAAAAAAAAAAEAAAAKAG4BWgABbGF0bgAIABAAAk1PTCAAKFJPTSAAQgAA//8ACQADAAgACwAAAA4AEQAUABcAGgAA//8ACgAEAAYACQAMAAEADwASABUAGAAbAAD//wAKAAUABwAKAA0AAgAQABMAFgAZABwAHWxpZ2EAsGxpZ2EAsGxpZ2EAsGxudW0AtmxudW0AtmxudW0AtmxvY2wAvGxvY2wAvG9udW0Awm9udW0Awm9udW0AwnBudW0AynBudW0AynBudW0AynNhbHQA0HNhbHQA0HNhbHQA0HNzMDEA0HNzMDEA0HNzMDEA0HNzMDIA2HNzMDIA2HNzMDIA2HNzMDMA3nNzMDMA3nNzMDMA3nRudW0A5HRudW0A5HRudW0A5AAAAAEACQAAAAEABwAAAAEACAAAAAIAAgADAAAAAQAEAAAAAgAAAAEAAAABAAAAAAABAAEAAAACAAUABgAKABYAPAB8AJQAzADgAO4BAgEuAVAAAQAAAAEACAACABAABQOPA5ADkQOSA5MAAQAFAEoA3wDhAOMA5QABAAAAAQAIAAIALgAUACwAjgCPAJAAkQDqAOwA7gDwAPIA9AFaAWcBdwGhAaICyQLYA0UDRwACAAEDlAOnAAAAAQAAAAEACAABAAYDbgACAAEAEwAcAAAAAQAAAAEACAACABoACgOBA4MDhAOFA4YDhwOIA4kDigOCAAIAAwATABMAAAAVABwAAQOAA4AACQABAAAAAQAIAAEABgNsAAEAAQAUAAEAAAABAAgAAQA8/JIAAQAAAAEACAABAAb8lAABAAEDgAABAAAAAQAIAAIAGgAKABMDgAAVABYAFwAYABkAGgAbABwAAgABA4EDigAAAAEAAAABAAgAAgAOAAQDjQOOASABIQABAAQBJAElAUkBSgAEAAAAAQAIAAEANgABAAgABQAMABQAHAAiACgCXgADAEkATwJdAAMASQBMA4sAAgBJAjUAAgBPAjQAAgBMAAEAAQBJAAA=";

var sourceCodeProRegular = "data:font/ttf;base64,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BXj6iAABAN7+cAF6A+gAAwALALoAAQAAAAMrMDETETMR3pz+cAV4+ogAAwAhAQUCNwFTAAMABwALAC0AuwABAAEAAAAEK7gAABC4AATQuAABELgABdC4AAAQuAAI0LgAARC4AAnQMDEBNTMVITUzFSE1MxUBsYb+sob+soYBBU5OTk5OTgADACEA3gI3AXoAAwAHAAsAKwC6AAEAAAADK7gAABC4AATQuAABELgABdC4AAAQuAAI0LgAARC4AAnQMDElNTMVITUzFSE1MxUBsYb+sob+sobenJycnJycAAMBBf8XAVMDQQADAAcACwALALoAAQAAAAMrMDEBETMRAxEzEQMRMxEBBU5OTk5OAjcBCv72/nABCv72/nABCv72AAMA3v8XAXoDQQADAAcACwAbALoACQAIAAMrugABAAAAAyu6AAUABAADKzAxExEzEQMRMxEDETMR3pycnJycAjcBCv72/nABCv72/nABCv72AAQAEwEFAkUBUwADAAcACwAPAD0AuwABAAEAAAAEK7gAABC4AATQuAABELgABdC4AAAQuAAI0LgAARC4AAnQuAAAELgADNC4AAEQuAAN0DAxATUzFSE1MxUhNTMVITUzFQHVcP76cP76cP76cAEFTk5OTk5OTk4ABAATAN4CRQF6AAMABwALAA8AOwC6AAEAAAADK7gAABC4AATQuAABELgABdC4AAAQuAAI0LgAARC4AAnQuAAAELgADNC4AAEQuAAN0DAxJTUzFSE1MxUhNTMVITUzFQHVcP76cP76cP76cN6cnJycnJycnAAEAQX++QFTA18AAwAHAAsADwAjALoADQAMAAMrugABAAAAAyu6AAkACAADK7oABQAEAAMrMDEBNTMVAzUzFQM1MxUDNTMVAQVOTk5OTk5OAn7h4f7U4eH+1OHh/tPh4QAEAN7++QF6A18AAwAHAAsADwAjALoADQAMAAMrugABAAAAAyu6AAkACAADK7oABQAEAAMrMDETNTMVAzUzFQM1MxUDNTMV3pycnJycnJwCfuHh/tTh4f7U4eH+0+HhAAEBBf5wAn8BUwAFAA0AuwAFAAEAAAAEKzAxASERIxEhAn/+1E4BegEF/WsC4wABAQX+cAJ/AXoABQALALoABQAAAAMrMDElIREjESECf/7UTgF63v2SAwoAAQDe/nACfwFTAAUADQC7AAUAAQAAAAQrMDEBIREjESECf/77nAGhAQX9awLjAAEA3v5wAn8BegAFAAsAugAFAAAAAyswMSUhESMRIQJ//vucAaHe/ZIDCgAB/9n+cAFTAVMABQANALsABQABAAIABCswMQEjESE1IQFTTv7UAXr+cAKVTgAB/9n+cAFTAXoABQALALoABQACAAMrMDEBIxEhNSEBU07+1AF6/nACbpwAAf/Z/nABegFTAAUADQC7AAUAAQACAAQrMDEBIxEhNSEBepz++wGh/nAClU4AAf/Z/nABegF6AAUACwC6AAUAAgADKzAxASMRITUhAXqc/vsBof5wAm6cAAEBBQEFAn8D6AAFAA0AuwAFAAEAAAAEKzAxASERMxEhAn/+hk4BLAEFAuP9awABAQUA3gJ/A+gABQALALoABQAAAAMrMDElIREzESECf/6GTgEs3gMK/ZIAAQDeAQUCfwPoAAUADQC7AAMAAQAAAAQrMDETETMRIRXenAEFAQUC4/1rTgABAN4A3gJ/A+gABQALALoAAwAAAAMrMDE3ETMRIRXenAEF3gMK/ZKcAAH/2QEFAVMD6AAFAA0AuwADAAEAAAAEKzAxASE1IREzAVP+hgEsTgEFTgKVAAH/2QDeAVMD6AAFAAsAugADAAAAAyswMSUhNSERMwFT/oYBLE7enAJuAAH/2QEFAXoD6AAFAA0AuwABAAEAAAAEKzAxAzUhETMRJwEFnAEFTgKV/R0AAf/ZAN4BegPoAAUACwC6AAEAAAADKzAxJzUhETMRJwEFnN6cAm789gABAQX+cAJ/A+gABwANALsABwABAAAABCswMQEhESMRMxEhAn/+1E5OASwBBf1rBXj9awABAQX+cAJ/A+gABwALALoABwAAAAMrMDElIREjETMRIQJ//tROTgEs3v2SBXj9kgABAN7+cAJ/A+gACQAVALsACQABAAAABCu4AAAQuAAE0DAxASERIxEjETMRIQJ//tROJ5wBBQEF/WsClQLj/WsAAQDe/nACfwPoAAkAFQC7AAkAAQAAAAQruAAJELgABNAwMQEhESMRMxEzESECf/77nCdOASwBBf1rAuMClf1rAAEA3v5wAn8D6AAHAA0AuwAHAAEAAAAEKzAxASERIxEzESECf/77nJwBBQEF/WsFeP1rAAEA3v5wAn8D6AAJABMAugAJAAAAAyu4AAAQuAAE0DAxJSERIxEjETMRIQJ//tROJ5wBBd79kgJuAwr9kgABAN7+cAJ/A+gACQATALoACQAAAAMruAAJELgABNAwMSUhESMRMxEzESECf/77nCdOASze/ZIDCgJu/ZIAAQDe/nACfwPoAAcACwC6AAcAAAADKzAxJSERIxEzESECf/77nJwBBd79kgV4/ZIAAf/Z/nABUwPoAAcADQC7AAUAAQACAAQrMDEBIxEhNSERMwFTTv7UASxO/nAClU4ClQAB/9n+cAFTA+gABwALALoABQACAAMrMDEBIxEhNSERMwFTTv7UASxO/nACbpwCbgAB/9n+cAF6A+gACQAVALsABQABAAIABCu4AAIQuAAI0DAxASMRITUhETMRIwFTTv7UAQWcJ/5wApVOApX9HQAB/9n+cAF6A+gACQAVALsABQABAAIABCu4AAUQuAAI0DAxASMRITUhETMRMwF6nP77ASxOJ/5wApVOApX9awAB/9n+cAF6A+gABwANALsABQABAAIABCswMQEjESE1IREzAXqc/vsBBZz+cAKVTgKVAAH/2f5wAXoD6AAJABMAugAFAAIAAyu4AAIQuAAI0DAxASMRITUhETMRIwFTTv7UAQWcJ/5wAm6cAm789gAB/9n+cAF6A+gACQATALoABQACAAMruAAFELgACNAwMQEjESE1IREzETMBepz++wEsTif+cAJunAJu/ZIAAf/Z/nABegPoAAcACwC6AAUAAgADKzAxASMRITUhETMBepz++wEFnP5wAm6cAm4AAf/Z/nACfwFTAAcAFQC7AAcAAQAAAAQruAAAELgABNAwMQEhESMRITUhAn/+1E7+1AKmAQX9awKVTgAB/9n+cAJ/AXoACQAVALsABwABAAgABCu6AAUAAgADKzAxASMRITUhFSEVIQFTTv7UAXoBLP7U/nACbpwnTgAB/9n+cAJ/AXoACQAVALsABwABAAQABCu6AAkAAQADKzAxJSERIxEhNSE1IQJ//tRO/tQBLAF63v2SApVOJwAB/9n+cAJ/AXoABwATALoABwAAAAMruAAAELgABNAwMSUhESMRITUhAn/+1E7+1AKm3v2SAm6cAAH/2f5wAn8BUwAHABUAuwAHAAEAAAAEK7gAABC4AATQMDEBIREjESE1IQJ//vuc/vsCpgEF/WsClU4AAf/Z/nACfwF6AAkAFQC7AAkAAQAAAAQrugAHAAQAAyswMQEhESMRITUhFSECf/77nP77AaEBBQEF/WsCbpwnAAH/2f5wAn8BegAJABUAuwAHAAEABAAEK7oACAABAAMrMDElIREjESE1ITUhAn/++5z++wEFAaHe/ZIClU4nAAH/2f5wAn8BegAHABMAugAHAAAAAyu4AAAQuAAE0DAxJSERIxEhNSECf/77nP77Aqbe/ZICbpwAAf/ZAQUCfwPoAAcAFQC7AAcAAQAAAAQruAAHELgAAtAwMQEhNSERMxEhAn/9WgEsTgEsAQVOApX9awAB/9kA3gJ/A+gACQAVALsACQABAAAABCu6AAUAAgADKzAxASEVITUhETMRIQJ//tT+hgEsTgEsAQUnnAJu/WsAAf/ZAN4CfwPoAAkAFQC7AAUAAQACAAQrugAIAAEAAyswMSUhNSE1IREzESECf/6G/tQBLE4BLN4nTgKV/ZIAAf/ZAN4CfwPoAAcAEwC6AAcAAAADK7gABxC4AALQMDElITUhETMRIQJ//VoBLE4BLN6cAm79kgAB/9kBBQJ/A+gABwAVALsABwABAAAABCu4AAcQuAAC0DAxASE1IREzESECf/1aAQWcAQUBBU4Clf1rAAH/2QDeAn8D6AAJABUAuwAGAAEABwAEK7oAAgAJAAMrMDEnNSERMxEhFSEVJwEFnAEF/vvenAJu/WtOJwAB/9kA3gJ/A+gACQAVALsABAABAAEABCu6AAcAAAADKzAxNzUhNSERMxEhFd7++wEFnAEF3idOApX9kpwAAf/ZAN4CfwPoAAcAEwC6AAcAAAADK7gABxC4AALQMDElITUhETMRIQJ//VoBBZwBBd6cAm79kgAB/9n+cAJ/A+gACwAdALsACwABAAAABCu4AAAQuAAE0LgACxC4AAbQMDEBIREjESE1IREzESECf/7UTv7UASxOASwBBf1rApVOApX9awAB/9n+cAJ/A+gACwAVALoABwAEAAMruwALAAEAAAAEKzAxASERIxEhNSERMxEhAn/+1E7+1AEsTgEsAQX9awJunAJu/WsAAf/Z/nACfwPoAAsAFQC6AAsAAAADK7sABwABAAQABCswMSUhESMRITUhETMRIQJ//tRO/tQBLE4BLN79kgKVTgKV/ZIAAf/Z/nACfwPoAAsAGwC6AAsAAAADK7gAABC4AATQuAALELgABtAwMSUhESMRITUhETMRIQJ//tRO/tQBLE4BLN79kgJunAJu/ZIAAf/Z/nACfwPoAAsAHQC7AAsAAQAAAAQruAAAELgABNC4AAsQuAAG0DAxASERIxEhNSERMxEhAn/+1E7+1AEFnAEFAQX9awKVTgKV/WsAAf/Z/nACfwPoAAsAHQC7AAsAAQAAAAQruAAAELgABNC4AAsQuAAG0DAxASERIxEhNSERMxEhAn/++5z++wEsTgEsAQX9awKVTgKV/WsAAf/Z/nACfwPoAAsAHQC7AAsAAQAAAAQruAAAELgABNC4AAsQuAAG0DAxASERIxEhNSERMxEhAn/++5z++wEFnAEFAQX9awKVTgKV/WsAAf/Z/nACfwPoAA0AHQC6AAcABAADK7sACwABAAwABCu4AAQQuAAA0DAxJSMRIxEhNSERMxEhFSEBeidO/tQBBZwBBf773v2SAm6cAm79a04AAf/Z/nACfwPoAA0AHQC6AA0AAAADK7sACQABAAYABCu4AAAQuAAE0DAxJSERIxEjNSE1IREzESECf/7UTif++wEFnAEF3v2SAm4nTgKV/ZIAAf/Z/nACfwPoAA0AHQC6AAUAAgADK7sACwABAAwABCu4AAUQuAAI0DAxASMRITUhETMRMxUhFSEBepz++wEsTicBBf77/nACbpwCbv2SJ04AAf/Z/nACfwPoAA0AHQC6AA0AAAADK7sABwABAAQABCu4AA0QuAAI0DAxJSERIxEhNSE1MxEzESECf/77nP77AQUnTgEs3v2SApVOJwJu/ZIAAf/Z/nACfwPoAAsAGwC6AAsAAAADK7gAABC4AATQuAALELgABtAwMSUhESMRITUhETMRIQJ//tRO/tQBBZwBBd79kgJunAJu/ZIAAf/Z/nACfwPoAAsAGwC6AAsAAAADK7gAABC4AATQuAALELgABtAwMSUhESMRITUhETMRIQJ//vuc/vsBLE4BLN79kgJunAJu/ZIAAf/Z/nACfwPoAAsAFQC6AAcABAADK7sACwABAAAABCswMQEhESMRITUhETMRIQJ//vuc/vsBBZwBBQEF/WsCbpwCbv1rAAH/2f5wAn8D6AALABUAugALAAAAAyu7AAcAAQAEAAQrMDElIREjESE1IREzESECf/77nP77AQWcAQXe/ZIClU4Clf2SAAH/2f5wAn8D6AALABsAugALAAAAAyu4AAAQuAAE0LgACxC4AAbQMDElIREjESE1IREzESECf/77nP77AQWcAQXe/ZICbpwCbv2SAAIASwEFAg0BUwADAAcAHQC7AAEAAQAAAAQruAAAELgABNC4AAEQuAAF0DAxATUzFSE1MxUBd5b+PpYBBU5OTk4AAgBLAN4CDQF6AAMABwAbALoAAQAAAAMruAAAELgABNC4AAEQuAAF0DAxJTUzFSE1MxUBd5b+PpbenJycnAACAQX/agFTAu4AAwAHAAsAugABAAQAAyswMQERMxEDETMRAQVOTk4BwgEs/tT9qAEs/tQAAgDe/2oBegLuAAMABwALALoAAQAAAAMrMDETETMRAxEzEd6cnJwBwgEs/tT9qAEs/tQAAv/ZALcCfwGhAAMABwAXALsABQABAAQABCu7AAEAAQAAAAQrMDEDNSEVBTUhFScCpv1aAqYBU05OnE5OAAIAt/5wAaED6AADAAcAGwC6AAEAAAADK7gAABC4AATQuAABELgABdAwMQERMxEjETMRAVNO6k7+cAV4+ogFePqIAAEBBf5wAn8BoQAJABcAuwAFAAEABgAEK7sACQABAAAABCswMSUhESMRIRUhFSECf/7UTgF6/tQBLLf9uQMxTk4AAQC3/nACfwFTAAkAFQC7AAUAAQACAAQruAACELgAB9AwMQERIxEjESEVIxEBU05OAcje/nAClf1rAuNO/WsAAgC3/nACfwGhAAUACwAXALsABQABAAAABCu7AAsAAQAGAAQrMDEBIREjESEVIxEjESECf/6GTgHI3k4BLAFT/R0DMer9uQKVAAH/2f5wAVMBoQAJABcAuwAJAAEABgAEK7sABQABAAIABCswMQEjESE1ITUhNSEBU07+1AEs/tQBev5wAkdOTk4AAf/Z/nABoQFTAAkAFQC7AAgAAQABAAQruAABELgABdAwMQERIxEjESM1IREBU05O3gHI/nAClf1rApVO/R0AAv/Z/nABoQGhAAUACwAXALsABQABAAIABCu7AAsAAQAIAAQrMDEBIxEhNSEDIxEjNSEBoU7+hgHInE7eASz+cALjTvzPAkdOAAEBBQC3An8D6AAJABcAuwAHAAEAAAAEK7sABAABAAUABCswMSURMxEhFSEVIRUBBU4BLP7UASy3AzH9uU5OTgABALcBBQJ/A+gACQAVALsAAwABAAAABCu4AAMQuAAH0DAxExEzETMRMxEzFbdOTk7eAQUC4/1rApX9a04AAgC3ALcCfwPoAAUACwAXALsACQABAAYABCu7AAMAAQAAAAQrMDEBETMRMxUFETMRIRUBU07e/jhOAXoBUwKV/blOnAMx/R1OAAH/2QC3AVMD6AAJABcAuwADAAEAAAAEK7sABwABAAQABCswMSUhNSE1ITUhETMBU/6GASz+1AEsTrdOTk4CRwAB/9kBBQGhA+gACQAVALsABwABAAAABCu4AAcQuAAC0DAxASE1MxEzETMRMwGh/jjeTk5OAQVOApX9awKVAAL/2QC3AaED6AAFAAsAFwC7AAkAAQAGAAQruwADAAEAAAAEKzAxASE1MxEzEyE1IREzAQX+1N5OnP44AXpOAVNOAkf8z04C4wABAQX+cAJ/A+gACwAXALsACwABAAAABCu7AAcAAQAIAAQrMDElIREjETMRIRUhFSECf/7UTk4BLP7UASy3/bkFeP25Tk4AAgC3/nACfwPoAAMACwANALsACwABAAQABCswMRMRMxEBIxEjETMRM7dOAXreTk7e/nAFePqIApX9awV4/WsAAwC3/nACfwPoAAMACQAPABcAuwAPAAEACgAEK7sABwABAAQABCswMRMRMxETETMRMxUVIxEjESG3Tk5O3t5OASz+cAV4+ogC4wKV/blOnP25ApUAAf/Z/nABUwPoAAsAFwC7AAUAAQACAAQruwAJAAEABgAEKzAxASMRITUhNSE1IREzAVNO/tQBLP7UASxO/nACR05OTgJHAAL/2f5wAaED6AADAAsADQC7AAkAAQAGAAQrMDEBETMRIyMRIzUzETMBU06cTt7eTv5wBXj6iAKVTgKVAAP/2f5wAaED6AADAAkADwAXALsADwABAAwABCu7AAcAAQAEAAQrMDEBETMRAyE1MxEzESMRIzUhAVNOnP7U3k5O3gEs/nAFePqIAuNOAkf6iAJHTgAC/9n+cAJ/AaEAAwALAB8AuwABAAEAAAAEK7sACwABAAQABCu4AAQQuAAI0DAxAzUhFRUhESMRITUhJwKm/tRO/tQCpgFTTk6c/bkCR04AAf/Z/nACfwFTAAsAHQC7AAgAAQAJAAQruAAJELgAAdC4AAkQuAAF0DAxAREjESMRIzUhFSMRAVNOTt4Cpt7+cAKV/WsC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IyImJzQ2MzIWFRQGIyImJzQ2MzIWFRQGIyImBTQ2MzIWFRQGIyImJzQ2MzIWFRQGIyImJzQ2MzIWFRQGIyImBTQ2MzIWFRQGIyImJzQ2MzIWFRQGIyImJzQ2MzIWFRQGIyImBTQ2MzIWFRQGIyImJzQ2MzIWFRQGIyImJzQ2MzIWFRQGIyImBTQ2MzIWFRQGIyImJzQ2MzIWFRQGIyImJzQ2MzIWFRQGIyImBTQ2MzIWFRQGIyImJzQ2MzIWFRQGIyImJzQ2MzIWFRQGIyImBTQ2MzIWFRQGIyImJzQ2MzIWFRQGIyImJzQ2MzIWFRQGIyImAdAVDw8VFQ8PFcgVDw8VFQ8PFcgVDw8VFQ8PFQE4DgoKDg4KCg7IDgoKDg4KCg7IDgoKDg4KCg4B6BUPDxUVDw8VyBUPDxUVDw8VyBUPDxUVDw8VATgOCgoODgoKDsgOCgoODgoKDsgOCgoODgoKDgHoFQ8PFRUPDxXIFQ8PFRUPDxXIFQ8PFRUPDxUBOA4KCg4OCgoOyA4KCg4OCgoOyA4KCg4OCgoOAegVDw8VFQ8PFcgVDw8VFQ8PFcgVDw8VFQ8PFQE4DgoKDg4KCg7IDgoKDg4KCg7IDgoKDg4KCg4B6BUPDxUVDw8VyBUPDxUVDw8VyBUPDxUVDw8VATgOCgoODgoKDsgOCgoODgoKDsgOCgoODgoKDgHoFQ8PFRUPDxXIFQ8PFRUPDxXIFQ8PFRUPDxUBOA4KCg4OCgoOyA4KCg4OCgoOyA4KCg4OCgoOAegVDw8VFQ8PFcgVDw8VFQ8PFcgVDw8VFQ8PFQE4DgoKDg4KCg7IDgoKDg4KCg7IDgoKDg4KCg4DhA8VFQ8PFRUPDxUVDw8VFQ8PFRUPDxUVVQoODgoKDg4KCg4OCgoODgoKDg4KCg4OWg8VFQ8PFRUPDxUVDw8VFQ8PFRUPDxUVVQoODgoKDg4KCg4OCgoODgoKDg4KCg4OWg8VFQ8PFRUPDxUVDw8VFQ8PFRUPDxUVVQoODgoKDg4KCg4OCgoODgoKDg4KCg4OWg8VFQ8PFRUPDxUVDw8VFQ8PFRUPDxUVVQoODgoKDg4KCg4OCgoODgoKDg4KCg4OWg8VFQ8PFRUPDxUVDw8VFQ8PFRUPDxUVVQoODgoKDg4KCg4OCgoODgoKDg4KCg4OWg8VFQ8PFRUPDxUVDw8VFQ8PFRUPDxUV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NDYzMhYVFAYjIiYFNDYzMhYVFAYjIiYnNDYzMhYVFAYjIiYnNDYzMhYVFAYjIiYFNDYzMhYVFAYjIiYnNDYzMhYVFAYjIiYnNDYzMhYVFAYjIiYFNDYzMhYVFAYjIiYnNDYzMhYVFAYjIiYnNDYzMhYVFAYjIiYFNDYzMhYVFAYjIiYnNDYzMhYVFAYjIiYnNDYzMhYVFAYjIiYFNDYzMhYVFAYjIiYnNDYzMhYVFAYjIiYnNDYzMhYVFAYjIiYFNDYzMhYVFAYjIiYnNDYzMhYVFAYjIiYnNDYzMhYVFAYjIiYFNDYzMhYVFAYjIiYnNDYzMhYVFAYjIiYnNDYzMhYVFAYjIiYBoy8iIi8vIiIvyC8iIi8vIiIvyC8iIi8vIiIvAUcfFxcfHxcXH8gfFxcfHxcXH8gfFxcfHxcXHwHZLyIiLy8iIi/ILyIiLy8iIi/ILyIiLy8iIi8BRx8XFx8fFxcfyB8XFx8fFxcfyB8XFx8fFxcfAdkvIiIvLyIiL8gvIiIvLyIiL8gvIiIvLyIiLwFHHxcXHx8XFx/IHxcXHx8XFx/IHxcXHx8XFx8B2S8iIi8vIiIvyC8iIi8vIiIvyC8iIi8vIiIvAUcfFxcfHxcXH8gfFxcfHxcXH8gfFxcfHxcXHwHZLyIiLy8iIi/ILyIiLy8iIi/ILyIiLy8iIi8BRx8XFx8fFxcfyB8XFx8fFxcfyB8XFx8fFxcfAdkvIiIvLyIiL8gvIiIvLyIiL8gvIiIvLyIiLwFHHxcXHx8XFx/IHxcXHx8XFx/IHxcXHx8XFx8B2S8iIi8vIiIvyC8iIi8vIiIvyC8iIi8vIiIvAUcfFxcfHxcXH8gfFxcfHxcXH8gfFxcfHxcXHwOEIi8vIiIvLyIiLy8iIi8vIiIvLyIiLy9CFx8fFxcfHxcXHx8XFx8fFxcfHxcXHx9NIi8vIiIvLyIiLy8iIi8vIiIvLyIiLy9CFx8fFxcfHxcXHx8XFx8fFxcfHxcXHx9NIi8vIiIvLyIiLy8iIi8vIiIvLyIiLy9CFx8fFxcfHxcXHx8XFx8fFxcfHxcXHx9NIi8vIiIvLyIiLy8iIi8vIiIvLyIiLy9CFx8fFxcfHxcXHx8XFx8fFxcfHxcXHx9NIi8vIiIvLyIiLy8iIi8vIiIvLyIiLy9CFx8fFxcfHxcXHx8XFx8fFxcfHxcXHx9NIi8v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FhUUBgMyFhUUBiMiJjU0NgEyFRQGIyImNTQXMhYVFAYjIiY1NDYXMhYVFAYjIiY1NDYXMhUUIyImNTQ2FzIVFAYjIiY1NDYXMhUUBiMiJjU0FzIVFAYjIiY1NDYlMhYVFAYjIiY1NDYHMhYVFAYjIiY1NDYHMhYVFAYjIjU0BzIWFRQGIyImNTQHMhUUBiMiJjU0BzIWFRQGIyImNTQnMhYVFAYjIiY1NDY3MhYVFAYjIiY1NDYHMhYVFAYjIiY1NDYHMhYVFAYjIjU0JzIWFRQGIyImNTQ2FzIWFRQGIyImNTQ2FzIVFCMiJjU0NicyFRQjIjU0NzIWFRQGIyImNTQ2JyI1NDMyFRQXIiY1NDYzMhYVFAYHMhYVFAYjIiY1NDY3IiY1NDYzMhYVFAYXMhUUIyI1NCcyFhUUBiMiJjU0NjciNTQzMhUUByImNTQ2MzIWFRQGFzIWFRQGIyImNTQ2NyImNTQ2MzIWFRQGASwUFBT+6RQUFAMUFBQNCAwMCAkLCyIIDAwIFAoqCQsUFAsvCAwMCBQKATkJCxQUCw8UFBQlFBQUNQkLCwkIDAwzCgoUCAwMPAkLFBQLQQoKFAgMDEIJCwsJCQsL/wAUCwkJCxoJCwsJCQsLGgkLCwkJCwsqFBQIDAwzFAoKCAwMPBQLCQkLTBQKCggMDAFFCQsLCQkLCwgJCwsJCQsLGAgMDAgUFwgMDAgKCiAUCwkJCyQIDAwICgomCQsLCQkLC5kJCwsJCQsLGgkLCwkJCwsqCAwMCBS2CQsLCQkLCywJCwsJCQsLPBQUCAwMDBQUFDwJCwsJCQsLHxQUFBQJCwsJCQsLWQkLCwkJCwsJCQsLCQkLC7sUFBQUCQsLCQkLCzEUFBQ8CQsLCQkLC0cJCwsJCQsLCQkLCwkJCwsCQxQUFBTPFBQUFDsUFBQUMg0JCAwMCAkNKw0JCQsUCQ0eDQkUFAkNEg0JCQsUCQ3++A0JFBQJDUAUFBQUOxQUFBQyDQkIDAwICQ0rDQkUCwkJDR4NCRQUCQ0SDQkUCwkJDf4VDQkIDAwICQ0BDRYIDAwIFj4NCQgMDAgJDTsNCQgMDAgJDTQUFAsJCQsrFggMDAgLCx4WCAwMCBYSFggMDAgLC8oNCQgMDAgJDTsNCQgMDAgJDTQLCQkLFBQrCwsIDAwIFh4WCAwMCBYSCwsIDAwIFnkNCQgM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AAApfgAAKZQAACmqAAApwAAAKdYAACnsAAAqAgAAKiAAACo2AAAqTAAAKmIAACp4AAAqjgAAKqQAACq6AAAq0AAAKuYAACvZAAAr7wAALAUAACwdAAAsNQAALE0AAC0IAAAtHgAALTQAAC1KAAAtYAAALXYAAC2MAAAtogAALbgAAC5tAAAugwAALpsAAC6xAAAuxwAALt0AAC71AAAvDQAALyMAAC85AAAvTwAAL2cAAC+FAAAvnQAAL/wAADAUAAAwKgAAMEAAADBYAAAwbgAAMIQAADCaAAAwsAAAMMYAADDcAAAw9AAAMQwAADEiAAAxOAAAMU4AADFkAAAxegAAMZAAADGmAAAxvAAAMdIAADK0AAAyzAAAMuIAADL4AAAzDgAAMyQAADM6AAAzWAAANDcAADRNAAA0YwAANHkAADSPAAA0pwAANL0AADXWAAA17AAANpYAADasAAA2wgAANtgAADbuAAA3BgAANyQAADc8AAA3UgAAN2gAADd+AAA3lAAAN6oAADfAAAA32AAAOLoAADjQAAA45gAAOPwAADkUAAA5LAAAObUAADnLAAA54QAAOfcAADoNAAA6IwAAOjkAADpPAAA6ZQAAOnsAADqRAAA7WAAAO24AADuEAAA7mgAAO7AAADvIAAA73gAAPJAAADymAAA8vAAAPNIAADzoAAA9AAAAPRgAAD0uAAA9RAAAPVoAAD1wAAA9hgAAPZwAAD2yAAA9yAAAPd4AAD32AAA+DAAAPiIAAD44AAA+TgAAPmQAAD56AAA+kgAAPqoAAD9PAAA/0wAAQI8AAEFVAABB0AAAQm0AAEKNAABCowAAQrkAAELPAABC5QAAQvsAAEMRAABDJwAAQz0AAERuAABEhAAARbEAAEXJAABF3wAARfUAAEYLAABGIQAARjcAAEZVAABGawAARoEAAEaXAABGrQAARssAAEgkAABIOgAASFAAAEleAABJdgAASYwAAEmiAABJuAAASc4AAEnkAABK6wAASwMAAEsbAABLMQAATC0AAExDAABMWQAATG8AAEyFAABMmwAATLEAAEzHAABNzQAATeMAAE37AABOEQAATicAAE49AABOUwAATmkAAE5/AABOnQAATrMAAE7JAABO3wAATvUAAE8LAABPIQAATzcAAE9NAABPYwAAT3sAAE+TAABPqwAAT8MAAE/bAABP8wAAUKcAAFC9AABQ0wAAUOkAAFD/AABRFQAAUSsAAFFBAABRVwAAUW0AAFGLAABRoQAAUe4AAFIEAABSGgAAUjIAAFJKAABSzwAAUuUAAFL9AABTEwAAUysAAFNJAABTYQAAU+kAAFQBAABUFwAAVC0AAFRFAABUWwAAVHEAAFSHAABUnQAAVLMAAFTJAABU4QAAVPkAAFXNAABV4wAAVfkAAFYPAABWJQAAVjsAAFZRAABWZwAAVn0AAFduAABXhgAAV5wAAFeyAABXyAAAV94AAFf0AABYEgAAWCgAAFg+AABZJQAAWTsAAFlRAABZZwAAWX0AAFmVAABarwAAWsUAAFvmAABb/AAAXBIAAFwoAABcPgAAXFYAAFx0AABcjAAAXKIAAFy4AABczgAAXOQAAFz6AABdEAAAXSgAAF4ZAABeoAAAXrgAAF7OAABe5AAAXvwAAF8UAABfLAAAX/gAAGAOAABgJAAAYDoAAGBQAABgZgAAYHwAAGCSAABgqAAAYL4AAGDUAABhsQAAYccAAGHdAABh8wAAYgkAAGIhAABiNwAAYwoAAGMgAABjNgAAY0wAAGNiAABjegAAY5IAAGOoAABjvgAAY9QAAGPqAABkAAAAZBYAAGQsAABkQgAAZFgAAGRwAABkhgAAZJwAAGSyAABkyAAAZN4AAGT0AABlDAAAZSQAAGYbAABnDwAAZ94AAGhaAABpPwAAai0AAGrvAABr6gAAbNAAAG3qAABuhQAAb5oAAHCzAABxxQAAcokAAHNwAABzgAAAdEEAAHVpAAB2PwAAdk8AAHcvAAB32AAAeQIAAHoSAAB6wgAAe6MAAHyPAAB9NQAAfggAAH8IAAB/GAAAfy4AAH+YAAB/rgAAgD4AAIBWAACBLQAAgaMAAIKLAACC0wAAg7UAAIShAACFtAAAhoIAAIdQAACH5wAAiKIAAImSAACKhAAAixIAAIueAACMXAAAjSAAAI2LAACOKwAAjs4AAI/fAACQdQAAkSsAAJHCAACSaAAAkzQAAJQCAACUsAAAlR4AAJXoAACWkwAAlwUAAJeyAACYgQAAmU8AAJrWAACb1QAAnOwAAJ10AACd/gAAnqkAAJ9VAACf8AAAoMkAAKGDAAChkwAAoakAAKG/AACh1QAAoesAAKIBAACiFwAAoi0AAKJDAACjdAAAo4oAAKOiAACjuAAAo84AAKPkAACj+gAApBAAAKQuAACkRAAApFoAAKRwAACkhgAApKQAAKXNAACl3QAApfMAAKYJAACmHwAApjUAAKZLAACmYQAApncAAKaNAACmowAApwQAAKcaAACnMAAAp0YAAKdcAACncgAAp4gAAKeeAACntAAAp8oAAKfoAACn/gAAqBQAAKipAACpVQAAqdEAAKpjAACrSgAAq6sAAKvBAACr2QAAq+8AAKwHAACsJQAArD0AAKzNAACs5QAArdMAAK3rAACutQAArsUAAK7VAACvIgAAr5YAAK+mAACvtgAAr8YAALCNAACwnQAAsK0AALEYAACxKAAAsTgAALG0AACxxAAAshsAALIrAACyrAAAsrwAALLMAACzpQAAs7UAALRRAAC1JgAAtdIAALZgAAC27QAAt3QAALeKAAC4OgAAuMUAALjbAAC5ugAAutcAALv8AAC8nQAAvZUAAL5yAAC/QwAAv/4AAMDBAADBQAAAwgoAAMKkAADDkQAAxBgAAMVHAADF7wAAxqwAAMeCAADIOQAAyMAAAMlqAADKTwAAytsAAMu0AADMlwAAzU8AAM5UAADPPQAAz00AANA6AADQUAAA0GYAANB8AADQkgAA0KgAANC+AADQ1AAA0OoAANEAAADRFgAA0SwAANIUAADS0wAA034AANPmAADUYAAA1HgAANSKAADUnAAA1MUAANTrAADU+wAA1QsAANUbAADVdAAA1YQAANWUAADVpAAA1bQAANXEAADV1AAA1eQAANX0AADWBAAA1hQAANYkAADWNAAA1kQAANZUAADWZAAA1nQAANcKAADXGgAA1yoAANfpAADX+QAA2SYAANoAAADajQAA2qMAANtfAADb+wAA3AsAANwbAADcKwAA3DsAANxLAADcWwAA3GsAAN0DAADdxgAA3dYAAN5QAADe1gAA30UAAN/YAADgcwAA4Q8AAOGbAADiSgAA4yUAAOPHAADj3QAA4/MAAOTDAADk2QAA5YwAAOWcAADlrAAA5cIAAOXSAADmtwAA53sAAOgRAADoJwAA6D0AAOhTAADoywAA6W0AAOooAADqyQAA6yQAAOujAADs9AAA7fAAAO7UAADvlQAA8C4AAPDuAADw/gAA8Z8AAPJ6AADzJgAA87AAAPPAAADz1gAA8+wAAPP8AAD0EgAA9CIAAPQ4AAD0TgAA9F4AAPR0AAD0igAA9JoAAPWVAAD2WwAA9qgAAPdWAAD3ZgAA+HIAAPlEAAD52wAA+fEAAPqmAAD7NQAA/AMAAPx0AAD8hAAA/NoAAPzqAAD8+gAA/U8AAP1fAAD+4QAA/vEAAP9qAAD/8gABAGEAAQD0AAEBgAABAhwAAQKkAAEDUQABBCAAAQTCAAEE2AABBO4AAQXRAAEF5wABBpoAAQaqAAEGwAABBtYAAQbsAAEHwgABCG8AAQh/AAEIlQABCKsAAQjBAAEJMQABCesAAQn7AAEKmQABCvMAAQtvAAEMogABDZEAAQ5qAAEPIwABD7YAARB3AAEQ7AABEZUAARJsAAETFQABEyUAARM7AAETSwABE2EAARNxAAEThwABE5cAAROtAAETwwABE9MAARPpAAET/wABFA8AARQlAAEVKQABFT8AARasAAEYAgABGL0AARklAAEZxQABGqkAARtGAAEcFAABHPkAAR1gAAEebgABH1UAASAiAAEgigABIUUAASGtAAEiRwABIxQAASOZAAEkVgABJGYAASS9AAEkzQABJaIAASZuAAEm1gABJ5sAASgDAAEomQABKX0AASoSAAEq1AABK7MAASwaAAEtMgABLg8AAS7bAAEvQwABL4cAAS/QAAEv6AABMAAAATCtAAExGwABMY4AATIwAAEy5QABMxEAATMnAAEzcQABM7kAATPPAAEz5QABM/cAATQRAAE0WgABNIgAATS1AAE0ywABNOEAATTxAAE1AQABNREAATU2AAE1WgABNX8AATWPAAE1oQABNewAATZiAAE2hwABNsMAATbtAAE3JAABN1kAATe3AAE37QABOCUAAThRAAE4pQABOQUAATkpAAE5TgABOYoAATmwAAE58wABOjMAATpyAAE6qwABOuQAATuoAAE8awABPKAAATzFAAE8+wABPS4AAT2XAAE97gABPoEAAT+KAAE/8AABQAYAAUAeAAFBYQABQmIAAUNYAAFEGwABROMAAUUNAAFFOAABRWIAAUWMAAFF0gABRhcAAUZDAAFGcAABRpoAAUbEAAFH2wABSOMAAUnOAAFKeQABS4oAAUyMAAFNrwABTmkAAU7iAAFPBwABTxcAAU8nAAFQUQABUGMAAVB1AAFQhwABUJkAAVCrAAFQvQABUM8AAVDhAAFQ8wABUQUAAVEX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AEMAQwBDAEMAQwBOACoAKgAqACoAKgAqAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwArAAoACgAKAAoAJgAmACYAJgAmACYAJgAmAEEAQQBBAEEAQQBBAAwAZQA7AFUAcABEAFoAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAEkAUQBRAFEAUQBRAFEAUQBRABEAEQARABQAXQBQAFAAUABQAFAANgA8ADwAPAA8AEQARABEAEQARABEAEQARABEAEQARABEAEQARABEAEQARABEAEgASABIAEgASABIAEgASP/w//YAXQBdACgAXQAUAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaADcAagBqAGoAagBKAEoASgBKAEoASgBKACQAOgA6ADoAXQBdAF0AXQBdAF0AXQBd/+oAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwANQA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8AAsAkgBnAJIAkgCEAIQAQQBHAEcARwBHAEcARwBHAFgAZwBFAEUARQBFAEUARQBFAE0ATQBNAE0ATQBNAE0ATQBNAE0ATQBNAE0ATQBNAE0ATQBNAE0ATQBNAE0ATQAzAAgACAAIAAgAMQAxADEAMQAxADEAMQAxAEcARwBHAEcARwBHADwAXQBdADcAXf/4AFAAXgBdAF0APQBQADwAPAA/ADwAcwBFABYAWwA+AD0ANwA8ADwATgAzADwATQBdAF0AXQBaAFYAOAAcAEoASgBKAE8AlAAqACoAOv/7AF0AYAA8ACEALAA/AD8APwCSAJIAYwA3AEcAOAA4ADYARQACADIATQAzAAgAMQA5AEcARwA7AAAAGQAwAEcAWQBHAFIAVAA8AFIAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADkAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAYwBjAGMAYwBjAGMAYwBjAGMAYwBjAGMAYwBjAFoAYwBaAGMAOABjAGMAYwBjAGMAYwBjAGMALv/8AGMAYwAgAGMAhwArAHIAQQBPADAAXwBiACsASABSAEYAMABPAGYASwAqACYAGgA2ACwAJgAkABgAGAAYAF8AGAAoACYAGAA5AF0AMABBAFsAdABdAEgAUQBkADgAVAAvAFwAQAAbAF0APABCAE8ALAA4ADUAIgBaAF0ATwAsACUAOQBbAF0AUQBRAEAATwBPACIAUQBPAGQAPgBbAJIARADFANsA2wEBAPABCQCLAQsA+wDoAOgA3ADRAQkAkACKAJAAlACfAJ8AfwCRAIsAkwAgAGMAYwCHABYAcgABAD4ATgBOAGYAAgBIAE8AMABPAGYAQQAqAC8AGgA2AE8AQQAoACYAEwA3AGIALgAsAB4AcgByAAUAhwBCAEMAXwBfAFH/+AAnAAUAZgBOAC8ASwAYADAAJgCHADwAAQA+AGYAEwBPAEEAJgAmADYAQQBbAF8AAQAg//8AcgA7AE4AMAAwAC8ALwBRAEsAaACSACoARAAGAD4AZABkAG4AHQBAAF0APABdAF0AUABCADEAIABAAF4AWAA6ADoAIwBGAH0APQAsADcARABEABQAkgBQAEcAWgBaADf/+QA6ABQAbgBkADEAZwApADwARgCiAEgABgA+AG4AIQBdAFAAMwAzAEAAWABdAAYASgBRABEARABFAGQAPAA8ADEAMQA8ADwAVQBjAAIAKgBHAGEARQA5ACcAOABNAEYARABDAEcAYQBHAGEARQA5ACcAOABOAEYARABDAEcAYQBHAGEARQA5ACcAOABNAEYARABDAEcAYQDbAMUA2wDFACAA4wDjAG0AeQD1AIMA0QDZAF8AZwDZAGcA1ADFANMAUwBhAFUAVQBVAFAAAABQAAAA2wCXAIsApgCaAIsAdQCmAJoAiwB1AIoAdQCYAAAAPAA8AD7/ZgDQAHoA4QBiAHgAYwBjAQcAYwEHAFQAfwB/AFsASACdAF4ADgBXAA4AXgB0AOEAYgDhAGIAugBiAOIAYgDhAGIAHgAeAHD/+wAPADEAMQBXAGgAhgCGAIYAVQCNAK8AkgCOAJQAjgCXAJwAlwCRAOwA0wD7APQAjQCvAJIAjgCUAI4AlwCcAJcAkQDsANMA+wD0AKEA0ACtAKwArACsALAAtwCvAK0A7ADVAPsA9AChANAArQCsAKwArACwALcArwCtAOwA1QD7APQAowCJAI4AowCsALUAiQCRAMYAlQCvAK8AjAC9AMQARgCvAI4ArACJAPMAogCkAJ8AiwA0AJ8AjACSAJEAkQCOAJIAoACJAIkArQD7AN4ApQA9ADoAVQBNADUAOgBxADEAYABOAC4AKgAcAG0AKgBUAD0AYABsAC0ANwA3ACoARQAcABwAHAAcADAAHAAcACAAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcAFMAHABVAFUAZgBVANgAVQBVAHgAawBVAFUAVQBvAFUATABMAFUAVQBgAFX//ACvAQEAqgDwAFQATAC6AQkAmQA+ACsAJgAgAEYAUABGADQAGwB0ABoAEQAhAB0AIQBgAFEAVgBnABEAIQAdACH/9ABVADwASgA+AFcASQBJACEAPgA+AD4APgA+AD4AKgAqABX/5wBEADP/5//n//oATQAEAAkACQAFAAkACQAd/7n/4P/8/+YALQA8//T//QBgADEBAQDRANkA4gC+AKAAygDKAIAApADsAJEAkQD5AKcA7ACkAPkAfwCUAKcAkAC+AMUA6gDNANIANQCkALEA0QDsAOsBCQCRAJgAfwB7AKcApgCnAKYAkACPAJoAlQDqAPEAlACeAOgA6ACLAL4AywDFALkAkQCYAP8AawBqAJAAmgD1ANwA9wDoAOAA0ADgASMA4AC4ALgAuAC4AOoAlAC+AM0A3gDNAM0A0gDTAQkAsQCRAJAAkAB/AKcAbwDuALEAsQCBAM4AfwEL/z//ZgCeAJgAiwCeAJgAkQCTAJ4AmACeAJgApgCrADUAWQCmAKsAowCbAJAAmgCQAJoAkACaAJwAmwCrAKMApwCmAJQAigCfAJAAkACfAAAAAAAAAAD/2f/ZAQUA3gAhACEBBQDeABMAEwEFAN4BBQEFAN4A3v/Z/9n/2f/ZAQUBBQDeAN7/2f/Z/9n/2QEFAQUA3gDeAN4A3gDeAN7/2f/Z/9n/2f/Z/9n/2f/Z/9n/2f/Z/9n/2f/Z/9n/2f/Z/9n/2f/Z/9n/2f/Z/9n/2f/Z/9n/2f/Z/9n/2f/Z/9n/2f/Z/9n/2f/Z/9n/2QBLAEsBBQDe/9kAtwEFALcAt//Z/9n/2QEFALcAt//Z/9n/2QEFALcAt//Z/9n/2f/Z/9n/2f/Z/9n/2f/Z/9n/2QEF/9n/2QEFAAAAAAAA/9kBBQEFAQX/2QDeAQUA3v/ZAN7/2QDeAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABLP/o/9z/ygAAAg0AAAEsAAAAAAAAAAAAAAEsAAAAAAAAAAAAHgAPAE0ABABNAAT/5//6AAkACQAFAAkACQAd/7n/4P/8/+YALQA0ADkAYwBTAC0AAP/5AAD/9QAAAAEAAAPY/u8AAAJY/z//PwMZAAEAAAAAAAAAAAAAAAAAAAABAAMCWAGQAAUAAAKKAlgAAABLAooCWAAAAV4AMgEgAAACCwUJAwQDAgIEIAAC9wIAOAMAAAAAAAAAAEFEQk8AQAAg//8C7v8GAAAD2AERYAABnwAAAAAB4AKUAAAAIAADAAAABQAAAAMAAAAsAAAABAAADNIAAAAFAAAxHgADAAEAAAAsAAMACgAADNIABAymAAABrAEAAAcArAAvADkAQABaAGAAegB+AYABigGPAZMBoQGwAcIB3AHjAecB6wH1Af8CGwI3AkMCXAJnAmgCbgJ2AnsCfgKEApIClQKZAp8CogKkAqcCsAKzArkCvAK/AsECzALRAt4C5AMMAxMDIAMqAywDMQM0Az0DQgNFA18DYQN1A3oDfgOKA4wDkAOhA6kDsAPBA84D0QPVA9cD2QPbA90D4QQPBC8EXwRjBHUEkwSbBKMEqwSzBLcEuwTCBNEE2QTjBOkE7wTzHUMdSR1NHVAdUh1YHVsdnB2gHbseBx4RHhceIR4rHjseSR5THmMebx6FHpcenh75H8Efzx/fH+8f/iAHIBAgHiAiICYgMCAzIDUgOiA/IEQgSSBxIHkgfyCJII4glCChIKQgpyCpIKwgriCyILUguiC9IQUhEyEXISAhIiEmIS4hXiGJIZkhqCHTIgAiAyIGIg8iEiIVIhoiHyIpIisiNyJIImEiZSMCIxAjISWfJaElrCW6JcQlxiXMJc8l2SXmJhEmFSY8JkAmQiZgJmMmZiZrJxMnUidkJ+cuGC4l4KLgs/sC/g/+////AAAAIAAwADoAQQBbAGEAewCgAYoBjwGSAaABrwHCAc0B4gHmAeoB9AH4AhgCNwJDAlACXgJoAmoCbwJ4An0CgAKHApQCmAKcAqECpAKmArACsgK3ArsCvgLBAsYC0ALYAuADAAMPAxgDIwMsAy4DNAM5A0IDRQNfA2EDdAN6A34DhAOMA44DkQOjA6oDsQPCA9AD1QPXA9kD2wPdA+EEAAQQBDAEYgRyBJAElgSgBKoErgS2BLoEwATPBNQE4gTmBO4E8h1DHUcdTR1PHVIdVh1bHZwdoB27HgYeDB4WHiAeJB4yHj4eUh5YHmwefh6OHp4eoB+9H80f3R/tH/0gByAQIBIgICAmIC8gMiA1IDkgPCBEIEcgcCB0IH0ggCCNIJQgoSCjIKYgqSCrIK4gsSC0ILggvSEFIRMhFiEgISIhJiEuIVAhiSGQIagh0CIAIgIiBiIPIhEiFSIZIh4iKSIrIjciSCJgImQjAiMQIxwlACWgJaolsiW8JcYlySXPJdgl5iYQJhUmOiZAJkImYCZjJmUmaicTJ1InZCfmLhguIuCg4LD7Af4O/v///wAAAy4AAP/BAAD/uwAAAAD+0v9uAAAAAAAAAFcAAAAAAAAAAAAAAAAAAP+W/g0AAP+B/4IAAP+E/4P/gv+B/3//gQAAAAD/dv9u/20BcQAAAAACFAITAhICEwIEAAAAAAAAAAAB+gAAAfoB+QH3AfMB7wHtAdQB0/85/zf/LAAA/u0AAP7L/soAAP7MAAD+xv7D/s7+zf7M/sv+yP7i/rL+3QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA5tcAAObTAADm1gAA5tTmgOZ/5ngAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADiLAAAAAAAAAAAAAAAAOVU44oAAAAA42AAAORT5FLjWwAA5BMAAAAA428AAONt42rjouOmAADjo+OiAADjpeOc45sAAOOY45DjgwAA4rbis+Np42kAAOLlAADi/uLQ4pAAAOKI4oUAAOJDAAAAAOJY4l/iW+I2AADiFOHL4XAAAOBe3wkAAAAAAADe5gAA3tgAAN273qnesAAA3oneiN5h3lwAAN5S3ajdWd1g2+bVr9WsJXUlaAsSB/IHAAABAawAAAHIAAAB0gAAAdoB4AAAAAADnAOeA6AAAAOgA74DwAPCA8QDxgPUAAAAAAPWAAAAAAPqAAAAAAAAAAAAAAAAA+YD6AAAAAAAAAAAA+YD6AAAAAAAAAAAAAAD4gPuA/YEDgAABBQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAwAAAQWAAAAAAQWAAAEIAAAAAAAAAAAAAAAAAAAAAAAAAAABCQEJgQsBDIEPARCBEQETgRQBFIEVgRaBGQEZgRsBG4AAARuAAAEcAAABHAAAAAAAAAAAARsBG4EeAR6BHwEigScBLIEtATKBNAE3gAABO4FoAWoBawFsAW0AAAAAAWyBcoAAAXMAAAAAAAABcgAAAXMBdAAAAXQAAAAAAAAAAAFzAAAAAAFygAAAAAAAAXGAAAAAAAABcQAAAAAAAAAAAW+AAAF2AAAAAAAAAXkAAAAAAXiAAAF4gXkAAAAAAAAAAAF3gAAAAAAAAXaAAAAAAXgBeQF9AAABgIAAAYGAAAAAAAABgIAAAAAAAAAAAX+AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQOHA4wD2QRBBFoDXQOLA7IDswO8BG8DgwOYA4IDuAOEA4UEdgR0BHcDiQPXA7QDugO1BHsDrgTXA7YDuQO3BH0FWgOIBEUEQgRABEMDuwO/BOED0gQXA5YEfwOZA9QE4gSEBHoD4QPiBNgEiAPAA58E5wPgBBkDlwRcBF0EXgOKADYANwA4ADkAOgA9AE0AUgBdAF4AXwBhAH4AfwCAAIIA+wCcAKEAogCjAKQApQRxALkA0QDSANMA1QDuAPwBlwECAQMBBAEFAQYBCQEZAR4BKAEpASoBLAFJAUoBSwFNAcoBaAFuAW8BcAFxAXIEcgGGAaABoQGiAaQBvQHLAb8AOwEHADwBCABAAQwAUwEfAFQBIABWASIAVQEhAFcBIwBbAScAYgEtAGMBLgBkATAAZQEvAGABKwBwATsAcQE8AHIBPQBzAT4AeAFCAH0BSACBAUwAgwFOAIkBUwCGAVAAhAFUAP8BzgCKAVUAiwFWAVkAjgFaAJABXACPAVsAlQFhAJQBYACZAWUAnQFpAJsBZwFtAP4BzACmAXMAqAF+AKcBdAC7AYgAvAGJAL8BigC9AYsAwwGQAMQBkQDGAZMAxQGSAMwBmgDLAZkA0AGfANQBowDWAaUA1wGmANgBpwDZAagA2wGqAOsBugDvAb4A8AD1AcQA9wHGAPYBxQGYARwERgB3ALIBgADiAbEAPwELAIUBTwCpAXUA2gGpANwBqwDdAawA3gGtAN8BrgBPARsAdAE/AKoBdgBvAToAmgFmAD4BCgBOARoAugGHAMcBlADNAZsB0QHZAdIB0wHUAdUB1gHXAdgB2wHcAd0B3gHrAe4B7wHwAfECGgHaAekB7AHtAfIEIwQrBDAEMgTOBOME5gTkBOgE4ATlBNYENwQlBCwEMQQ4BOoE7QTwBPIE9AT2BPgE/AT+BQAFAwUFBQcFCgUCBQwFDgUQBRsFHAUdBR4FIAUiBSQFJQKvArACdAKrAnUCdgJ3AnoCfAKjAngCewKaApsCnAKdAqQClQKOAo8CkAKRApICkwKUAp4CoQKfAqACogLyAz0C8wM+AvQDPwL1A0AC9gNBAvcDQgL4A0MC+QNEAvoDRQL7A0YC/ANHAv0DSAL+A0kC/wNKAwADSwMBA0wDAgMDA00DTgMEA08DBQNQAwYDUQMHA1IDCANTAwkDVAMKA1UDCwNWAwwDVwQbBB0EHgQkBCYEKQQtBC4AUQEdAFgBJABZASUAWgEmAG4BOQB1AUAAegFEAHkBQwB7AUYAfAFHAIwBVwCNAVgAkQFdAJIBXgCTAV8AlgFiAJcBYwCYAWQAngFqAJ8BawCgAWwAuAF/AL4BjADAAY0AwQGOAMIBjwDIAZUAyQGWAM4BnADPAZ0A6AG3AOkBuADqAbkA7AG7APEBwAD4AccA+QHIAPoByQFFAZ4AQQENAEIBDgBDAQ8ARAEQAEUBEQBGARIARwETAEgBFABJARUASgEWAEsBFwBMARgAZgExAGcBMgBoATMAaQE0AGoBNQBrATYAbAE3AG0BOACHAVEAiAFSAKsBdwCsAXgArQF5AK4BegCvAXsAsAF8ALEBfQCzAYEAtAGCALUBgwC2AYQAtwGFAOABrwDhAbAA4wGyAOQBswDlAbQA5gG1AOcBtgDtAbwA8gHBAPMBwgD0AcMCswKyArQCvgLBArgCugK8ArkCuwK9Ar8CwAK2ArcCtQOdA5sDnAOeA8EDrwONA44DkQOTA48DkAOSA70DvgOgBf4EWwPCA8YDsAOxA8MDxQPEA98EIgPpA+oEJwRWBEgETAREBFQEUQRSA1wD0wRnBGwEbQRfBGAEYQRiBGMEZARlBGYEaARpBGoEawSYBJkEmgSbBKQEpQScBJ0EngSfBIkEkQSTBHAEcwSNBIMEggR8BHUDyAPJA8oDywSLBIwDogOjA60ErQSuA6QDpQSvBLADpgOnBLUEsQSyA6gDqQSzBLQDqgOrBLYEuATMBKgE6QOsBLcEwgTDBMsEvgTAAAwAAAAAJEwAAAAAAAADBQAAACAAAAAgAAAAAQAAACEAAAAhAAADhwAAACIAAAAiAAADjAAAACMAAAAjAAAD2QAAACQAAAAkAAAEQQAAACUAAAAlAAAEWgAAACYAAAAmAAADXQAAACcAAAAnAAADiwAAACgAAAApAAADsgAAACoAAAAqAAADvAAAACsAAAArAAAEbwAAACwAAAAsAAADgwAAAC0AAAAtAAADmAAAAC4AAAAuAAADggAAAC8AAAAvAAADuAAAADAAAAA5AAADXgAAADoAAAA7AAADhAAAADwAAAA8AAAEdgAAAD0AAAA9AAAEdAAAAD4AAAA+AAAEdwAAAD8AAAA/AAADiQAAAEAAAABAAAAD1wAAAEEAAABaAAAAAgAAAFsAAABbAAADtAAAAFwAAABcAAADugAAAF0AAABdAAADtQAAAF4AAABeAAAEewAAAF8AAABfAAADrgAAAGAAAABgAAAE1wAAAGEAAAB6AAAAHAAAAHsAAAB7AAADtgAAAHwAAAB8AAADuQAAAH0AAAB9AAADtwAAAH4AAAB+AAAEfQAAAKAAAACgAAAFWgAAAKEAAAChAAADiAAAAKIAAACiAAAERQAAAKMAAACjAAAEQgAAAKQAAACkAAAEQAAAAKUAAAClAAAEQwAAAKYAAACmAAADuwAAAKcAAACnAAADvwAAAKgAAACoAAAE4QAAAKkAAACpAAAD0gAAAKoAAACqAAAEFwAAAKsAAACrAAADlgAAAKwAAACsAAAEfwAAAK0AAACtAAADmQAAAK4AAACuAAAD1AAAAK8AAACvAAAE4gAAALAAAACwAAAEhAAAALEAAACxAAAEegAAALIAAACzAAAD4QAAALQAAAC0AAAE2AAAALUAAAC1AAAEiAAAALYAAAC2AAADwAAAALcAAAC3AAADnwAAALgAAAC4AAAE5wAAALkAAAC5AAAD4AAAALoAAAC6AAAEGQAAALsAAAC7AAADlwAAALwAAAC+AAAEXAAAAL8AAAC/AAADigAAAMAAAADEAAAANgAAAMUAAADFAAAAPQAAAMYAAADGAAAATQAAAMcAAADHAAAAUgAAAMgAAADKAAAAXQAAAMsAAADLAAAAYQAAAMwAAADOAAAAfgAAAM8AAADPAAAAggAAANAAAADQAAAA+wAAANEAAADRAAAAnAAAANIAAADWAAAAoQAAANcAAADXAAAEcQAAANgAAADYAAAAuQAAANkAAADbAAAA0QAAANwAAADcAAAA1QAAAN0AAADdAAAA7gAAAN4AAADeAAAA/AAAAN8AAADfAAABlwAAAOAAAADkAAABAgAAAOUAAADlAAABCQAAAOYAAADmAAABGQAAAOcAAADnAAABHgAAAOgAAADqAAABKAAA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BGMAAARjAAADPQAABHIAAARyAAAC8wAABHMAAARzAAADPgAABHQAAAR0AAAC9AAABHUAAAR1AAADPwAABJAAAASQAAAC9QAABJEAAASRAAADQAAABJIAAASSAAAC9gAABJMAAASTAAADQQAABJYAAASWAAAC9wAABJcAAASXAAADQgAABJgAAASYAAAC+AAABJkAAASZAAADQwAABJoAAASaAAAC+QAABJsAAASbAAADRAAABKAAAASgAAAC+gAABKEAAAShAAADRQAABKIAAASiAAAC+wAABKMAAASjAAADRgAABKoAAASqAAAC/AAABKsAAASrAAADRwAABK4AAASuAAAC/QAABK8AAASvAAADSAAABLAAAASwAAAC/gAABLEAAASxAAADSQAABLIAAASyAAAC/wAABLMAAASzAAADSgAABLYAAAS2AAADAAAABLcAAAS3AAADSwAABLoAAAS6AAADAQAABLsAAAS7AAADTAAABMAAAATBAAADAgAABMIAAATCAAADTQAABM8AAATPAAADTgAABNAAAATQAAADBAAABNEAAATRAAADTwAABNQAAATUAAADBQAABNUAAATVAAADUAAABNYAAATWAAADBgAABNcAAATXAAADUQAABNgAAATYAAADBwAABNkAAATZAAADUgAABOIAAATiAAADCAAABOMAAATjAAADUwAABOYAAATmAAADCQAABOcAAATnAAADVAAABOgAAAToAAADCgAABOkAAATpAAADVQAABO4AAATuAAADCwAABO8AAATvAAADVgAABPIAAATyAAADDAAABPMAAATzAAADVwAAHUMAAB1DAAAEGgAAHUcAAB1HAAAEGwAAHUgAAB1JAAAEHQAAHU0AAB1NAAAEIAAAHU8AAB1PAAAEJAAAHVAAAB1QAAAEJgAAHVIAAB1SAAAEKAAAHVYAAB1WAAAEKQAAHVcAAB1YAAAELQAAHVsAAB1bAAAELwAAHZwAAB2cAAAEHAAAHaAAAB2gAAAEHwAAHbsAAB27AAAEMwAAHgYAAB4GAAAAUQAAHgcAAB4HAAABHQAAHgwAAB4MAAAAWAAAHg0AAB4NAAABJAAAHg4AAB4OAAAAWQAAHg8AAB4PAAABJQAAHhAAAB4QAAAAWgAAHhEAAB4RAAABJgAAHhYAAB4WAAAAbgAAHhcAAB4XAAABOQAA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HvEAAB7xAAABtgAAHvIAAB7yAAAA7QAAHvMAAB7zAAABvAAAHvQAAB70AAAA8gAAHvUAAB71AAABwQAAHvYAAB72AAAA8wAAHvcAAB73AAABwgAAHvgAAB74AAAA9AAAHvkAAB75AAABwwAAH70AAB+9AAACswAAH74AAB++AAACsgAAH78AAB+/AAACtAAAH8AAAB/AAAACvgAAH8EAAB/BAAACwQAAH80AAB/NAAACuAAAH84AAB/OAAACugAAH88AAB/PAAACvAAAH90AAB/dAAACuQAAH94AAB/eAAACuwAAH98AAB/fAAACvQAAH+0AAB/uAAACvwAAH+8AAB/vAAACtgAAH/0AAB/9AAACtwAAH/4AAB/+AAACtQAAIAcAACAHAAAFWwAAIBAAACAQAAADmgAAIBIAACASAAADnQAAIBMAACAUAAADmwAAIBUAACAVAAADngAAIBYAACAWAAADwQAAIBcAACAXAAADrwAAIBgAACAZAAADjQAAIBoAACAaAAADkQAAIBsAACAbAAADkwAAIBwAACAdAAADjwAAIB4AACAeAAADkgAAICAAACAhAAADvQAAICIAACAiAAADoAAAICYAACAmAAADhgAAIC8AACAvAAAF/gAAIDAAACAwAAAEWwAAIDIAACAzAAAEhQAAIDUAACA1AAAEhwAAIDkAACA6AAADlAAAIDwAACA8AAADwgAAID0AACA9AAADxgAAID4AACA/AAADsAAAIEQAACBEAAAEVwAAIEcAACBHAAADwwAAIEgAACBIAAADxQAAIEkAACBJAAADxAAAIHAAACBwAAAD3wAAIHEAACBxAAAEIgAAIHQAACB5AAAD4wAAIH0AACB+AAAD6QAAIH8AACB/AAAEJwAAIIAAACCJAAAD7QAAII0AACCOAAAD9wAAIJQAACCUAAAENgAAIKEAACChAAAERwAAIKMAACCjAAAEVgAAIKQAACCkAAAESAAAIKYAACCnAAAESQAAIKkAACCpAAAESwAAIKsAACCrAAAETAAAIKwAACCsAAAERAAAIK4AACCuAAAEUwAAILEAACCyAAAETQAAILQAACC1AAAETwAAILgAACC4AAAEVAAAILkAACC6AAAEUQAAIL0AACC9AAAEVQAAIQUAACEFAAAElQAAIRMAACETAAAElgAAIRYAACEWAAADXAAA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AHQAZQBzACAAYQBuAGQALwBvAHIAIABvAHQAaABlAHIAIABjAG8AdQBuAHQAcgBpAGUAcwAuAEEAZABvAGIAZQAgAFMAeQBzAHQAZQBtAHMAIABJAG4AYwBvAHIAcABvAHIAYQB0AGUAZABQAGEAdQBsACAARAAuACAASAB1AG4AdAAsACAAVABlAG8AIABUAHUAbwBtAGkAbgBlAG4AaAB0AHQAcAA6AC8ALwB3AHcAdwAuAGEAZABvAGIAZQAuAGMAbwBtAC8AdAB5AHAAZQBUAGgAaQBzACAARgBvAG4AdAAgAFMAbwBmAHQAdwBhAHIAZQAgAGkAcwAgAGwAaQBjAGUAbgBzAGUAZAAgAHUAbgBkAGUAcgAgAHQAaABlACAAUwBJAEwAIABPAHAAZQBuACAARgBvAG4AdAAgAEwAaQBjAGUAbgBzAGUALAAgAFYAZQByAHMAaQBvAG4AIAAxAC4AMQAuACAAVABoAGkAcwAgAGwAaQBjAGUAbgBzAGUAIABpAHMAIABhAHYAYQBpAGwAYQBiAGwAZQAgAHcAaQB0AGgAIABhACAARgBBAFEAIABhAHQAOgAgAGgAdAB0AHAAOgAvAC8AcwBjAHIAaQBwAHQAcwAuAHMAaQBsAC4AbwByAGcALwBPAEYATAAuACAAVABoAGkAcwAgAEYAbwBuAHQAIABTAG8AZgB0AHcAYQByAGUAIABpAHMAIABkAGkAcwB0AHIAaQBiAHUAdABlAGQAIABvAG4AIABhAG4AICAYAEEAUwAgAEkAUyAZACAAQgBBAFMASQBTACwAIABXAEkAVABIAE8AVQBUACAAVwBBAFIAUgBBAE4AVABJAEUAUwAgAE8AUgAgAEMATwBOAEQASQBUAEkATwBOAFMAIABPAEYAIABBAE4AWQAgAEsASQBOAEQALAAgAGUAaQB0AGgAZQByACAAZQB4AHAAcgBlAHMAcwAgAG8AcgAgAGkAbQBwAGwAaQBlAGQALgAgAFMAZQBlACAAdABoAGUAIABTAEkATAAgAE8AcABlAG4AIABGAG8AbgB0ACAATABpAGMAZQBuAHMAZQAgAGYAbwByACAAdABoAGUAIABzAHAAZQBjAGkAZgBpAGMAIABsAGEAbgBnAHUAYQBnAGUALAAgAHAAZQByAG0AaQBzAHMAaQBvAG4AcwAgAGEAbgBkACAAbABpAG0AaQB0AGEAdABpAG8AbgBzACAAZwBvAHYAZQByAG4AaQBuAGcAIAB5AG8AdQByACAAdQBzAGUAIABvAGYAIAB0AGgAaQBzACAARgBvAG4AdAAgAFMAbwBmAHQAdwBhAHIAZQAuAGgAdAB0AHAAOgAvAC8AdwB3AHcALgBhAGQAbwBiAGUALgBjAG8AbQAvAHQAeQBwAGUALwBsAGUAZwBhAGwALgBoAHQAbQBsAHMAaQBtAHAAbABlACAAYQBzAGkAbQBwAGwAZQAgAGcAcwBlAHIAaQBmAGUAZAAgAGkAIAAmACAAbABTAGEAbQBpACABSgBjAHUAcgBzAGkAdgBlACADsgBjAHUAcgBzAGkAdgBlACADuABjAHUAcgBzAGkAdgBlACADxgBTAGUAcgBiAGkAYQBuACADxgBDAHkAcgBpAGwAbABpAGMAIABiAHIAZQB2AGUAIABbAtgAXQBzAGwAYQBzAGgAZQBkACAAegBlAHIAbwAgAFsAMABdAHQAeQBwAG8AZwByAGEAcABoAGkAYwAgAGgAeQBwAGgAZQBuACAAWwAtAF0AdAB5AHAAbwBnAHIAYQBwAGgAaQBjACAAYQBzAHQAZQByAGkAcwBrACAAWwAqAF0AcwBsAGEAcwBoAGUAZAAgAGQAbwBsAGwAYQByACAAcwBpAGcAbgAgAFsAJABdAGEAbAB0AGUAcgBuAGEAdABlACAAbgB1AG0AZQByAGEAbAAgAG8AbgBlACAAWwAxAF0AdAB5AHAAbwBnAHIAYQBwAGgAaQBjACAAYQBsAHQAZQByAG4AYQB0AGUAcwAgAFsALQAsACoAXQBzAGkAbQBwAGwAZQAgAGEALAAgAGMAdQByAHMAaQB2AGUAIAOyAHMAaQBtAHAAbABlACAAZwAsACAAYwB1AHIAcwBpAHYAZQAgA7gALAAgAFMAZQByAGIAaQBhAG4AIAQxAFMAYQBtAGkAIAFKACwAIABjAHUAcgBzAGkAdgBlACADxgAAAAIAAAAAAAD/tQAyAAAAAQAAAAAAAAAAAAAAAAAAAAAGHAAAAAMAJAAlACYAJwAoACkAKgArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADsAPAA9AEQARQBGAEcASABJAEoASwBMAE0ATgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwAXQCtAMkAxwCuAGIBAgEDAGMBBAEFAQYBBwEIAQkBCgELAQwBDQEOAQ8BEAERARIAkAETARQBFQEWAGQA/QEXAP8BGAEZARoBGwEcAR0BHgDLAGUAyAEfAMoBIAEhASIBIwEkASUBJgEnASgBKQEqASsBLAEtAS4A+AEvATABMQEyATMBNAE1ATYBNwE4ATkBOgDPAMwAzQE7AM4BPAD6AT0BPgE/AUABQQFCAUMBRAFFAUYBRwFIAUkBSgFLAOIBTAFNAU4BTwFQAVEBUgBmAVMBVAFVAVYA0wDQANEArwBnAVcBWAFZAVoBWwFcAV0BXgFfAWABYQFiAWMBZAFlAWYBZwFoAWkAkQFqALABawFsAW0BbgFvAXABcQFyAXMA5AF0AXUBdgF3AXgBeQF6AXsBfAF9AX4A1gDUANUBfwBoAYABgQGCAYMBhAGFAYYBhwGIAYkBigGLAYwBjQGOAY8BkAGRAZIBkwGUAZUBlgGXAOsBmAC7AZkBmgGbAZwBnQDmAZ4BnwGgAaEA6QDtAaIBowGkAaUBpgBqAGkAawBtAGwBpwGoAG4BqQGqAasBrAGtAa4BrwGwAbEBsgGzAbQBtQG2AbcAoAG4AbkBugG7AG8A/gG8AQABvQG+Ab8BwAHBAQEAcQBwAHIBwgBzAcMBxAHFAcYBxwHIAckBygHLAcwBzQHOAc8B0AHRAPkB0gHTAdQB1QHWAdcB2AHZAdoB2wHcAd0AdQB0AHYB3gB3Ad8B4AHhAeIB4wHkANcB5QHmAecB6AHpAeoB6wHsAe0B7gHvAOMB8AHxAfIB8wH0AfUB9gB4AfcB+AH5AfoB+wB6AHkAewB9AHwB/AH9Af4B/wIAAgECAgIDAgQCBQIGAgcCCAIJAgoCCwIMAg0CDgChAg8AsQIQAhECEgITAhQCFQIWAhcCGADlAhkCGgIbAhwAiQIdAh4CHwIgAiECIgIjAiQAfwB+AIACJQCBAiYCJwIoAikCKgIrAiwCLQIuAi8CMAIxAjICMwI0AjUCNgI3AjgCOQI6AjsCPAI9AOwCPgC6Aj8CQAJBAkICQwDnAkQCRQJGAkcA6gDuAkgCSQJKAksCTAJNAk4CTwJQAlECUgJTAlQCVQJWAlcCWAJZAloCWwJcAl0CXgJfAmACYQJiAmMCZAJlAmYCZwJoAmkCagJrAmwCbQJuAm8CcAJxAnICcwJ0AnUCdgJ3AngCeQJ6AnsCfAJ9An4CfwKAAoECggKDAoQChQKGAocCiAKJAooCiwKMAo0CjgKPApACkQKSApMClAKVApYClwKYApkCmgKbApwCnQKeAp8CoAKhAqICowKkAqUCpgKnAqgCqQKqAqsCrAKtAq4CrwKwArECsgKzArQCtQK2ArcCuAK5AroCuwK8Ar0CvgK/AsACwQLCAsMCxALFAsYCxwLIAskCygLLAswCzQLOAs8C0ALRAtIC0wLUAtUC1gLXAtgC2QLaAtsC3ALdAt4C3wLgAuEC4gLjAuQC5QLmAucC6ALpAuoC6wLsAu0C7gLvAvAC8QLyAvMC9AL1AvYC9wL4AvkC+gL7AvwC/QL+Av8DAAMBAwIDAwMEAwUDBgMHAJsDCAMJAwoDCwMMAw0DDgMPAxADEQMSAxMDFAMVAxYDFwMYAxkDGgMbAxwDHQMeAx8DIAMhAyIDIwMkAyUDJgMnAygDKQMqAysDLAMtAy4DLwMwAzEDMgMzAzQDNQM2AzcDOAM5AzoDOwM8Az0DPgM/A0ADQQNCA0MDRANFA0YDRwNIA0kDSgNLA0wDTQNOA08DUANRA1IDUwNUA1UDVgNXA1gDWQNaA1sDXANdA14DXwNgA2EDYgNjA2QDZQNmA2cDaANpA2oDawNsA20DbgNvA3ADcQNyA3MDdAN1A3YDdwN4A3kDegN7A3wDfQN+A38DgAOBA4IDgwOEA4UDhgOHA4gDiQOKA4sDjAONA44DjwOQA5EDkgOTA5QDlQOWA5cDmAOZA5oDmwOcA50DngOfA6ADoQOiA6MDpAOlA6YDpwOoA6kDqgOrA6wDrQOuA68DsAOxA7IDswO0A7UDtgO3A7gDuQO6A7sDvAO9A74DvwPAA8EDwgPDA8QDxQPGA8cDyAPJA8oDywPMA80DzgPPA9AD0QPSA9MD1APVA9YD1wAJABMAFAAVABYAFwAYABkAGgAbABwD2APZA9oD2wPcA90D3gPfA+AD4QPiA+MD5APlA+YD5wPoA+kD6gPrA+wD7QPuA+8D8APxABEADwAdAB4AqwAEAKMAIgCiAAoABQC2ALcAtAC1AMQAxQPyAL4AvwCpAKoAEAPzA/QAsgCzA/UD9gDDAIcD9wP4A/kD+gP7A/wD/QP+A/8EAAQBBAIEAwBCBAQEBQQGAAsADAA+AEAAXgBgABIAXwA/AOgADQCCAMIAhgCIBAcECAQJBAoECwQMBA0EDgQPBBAEEQQSBBMEFAQVBBYEFwCLBBgAigCMBBkAIwQaAAYEGwQcBB0EHgQfBCAEIQQiBCMEJAQlBCYEJwQoBCkEKgQrBCwELQQuBC8EMAQxBDIEMwQ0BDUENgQ3BDgEOQQ6BDsEPAQ9BD4EPwRABEEEQgRDBEQERQRGBEcESARJBEoESwRMBE0ETgRPBFAEUQRSBFMEVARVBFYEVwCdBFgAngRZBFoEWwRcBF0EXgRfBGAEYQRiBGMEZARlBGYEZwRoBGkEagRrBGwEbQRuBG8EcARxBHIEcwR0BHUEdgR3BHgEeQR6BHsEfAR9BH4AvQAHAIUAlgR/AIQEgASBBIIEgwSEBIUEhgSHBIgEiQSKBIsEjASNBI4EjwD3ALwEkASRAAgAxgD1APQA9gSSBJMElASVBJYElwSYBJkEmgSbBJwEnQSeBJ8EoAShAA4A7wDwALgEogAgBKMAHwAhAJQAlQCTAEEAjwBhAKcApASkBKUEpgCSAIMEpwSoBKkEqgCYAJwEqwSsAKUErQSuBK8EsASxAJkAmgSyBLMEtAS1BLYEtwS4BLkEugS7BLwEvQS+BL8EwATBBMIEwwTEBMUExgTHBMgEyQTKBMsEzATNBM4EzwTQBNEE0gTTBNQE1QTWBNcE2ATZBNoE2wTcBN0E3gTfBOAE4QTiBOME5ATlBOYE5wToALkE6QTqBOsE7ATtBO4E7wTwBPEE8gBDAI0A2ADhBPME9AT1BPYE9wDZAI4A2gDbAN0A3wDcAN4A4AT4BPkE+gT7BPwE/QT+BP8FAAUBBQIFAwUEBQUFBgUHBQgFCQUKBQsFDAUNBQ4FDwUQBREFEgUTBRQFFQUWBRcFGAUZBRoFGwUcBR0FHgUfBSAFIQUiBSMFJAUlBSYFJwUoBSkFKgUrBSwFLQUuBS8FMAUxBTIFMwU0BTUFNgU3BTgFOQU6BTsFPAU9BT4FPwVABUEFQgVDBUQFRQVGBUcFSAVJBUoFSwVMBU0FTgVPBVAFUQVSBVMFVAVVBVYFVwVYBVkFWgVbBVwFXQVeBV8FYAVhBWIFYwVkBWUFZgVnBWgFaQVqBWsFbAVtBW4FbwVwBXEFcgVzBXQFdQV2BXcFeAV5BXoFewV8BX0FfgV/BYAFgQWCBYMFhAWFBYYFhwWIBYkFigWLBYwFjQWOBY8FkAWRBZIFkwWUBZUFlgWXBZgFmQWaBZsFnAWdBZ4FnwWgBaEFogWjBaQFpQWmBacFqAWpBaoFqwWsBa0FrgWvBbAFsQWyBbMFtAW1BbYFtwW4BbkFugW7BbwFvQW+Bb8FwAXBBcIFwwXEBcUFxgXHBcgFyQXKBcsFzAXNBc4FzwXQBdEF0gXTBdQF1QXWBdcF2AXZBdoF2wXcBd0F3gXfBeAF4QXiBeMF5AXlBeYF5wXoBekF6gXrBewF7QXuBe8F8AXxBfIF8wX0BfUF9gX3BfgF+QX6BfsF/AX9Bf4F/wYABgEGAgYDBgQGBQYGBgcGCAYJBgoGCwYMBg0GDgYPBhAGEQYSBhMGFAYVBhYGFwYYBhkGGgYbBhwGHQYeBh8GIAYhBiIGIwYkBiUGJgYnBigGKQYqB0FtYWNyb24GQWJyZXZlCkFyaW5nYWN1dGUHdW5pMDFDRAdBb2dvbmVrB3VuaTFFQTAHdW5pMUVBMgd1bmkxRUE0B3VuaTFFQTYHdW5pMUVBOAd1bmkxRUFBB3VuaTFFQUMHdW5pMUVBRQd1bmkxRUIwB3VuaTFFQjIHdW5pMUVCNAd1bmkxRUI2B0FFYWN1dGUHdW5pMDFFMgd1bmkwMjQzB3VuaTFFMDYLQ2NpcmN1bWZsZXgKQ2RvdGFjY2VudAZEY2Fyb24HdW5pMUUwQwd1bmkxRTBFB3VuaTFFMTAGRGNyb2F0B3VuaTAxOEEGRWNhcm9uB0VtYWNyb24GRWJyZXZlCkVkb3RhY2NlbnQHRW9nb25lawd1bmkxRUI4B3VuaTFFQkEHdW5pMUVCQwd1bmkxRUJFB3VuaTFFQzAHdW5pMUVDMgd1bmkxRUM0B3VuaTFFQzYHdW5pMUUxNgd1bmkwMUY0C0djaXJjdW1mbGV4Ckdkb3RhY2NlbnQHdW5pMDEyMgZHY2Fyb24HdW5pMUUyMAt1bmkwMDQ3MDMwMwd1bmkwMTkzC0hjaXJjdW1mbGV4B3VuaTFFMjYHdW5pMUUyNAd1bmkxRTI4B3VuaTFFMkEESGJhcgZJdGlsZGUHSW1hY3Jvbgd1bmkwMUNGB0lvZ29uZWsHdW5pMUVDOAd1bmkxRUNBBklicmV2ZQtKY2lyY3VtZmxleAd1bmkwMTM2B3VuaTFFMzIHdW5pMUUzNAZMYWN1dGUGTGNhcm9uB3VuaTAxM0IHdW5pMUUzNgd1bmkxRTM4B3VuaTFFM0EETGRvdAd1bmkxRTNFB3VuaTFFNDAHdW5pMUU0MgZOYWN1dGUHdW5pMDFGOAZOY2Fyb24HdW5pMDE0NQd1bmkxRTQ0B3VuaTFFNDYHdW5pMUU0OAdPbWFjcm9uDU9odW5nYXJ1bWxhdXQGT2JyZXZlB3VuaTAxRDEHdW5pMDFFQQd1bmkxRUNDB3VuaTFFQ0UHdW5pMUVEMAd1bmkxRUQyB3VuaTFFRDQHdW5pMUVENgd1bmkxRUQ4BU9ob3JuB3VuaTFFREEHdW5pMUVEQwd1bmkxRURFB3VuaTFFRTAHdW5pMUVFMgd1bmkxRTUyC09zbGFzaGFjdXRlBlJhY3V0ZQZSY2Fyb24HdW5pMUU1OAd1bmkwMTU2B3VuaTFFNUEHdW5pMUU1Qwd1bmkxRTVFBlNhY3V0ZQtTY2lyY3VtZmxleAd1bmkwMTVFB3VuaTAyMTgHdW5pMUU2MAd1bmkxRTYyB3VuaTFFOUUGVGNhcm9uB3VuaTAxNjIHdW5pMDIxQQd1bmkxRTZDB3VuaTFFNkUEVGJhcgZVdGlsZGUHVW1hY3JvbgZVYnJldmUFVXJpbmcNVWh1bmdhcnVtbGF1dAd1bmkwMUQzB1VvZ29uZWsHdW5pMDFENQd1bmkwMUQ3B3VuaTAxRDkHdW5pMDFEQgd1bmkxRUU0B3VuaTFFRTYFVWhvcm4HdW5pMUVFOAd1bmkxRUVBB3VuaTFFRUMHdW5pMUVFRQd1bmkxRUYwB3VuaTFFN0UGV2dyYXZlBldhY3V0ZQtXY2lyY3VtZmxleAlXZGllcmVzaXMGWWdyYXZlC1ljaXJjdW1mbGV4B3VuaTFFOEUHdW5pMUVGNAd1bmkxRUY2B3VuaTFFRjgGWmFjdXRlClpkb3RhY2NlbnQHdW5pMUU5MAd1bmkxRTkyB3VuaTFFOTQHdW5pMDE4RgNFbmcCSUoPdW5pMDA0QzAwQjcwMDRDC3VuaTAxMzIwMzAxB2FtYWNyb24GYWJyZXZlCmFyaW5nYWN1dGUHdW5pMDFDRQdhb2dvbmVrB3VuaTFFQTEHdW5pMUVBMwd1bmkxRUE1B3VuaTFFQTcHdW5pMUVBOQd1bmkxRUFCB3VuaTFFQUQHdW5pMUVBRgd1bmkxRUIxB3VuaTFFQjMHdW5pMUVCNQd1bmkxRUI3B2FlYWN1dGUHdW5pMDFFMwd1bmkwMTgwB3VuaTFFMDcLY2NpcmN1bWZsZXgKY2RvdGFjY2VudAZkY2Fyb24HdW5pMUUwRAd1bmkxRTBGB3VuaTFFMTEGZWNhcm9uB2VtYWNyb24GZWJyZXZlB2VvZ29uZWsKZWRvdGFjY2VudAd1bmkxRUI5B3VuaTFFQkIHdW5pMUVCRAd1bmkxRUJGB3VuaTFFQzEHdW5pMUVDMwd1bmkxRUM1B3VuaTFFQzcHdW5pMUUxNwd1bmkwMUY1C2djaXJjdW1mbGV4Cmdkb3RhY2NlbnQHdW5pMDEyMwZnY2Fyb24HdW5pMUUyMQt1bmkwMDY3MDMwMwtoY2lyY3VtZmxleAd1bmkxRTI3B3VuaTFFMjUHdW5pMUU5Ngd1bmkxRTI5B3VuaTFFMkIEaGJhcgZpdGlsZGUHaW1hY3Jvbgd1bmkwMUQwB2lvZ29uZWsHdW5pMUVDOQd1bmkxRUNCBmlicmV2ZQtqY2lyY3VtZmxleAd1bmkwMTM3B3VuaTFFMzMHdW5pMUUzNQxrZ3JlZW5sYW5kaWMGbGFjdXRlBmxjYXJvbgd1bmkwMTNDB3VuaTFFMzcHdW5pMUUzOQd1bmkxRTNCBGxkb3QHdW5pMUUzRgd1bmkxRTQxB3VuaTFFNDMGbmFjdXRlB3VuaTAxRjkGbmNhcm9uB3VuaTAxNDYHdW5pMUU0NQd1bmkxRTQ3B3VuaTFFNDkLbmFwb3N0cm9waGUHb21hY3Jvbg1vaHVuZ2FydW1sYXV0B3VuaTAxRDIHdW5pMDFFQgd1bmkxRUNEB3VuaTFFQ0YHdW5pMUVEMQd1bmkxRUQzB3VuaTFFRDUHdW5pMUVENwd1bmkxRUQ5Bm9icmV2ZQd1bmkxRTUzBW9ob3JuB3VuaTFFREIHdW5pMUVERAd1bmkxRURGB3VuaTFFRTEHdW5pMUVFMwtvc2xhc2hhY3V0ZQZyYWN1dGUHdW5pMDE1NwZyY2Fyb24HdW5pMUU1OQd1bmkxRTVCB3VuaTFFNUQHdW5pMUU1RgZzYWN1dGULc2NpcmN1bWZsZXgHdW5pMDE1Rgd1bmkwMjE5B3VuaTFFNjEHdW5pMUU2MwVsb25ncwZ0Y2Fyb24HdW5pMDE2Mwd1bmkwMjFCB3VuaTFFNkQHdW5pMUU2Rgd1bmkxRTk3BHRiYXIGdXRpbGRlB3VtYWNyb24GdWJyZXZlBXVyaW5nDXVodW5nYXJ1bWxhdXQHdW5pMDFENAd1b2dvbmVrB3VuaTAxRDYHdW5pMDFEOAd1bmkwMURBB3VuaTAxREMHdW5pMUVFNQd1bmkxRUU3BXVob3JuB3VuaTFFRTkHdW5pMUVFQgd1bmkxRUVEB3VuaTFFRUYHdW5pMUVGMQd1bmkxRTdGBndncmF2ZQZ3YWN1dGULd2NpcmN1bWZsZXgJd2RpZXJlc2lzBnlncmF2ZQt5Y2lyY3VtZmxleAd1bmkxRThGB3VuaTFFRjUHdW5pMUVGNwd1bmkxRUY5BnphY3V0ZQp6ZG90YWNjZW50B3VuaTFFOTEHdW5pMUU5Mwd1bmkxRTk1A2VuZwd1bmkwMjM3AmlqD3VuaTAwNkMwMEI3MDA2Qwt1bmkwMTMzMDMwMQd1bmkwMjUwB3VuaTAyNTIHdW5pMDI1Mwd1bmkwMjU0B3VuaTAyNTUHdW5pMDI1Ngd1bmkwMjU3B3VuaTAyNTgHdW5pMDI1MQd1bmkwMjk5B3VuaTAyNTkHdW5pMDI1QQd1bmkwMjVCB3VuaTAyNUMHdW5pMDI1RQd1bmkwMjVGB3VuaTAyNjAHdW5pMDI2MQd1bmkwMjYyB3VuaTAyNjMHdW5pMDI2NAd1bmkwMjY1B3VuaTAyNjYHdW5pMDI2Nwd1bmkwMjlDB3VuaTAyNjgHdW5pMDI2QQd1bmkwMjlEB3VuaTAyOUUHdW5pMDI2Qgd1bmkwMjZDB3VuaTAyNkQHdW5pMDI2RQd1bmkwMjlGB3VuaTAyNkYHdW5pMDI3MAd1bmkwMjcxB3VuaTAyNzIHdW5pMDI3Mwd1bmkwMjc0B3VuaTAyNzUHdW5pMDI3Ngd1bmkwMjc4B3VuaTAyNzkHdW5pMDI3QQd1bmkwMjdCB3VuaTAyN0QHdW5pMDI3RQd1bmkwMjgwB3VuaTAyODEHdW5pMDI4Mgd1bmkwMjgzB3VuaTAyODQHdW5pMDI4Nwd1bmkwMjg4B3VuaTAyODkHdW5pMDI4QQd1bmkwMjhCB3VuaTAyOEMHdW5pMDI4RAd1bmkwMjhFB3VuaTAyOEYHdW5pMDI5MAd1bmkwMjkxB3VuaTAyOTIHdW5pMDJBNAd1bmkwMkE2B3VuaTAyQTcHdW5pMDI5NAd1bmkwMjk1B3VuaTAyQTEHdW5pMDJBMgd1bmkwMUMyB3VuaTAyOTgJdW5pMDE0QS5hA2EuYQhhZ3JhdmUuYQhhYWN1dGUuYQ1hY2lyY3VtZmxleC5hCGF0aWxkZS5hC2FkaWVyZXNpcy5hCWFtYWNyb24uYQhhYnJldmUuYQdhcmluZy5hDGFyaW5nYWN1dGUuYQl1bmkwMUNFLmEJdW5pMUVBMS5hCXVuaTFFQTMuYQl1bmkxRUE1LmEJdW5pMUVBNy5hCXVuaTFFQTkuYQl1bmkxRUFCLmEJdW5pMUVBRC5hCXVuaTFFQUYuYQl1bmkxRUIxLmEJdW5pMUVCMy5hCXVuaTFFQjUuYQl1bmkxRUI3LmEJYW9nb25lay5hA2cuYQl1bmkwMUY1LmENZ2NpcmN1bWZsZXguYQhnYnJldmUuYQxnZG90YWNjZW50LmEJdW5pMDEyMy5hCGdjYXJvbi5hCXVuaTFFMjEuYQ11bmkwMDY3MDMwMy5hA2kuYQpkb3RsZXNzaS5hCGlncmF2ZS5hCGlhY3V0ZS5hDWljaXJjdW1mbGV4LmEIaXRpbGRlLmELaWRpZXJlc2lzLmEJaW1hY3Jvbi5hCXVuaTAxRDAuYQlpb2dvbmVrLmEJdW5pMUVDOS5hCXVuaTFFQ0IuYQl1bmkwMTJELmEJdW5pMDI2OC5hCWlvZ29uZWsuZAppb2dvbmVrLmRhCXVuaTAyNjguZAp1bmkwMjY4LmRhCXVuaTAyOUQuZANsLmEIbGFjdXRlLmEIbGNhcm9uLmEJdW5pMDEzQy5hCXVuaTFFMzcuYQl1bmkxRTM5LmEJdW5pMUUzQi5hCGxzbGFzaC5hBmxkb3QuYRF1bmkwMDZDMDBCNzAwNkMuYQl1bmkwMjZCLmEJdW5pMDI2Qy5hBUFscGhhBEJldGEFR2FtbWEHdW5pMDM5NAdFcHNpbG9uBFpldGEDRXRhBVRoZXRhBElvdGEFS2FwcGEGTGFtYmRhAk11Ak51AlhpB09taWNyb24CUGkDUmhvBVNpZ21hA1RhdQdVcHNpbG9uA1BoaQNDaGkDUHNpB3VuaTAzQTkKQWxwaGF0b25vcwxFcHNpbG9udG9ub3MIRXRhdG9ub3MJSW90YXRvbm9zDElvdGFkaWVyZXNpcwxPbWljcm9udG9ub3MMVXBzaWxvbnRvbm9zD1Vwc2lsb25kaWVyZXNpcwpPbWVnYXRvbm9zBWFscGhhBGJldGEFZ2FtbWEFZGVsdGEHZXBzaWxvbgR6ZXRhA2V0YQV0aGV0YQRpb3RhBWthcHBhBmxhbWJkYQd1bmkwM0JDAm51AnhpB29taWNyb24DcmhvBXNpZ21hA3RhdQd1cHNpbG9uA3BoaQNjaGkDcHNpBW9tZWdhB3VuaTAzQzIHdW5pMDNEMAd1bmkwM0QxB3VuaTAzRDUFcGhpLmEKYWxwaGF0b25vcwxlcHNpbG9udG9ub3MIZXRhdG9ub3MJaW90YXRvbm9zDGlvdGFkaWVyZXNpcwxvbWljcm9udG9ub3MMdXBzaWxvbnRvbm9zD3Vwc2lsb25kaWVyZXNpcwpvbWVnYXRvbm9zEWlvdGFkaWVyZXNpc3Rvbm9zFHVwc2lsb25kaWVyZXNpc3Rvbm9zB3VuaTAzRDcHdW5pMDNEOQd1bmkwM0RCB3VuaTAzREQHdW5pMDNFMQd1bmkwMzdFCWFub3RlbGVpYQ1hbm90ZWxlaWEuY2FwB3VuaTAzNzQHdW5pMDM3NQV0b25vcw1kaWVyZXNpc3Rvbm9zB3VuaTAzN0EHdW5pMUZCRQd1bmkxRkJEB3VuaTFGQkYHdW5pMUZGRQd1bmkxRkVGB3VuaTFGRkQHdW5pMUZDRAd1bmkxRkREB3VuaTFGQ0UHdW5pMUZERQd1bmkxRkNGB3VuaTFGREYHdW5pMUZDMAd1bmkxRkVEB3VuaTFGRUUHdW5pMUZDMQd1bmkwNDEwB3VuaTA0MTEHdW5pMDQxMgd1bmkwNDEzB3VuaTA0MTQHdW5pMDQxNQd1bmkwNDE2B3VuaTA0MTcHdW5pMDQxOAd1bmkwNDE5B3VuaTA0MUEHdW5pMDQxQgd1bmkwNDFDB3VuaTA0MUQHdW5pMDQxRQd1bmkwNDFGB3VuaTA0MjAHdW5pMDQyMQd1bmkwNDIyB3VuaTA0MjMHdW5pMDQyNAd1bmkwNDI1B3VuaTA0MjYHdW5pMDQyNwd1bmkwNDI4B3VuaTA0MjkHdW5pMDQyQQd1bmkwNDJCB3VuaTA0MkMHdW5pMDQyRAd1bmkwNDJFB3VuaTA0MkYHdW5pMDQwMAd1bmkwNDAxB3VuaTA0MDIHdW5pMDQwMwd1bmkwNDA0B3VuaTA0MDUHdW5pMDQwNgd1bmkwNDA3B3VuaTA0MDgHdW5pMDQwOQd1bmkwNDBBB3VuaTA0MEIHdW5pMDQwQwd1bmkwNDBEB3VuaTA0MEUHdW5pMDQwRgd1bmkwNDYyB3VuaTA0NzIHdW5pMDQ3NAd1bmkwNDkwB3VuaTA0OTIHdW5pMDQ5Ngd1bmkwNDk4B3VuaTA0OUEHdW5pMDRBMAd1bmkwNEEyB3VuaTA0QUEHdW5pMDRBRQd1bmkwNEIwB3VuaTA0QjIHdW5pMDRCNgd1bmkwNEJBB3VuaTA0QzAHdW5pMDRDMQd1bmkwNEQwB3VuaTA0RDQHdW5pMDRENgd1bmkwNEQ4B3VuaTA0RTIHdW5pMDRFNgd1bmkwNEU4B3VuaTA0RUUHdW5pMDRGMgd1bmkwNDMwB3VuaTA0MzEHdW5pMDQzMgd1bmkwNDMzB3VuaTA0MzQHdW5pMDQzNQd1bmkwNDM2B3VuaTA0MzcHdW5pMDQzOAd1bmkwNDM5B3VuaTA0M0EHdW5pMDQzQgd1bmkwNDNDB3VuaTA0M0QHdW5pMDQzRQd1bmkwNDNGB3VuaTA0NDAHdW5pMDQ0MQd1bmkwNDQyB3VuaTA0NDMHdW5pMDQ0NAd1bmkwNDQ1B3VuaTA0NDYHdW5pMDQ0Nwd1bmkwNDQ4B3VuaTA0NDkHdW5pMDQ0QQd1bmkwNDRCB3VuaTA0NEMHdW5pMDQ0RAd1bmkwNDRFB3VuaTA0NEYHdW5pMDQ1MAd1bmkwNDUxB3VuaTA0NTIHdW5pMDQ1Mwd1bmkwNDU0B3VuaTA0NTUHdW5pMDQ1Ngd1bmkwNDU3B3VuaTA0NTgHdW5pMDQ1OQd1bmkwNDVBB3VuaTA0NUIHdW5pMDQ1Qwd1bmkwNDVEB3VuaTA0NUUHdW5pMDQ1Rgd1bmkwNDYzB3VuaTA0NzMHdW5pMDQ3NQd1bmkwNDkxB3VuaTA0OTMHdW5pMDQ5Nwd1bmkwNDk5B3VuaTA0OUIHdW5pMDRBMQd1bmkwNEEzB3VuaTA0QUIHdW5pMDRBRgd1bmkwNEIxB3VuaTA0QjMHdW5pMDRCNwd1bmkwNEJCB3VuaTA0QzIHdW5pMDRDRgd1bmkwNEQxB3VuaTA0RDUHdW5pMDRENwd1bmkwNEQ5B3VuaTA0RTMHdW5pMDRFNwd1bmkwNEU5B3VuaTA0RUYHdW5pMDRGMwl1bmkwNDMwLmEJdW5pMDREMS5hC3VuaTA0MzEuc3JiCXVuaTA0NTYuYQd1bmkyMTE2Bnplcm8uYQVvbmUuYQl6ZXJvLm9udW0Ib25lLm9udW0IdHdvLm9udW0KdGhyZWUub251bQlmb3VyLm9udW0JZml2ZS5vbnVtCHNpeC5vbnVtCnNldmVuLm9udW0KZWlnaHQub251bQluaW5lLm9udW0GemVyby5iBW9uZS5iCHplcm8uY2FwB29uZS5jYXAHdHdvLmNhcAl0aHJlZS5jYXAIZm91ci5jYXAIZml2ZS5jYXAHc2l4LmNhcAlzZXZlbi5jYXAJZWlnaHQuY2FwCG5pbmUuY2FwBnplcm8uYwVvbmUuYw1xdW90ZXJldmVyc2VkB3VuaTAwQUQHdW5pMjAxMApmaWd1cmVkYXNoB3VuaTIwMTUHdW5pMjVFNgd1bmkyNUFBB3VuaTI1QUIHdW5pMjVCNAd1bmkyNUI1B3VuaTI1QjgHdW5pMjVCOQd1bmkyNUJFB3VuaTI1QkYHdW5pMjVDMgd1bmkyNUMzCWludmJ1bGxldApmaWxsZWRyZWN0DXVuZGVyc2NvcmVkYmwHdW5pMjAzRQd1bmkyMDNGB3VuaTIwMTYJZXhjbGFtZGJsB3VuaTIwNDcHdW5pMjA0OQd1bmkyMDQ4B3VuaTIwM0QHdW5pMkUxOAd1bmkyMzFDB3VuaTIzMUQHdW5pMjMxRQd1bmkyMzFGB3VuaTI3RTYHdW5pMjdFNwd1bmkyRTIyB3VuaTJFMjMHdW5pMkUyNAd1bmkyRTI1B3VuaTIxMTcHdW5pMjEyMAdhdC5jYXNlCmFzdGVyaXNrLmEIaHlwaGVuLmEJdW5pMDBBRC5hCXVuaTIwMTAuYQhkb2xsYXIuYQl6ZXJvLnN1cHMIb25lLnN1cHMIdHdvLnN1cHMKdGhyZWUuc3Vwcwlmb3VyLnN1cHMJZml2ZS5zdXBzCHNpeC5zdXBzCnNldmVuLnN1cHMKZWlnaHQuc3VwcwluaW5lLnN1cHMOcGFyZW5sZWZ0LnN1cHMPcGFyZW5yaWdodC5zdXBzC3BlcmlvZC5zdXBzCmNvbW1hLnN1cHMJemVyby5zdWJzCG9uZS5zdWJzCHR3by5zdWJzCnRocmVlLnN1YnMJZm91ci5zdWJzCWZpdmUuc3VicwhzaXguc3VicwpzZXZlbi5zdWJzCmVpZ2h0LnN1YnMJbmluZS5zdWJzDnBhcmVubGVmdC5zdWJzD3BhcmVucmlnaHQuc3VicwtwZXJpb2Quc3Vicwpjb21tYS5zdWJzCXplcm8uZG5vbQhvbmUuZG5vbQh0d28uZG5vbQp0aHJlZS5kbm9tCWZvdXIuZG5vbQlmaXZlLmRub20Ic2l4LmRub20Kc2V2ZW4uZG5vbQplaWdodC5kbm9tCW5pbmUuZG5vbQ5wYXJlbmxlZnQuZG5vbQ9wYXJlbnJpZ2h0LmRub20LcGVyaW9kLmRub20KY29tbWEuZG5vbQl6ZXJvLm51bXIIb25lLm51bXIIdHdvLm51bXIKdGhyZWUubnVtcglmb3VyLm51bXIJZml2ZS5udW1yCHNpeC5udW1yCnNldmVuLm51bXIKZWlnaHQubnVtcgluaW5lLm51bXIOcGFyZW5sZWZ0Lm51bXIPcGFyZW5yaWdodC5udW1yC3BlcmlvZC5udW1yCmNvbW1hLm51bXINb3JkZmVtaW5pbmUuYQZhLnN1cHMGYi5zdXBzBmMuc3VwcwZkLnN1cHMGZS5zdXBzBmYuc3VwcwZnLnN1cHMGaC5zdXBzBmkuc3VwcwZqLnN1cHMGay5zdXBzBmwuc3VwcwZtLnN1cHMGbi5zdXBzBm8uc3VwcwZwLnN1cHMGcS5zdXBzBnIuc3VwcwZzLnN1cHMGdC5zdXBzBnUuc3VwcwZ2LnN1cHMGdy5zdXBzBnguc3VwcwZ5LnN1cHMGei5zdXBzC2VncmF2ZS5zdXBzC2VhY3V0ZS5zdXBzDHVuaTAyNTkuc3Vwcwd1bmkwMkUwB3VuaTAyRTQGYS5zdXBhBmcuc3VwYQZpLnN1cGEKY29sb24uc3VwcwtoeXBoZW4uc3VwcwtlbmRhc2guc3VwcwtlbWRhc2guc3VwcwRFdXJvB3VuaTAxOTINY29sb25tb25ldGFyeQRsaXJhB3VuaTIwQTYGcGVzZXRhB3VuaTIwQTkEZG9uZwd1bmkyMEIxB3VuaTIwQjIHdW5pMjBCNAd1bmkyMEI1B3VuaTIwQjkHdW5pMjBCQQd1bmkyMEFFB3VuaTIwQjgHdW5pMjBCRAd1bmkyMjE1CnNsYXNoLmZyYWMIb25ldGhpcmQJdHdvdGhpcmRzB3VuaTIxNTUHdW5pMjE1Ngd1bmkyMTU3B3VuaTIxNTgHdW5pMjE1OQd1bmkyMTVBB3VuaTIxNTAJb25lZWlnaHRoDHRocmVlZWlnaHRocwtmaXZlZWlnaHRocwxzZXZlbmVpZ2h0aHMHdW5pMjE1MQd1bmkyMTUyB3VuaTIxODkHdW5pMjIxOQtlcXVpdmFsZW5jZQ1yZXZsb2dpY2Fsbm90DGludGVyc2VjdGlvbgpvcnRob2dvbmFsB3VuaTIwMzIHdW5pMjAzMwd1bmkyMDM1B3VuaTAwQjUKaW50ZWdyYWx0cAppbnRlZ3JhbGJ0B3VuaTIyMDYHdW5pMjEyNgd1bmkyMjAwB3VuaTIyMDMHdW5pMjIzNwd1bmkyMTA1B3VuaTIxMTMJZXN0aW1hdGVkB3VuaTIxOTAHYXJyb3d1cAd1bmkyMTkyCWFycm93ZG93bgd1bmkyMTk2B3VuaTIxOTcHdW5pMjE5OAd1bmkyMTk5B3VuaTIxRDAHdW5pMjFEMQd1bmkyMUQyB3VuaTIxRDMJYXJyb3dib3RoCWFycm93dXBkbgxhcnJvd3VwZG5ic2UHdW5pMjVDRgd1bmkyNUNCB3VuaTI1QTAHdW5pMjVBMQd1bmkyNzUyB3VuaTI1QzYHdHJpYWd1cAd1bmkyNUIzB3VuaTI1QjYHdW5pMjVCNwd0cmlhZ2RuB3VuaTI1QkQHdW5pMjVDMAd1bmkyNUMxB3RyaWFncnQHdHJpYWdsZglpbnZjaXJjbGUHdW5pMjVDOQd1bmkyNjEwB3VuaTI2MTEHdW5pMjcxMwttdXNpY2Fsbm90ZQ5tdXNpY2Fsbm90ZWRibAVoZWFydARjbHViB2RpYW1vbmQFc3BhZGUJc21pbGVmYWNlDGludnNtaWxlZmFjZQd1bmkyNzY0B3VuaTI2MTUGdTFGNEE5BnUxRjkxNgZ1MUY1MTIGZmVtYWxlBG1hbGUDc3VuBWhvdXNlB3VuaTAyQjkHdW5pMDJCQgd1bmkwMkJDB3VuaTAyQkUHdW5pMDJCRgd1bmkwMkMxB3VuaTAyRDAHdW5pMDJEMQd1bmkwMkRFB3VuaTAyQzgHdW5pMDJDOQd1bmkwMkNBB3VuaTAyQ0IHdW5pMDJDQwd1bmkyNUNDB3VuaTAzMDALdW5pMDMwMC5jYXAJdW5pMDMwMC5nB3VuaTAzMDELdW5pMDMwMS5jYXAJdW5pMDMwMS5nB3VuaTAzMDILdW5pMDMwMi5jYXAHdW5pMDMwMwt1bmkwMzAzLmNhcAd1bmkwMzA0C3VuaTAzMDQuY2FwB3VuaTAzMDULdW5pMDMwNS5jYXAHdW5pMDMwNgl1bmkwMzA2LmMLdW5pMDMwNi5jYXAMdW5pMDMwNi5jY2FwB3VuaTAzMDcLdW5pMDMwNy5jYXAHdW5pMDMwOAt1bmkwMzA4LmNhcAd1bmkwMzA5C3VuaTAzMDkuY2FwB3VuaTAzMTAHdW5pMDMwQQt1bmkwMzBBLmNhcAd1bmkwMzBCC3VuaTAzMEIuY2FwB3VuaTAzMEMLdW5pMDMwQy5jYXAJdW5pMDMwQy5hB3VuaTAzMEYLdW5pMDMwRi5jYXAHdW5pMDMxMQt1bmkwMzExLmNhcAd1bmkwMzEyCXVuaTAzMTIuZwd1bmkwMzEzCXVuaTAzMTMuZwd1bmkwMzE4B3VuaTAzMTkHdW5pMDMxQQd1bmkwMzFCB3VuaTAzMUMHdW5pMDMxRAd1bmkwMzFFB3VuaTAzMUYHdW5pMDMyMAd1bmkwMzIzB3VuaTAzMjQHdW5pMDMyNQd1bmkwMzI2CXVuaTAzMjYuYQd1bmkwMzI3C3VuaTAzMjcuY2FwB3VuaTAzMjgLdW5pMDMyOC5jYXAHdW5pMDMyOQd1bmkwMzJBB3VuaTAzMkMHdW5pMDMyRQd1bmkwMzJGB3VuaTAzMzAHdW5pMDMzMQd1bmkwMzM0B3VuaTAzMzkHdW5pMDMzQQd1bmkwMzNCB3VuaTAzM0MHdW5pMDMzRAd1bmkwMzQyB3VuaTAzNDUHdW5pMDM1Rgd1bmkwMzYxC3VuaTAzMDgwMzAxD3VuaTAzMDgwMzAxLmNhcA11bmkwMzA4MDMwMS5nC3VuaTAzMDgwMzAwD3VuaTAzMDgwMzAwLmNhcA11bmkwMzA4MDMwMC5nC3VuaTAzMDgwMzAzC3VuaTAzMDgwMzA0D3VuaTAzMDgwMzA0LmNhcAt1bmkwMzA4MDMwQw91bmkwMzA4MDMwQy5jYXALdW5pMDMwMjAzMDEPdW5pMDMwMjAzMDEuY2FwC3VuaTAzMDIwMzAwD3VuaTAzMDIwMzAwLmNhcAt1bmkwMzAyMDMwOQ91bmkwMzAyMDMwOS5jYXALdW5pMDMwMjAzMDMPdW5pMDMwMjAzMDMuY2FwC3VuaTAzMDYwMzAxD3VuaTAzMDYwMzAxLmNhcAt1bmkwMzA2MDMwMA91bmkwMzA2MDMwMC5jYXALdW5pMDMwNjAzMDkPdW5pMDMwNjAzMDkuY2FwC3VuaTAzMDYwMzAzD3VuaTAzMDYwMzAzLmNhcAt1bmkwMzAyMDMwNg91bmkwMzAyMDMwNi5jYXALdW5pMDMwNDAzMDEPdW5pMDMwNDAzMDEuY2FwC3VuaTAzMTIwMzAxC3VuaTAzMTIwMzAwC3VuaTAzMTIwMzAzC3VuaTAzMTMwMzAxC3VuaTAzMTMwMzAwC3VuaTAzMTMwMzAzB3VuaTAwQTAHdW5pMjAwNwpzcGFjZS5mcmFjDG5ic3BhY2UuZnJhYwd1bmkyNTAwB3VuaTI1MDEHdW5pMjUwMgd1bmkyNTAzB3VuaTI1MDQHdW5pMjUwNQd1bmkyNTA2B3VuaTI1MDcHdW5pMjUwOAd1bmkyNTA5B3VuaTI1MEEHdW5pMjUwQgd1bmkyNTBDB3VuaTI1MEQHdW5pMjUwRQd1bmkyNTBGB3VuaTI1MTAHdW5pMjUxMQd1bmkyNTEyB3VuaTI1MTMHdW5pMjUxNAd1bmkyNTE1B3VuaTI1MTYHdW5pMjUxNwd1bmkyNTE4B3VuaTI1MTkHdW5pMjUxQQd1bmkyNTFCB3VuaTI1MUMHdW5pMjUxRAd1bmkyNTFFB3VuaTI1MUYHdW5pMjUyMAd1bmkyNTIxB3VuaTI1MjIHdW5pMjUyMwd1bmkyNTI0B3VuaTI1MjUHdW5pMjUyNgd1bmkyNTI3B3VuaTI1MjgHdW5pMjUyOQd1bmkyNTJBB3VuaTI1MkIHdW5pMjUyQwd1bmkyNTJEB3VuaTI1MkUHdW5pMjUyRgd1bmkyNTMwB3VuaTI1MzEHdW5pMjUzMgd1bmkyNTMzB3VuaTI1MzQHdW5pMjUzNQd1bmkyNTM2B3VuaTI1MzcHdW5pMjUzOAd1bmkyNTM5B3VuaTI1M0EHdW5pMjUzQgd1bmkyNTNDB3VuaTI1M0QHdW5pMjUzRQd1bmkyNTNGB3VuaTI1NDAHdW5pMjU0MQd1bmkyNTQyB3VuaTI1NDMHdW5pMjU0NAd1bmkyNTQ1B3VuaTI1NDYHdW5pMjU0Nwd1bmkyNTQ4B3VuaTI1NDkHdW5pMjU0QQd1bmkyNTRCB3VuaTI1NEMHdW5pMjU0RAd1bmkyNTRFB3VuaTI1NEYHdW5pMjU1MAd1bmkyNTUxB3VuaTI1NTIHdW5pMjU1Mwd1bmkyNTU0B3VuaTI1NTUHdW5pMjU1Ngd1bmkyNTU3B3VuaTI1NTgHdW5pMjU1OQd1bmkyNTVBB3VuaTI1NUIHdW5pMjU1Qwd1bmkyNTVEB3VuaTI1NUUHdW5pMjU1Rgd1bmkyNTYwB3VuaTI1NjEHdW5pMjU2Mgd1bmkyNTYzB3VuaTI1NjQHdW5pMjU2NQd1bmkyNTY2B3VuaTI1NjcHdW5pMjU2OAd1bmkyNTY5B3VuaTI1NkEHdW5pMjU2Qgd1bmkyNTZDB3VuaTI1NkQHdW5pMjU2RQd1bmkyNTZGB3VuaTI1NzAHdW5pMjU3MQd1bmkyNTcyB3VuaTI1NzMHdW5pMjU3NAd1bmkyNTc1B3VuaTI1NzYHdW5pMjU3Nwd1bmkyNTc4B3VuaTI1NzkHdW5pMjU3QQd1bmkyNTdCB3VuaTI1N0MHdW5pMjU3RAd1bmkyNTdFB3VuaTI1N0YHdW5pMjU4MAd1bmkyNTgxB3VuaTI1ODIHdW5pMjU4Mwd1bmkyNTg0B3VuaTI1ODUHdW5pMjU4Ngd1bmkyNTg3B3VuaTI1ODgHdW5pMjU4OQd1bmkyNThBB3VuaTI1OEIHdW5pMjU4Qwd1bmkyNThEB3VuaTI1OEUHdW5pMjU4Rgd1bmkyNTkwB3VuaTI1OTEHdW5pMjU5Mgd1bmkyNTkzB3VuaTI1OTQHdW5pMjU5NQd1bmkyNTk2B3VuaTI1OTcHdW5pMjU5OAd1bmkyNTk5B3VuaTI1OUEHdW5pMjU5Qgd1bmkyNTlDB3VuaTI1OUQHdW5pMjU5RQd1bmkyNTlGB3VuaTIwMkYHdW5pRkVGRgd1bmlGRTBFB3VuaUZFMEYGdTFGM0I1BnUxRjNCNg51MUYzQjVfdW5pRkUwRg51MUYzQjZfdW5pRkUwRg91bmkyNjExX3VuaUZFMEYPdW5pMjcxM191bmlGRTBGD3VuaTI2NjVfdW5pRkUwRg91bmkyNjYzX3VuaUZFMEYPdW5pMjY2Nl91bmlGRTBGD3VuaTI2NjBfdW5pRkUwRg91bmkyNjNBX3VuaUZFMEYPdW5pMjYzQl91bmlGRTBGD3VuaTI3NjRfdW5pRkUwRg91bmkyNjE1X3VuaUZFMEYOdTFGNEE5X3VuaUZFMEYOdTFGOTE2X3VuaUZFMEYOdTFG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AOIAOAD7APsAOQD9AP4AOgEZARkAPAEnAScAPQFUAVQAPgFgAWAAPwGAAYAAQAGGAYYAQQGIAYgAQgGfAZ8AQwGxAbEARAHKAc0ARQHRAg4ASQIRAhgAhwIcAhwAjwI0AjQAkAI9Aj4AkQJKAkoAkwJNAlAAlAJXAlcAmAJaAlwAmQJiAmIAnAJzAnMAnQJ9An0AngKDAoMAnwKUApQAoATpBOkAoQAXAAADTgAAA04AAANOAAADTgAAA04AAANOAAADTgAAA04AAANOAAADTgAAA04AAANOAAADTgAAA04AAANOAAADTgAAA04AAANOAAADTgAAA04AAANOAAADTgAAA04AogLwAUYBTAI2AVIBWAFeAvAC8ALwAWQBsgLwAvAC8AFqAsABlALwAvACTgKWAvAC8AJ4AvABcAF2AsYCeAF8AYIBpgLSAfoBiAIeAY4BlALwAcoBmgJyAb4BxALwAvAC8ALwAaABpgGsAbgBsgLwAvAC8AG4AsYCnAG+AsYC0gIeAvAC8AG+AcQC8AKcAcoCEgH6ApwCeAJ4AdAB1gHcAvACNgLGAsAB4gHoAngB7gH0AfoCzALMAgACBgLwAgwCeAISAvAC0gLwAtgCGAIeAh4CJAIqAjACNgI8AmYCQgJIAk4C8AJUAloCYAJgAmYCbAJyAngCxgJ+AoQChAKKApAC8ALwApYC8ALwApwC8AKiAqgCrgK0AroCwAK6AsACxgLMAt4C3gLeAtIC3gLYAt4C3gLeAt4C8ALwAvAC5ALqAvAC8AABATP/7AABAVj/7AABAU3/7AABALX/7AABAUr/7AABAVL/7AABAIz/7AABATb/7AABAVT/7AABASP/7AABATT/JQABAU//7AABATT/7AABATn/7AABAc3/JQABAQv/JQABATr/7AABAVD/7AABAV3/7AABASL/7AABATX/7AABAXz/7AABAIn/JQABARj/7AABAWj/7AABATP/JQABASj/7AABAOH/7AABAR//7AABAS3/7AABAO3/JQABAUb/7AABASz/owABAWH/owABAWn/JQABAcL/JQABAYH/7AABAYH/JQABAWX/JQABAVf/7AABASb/7AABAfD/HgABAK7/JQABAa7/JQABAS7/7AABAV7/7AABASz/JQABAQ//7AABATD/JQABAUj/JQABAL//7AABATz/7AABATb/JQABAQD/JQABAWD/uAABAXz/JQABAS//7AABATL/7AABAR7/HgABAUr/JQABAU7/7AABAUv/JQABARf/7AABAUD/7AABATD/7AABASb/JQABAVz/7AABAN//JQABAUj/7AABARb/7AABAIf/7AABASz/7AAEAAAAAQAIAAEADAASAAEAHgAkAAEAAQUrAAEABAANACcCUATpAAEAAAAiAAQACgAQABYAHAABALABUQABASABgQABAVEBgQABASwA9AAEAAAAAQAIAAEADAASAAEAHgAqAAEAAQUVAAEABAAQABYAKgTpAAEAAAAGAAEBLAHmAAQACgAQABYAHAABAaQChgABAfcCmgABAZsB5gABAZ8B5gAEAAAAAQAIAAEADAAUAAEAWABiAAEAAgUiBSMAAQAgAAIABgAKABAAFgAaABwAIAAkACoAMAA0ADcAOgA9AF4ApQD9AQMBBgEJASkBVAFyAdsCHAIeAiECJAI9Aj4E6QACAAAAjgAAAI4AIABOAHgAhACEAIQAhABgAGYAbACEAEIASABOAE4ATgBUAIQAWgBgAGAAYABmAGwAhAByAHgAeAB4AHgAfgB+AIQAAQGqAAAAAQEG/5cAAQH4AAAAAQGtAAAAAQE2AAAAAQG0AAAAAQGUAAAAAQFkAAAAAQEoAAAAAQGuAAAAAQFQAAAAAQEsAAAABgEAAAEACAABAAwALgABAEoBiAACAAUE6gUIAAAFCgURAB8FMAUxACcFNQVRACkFVAVZAEYAAQAMBOoE7QTwBPIE9AT2BPgE+QT8BP4FAAUDAEwAAAE4AAABMgAAATgAAAE4AAABMgAAATgAAAE4AAABMgAAATgAAAEyAAABOAAAATIAAAE4AAABMgAAATgAAAE4AAABMgAAATIAAAE4AAABMgAAATgAAAEyAAABOAAAATIAAAE4AAABOAAAATIAAAE4AAABMgAAATgAAAEyAAABOAAAATIAAAE4AAABMgAAATgAAAE4AAABOAAAATgAAAE4AAABOAAAATgAAAEyAAABOAAAATgAAAEyAAABOAAAATgAAAE4AAABMgAAATgAAAEyAAABOAAAATIAAAE4AAABMgAAATgAAAEyAAABOAAAATIAAAE4AAABMgAAATgAAAEyAAABOAAAATIAAAE4AAABMgAAATgAAAEyAAABOAAAATgAAAE4AAABOAAAATgAAAE4AAEBLAKkAAEBLAH7AAwAGgAaACAALAAmACYALAAsADIAOAA+AEQAAQEsAmoAAQEsAtwAAQEsAj4AAQEsAkwAAQEsAsUAAQEsAmkAAQEsAlsAAQEsAlQAAAABAAAACgJICb4ABERGTFQAGmN5cmwAZmdyZWsBBGxhdG4BUgAEAAAAAP//ACEAAAAHAA4AFQAcACMAKgAxADgAPwBGAE0AVABbAGIAaQBwAHcAgwCKAJEAmACfAKYArQC0ALsAwgDJANAA1wDeAOUACgABU1JCIABUAAD//wAiAAEACAAPABYAHQAkACsAMgA5AEAARwBOAFUAXABjAGoAcQB4AH4AhACLAJIAmQCgAKcArgC1ALwAwwDKANEA2ADfAOYAAP//ACIAAgAJABAAFwAeACUALAAzADoAQQBIAE8AVgBdAGQAawByAHkAfwCFAIwAkwCaAKEAqACvALYAvQDEAMsA0gDZAOAA5wAEAAAAAP//ACIAAwAKABEAGAAfACYALQA0ADsAQgBJAFAAVwBeAGUAbABzAHoAgACGAI0AlACbAKIAqQCwALcAvgDFAMwA0wDaAOEA6AAQAAJOU00gAFhTS1MgAKIAAP//ACEABAALABIAGQAgACcALgA1ADwAQwBKAFEAWABfAGYAbQB0AHsAhwCOAJUAnACjAKoAsQC4AL8AxgDNANQA2wDiAOkAAP//ACIABQAMABMAGgAhACgALwA2AD0ARABLAFIAWQBgAGcAbgB1AHwAgQCIAI8AlgCdAKQAqwCyALkAwADHAM4A1QDcAOMA6gAA//8AIgAGAA0AFAAbACIAKQAwADcAPgBFAEwAUwBaAGEAaABvAHYAfQCCAIkAkACXAJ4ApQCsALMAugDBAMgAzwDWAN0A5ADrAOxjYXNlBYpjYXNlBYpjYXNlBYpjYXNlBYpjYXNlBYpjYXNlBYpjYXNlBYpjY21wBZBjY21wBZBjY21wBZBjY21wBZBjY21wBZBjY21wBZBjY21wBZBjdjAxBZ5jdjAxBZ5jdjAxBZ5jdjAxBZ5jdjAxBZ5jdjAxBZ5jdjAxBZ5jdjAyBbJjdjAyBbJjdjAyBbJjdjAyBbJjdjAyBbJjdjAyBbJjdjAyBbJjdjA0BcZjdjA0BcZjdjA0BcZjdjA0BcZjdjA0BcZjdjA0BcZjdjA0BcZjdjA2BdpjdjA2BdpjdjA2BdpjdjA2BdpjdjA2BdpjdjA2BdpjdjA2BdpjdjA3Be5jdjA3Be5jdjA3Be5jdjA3Be5jdjA3Be5jdjA3Be5jdjA3Be5jdjA4BgJjdjA4BgJjdjA4BgJjdjA4BgJjdjA4BgJjdjA4BgJjdjA4BgJjdjA5BhZjdjA5BhZjdjA5BhZjdjA5BhZjdjA5BhZjdjA5BhZjdjA5BhZjdjEwBipjdjEwBipjdjEwBipjdjEwBipjdjEwBipjdjEwBipjdjEwBipjdjExBj5jdjExBj5jdjExBj5jdjExBj5jdjExBj5jdjExBj5jdjExBj5jdjEyBlJjdjEyBlJjdjEyBlJjdjEyBlJjdjEyBlJjdjEyBlJjdjEyBlJjdjE0BmZjdjE0BmZjdjE0BmZjdjE0BmZjdjE0BmZjdjE0BmZjdjE0BmZjdjE1BnpjdjE1BnpjdjE1BnpjdjE1BnpjdjE1BnpjdjE1BnpjdjE1BnpjdjE2Bo5jdjE2Bo5jdjE2Bo5jdjE2Bo5jdjE2Bo5jdjE2Bo5jdjE2Bo5jdjE3BqJjdjE3BqJjdjE3BqJjdjE3BqJjdjE3BqJjdjE3BqJjdjE3BqJkbm9tBrZkbm9tBrZkbm9tBrZkbm9tBrZkbm9tBrZkbm9tBrZkbm9tBrZmcmFjBrxmcmFjBrxmcmFjBrxmcmFjBrxmcmFjBrxmcmFjBrxmcmFjBrxsb2NsBshsb2NsBs5sb2NsBtZsb2NsBtxsb2NsBtxudW1yBuJudW1yBuJudW1yBuJudW1yBuJudW1yBuJudW1yBuJudW1yBuJvbnVtBuhvbnVtBuhvbnVtBuhvbnVtBuhvbnVtBuhvbnVtBuhvbnVtBuhvcmRuBu5vcmRuBu5vcmRuBu5vcmRuBu5vcmRuBu5vcmRuBu5vcmRuBu5zYWx0BvRzYWx0BvRzYWx0BvRzYWx0BvRzYWx0BvRzYWx0BvRzYWx0BvRzaW5mB2BzaW5mB2BzaW5mB2BzaW5mB2BzaW5mB2BzaW5mB2BzaW5mB2BzczAxBxBzczAxBxBzczAxBxBzczAxBxBzczAxBxBzczAxBxBzczAxBxBzczAyBxxzczAyBxxzczAyBxxzczAyBxxzczAyBxxzczAyBxxzczAyBxxzczAzByhzczAzByhzczAzByhzczAzByhzczAzByhzczAzByhzczAzByhzczA0BzZzczA0BzZzczA0BzZzczA0BzZzczA0BzZzczA0BzZzczA0BzZzczA1B0BzczA1B0BzczA1B0BzczA1B0BzczA1B0BzczA1B0BzczA1B0BzczA2B0xzczA2B0xzczA2B0xzczA2B0xzczA2B0xzczA2B0xzczA2B0xzczA3B1ZzczA3B1ZzczA3B1ZzczA3B1ZzczA3B1ZzczA3B1ZzczA3B1ZzdWJzB2BzdWJzB2BzdWJzB2BzdWJzB2BzdWJzB2BzdWJzB2BzdWJzB2BzdXBzB2ZzdXBzB2ZzdXBzB2ZzdXBzB2ZzdXBzB2ZzdXBzB2ZzdXBzB2Z6ZXJvB3B6ZXJvB3B6ZXJvB3B6ZXJvB3B6ZXJvB3B6ZXJvB3B6ZXJvB3AAAAABAB8AAAAFABAAEQASABMAFAAGAAEAAAAAAQAAAAAAAAAAAAAAAAYAAQABAAABAQAAAAAAAAAAAAAABgABAAIAAAECAAAAAAAAAAAAAAAGAAEAAwAAAQMAAAAAAAAAAAAAAAYAAQAEAAABBAAAAAAAAAAAAAAABgABAAUAAAEFAAAAAAAAAAAAAAAGAAEABgAAAQYAAAAAAAAAAAAAAAYAAQAIAAABBwAAAAAAAAAAAAAABgABAAcAAAEIAAAAAAAAAAAAAAAGAAEACQAAAQkAAAAAAAAAAAAAAAYAAQAKAAABCgAAAAAAAAAAAAAABgABAAsAAAELAAAAAAAAAAAAAAAGAAEADAAAAQwAAAAAAAAAAAAAAAYAAQANAAABDQAAAAAAAAAAAAAAAAABABYAAAAEABUAFwAYABkAAAABAAcAAAACAAcACAAAAAEADgAAAAEAAwAAAAEAFQAAAAEAHgAAAAEAGgAAAAwAAAABAAIAAwAEAAUABgAJAAoACwAMACAACAACAAoACwAAAQ4ACAACAAAABAAAAQ8ACgADAAEABQAIAAABEAAGAAEAAgAAAREACAACAAMABgAAARIABgABAAwAAAETAAYAAQAgAAABFAAAAAEAHQAAAAMAGgAbABwAAAABAAkAIwBIALYA7gF4AYwBoAG0AcgB3gHyAgoCIgI2AkoCXgKAAvYDZAQMBSwGXAdYB4QHsAfEB/AITAiqCNYI+AlACV4KUApoCpYAAQAAAAEACAACAD4AHAIcAh0CHgIfAiACIQIiAiMCJAIlAiYCMwInAigCKQIqAisCLAItAi4CLwIwAjECMgNYA1kEGAQ5AAIABgAcABwAAAECARgAAQMNAw0AGANPA08AGQQXBBcAGgQaBBoAGwABAAAAAQAIAAIAGgAKAjQCNQI2AjcCOAI5AjoCOwI8BDoAAgADACIAIgAAAToBQQABBCAEIAAJAAEAAAABAAgAAgBCAB4CPQJQAj8CQAJBAkICQwJEAkUCRgJHAkgCSQI+AlECUgJTAlQCVQJWAlcCWAJZAkoCWgJbAkwCTgNbBDsAAQAeACQAJwFJAUoBSwFMAU0BTgFPAVABUQFSAVMBVAFaAVsBXAFdAV4BXwFgAWEBzwHqAe4B7wJLAk0DMwQiAAEAAAABAAgAAQAGAR0AAQABAP4AAQAAAAEACAABAAYAGAABAAECfgABAAAAAQAIAAEABgATAAEAAQKEAAEAAAABAAgAAQAGAAgAAQABApEAAQAAAAEACAABAAYAAQABAAIE+AT6AAEAAAABAAgAAQAGAEwAAQABAw4AAQAAAAEACAABAAYACgABAAMDXgNqA3YAAQAAAAEACAABAAYAQwABAAMDmAOZA5oAAQAAAAEACAABAAYAHgABAAEDvAABAAAAAQAIAAEABv+dAAEAAQRBAAEAAAABAAgAAQAGAAoAAQABA18AAQAAAAEACAACAA4ABATsBO8FDwURAAEABATqBO0FDgUQAAIAAAABAAgAAQAaAAoAMgA4AD4ARABKAFAAVgBcAGIAaAABAAoAXwBiAKMApgEqAS0BcAFzAukDNAACAAYE8AACAAYE9AACABAE8AACABAE9AACACAE8AACACAE9AACACoE8AACACoE9AACAAoE/gACAVQE/gAGAAAAAwAMADAATgADAAAAAQASAAEAHgABAAAADwABAAQAXwCjASoBcAABAAEE+AADAAAAAQASAAEAOAABAAAADwABAAQAYgCmAS0BcwADAAAAAQASAAEAGgABAAAADwABAAIC6QM0AAEAAQTtAAYAAAADAAwAJgBGAAMAAAACABQANAABAFwAAQAAACEAAQABACQAAwAAAAIAFAAaAAEAQgABAAAAIQABAAECPQABAAEFIgADAAAAAQASAAEAIgABAAAAIgABAAYAJAAlAVAB6gHsAkYAAQAeBOoE7QTwBPIE9AT2BPgE+QT8BP4FAAUDBQUFBwUK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";

// OpenSans font
var fontStylesString = "\n  input:focus,\n  select:focus,\n  textarea:focus,\n  button:focus {\n      outline: none;\n  }\n\n  @font-face {\n    src: url(".concat(openSansRegular, ");\n    font-family: OpenSans-Regular;\n  }\n\n  @font-face {\n    src: url(").concat(openSansBold, ");\n    font-family: OpenSans-Bold;\n  }\n\n  @font-face {\n    src: url(").concat(openSansBoldItalic, ");\n    font-family: OpenSans-BoldItalic;\n  }\n\n  @font-face {\n    src: url(").concat(openSansExtraBold, ");\n    font-family: OpenSans-ExtraBold;\n  }\n\n  @font-face {\n    src: url(").concat(openSansExtraBoldItalic, ");\n    font-family: OpenSans-ExtraBoldItalic;\n  }\n\n  @font-face {\n    src: url(").concat(openSansItalic, ");\n    font-family: OpenSans-Italic;\n  }\n\n  @font-face {\n    src: url(").concat(openSansLight, ");\n    font-family: OpenSans-Light;\n  }\n\n  @font-face {\n    src: url(").concat(openSansLightItalic, ");\n    font-family: OpenSans-LightItalic;\n  }\n\n  @font-face {\n    src: url(").concat(openSansSemiBold, ");\n    font-family: OpenSans-SemiBold;\n  }\n\n  @font-face {\n    src: url(").concat(openSansSemiBoldItalic, ");\n    font-family: OpenSans-SemiBoldItalic;\n  }\n\n  @font-face {\n    src: url(").concat(sourceCodeProRegular, ");\n    font-family: SourceCodePro-Regular;\n  }\n");
var fontStyles = document.createElement("style");
fontStyles.type = "text/css";
if (fontStyles.styleSheet) {
    fontStyles.styleSheet.cssText = fontStylesString;
}
else {
    fontStyles.appendChild(document.createTextNode(fontStylesString));
}
var injectFonts = function () {
    if (document) {
        document.head.appendChild(fontStyles);
    }
};

var weights = {
    bold: text.bold,
    regular: text.body,
};
var truncateMaxChars = function (str, maxlimit) {
    if (maxlimit === void 0) { maxlimit = 100; }
    return str && str.length > maxlimit
        ? "".concat(str.substring(0, maxlimit - 3), "...")
        : str;
};
var TypographyBase = React__default["default"].forwardRef(function (_a, ref) {
    var numberOfLines = _a.numberOfLines, onPress = _a.onPress, _b = _a.weight, weight = _b === void 0 ? "regular" : _b, style = _a.style, color = _a.color, children = _a.children, fontSize = _a.fontSize, underline = _a.underline;
    return (jsxRuntime.exports.jsx(reactNative.Text
    // react's ref does not match react-native ref type - react native using legacy ref.
    // perhaps there is a workaround to properly type it?
    // @ts-ignore
    , __assign({ 
        // react's ref does not match react-native ref type - react native using legacy ref.
        // perhaps there is a workaround to properly type it?
        // @ts-ignore
        ref: ref, numberOfLines: numberOfLines, testID: "typographyBody", onPress: onPress, style: [
            {
                fontSize: fontSize,
                color: color,
                textDecorationLine: underline ? "underline" : "none",
            },
            weights[weight],
            style,
        ] }, { children: children })));
});
var SubCaption = function (_a) {
    var props = __rest(_a, []);
    return (jsxRuntime.exports.jsx(TypographyBase, __assign({}, props, { fontSize: FONT_SIZE_SUB_CAPTION })));
};
var Caption$1 = function (_a) {
    var props = __rest(_a, []);
    return (jsxRuntime.exports.jsx(TypographyBase, __assign({}, props, { fontSize: FONT_SIZE_CAPTION })));
};
var Body = React__default["default"].forwardRef(function (_a, ref) {
    var props = __rest(_a, []);
    return (jsxRuntime.exports.jsx(TypographyBase, __assign({ ref: ref }, props, { fontSize: FONT_SIZE_BODY })));
});
var SubHeader = function (_a) {
    var props = __rest(_a, []);
    return (jsxRuntime.exports.jsx(TypographyBase, __assign({}, props, { fontSize: FONT_SIZE_SUB_HEADER })));
};
var Header = function (_a) {
    var props = __rest(_a, []);
    return (jsxRuntime.exports.jsx(TypographyBase, __assign({}, props, { fontSize: FONT_SIZE_HEADER })));
};
var LargeHeader = function (_a) {
    var props = __rest(_a, []);
    return (jsxRuntime.exports.jsx(TypographyBase, __assign({}, props, { fontSize: FONT_SIZE_LARGE_HEADER })));
};
var Title$1 = function (_a) {
    var props = __rest(_a, []);
    return (jsxRuntime.exports.jsx(TypographyBase, __assign({}, props, { fontSize: FONT_SIZE_TITLE })));
};
var LargeTitle = function (_a) {
    var props = __rest(_a, []);
    return (jsxRuntime.exports.jsx(TypographyBase, __assign({}, props, { fontSize: FONT_SIZE_LARGE_TITLE })));
};

var whiteBackgroundGradient = {
    gradientColors: [white$1, white$1],
};
// container styles by type
var typeContainerStyles = {
    primary: {
        backgroundColor: dodgerBlue,
        gradientColors: [cyanBlue, dodgerBlue],
    },
    primary_hover: {
        backgroundColor: "#002579",
        opacity: 0.8,
        gradientColors: ["#0040D2", "#002579"],
    },
    secondary: __assign({ backgroundColor: white$1, borderWidth: 1, borderColor: dodgerBlue }, whiteBackgroundGradient),
    secondary_hover: {
        borderColor: "#002579",
    },
    disabled: {
        gradientColors: [grey$1, grey$1],
    },
    minimal: __assign({ backgroundColor: "white", borderColor: "white" }, whiteBackgroundGradient),
    "danger-minimal": __assign({ backgroundColor: "white", borderColor: "white" }, whiteBackgroundGradient),
};
// text style by type
var typeTextStyles = {
    primary: {
        color: white$1,
    },
    secondary: {
        color: dodgerBlue,
    },
    secondary_hover: {
        color: "#002579",
    },
    disabled: {
        color: white$1,
    },
    minimal: {
        color: dodgerBlue,
    },
    "danger-minimal": {
        color: "red",
    },
};

var styles$17 = reactNative.StyleSheet.create({
    container: {
        borderRadius: 50,
        maxWidth: 600,
        minWidth: 100,
        height: 48,
    },
});
var getHoverStyle = function (type) {
    return {
        container: __assign(__assign({}, typeContainerStyles[type]), typeContainerStyles["".concat(type, "_hover")]),
        text: __assign(__assign({}, typeTextStyles[type]), typeTextStyles["".concat(type, "_hover")]),
    };
};
var getBaselineStyle = function (type) {
    return {
        container: __assign({}, typeContainerStyles[type]),
        text: __assign({}, typeTextStyles[type]),
    };
};
// will default to primary style if incorrect type is given
var getStyles = function (type, isHovering) {
    return isHovering ? getHoverStyle(type) : getBaselineStyle(type);
};
var Button$2 = function (_a) {
    var title = _a.title, children = _a.children, onPress = _a.onPress, style = _a.style, type = _a.type, _b = _a.isHovering, isHovering = _b === void 0 ? false : _b;
    var typeStyle = getStyles(type, isHovering);
    return (jsxRuntime.exports.jsx(LinearGradient__default["default"], __assign({ style: [styles$17.container, typeStyle.container, style], start: { x: 0, y: 1 }, end: { x: 1, y: 1 }, colors: typeStyle.container.gradientColors }, { children: jsxRuntime.exports.jsx(reactNative.TouchableOpacity, __assign({ style: [containers.fullHeight, padding.ph24, containers.fullWidth, containers.center], onPress: onPress, disabled: type === "disabled" }, { children: title ? (jsxRuntime.exports.jsx(Body, __assign({ weight: "bold", style: typeStyle.text, color: typeStyle.text.color }, { children: title }))) : (children) })) })));
};

var build = {exports: {}};

(function (module, exports) {
	!function(e,t){module.exports=t(React__default["default"]);}(commonjsGlobal,(function(e){return function(e){var t={};function r(l){if(t[l])return t[l].exports;var a=t[l]={i:l,l:!1,exports:{}};return e[l].call(a.exports,a,a.exports,r),a.l=!0,a.exports}return r.m=e,r.c=t,r.d=function(e,t,l){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:l});},r.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0});},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"===typeof e&&e&&e.__esModule)return e;var l=Object.create(null);if(r.r(l),Object.defineProperty(l,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var a in e)r.d(l,a,function(t){return e[t]}.bind(null,a));return l},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="/",r(r.s=1)}([function(t,r){t.exports=e;},function(e,t,r){e.exports=r(2);},function(e,t,r){function l(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);t&&(l=l.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,l);}return r}function i(e,t){if(null==e)return {};var r,l,a=function(e,t){if(null==e)return {};var r,l,a={},i=Object.keys(e);for(l=0;l<i.length;l++)r=i[l],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(l=0;l<i.length;l++)r=i[l],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r]);}return a}r.r(t);var n=r(0),c=r.n(n),h=function(e){for(var t=0,r=0;r<e.length;r++){t=(t<<5)-t+e.charCodeAt(r),t&=t;}return Math.abs(t)},o=function(e,t){return Math.floor(e/Math.pow(10,t)%10)},s=function(e,t){return !(o(e,t)%2)},m=function(e,t,r){var l=e%t;return r&&o(e,r)%2===0?-l:l},f=function(e,t,r){return t[e%r]};var u=function(e){var t=function(e,t){var r=h(e),l=t&&t.length;return Array.from({length:4},(function(e,a){return {color:f(r+a,t,l),translateX:m(r*(a+1),40-(a+17),1),translateY:m(r*(a+1),40-(a+17),2),rotate:m(r*(a+1),360),isSquare:s(r,2)}}))}(e.name,e.colors);return n.createElement("svg",{viewBox:"0 0 80 80",fill:"none",role:"img",xmlns:"http://www.w3.org/2000/svg",width:e.size,height:e.size},n.createElement("title",null,e.name),n.createElement("mask",{id:"mask__bauhaus",maskUnits:"userSpaceOnUse",x:0,y:0,width:80,height:80},n.createElement("rect",{width:80,height:80,rx:e.square?void 0:160,fill:"#FFFFFF"})),n.createElement("g",{mask:"url(#mask__bauhaus)"},n.createElement("rect",{width:80,height:80,fill:t[0].color}),n.createElement("rect",{x:10,y:30,width:80,height:t[1].isSquare?80:10,fill:t[1].color,transform:"translate("+t[1].translateX+" "+t[1].translateY+") rotate("+t[1].rotate+" 40 40)"}),n.createElement("circle",{cx:40,cy:40,fill:t[2].color,r:16,transform:"translate("+t[2].translateX+" "+t[2].translateY+")"}),n.createElement("line",{x1:0,y1:40,x2:80,y2:40,strokeWidth:2,stroke:t[3].color,transform:"translate("+t[3].translateX+" "+t[3].translateY+") rotate("+t[3].rotate+" 40 40)"})))};var d=function(e){var t=function(e,t){var r=h(t),l=e&&e.length,a=Array.from({length:5},(function(t,a){return f(r+a,e,l)})),i=[];return i[0]=a[0],i[1]=a[1],i[2]=a[1],i[3]=a[2],i[4]=a[2],i[5]=a[3],i[6]=a[3],i[7]=a[0],i[8]=a[4],i}(e.colors,e.name);return c.a.createElement("svg",{viewBox:"0 0 90 90",fill:"none",role:"img",xmlns:"http://www.w3.org/2000/svg",width:e.size,height:e.size},c.a.createElement("title",null,e.name),c.a.createElement("mask",{id:"mask__ring",maskUnits:"userSpaceOnUse",x:0,y:0,width:90,height:90},c.a.createElement("rect",{width:90,height:90,rx:e.square?void 0:180,fill:"#FFFFFF"})),c.a.createElement("g",{mask:"url(#mask__ring)"},c.a.createElement("path",{d:"M0 0h90v45H0z",fill:t[0]}),c.a.createElement("path",{d:"M0 45h90v45H0z",fill:t[1]}),c.a.createElement("path",{d:"M83 45a38 38 0 00-76 0h76z",fill:t[2]}),c.a.createElement("path",{d:"M83 45a38 38 0 01-76 0h76z",fill:t[3]}),c.a.createElement("path",{d:"M77 45a32 32 0 10-64 0h64z",fill:t[4]}),c.a.createElement("path",{d:"M77 45a32 32 0 11-64 0h64z",fill:t[5]}),c.a.createElement("path",{d:"M71 45a26 26 0 00-52 0h52z",fill:t[6]}),c.a.createElement("path",{d:"M71 45a26 26 0 01-52 0h52z",fill:t[7]}),c.a.createElement("circle",{cx:45,cy:45,r:23,fill:t[8]})))};var g=function(e){var t=function(e,t){var r=h(e),l=t&&t.length;return Array.from({length:64},(function(e,a){return f(r%a,t,l)}))}(e.name,e.colors);return n.createElement("svg",{viewBox:"0 0 80 80",fill:"none",role:"img",xmlns:"http://www.w3.org/2000/svg",width:e.size,height:e.size},n.createElement("title",null,e.name),n.createElement("mask",{id:"mask__pixel","mask-type":"alpha",maskUnits:"userSpaceOnUse",x:0,y:0,width:80,height:80},n.createElement("rect",{width:80,height:80,rx:e.square?void 0:160,fill:"#FFFFFF"})),n.createElement("g",{mask:"url(#mask__pixel)"},n.createElement("rect",{width:10,height:10,fill:t[0]}),n.createElement("rect",{x:20,width:10,height:10,fill:t[1]}),n.createElement("rect",{x:40,width:10,height:10,fill:t[2]}),n.createElement("rect",{x:60,width:10,height:10,fill:t[3]}),n.createElement("rect",{x:10,width:10,height:10,fill:t[4]}),n.createElement("rect",{x:30,width:10,height:10,fill:t[5]}),n.createElement("rect",{x:50,width:10,height:10,fill:t[6]}),n.createElement("rect",{x:70,width:10,height:10,fill:t[7]}),n.createElement("rect",{y:10,width:10,height:10,fill:t[8]}),n.createElement("rect",{y:20,width:10,height:10,fill:t[9]}),n.createElement("rect",{y:30,width:10,height:10,fill:t[10]}),n.createElement("rect",{y:40,width:10,height:10,fill:t[11]}),n.createElement("rect",{y:50,width:10,height:10,fill:t[12]}),n.createElement("rect",{y:60,width:10,height:10,fill:t[13]}),n.createElement("rect",{y:70,width:10,height:10,fill:t[14]}),n.createElement("rect",{x:20,y:10,width:10,height:10,fill:t[15]}),n.createElement("rect",{x:20,y:20,width:10,height:10,fill:t[16]}),n.createElement("rect",{x:20,y:30,width:10,height:10,fill:t[17]}),n.createElement("rect",{x:20,y:40,width:10,height:10,fill:t[18]}),n.createElement("rect",{x:20,y:50,width:10,height:10,fill:t[19]}),n.createElement("rect",{x:20,y:60,width:10,height:10,fill:t[20]}),n.createElement("rect",{x:20,y:70,width:10,height:10,fill:t[21]}),n.createElement("rect",{x:40,y:10,width:10,height:10,fill:t[22]}),n.createElement("rect",{x:40,y:20,width:10,height:10,fill:t[23]}),n.createElement("rect",{x:40,y:30,width:10,height:10,fill:t[24]}),n.createElement("rect",{x:40,y:40,width:10,height:10,fill:t[25]}),n.createElement("rect",{x:40,y:50,width:10,height:10,fill:t[26]}),n.createElement("rect",{x:40,y:60,width:10,height:10,fill:t[27]}),n.createElement("rect",{x:40,y:70,width:10,height:10,fill:t[28]}),n.createElement("rect",{x:60,y:10,width:10,height:10,fill:t[29]}),n.createElement("rect",{x:60,y:20,width:10,height:10,fill:t[30]}),n.createElement("rect",{x:60,y:30,width:10,height:10,fill:t[31]}),n.createElement("rect",{x:60,y:40,width:10,height:10,fill:t[32]}),n.createElement("rect",{x:60,y:50,width:10,height:10,fill:t[33]}),n.createElement("rect",{x:60,y:60,width:10,height:10,fill:t[34]}),n.createElement("rect",{x:60,y:70,width:10,height:10,fill:t[35]}),n.createElement("rect",{x:10,y:10,width:10,height:10,fill:t[36]}),n.createElement("rect",{x:10,y:20,width:10,height:10,fill:t[37]}),n.createElement("rect",{x:10,y:30,width:10,height:10,fill:t[38]}),n.createElement("rect",{x:10,y:40,width:10,height:10,fill:t[39]}),n.createElement("rect",{x:10,y:50,width:10,height:10,fill:t[40]}),n.createElement("rect",{x:10,y:60,width:10,height:10,fill:t[41]}),n.createElement("rect",{x:10,y:70,width:10,height:10,fill:t[42]}),n.createElement("rect",{x:30,y:10,width:10,height:10,fill:t[43]}),n.createElement("rect",{x:30,y:20,width:10,height:10,fill:t[44]}),n.createElement("rect",{x:30,y:30,width:10,height:10,fill:t[45]}),n.createElement("rect",{x:30,y:40,width:10,height:10,fill:t[46]}),n.createElement("rect",{x:30,y:50,width:10,height:10,fill:t[47]}),n.createElement("rect",{x:30,y:60,width:10,height:10,fill:t[48]}),n.createElement("rect",{x:30,y:70,width:10,height:10,fill:t[49]}),n.createElement("rect",{x:50,y:10,width:10,height:10,fill:t[50]}),n.createElement("rect",{x:50,y:20,width:10,height:10,fill:t[51]}),n.createElement("rect",{x:50,y:30,width:10,height:10,fill:t[52]}),n.createElement("rect",{x:50,y:40,width:10,height:10,fill:t[53]}),n.createElement("rect",{x:50,y:50,width:10,height:10,fill:t[54]}),n.createElement("rect",{x:50,y:60,width:10,height:10,fill:t[55]}),n.createElement("rect",{x:50,y:70,width:10,height:10,fill:t[56]}),n.createElement("rect",{x:70,y:10,width:10,height:10,fill:t[57]}),n.createElement("rect",{x:70,y:20,width:10,height:10,fill:t[58]}),n.createElement("rect",{x:70,y:30,width:10,height:10,fill:t[59]}),n.createElement("rect",{x:70,y:40,width:10,height:10,fill:t[60]}),n.createElement("rect",{x:70,y:50,width:10,height:10,fill:t[61]}),n.createElement("rect",{x:70,y:60,width:10,height:10,fill:t[62]}),n.createElement("rect",{x:70,y:70,width:10,height:10,fill:t[63]})))};var w=function(e){var t=function(e,t){var r,l=h(e),a=t&&t.length,i=f(l,t,a),n=m(l,10,1),c=n<5?n+4:n,o=m(l,10,2),u=o<5?o+4:o;return {wrapperColor:i,faceColor:(r=i,"#"===r.slice(0,1)&&(r=r.slice(1)),(299*parseInt(r.substr(0,2),16)+587*parseInt(r.substr(2,2),16)+114*parseInt(r.substr(4,2),16))/1e3>=128?"#000000":"#FFFFFF"),backgroundColor:f(l+13,t,a),wrapperTranslateX:c,wrapperTranslateY:u,wrapperRotate:m(l,360),wrapperScale:1+m(l,3)/10,isMouthOpen:s(l,2),isCircle:s(l,1),eyeSpread:m(l,5),mouthSpread:m(l,3),faceRotate:m(l,10,3),faceTranslateX:c>6?c/2:m(l,8,1),faceTranslateY:u>6?u/2:m(l,7,2)}}(e.name,e.colors);return n.createElement("svg",{viewBox:"0 0 36 36",fill:"none",role:"img",xmlns:"http://www.w3.org/2000/svg",width:e.size,height:e.size},n.createElement("title",null,e.name),n.createElement("mask",{id:"mask__beam",maskUnits:"userSpaceOnUse",x:0,y:0,width:36,height:36},n.createElement("rect",{width:36,height:36,rx:e.square?void 0:72,fill:"#FFFFFF"})),n.createElement("g",{mask:"url(#mask__beam)"},n.createElement("rect",{width:36,height:36,fill:t.backgroundColor}),n.createElement("rect",{x:"0",y:"0",width:36,height:36,transform:"translate("+t.wrapperTranslateX+" "+t.wrapperTranslateY+") rotate("+t.wrapperRotate+" 18 18) scale("+t.wrapperScale+")",fill:t.wrapperColor,rx:t.isCircle?36:6}),n.createElement("g",{transform:"translate("+t.faceTranslateX+" "+t.faceTranslateY+") rotate("+t.faceRotate+" 18 18)"},t.isMouthOpen?n.createElement("path",{d:"M15 "+(19+t.mouthSpread)+"c2 1 4 1 6 0",stroke:t.faceColor,fill:"none",strokeLinecap:"round"}):n.createElement("path",{d:"M13,"+(19+t.mouthSpread)+" a1,0.75 0 0,0 10,0",fill:t.faceColor}),n.createElement("rect",{x:14-t.eyeSpread,y:14,width:1.5,height:2,rx:1,stroke:"none",fill:t.faceColor}),n.createElement("rect",{x:20+t.eyeSpread,y:14,width:1.5,height:2,rx:1,stroke:"none",fill:t.faceColor}))))};var E=function(e){var t=function(e,t){var r=h(e),l=t&&t.length;return Array.from({length:4},(function(e,a){return f(r+a,t,l)}))}(e.name,e.colors),r=e.name.replace(/\s/g,"");return n.createElement("svg",{viewBox:"0 0 80 80",fill:"none",role:"img",xmlns:"http://www.w3.org/2000/svg",width:e.size,height:e.size},n.createElement("title",null,e.name),n.createElement("mask",{id:"mask__sunset",maskUnits:"userSpaceOnUse",x:0,y:0,width:80,height:80},n.createElement("rect",{width:80,height:80,rx:e.square?void 0:160,fill:"#FFFFFF"})),n.createElement("g",{mask:"url(#mask__sunset)"},n.createElement("path",{fill:"url(#gradient_paint0_linear_"+r+")",d:"M0 0h80v40H0z"}),n.createElement("path",{fill:"url(#gradient_paint1_linear_"+r+")",d:"M0 40h80v40H0z"})),n.createElement("defs",null,n.createElement("linearGradient",{id:"gradient_paint0_linear_"+r,x1:40,y1:0,x2:40,y2:40,gradientUnits:"userSpaceOnUse"},n.createElement("stop",{stopColor:t[0]}),n.createElement("stop",{offset:1,stopColor:t[1]})),n.createElement("linearGradient",{id:"gradient_paint1_linear_"+r,x1:40,y1:40,x2:40,y2:80,gradientUnits:"userSpaceOnUse"},n.createElement("stop",{stopColor:t[2]}),n.createElement("stop",{offset:1,stopColor:t[3]}))))};var p=function(e){var t=function(e,t){var r=h(e),l=t&&t.length;return Array.from({length:3},(function(e,a){return {color:f(r+a,t,l),translateX:m(r*(a+1),8,1),translateY:m(r*(a+1),8,2),scale:1.2+m(r*(a+1),4)/10,rotate:m(r*(a+1),360,1)}}))}(e.name,e.colors);return n.createElement("svg",{viewBox:"0 0 80 80",fill:"none",role:"img",xmlns:"http://www.w3.org/2000/svg",width:e.size,height:e.size},n.createElement("title",null,e.name),n.createElement("mask",{id:"mask__marble",maskUnits:"userSpaceOnUse",x:0,y:0,width:80,height:80},n.createElement("rect",{width:80,height:80,rx:e.square?void 0:160,fill:"#FFFFFF"})),n.createElement("g",{mask:"url(#mask__marble)"},n.createElement("rect",{width:80,height:80,fill:t[0].color}),n.createElement("path",{filter:"url(#prefix__filter0_f)",d:"M32.414 59.35L50.376 70.5H72.5v-71H33.728L26.5 13.381l19.057 27.08L32.414 59.35z",fill:t[1].color,transform:"translate("+t[1].translateX+" "+t[1].translateY+") rotate("+t[1].rotate+" 40 40) scale("+t[2].scale+")"}),n.createElement("path",{filter:"url(#prefix__filter0_f)",style:{mixBlendMode:"overlay"},d:"M22.216 24L0 46.75l14.108 38.129L78 86l-3.081-59.276-22.378 4.005 12.972 20.186-23.35 27.395L22.215 24z",fill:t[2].color,transform:"translate("+t[2].translateX+" "+t[2].translateY+") rotate("+t[2].rotate+" 40 40) scale("+t[2].scale+")"})),n.createElement("defs",null,n.createElement("filter",{id:"prefix__filter0_f",filterUnits:"userSpaceOnUse",colorInterpolationFilters:"sRGB"},n.createElement("feFlood",{floodOpacity:0,result:"BackgroundImageFix"}),n.createElement("feBlend",{in:"SourceGraphic",in2:"BackgroundImageFix",result:"shape"}),n.createElement("feGaussianBlur",{stdDeviation:7,result:"effect1_foregroundBlur"}))))},y=["pixel","bauhaus","ring","beam","sunset","marble"],x={geometric:"beam",abstract:"bauhaus"},v=function(e){var t=e.variant,r=void 0===t?"marble":t,n=e.colors,h=void 0===n?["#92A1C6","#146A7C","#F0AB3D","#C271B4","#C20D90"]:n,o=e.name,s=void 0===o?"Clara Barton":o,m=e.square,f=void 0!==m&&m,v=e.size,b=function(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){l(e,t,r[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t));}));}return e}({colors:h,name:s,size:void 0===v?40:v,square:f},i(e,["variant","colors","name","square","size"]));return {pixel:c.a.createElement(g,b),bauhaus:c.a.createElement(u,b),ring:c.a.createElement(d,b),beam:c.a.createElement(w,b),sunset:c.a.createElement(E,b),marble:c.a.createElement(p,b)}[Object.keys(x).includes(r)?x[r]:y.includes(r)?r:"marble"]};t.default=v;}])}));
} (build));

var Avatar$1 = /*@__PURE__*/getDefaultExportFromCjs(build.exports);

var styles$16 = reactNative.StyleSheet.create({
    borderRadius: {
        borderRadius: 100,
    },
    bg: {
        backgroundColor: "grey",
    },
});
var DEFAULT_CIRCLE_IMG_SIZE = 48;
var CircleImg = function (_a) {
    var size = _a.size, style = _a.style, uri = _a.uri, color = _a.color;
    var imgSize = React$3.useRef(size || DEFAULT_CIRCLE_IMG_SIZE);
    if (uri)
        return (jsxRuntime.exports.jsx(reactNative.Image, { source: { uri: uri }, style: [
                styles$16.borderRadius,
                styles$16.bg,
                { height: imgSize.current, width: imgSize.current },
                style,
            ] }));
    return (jsxRuntime.exports.jsx(reactNative.View, __assign({ style: [styles$16.borderRadius, style] }, { children: jsxRuntime.exports.jsx(Avatar$1, { size: size, name: "tokens", variant: "marble", colors: color }) })));
};

var Surface$2 = function (_a) {
    var style = _a.style, children = _a.children;
    return (jsxRuntime.exports.jsx(reactNative.View, __assign({ style: [containers.borderRadius, containers.shadow, style] }, { children: children })));
};

const pinkA100 = '#ff80ab';
const pinkA400 = '#f50057';
const grey50 = '#fafafa';
const grey200 = '#eeeeee';
const grey400 = '#bdbdbd';
const grey800 = '#424242';
const black = '#000000';
const white = '#ffffff';

var createTheming$2 = {};

var umd = {exports: {}};

(function (module, exports) {
	(function (global, factory) {
		module.exports = factory() ;
	}(commonjsGlobal, function () {
		var isMergeableObject = function isMergeableObject(value) {
			return isNonNullObject(value)
				&& !isSpecial(value)
		};

		function isNonNullObject(value) {
			return !!value && typeof value === 'object'
		}

		function isSpecial(value) {
			var stringValue = Object.prototype.toString.call(value);

			return stringValue === '[object RegExp]'
				|| stringValue === '[object Date]'
				|| isReactElement(value)
		}

		// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
		var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
		var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

		function isReactElement(value) {
			return value.$$typeof === REACT_ELEMENT_TYPE
		}

		function emptyTarget(val) {
			return Array.isArray(val) ? [] : {}
		}

		function cloneUnlessOtherwiseSpecified(value, options) {
			return (options.clone !== false && options.isMergeableObject(value))
				? deepmerge(emptyTarget(value), value, options)
				: value
		}

		function defaultArrayMerge(target, source, options) {
			return target.concat(source).map(function(element) {
				return cloneUnlessOtherwiseSpecified(element, options)
			})
		}

		function getMergeFunction(key, options) {
			if (!options.customMerge) {
				return deepmerge
			}
			var customMerge = options.customMerge(key);
			return typeof customMerge === 'function' ? customMerge : deepmerge
		}

		function getEnumerableOwnPropertySymbols(target) {
			return Object.getOwnPropertySymbols
				? Object.getOwnPropertySymbols(target).filter(function(symbol) {
					return target.propertyIsEnumerable(symbol)
				})
				: []
		}

		function getKeys(target) {
			return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))
		}

		function mergeObject(target, source, options) {
			var destination = {};
			if (options.isMergeableObject(target)) {
				getKeys(target).forEach(function(key) {
					destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
				});
			}
			getKeys(source).forEach(function(key) {
				if (!options.isMergeableObject(source[key]) || !target[key]) {
					destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
				} else {
					destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
				}
			});
			return destination
		}

		function deepmerge(target, source, options) {
			options = options || {};
			options.arrayMerge = options.arrayMerge || defaultArrayMerge;
			options.isMergeableObject = options.isMergeableObject || isMergeableObject;

			var sourceIsArray = Array.isArray(source);
			var targetIsArray = Array.isArray(target);
			var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

			if (!sourceAndTargetTypesMatch) {
				return cloneUnlessOtherwiseSpecified(source, options)
			} else if (sourceIsArray) {
				return options.arrayMerge(target, source, options)
			} else {
				return mergeObject(target, source, options)
			}
		}

		deepmerge.all = function deepmergeAll(array, options) {
			if (!Array.isArray(array)) {
				throw new Error('first argument should be an array')
			}

			return array.reduce(function(prev, next) {
				return deepmerge(prev, next, options)
			}, {})
		};

		var deepmerge_1 = deepmerge;

		return deepmerge_1;

	}));
} (umd));

var createThemeProvider$1 = {};

createThemeProvider$1.__esModule = true;
createThemeProvider$1.default = void 0;

var React$2 = _interopRequireWildcard$2(React__default["default"]);

function _interopRequireWildcard$2(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _inheritsLoose$2(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _defineProperty$6(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function createThemeProvider(defaultTheme, ThemeContext) {
  var _class, _temp;

  return _temp = _class =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose$2(ThemeProvider, _React$Component);

    function ThemeProvider() {
      return _React$Component.apply(this, arguments) || this;
    }

    var _proto = ThemeProvider.prototype;

    _proto.render = function render() {
      return React$2.createElement(ThemeContext.Provider, {
        value: this.props.theme
      }, this.props.children);
    };

    return ThemeProvider;
  }(React$2.Component), _defineProperty$6(_class, "defaultProps", {
    theme: defaultTheme
  }), _temp;
}

var _default$1 = createThemeProvider;
createThemeProvider$1.default = _default$1;

var createWithTheme$1 = {};

var reactIs$3 = {exports: {}};

var reactIs_production_min$2 = {};

/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactIs_production_min$2;

function requireReactIs_production_min$2 () {
	if (hasRequiredReactIs_production_min$2) return reactIs_production_min$2;
	hasRequiredReactIs_production_min$2 = 1;
var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?
	Symbol.for("react.suspense_list"):60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.block"):60121,w=b?Symbol.for("react.fundamental"):60117,x=b?Symbol.for("react.responder"):60118,y=b?Symbol.for("react.scope"):60119;
	function z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}reactIs_production_min$2.AsyncMode=l;reactIs_production_min$2.ConcurrentMode=m;reactIs_production_min$2.ContextConsumer=k;reactIs_production_min$2.ContextProvider=h;reactIs_production_min$2.Element=c;reactIs_production_min$2.ForwardRef=n;reactIs_production_min$2.Fragment=e;reactIs_production_min$2.Lazy=t;reactIs_production_min$2.Memo=r;reactIs_production_min$2.Portal=d;
	reactIs_production_min$2.Profiler=g;reactIs_production_min$2.StrictMode=f;reactIs_production_min$2.Suspense=p;reactIs_production_min$2.isAsyncMode=function(a){return A(a)||z(a)===l};reactIs_production_min$2.isConcurrentMode=A;reactIs_production_min$2.isContextConsumer=function(a){return z(a)===k};reactIs_production_min$2.isContextProvider=function(a){return z(a)===h};reactIs_production_min$2.isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===c};reactIs_production_min$2.isForwardRef=function(a){return z(a)===n};reactIs_production_min$2.isFragment=function(a){return z(a)===e};reactIs_production_min$2.isLazy=function(a){return z(a)===t};
	reactIs_production_min$2.isMemo=function(a){return z(a)===r};reactIs_production_min$2.isPortal=function(a){return z(a)===d};reactIs_production_min$2.isProfiler=function(a){return z(a)===g};reactIs_production_min$2.isStrictMode=function(a){return z(a)===f};reactIs_production_min$2.isSuspense=function(a){return z(a)===p};
	reactIs_production_min$2.isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};reactIs_production_min$2.typeOf=z;
	return reactIs_production_min$2;
}

var reactIs_development$2 = {};

/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactIs_development$2;

function requireReactIs_development$2 () {
	if (hasRequiredReactIs_development$2) return reactIs_development$2;
	hasRequiredReactIs_development$2 = 1;



	if (process.env.NODE_ENV !== "production") {
	  (function() {

	// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.
	var hasSymbol = typeof Symbol === 'function' && Symbol.for;
	var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
	var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
	var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
	var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
	var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
	var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
	var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
	// (unstable) APIs that have been removed. Can we remove the symbols?

	var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
	var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
	var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
	var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
	var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
	var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
	var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
	var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
	var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
	var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
	var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

	function isValidElementType(type) {
	  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
	  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
	}

	function typeOf(object) {
	  if (typeof object === 'object' && object !== null) {
	    var $$typeof = object.$$typeof;

	    switch ($$typeof) {
	      case REACT_ELEMENT_TYPE:
	        var type = object.type;

	        switch (type) {
	          case REACT_ASYNC_MODE_TYPE:
	          case REACT_CONCURRENT_MODE_TYPE:
	          case REACT_FRAGMENT_TYPE:
	          case REACT_PROFILER_TYPE:
	          case REACT_STRICT_MODE_TYPE:
	          case REACT_SUSPENSE_TYPE:
	            return type;

	          default:
	            var $$typeofType = type && type.$$typeof;

	            switch ($$typeofType) {
	              case REACT_CONTEXT_TYPE:
	              case REACT_FORWARD_REF_TYPE:
	              case REACT_LAZY_TYPE:
	              case REACT_MEMO_TYPE:
	              case REACT_PROVIDER_TYPE:
	                return $$typeofType;

	              default:
	                return $$typeof;
	            }

	        }

	      case REACT_PORTAL_TYPE:
	        return $$typeof;
	    }
	  }

	  return undefined;
	} // AsyncMode is deprecated along with isAsyncMode

	var AsyncMode = REACT_ASYNC_MODE_TYPE;
	var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
	var ContextConsumer = REACT_CONTEXT_TYPE;
	var ContextProvider = REACT_PROVIDER_TYPE;
	var Element = REACT_ELEMENT_TYPE;
	var ForwardRef = REACT_FORWARD_REF_TYPE;
	var Fragment = REACT_FRAGMENT_TYPE;
	var Lazy = REACT_LAZY_TYPE;
	var Memo = REACT_MEMO_TYPE;
	var Portal = REACT_PORTAL_TYPE;
	var Profiler = REACT_PROFILER_TYPE;
	var StrictMode = REACT_STRICT_MODE_TYPE;
	var Suspense = REACT_SUSPENSE_TYPE;
	var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

	function isAsyncMode(object) {
	  {
	    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
	      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

	      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
	    }
	  }

	  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
	}
	function isConcurrentMode(object) {
	  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
	}
	function isContextConsumer(object) {
	  return typeOf(object) === REACT_CONTEXT_TYPE;
	}
	function isContextProvider(object) {
	  return typeOf(object) === REACT_PROVIDER_TYPE;
	}
	function isElement(object) {
	  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	}
	function isForwardRef(object) {
	  return typeOf(object) === REACT_FORWARD_REF_TYPE;
	}
	function isFragment(object) {
	  return typeOf(object) === REACT_FRAGMENT_TYPE;
	}
	function isLazy(object) {
	  return typeOf(object) === REACT_LAZY_TYPE;
	}
	function isMemo(object) {
	  return typeOf(object) === REACT_MEMO_TYPE;
	}
	function isPortal(object) {
	  return typeOf(object) === REACT_PORTAL_TYPE;
	}
	function isProfiler(object) {
	  return typeOf(object) === REACT_PROFILER_TYPE;
	}
	function isStrictMode(object) {
	  return typeOf(object) === REACT_STRICT_MODE_TYPE;
	}
	function isSuspense(object) {
	  return typeOf(object) === REACT_SUSPENSE_TYPE;
	}

	reactIs_development$2.AsyncMode = AsyncMode;
	reactIs_development$2.ConcurrentMode = ConcurrentMode;
	reactIs_development$2.ContextConsumer = ContextConsumer;
	reactIs_development$2.ContextProvider = ContextProvider;
	reactIs_development$2.Element = Element;
	reactIs_development$2.ForwardRef = ForwardRef;
	reactIs_development$2.Fragment = Fragment;
	reactIs_development$2.Lazy = Lazy;
	reactIs_development$2.Memo = Memo;
	reactIs_development$2.Portal = Portal;
	reactIs_development$2.Profiler = Profiler;
	reactIs_development$2.StrictMode = StrictMode;
	reactIs_development$2.Suspense = Suspense;
	reactIs_development$2.isAsyncMode = isAsyncMode;
	reactIs_development$2.isConcurrentMode = isConcurrentMode;
	reactIs_development$2.isContextConsumer = isContextConsumer;
	reactIs_development$2.isContextProvider = isContextProvider;
	reactIs_development$2.isElement = isElement;
	reactIs_development$2.isForwardRef = isForwardRef;
	reactIs_development$2.isFragment = isFragment;
	reactIs_development$2.isLazy = isLazy;
	reactIs_development$2.isMemo = isMemo;
	reactIs_development$2.isPortal = isPortal;
	reactIs_development$2.isProfiler = isProfiler;
	reactIs_development$2.isStrictMode = isStrictMode;
	reactIs_development$2.isSuspense = isSuspense;
	reactIs_development$2.isValidElementType = isValidElementType;
	reactIs_development$2.typeOf = typeOf;
	  })();
	}
	return reactIs_development$2;
}

(function (module) {

	if (process.env.NODE_ENV === 'production') {
	  module.exports = requireReactIs_production_min$2();
	} else {
	  module.exports = requireReactIs_development$2();
	}
} (reactIs$3));

var reactIs$2 = reactIs$3.exports;

/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  '$$typeof': true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  '$$typeof': true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs$2.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs$2.Memo] = MEMO_STATICS;

function getStatics(component) {
  // React v16.11 and below
  if (reactIs$2.isMemo(component)) {
    return MEMO_STATICS;
  } // React v16.12 and above


  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
}

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;
function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
  if (typeof sourceComponent !== 'string') {
    // don't hoist over string (html) components
    if (objectPrototype) {
      var inheritedComponent = getPrototypeOf(sourceComponent);

      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
      }
    }

    var keys = getOwnPropertyNames(sourceComponent);

    if (getOwnPropertySymbols) {
      keys = keys.concat(getOwnPropertySymbols(sourceComponent));
    }

    var targetStatics = getStatics(targetComponent);
    var sourceStatics = getStatics(sourceComponent);

    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];

      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);

        try {
          // Avoid failures from read-only properties
          defineProperty(targetComponent, key, descriptor);
        } catch (e) {}
      }
    }
  }

  return targetComponent;
}

var hoistNonReactStatics_cjs = hoistNonReactStatics;

createWithTheme$1.__esModule = true;
createWithTheme$1.default = void 0;

var React$1 = _interopRequireWildcard$1(React__default["default"]);

var _deepmerge$1 = _interopRequireDefault$2(umd.exports);

var _hoistNonReactStatics = _interopRequireDefault$2(hoistNonReactStatics_cjs);

function _interopRequireDefault$2(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard$1(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _extends$X() { _extends$X = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$X.apply(this, arguments); }

function _objectWithoutPropertiesLoose$1(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _assertThisInitialized$1(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose$1(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _defineProperty$5(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var createWithTheme = function createWithTheme(ThemeProvider, ThemeContext) {
  return function withTheme(Comp) {
    var ThemedComponent =
    /*#__PURE__*/
    function (_React$Component) {
      _inheritsLoose$1(ThemedComponent, _React$Component);

      function ThemedComponent() {
        var _this;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;

        _defineProperty$5(_assertThisInitialized$1(_this), "_previous", void 0);

        _defineProperty$5(_assertThisInitialized$1(_this), "_merge", function (a, b) {
          var previous = _this._previous;

          if (previous && previous.a === a && previous.b === b) {
            return previous.result;
          }

          var result = a && b && a !== b ? (0, _deepmerge$1.default)(a, b) : a || b;
          _this._previous = {
            a: a,
            b: b,
            result: result
          };
          return result;
        });

        return _this;
      }

      var _proto = ThemedComponent.prototype;

      _proto.render = function render() {
        var _this2 = this;

        var _this$props = this.props,
            _reactThemeProviderForwardedRef = _this$props._reactThemeProviderForwardedRef,
            rest = _objectWithoutPropertiesLoose$1(_this$props, ["_reactThemeProviderForwardedRef"]);

        return React$1.createElement(ThemeContext.Consumer, null, function (theme) {
          return React$1.createElement(Comp, _extends$X({}, rest, {
            theme: _this2._merge(theme, rest.theme),
            ref: _reactThemeProviderForwardedRef
          }));
        });
      };

      return ThemedComponent;
    }(React$1.Component);

    var ResultComponent = React$1.forwardRef(function (props, ref) {
      return React$1.createElement(ThemedComponent, _extends$X({}, props, {
        _reactThemeProviderForwardedRef: ref
      }));
    });
    ResultComponent.displayName = "withTheme(" + (Comp.displayName || Comp.name) + ")";
    (0, _hoistNonReactStatics.default)(ResultComponent, Comp);
    return ResultComponent;
  };
};

var _default = createWithTheme;
createWithTheme$1.default = _default;

createTheming$2.__esModule = true;
createTheming$2.default = createTheming$1;

var React = _interopRequireWildcard(React__default["default"]);

var _deepmerge = _interopRequireDefault$1(umd.exports);

var _createThemeProvider = _interopRequireDefault$1(createThemeProvider$1);

var _createWithTheme = _interopRequireDefault$1(createWithTheme$1);

function _interopRequireDefault$1(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function createTheming$1(defaultTheme) {
  var ThemeContext = React.createContext(defaultTheme);
  var ThemeProvider = (0, _createThemeProvider.default)(defaultTheme, ThemeContext);
  var withTheme = (0, _createWithTheme.default)(ThemeProvider, ThemeContext);

  var useTheme = function useTheme(overrides) {
    var theme = React.useContext(ThemeContext);
    var result = React.useMemo(function () {
      return theme && overrides ? (0, _deepmerge.default)(theme, overrides) : theme || overrides;
    }, [theme, overrides]);
    return result;
  };

  return {
    ThemeContext: ThemeContext,
    ThemeProvider: ThemeProvider,
    withTheme: withTheme,
    useTheme: useTheme
  };
}

var _createTheming = _interopRequireDefault(createTheming$2);

var createTheming = _createTheming.default;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var colorString$1 = {exports: {}};

var colorName$1 = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};

var simpleSwizzle = {exports: {}};

var isArrayish$1 = function isArrayish(obj) {
	if (!obj || typeof obj === 'string') {
		return false;
	}

	return obj instanceof Array || Array.isArray(obj) ||
		(obj.length >= 0 && (obj.splice instanceof Function ||
			(Object.getOwnPropertyDescriptor(obj, (obj.length - 1)) && obj.constructor.name !== 'String')));
};

var isArrayish = isArrayish$1;

var concat = Array.prototype.concat;
var slice$1 = Array.prototype.slice;

var swizzle$1 = simpleSwizzle.exports = function swizzle(args) {
	var results = [];

	for (var i = 0, len = args.length; i < len; i++) {
		var arg = args[i];

		if (isArrayish(arg)) {
			// http://jsperf.com/javascript-array-concat-vs-push/98
			results = concat.call(results, slice$1.call(arg));
		} else {
			results.push(arg);
		}
	}

	return results;
};

swizzle$1.wrap = function (fn) {
	return function () {
		return fn(swizzle$1(arguments));
	};
};

/* MIT license */

var colorNames = colorName$1;
var swizzle = simpleSwizzle.exports;
var hasOwnProperty = Object.hasOwnProperty;

var reverseNames = Object.create(null);

// create a list of reverse color names
for (var name in colorNames) {
	if (hasOwnProperty.call(colorNames, name)) {
		reverseNames[colorNames[name]] = name;
	}
}

var cs = colorString$1.exports = {
	to: {},
	get: {}
};

cs.get = function (string) {
	var prefix = string.substring(0, 3).toLowerCase();
	var val;
	var model;
	switch (prefix) {
		case 'hsl':
			val = cs.get.hsl(string);
			model = 'hsl';
			break;
		case 'hwb':
			val = cs.get.hwb(string);
			model = 'hwb';
			break;
		default:
			val = cs.get.rgb(string);
			model = 'rgb';
			break;
	}

	if (!val) {
		return null;
	}

	return {model: model, value: val};
};

cs.get.rgb = function (string) {
	if (!string) {
		return null;
	}

	var abbr = /^#([a-f0-9]{3,4})$/i;
	var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
	var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
	var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
	var keyword = /^(\w+)$/;

	var rgb = [0, 0, 0, 1];
	var match;
	var i;
	var hexAlpha;

	if (match = string.match(hex)) {
		hexAlpha = match[2];
		match = match[1];

		for (i = 0; i < 3; i++) {
			// https://jsperf.com/slice-vs-substr-vs-substring-methods-long-string/19
			var i2 = i * 2;
			rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
		}

		if (hexAlpha) {
			rgb[3] = parseInt(hexAlpha, 16) / 255;
		}
	} else if (match = string.match(abbr)) {
		match = match[1];
		hexAlpha = match[3];

		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i] + match[i], 16);
		}

		if (hexAlpha) {
			rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
		}
	} else if (match = string.match(rgba)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i + 1], 0);
		}

		if (match[4]) {
			if (match[5]) {
				rgb[3] = parseFloat(match[4]) * 0.01;
			} else {
				rgb[3] = parseFloat(match[4]);
			}
		}
	} else if (match = string.match(per)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
		}

		if (match[4]) {
			if (match[5]) {
				rgb[3] = parseFloat(match[4]) * 0.01;
			} else {
				rgb[3] = parseFloat(match[4]);
			}
		}
	} else if (match = string.match(keyword)) {
		if (match[1] === 'transparent') {
			return [0, 0, 0, 0];
		}

		if (!hasOwnProperty.call(colorNames, match[1])) {
			return null;
		}

		rgb = colorNames[match[1]];
		rgb[3] = 1;

		return rgb;
	} else {
		return null;
	}

	for (i = 0; i < 3; i++) {
		rgb[i] = clamp$2(rgb[i], 0, 255);
	}
	rgb[3] = clamp$2(rgb[3], 0, 1);

	return rgb;
};

cs.get.hsl = function (string) {
	if (!string) {
		return null;
	}

	var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
	var match = string.match(hsl);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = ((parseFloat(match[1]) % 360) + 360) % 360;
		var s = clamp$2(parseFloat(match[2]), 0, 100);
		var l = clamp$2(parseFloat(match[3]), 0, 100);
		var a = clamp$2(isNaN(alpha) ? 1 : alpha, 0, 1);

		return [h, s, l, a];
	}

	return null;
};

cs.get.hwb = function (string) {
	if (!string) {
		return null;
	}

	var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
	var match = string.match(hwb);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = ((parseFloat(match[1]) % 360) + 360) % 360;
		var w = clamp$2(parseFloat(match[2]), 0, 100);
		var b = clamp$2(parseFloat(match[3]), 0, 100);
		var a = clamp$2(isNaN(alpha) ? 1 : alpha, 0, 1);
		return [h, w, b, a];
	}

	return null;
};

cs.to.hex = function () {
	var rgba = swizzle(arguments);

	return (
		'#' +
		hexDouble(rgba[0]) +
		hexDouble(rgba[1]) +
		hexDouble(rgba[2]) +
		(rgba[3] < 1
			? (hexDouble(Math.round(rgba[3] * 255)))
			: '')
	);
};

cs.to.rgb = function () {
	var rgba = swizzle(arguments);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ')'
		: 'rgba(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ', ' + rgba[3] + ')';
};

cs.to.rgb.percent = function () {
	var rgba = swizzle(arguments);

	var r = Math.round(rgba[0] / 255 * 100);
	var g = Math.round(rgba[1] / 255 * 100);
	var b = Math.round(rgba[2] / 255 * 100);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + r + '%, ' + g + '%, ' + b + '%)'
		: 'rgba(' + r + '%, ' + g + '%, ' + b + '%, ' + rgba[3] + ')';
};

cs.to.hsl = function () {
	var hsla = swizzle(arguments);
	return hsla.length < 4 || hsla[3] === 1
		? 'hsl(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%)'
		: 'hsla(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%, ' + hsla[3] + ')';
};

// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
// (hwb have alpha optional & 1 is default value)
cs.to.hwb = function () {
	var hwba = swizzle(arguments);

	var a = '';
	if (hwba.length >= 4 && hwba[3] !== 1) {
		a = ', ' + hwba[3];
	}

	return 'hwb(' + hwba[0] + ', ' + hwba[1] + '%, ' + hwba[2] + '%' + a + ')';
};

cs.to.keyword = function (rgb) {
	return reverseNames[rgb.slice(0, 3)];
};

// helpers
function clamp$2(num, min, max) {
	return Math.min(Math.max(min, num), max);
}

function hexDouble(num) {
	var str = Math.round(num).toString(16).toUpperCase();
	return (str.length < 2) ? '0' + str : str;
}

var conversions$2 = {exports: {}};

var colorName = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};

/* MIT license */

var cssKeywords = colorName;

// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)

var reverseKeywords = {};
for (var key in cssKeywords) {
	if (cssKeywords.hasOwnProperty(key)) {
		reverseKeywords[cssKeywords[key]] = key;
	}
}

var convert$2 = conversions$2.exports = {
	rgb: {channels: 3, labels: 'rgb'},
	hsl: {channels: 3, labels: 'hsl'},
	hsv: {channels: 3, labels: 'hsv'},
	hwb: {channels: 3, labels: 'hwb'},
	cmyk: {channels: 4, labels: 'cmyk'},
	xyz: {channels: 3, labels: 'xyz'},
	lab: {channels: 3, labels: 'lab'},
	lch: {channels: 3, labels: 'lch'},
	hex: {channels: 1, labels: ['hex']},
	keyword: {channels: 1, labels: ['keyword']},
	ansi16: {channels: 1, labels: ['ansi16']},
	ansi256: {channels: 1, labels: ['ansi256']},
	hcg: {channels: 3, labels: ['h', 'c', 'g']},
	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
	gray: {channels: 1, labels: ['gray']}
};

// hide .channels and .labels properties
for (var model in convert$2) {
	if (convert$2.hasOwnProperty(model)) {
		if (!('channels' in convert$2[model])) {
			throw new Error('missing channels property: ' + model);
		}

		if (!('labels' in convert$2[model])) {
			throw new Error('missing channel labels property: ' + model);
		}

		if (convert$2[model].labels.length !== convert$2[model].channels) {
			throw new Error('channel and label counts mismatch: ' + model);
		}

		var channels = convert$2[model].channels;
		var labels = convert$2[model].labels;
		delete convert$2[model].channels;
		delete convert$2[model].labels;
		Object.defineProperty(convert$2[model], 'channels', {value: channels});
		Object.defineProperty(convert$2[model], 'labels', {value: labels});
	}
}

convert$2.rgb.hsl = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var min = Math.min(r, g, b);
	var max = Math.max(r, g, b);
	var delta = max - min;
	var h;
	var s;
	var l;

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	l = (min + max) / 2;

	if (max === min) {
		s = 0;
	} else if (l <= 0.5) {
		s = delta / (max + min);
	} else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};

convert$2.rgb.hsv = function (rgb) {
	var rdif;
	var gdif;
	var bdif;
	var h;
	var s;

	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var v = Math.max(r, g, b);
	var diff = v - Math.min(r, g, b);
	var diffc = function (c) {
		return (v - c) / 6 / diff + 1 / 2;
	};

	if (diff === 0) {
		h = s = 0;
	} else {
		s = diff / v;
		rdif = diffc(r);
		gdif = diffc(g);
		bdif = diffc(b);

		if (r === v) {
			h = bdif - gdif;
		} else if (g === v) {
			h = (1 / 3) + rdif - bdif;
		} else if (b === v) {
			h = (2 / 3) + gdif - rdif;
		}
		if (h < 0) {
			h += 1;
		} else if (h > 1) {
			h -= 1;
		}
	}

	return [
		h * 360,
		s * 100,
		v * 100
	];
};

convert$2.rgb.hwb = function (rgb) {
	var r = rgb[0];
	var g = rgb[1];
	var b = rgb[2];
	var h = convert$2.rgb.hsl(rgb)[0];
	var w = 1 / 255 * Math.min(r, Math.min(g, b));

	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

	return [h, w * 100, b * 100];
};

convert$2.rgb.cmyk = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var c;
	var m;
	var y;
	var k;

	k = Math.min(1 - r, 1 - g, 1 - b);
	c = (1 - r - k) / (1 - k) || 0;
	m = (1 - g - k) / (1 - k) || 0;
	y = (1 - b - k) / (1 - k) || 0;

	return [c * 100, m * 100, y * 100, k * 100];
};

/**
 * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
 * */
function comparativeDistance(x, y) {
	return (
		Math.pow(x[0] - y[0], 2) +
		Math.pow(x[1] - y[1], 2) +
		Math.pow(x[2] - y[2], 2)
	);
}

convert$2.rgb.keyword = function (rgb) {
	var reversed = reverseKeywords[rgb];
	if (reversed) {
		return reversed;
	}

	var currentClosestDistance = Infinity;
	var currentClosestKeyword;

	for (var keyword in cssKeywords) {
		if (cssKeywords.hasOwnProperty(keyword)) {
			var value = cssKeywords[keyword];

			// Compute comparative distance
			var distance = comparativeDistance(rgb, value);

			// Check if its less, if so set as closest
			if (distance < currentClosestDistance) {
				currentClosestDistance = distance;
				currentClosestKeyword = keyword;
			}
		}
	}

	return currentClosestKeyword;
};

convert$2.keyword.rgb = function (keyword) {
	return cssKeywords[keyword];
};

convert$2.rgb.xyz = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;

	// assume sRGB
	r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
	g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
	b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

	var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

	return [x * 100, y * 100, z * 100];
};

convert$2.rgb.lab = function (rgb) {
	var xyz = convert$2.rgb.xyz(rgb);
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert$2.hsl.rgb = function (hsl) {
	var h = hsl[0] / 360;
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var t1;
	var t2;
	var t3;
	var rgb;
	var val;

	if (s === 0) {
		val = l * 255;
		return [val, val, val];
	}

	if (l < 0.5) {
		t2 = l * (1 + s);
	} else {
		t2 = l + s - l * s;
	}

	t1 = 2 * l - t2;

	rgb = [0, 0, 0];
	for (var i = 0; i < 3; i++) {
		t3 = h + 1 / 3 * -(i - 1);
		if (t3 < 0) {
			t3++;
		}
		if (t3 > 1) {
			t3--;
		}

		if (6 * t3 < 1) {
			val = t1 + (t2 - t1) * 6 * t3;
		} else if (2 * t3 < 1) {
			val = t2;
		} else if (3 * t3 < 2) {
			val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
		} else {
			val = t1;
		}

		rgb[i] = val * 255;
	}

	return rgb;
};

convert$2.hsl.hsv = function (hsl) {
	var h = hsl[0];
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var smin = s;
	var lmin = Math.max(l, 0.01);
	var sv;
	var v;

	l *= 2;
	s *= (l <= 1) ? l : 2 - l;
	smin *= lmin <= 1 ? lmin : 2 - lmin;
	v = (l + s) / 2;
	sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

	return [h, sv * 100, v * 100];
};

convert$2.hsv.rgb = function (hsv) {
	var h = hsv[0] / 60;
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var hi = Math.floor(h) % 6;

	var f = h - Math.floor(h);
	var p = 255 * v * (1 - s);
	var q = 255 * v * (1 - (s * f));
	var t = 255 * v * (1 - (s * (1 - f)));
	v *= 255;

	switch (hi) {
		case 0:
			return [v, t, p];
		case 1:
			return [q, v, p];
		case 2:
			return [p, v, t];
		case 3:
			return [p, q, v];
		case 4:
			return [t, p, v];
		case 5:
			return [v, p, q];
	}
};

convert$2.hsv.hsl = function (hsv) {
	var h = hsv[0];
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var vmin = Math.max(v, 0.01);
	var lmin;
	var sl;
	var l;

	l = (2 - s) * v;
	lmin = (2 - s) * vmin;
	sl = s * vmin;
	sl /= (lmin <= 1) ? lmin : 2 - lmin;
	sl = sl || 0;
	l /= 2;

	return [h, sl * 100, l * 100];
};

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
convert$2.hwb.rgb = function (hwb) {
	var h = hwb[0] / 360;
	var wh = hwb[1] / 100;
	var bl = hwb[2] / 100;
	var ratio = wh + bl;
	var i;
	var v;
	var f;
	var n;

	// wh + bl cant be > 1
	if (ratio > 1) {
		wh /= ratio;
		bl /= ratio;
	}

	i = Math.floor(6 * h);
	v = 1 - bl;
	f = 6 * h - i;

	if ((i & 0x01) !== 0) {
		f = 1 - f;
	}

	n = wh + f * (v - wh); // linear interpolation

	var r;
	var g;
	var b;
	switch (i) {
		default:
		case 6:
		case 0: r = v; g = n; b = wh; break;
		case 1: r = n; g = v; b = wh; break;
		case 2: r = wh; g = v; b = n; break;
		case 3: r = wh; g = n; b = v; break;
		case 4: r = n; g = wh; b = v; break;
		case 5: r = v; g = wh; b = n; break;
	}

	return [r * 255, g * 255, b * 255];
};

convert$2.cmyk.rgb = function (cmyk) {
	var c = cmyk[0] / 100;
	var m = cmyk[1] / 100;
	var y = cmyk[2] / 100;
	var k = cmyk[3] / 100;
	var r;
	var g;
	var b;

	r = 1 - Math.min(1, c * (1 - k) + k);
	g = 1 - Math.min(1, m * (1 - k) + k);
	b = 1 - Math.min(1, y * (1 - k) + k);

	return [r * 255, g * 255, b * 255];
};

convert$2.xyz.rgb = function (xyz) {
	var x = xyz[0] / 100;
	var y = xyz[1] / 100;
	var z = xyz[2] / 100;
	var r;
	var g;
	var b;

	r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
	g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
	b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

	// assume sRGB
	r = r > 0.0031308
		? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
		: r * 12.92;

	g = g > 0.0031308
		? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
		: g * 12.92;

	b = b > 0.0031308
		? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
		: b * 12.92;

	r = Math.min(Math.max(0, r), 1);
	g = Math.min(Math.max(0, g), 1);
	b = Math.min(Math.max(0, b), 1);

	return [r * 255, g * 255, b * 255];
};

convert$2.xyz.lab = function (xyz) {
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert$2.lab.xyz = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var x;
	var y;
	var z;

	y = (l + 16) / 116;
	x = a / 500 + y;
	z = y - b / 200;

	var y2 = Math.pow(y, 3);
	var x2 = Math.pow(x, 3);
	var z2 = Math.pow(z, 3);
	y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
	x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
	z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

	x *= 95.047;
	y *= 100;
	z *= 108.883;

	return [x, y, z];
};

convert$2.lab.lch = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var hr;
	var h;
	var c;

	hr = Math.atan2(b, a);
	h = hr * 360 / 2 / Math.PI;

	if (h < 0) {
		h += 360;
	}

	c = Math.sqrt(a * a + b * b);

	return [l, c, h];
};

convert$2.lch.lab = function (lch) {
	var l = lch[0];
	var c = lch[1];
	var h = lch[2];
	var a;
	var b;
	var hr;

	hr = h / 360 * 2 * Math.PI;
	a = c * Math.cos(hr);
	b = c * Math.sin(hr);

	return [l, a, b];
};

convert$2.rgb.ansi16 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];
	var value = 1 in arguments ? arguments[1] : convert$2.rgb.hsv(args)[2]; // hsv -> ansi16 optimization

	value = Math.round(value / 50);

	if (value === 0) {
		return 30;
	}

	var ansi = 30
		+ ((Math.round(b / 255) << 2)
		| (Math.round(g / 255) << 1)
		| Math.round(r / 255));

	if (value === 2) {
		ansi += 60;
	}

	return ansi;
};

convert$2.hsv.ansi16 = function (args) {
	// optimization here; we already know the value and don't need to get
	// it converted for us.
	return convert$2.rgb.ansi16(convert$2.hsv.rgb(args), args[2]);
};

convert$2.rgb.ansi256 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];

	// we use the extended greyscale palette here, with the exception of
	// black and white. normal palette only has 4 greyscale shades.
	if (r === g && g === b) {
		if (r < 8) {
			return 16;
		}

		if (r > 248) {
			return 231;
		}

		return Math.round(((r - 8) / 247) * 24) + 232;
	}

	var ansi = 16
		+ (36 * Math.round(r / 255 * 5))
		+ (6 * Math.round(g / 255 * 5))
		+ Math.round(b / 255 * 5);

	return ansi;
};

convert$2.ansi16.rgb = function (args) {
	var color = args % 10;

	// handle greyscale
	if (color === 0 || color === 7) {
		if (args > 50) {
			color += 3.5;
		}

		color = color / 10.5 * 255;

		return [color, color, color];
	}

	var mult = (~~(args > 50) + 1) * 0.5;
	var r = ((color & 1) * mult) * 255;
	var g = (((color >> 1) & 1) * mult) * 255;
	var b = (((color >> 2) & 1) * mult) * 255;

	return [r, g, b];
};

convert$2.ansi256.rgb = function (args) {
	// handle greyscale
	if (args >= 232) {
		var c = (args - 232) * 10 + 8;
		return [c, c, c];
	}

	args -= 16;

	var rem;
	var r = Math.floor(args / 36) / 5 * 255;
	var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	var b = (rem % 6) / 5 * 255;

	return [r, g, b];
};

convert$2.rgb.hex = function (args) {
	var integer = ((Math.round(args[0]) & 0xFF) << 16)
		+ ((Math.round(args[1]) & 0xFF) << 8)
		+ (Math.round(args[2]) & 0xFF);

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert$2.hex.rgb = function (args) {
	var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
	if (!match) {
		return [0, 0, 0];
	}

	var colorString = match[0];

	if (match[0].length === 3) {
		colorString = colorString.split('').map(function (char) {
			return char + char;
		}).join('');
	}

	var integer = parseInt(colorString, 16);
	var r = (integer >> 16) & 0xFF;
	var g = (integer >> 8) & 0xFF;
	var b = integer & 0xFF;

	return [r, g, b];
};

convert$2.rgb.hcg = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var max = Math.max(Math.max(r, g), b);
	var min = Math.min(Math.min(r, g), b);
	var chroma = (max - min);
	var grayscale;
	var hue;

	if (chroma < 1) {
		grayscale = min / (1 - chroma);
	} else {
		grayscale = 0;
	}

	if (chroma <= 0) {
		hue = 0;
	} else
	if (max === r) {
		hue = ((g - b) / chroma) % 6;
	} else
	if (max === g) {
		hue = 2 + (b - r) / chroma;
	} else {
		hue = 4 + (r - g) / chroma + 4;
	}

	hue /= 6;
	hue %= 1;

	return [hue * 360, chroma * 100, grayscale * 100];
};

convert$2.hsl.hcg = function (hsl) {
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var c = 1;
	var f = 0;

	if (l < 0.5) {
		c = 2.0 * s * l;
	} else {
		c = 2.0 * s * (1.0 - l);
	}

	if (c < 1.0) {
		f = (l - 0.5 * c) / (1.0 - c);
	}

	return [hsl[0], c * 100, f * 100];
};

convert$2.hsv.hcg = function (hsv) {
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;

	var c = s * v;
	var f = 0;

	if (c < 1.0) {
		f = (v - c) / (1 - c);
	}

	return [hsv[0], c * 100, f * 100];
};

convert$2.hcg.rgb = function (hcg) {
	var h = hcg[0] / 360;
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	if (c === 0.0) {
		return [g * 255, g * 255, g * 255];
	}

	var pure = [0, 0, 0];
	var hi = (h % 1) * 6;
	var v = hi % 1;
	var w = 1 - v;
	var mg = 0;

	switch (Math.floor(hi)) {
		case 0:
			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
		case 1:
			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
		case 2:
			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
		case 3:
			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
		case 4:
			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
		default:
			pure[0] = 1; pure[1] = 0; pure[2] = w;
	}

	mg = (1.0 - c) * g;

	return [
		(c * pure[0] + mg) * 255,
		(c * pure[1] + mg) * 255,
		(c * pure[2] + mg) * 255
	];
};

convert$2.hcg.hsv = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var v = c + g * (1.0 - c);
	var f = 0;

	if (v > 0.0) {
		f = c / v;
	}

	return [hcg[0], f * 100, v * 100];
};

convert$2.hcg.hsl = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var l = g * (1.0 - c) + 0.5 * c;
	var s = 0;

	if (l > 0.0 && l < 0.5) {
		s = c / (2 * l);
	} else
	if (l >= 0.5 && l < 1.0) {
		s = c / (2 * (1 - l));
	}

	return [hcg[0], s * 100, l * 100];
};

convert$2.hcg.hwb = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;
	var v = c + g * (1.0 - c);
	return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert$2.hwb.hcg = function (hwb) {
	var w = hwb[1] / 100;
	var b = hwb[2] / 100;
	var v = 1 - b;
	var c = v - w;
	var g = 0;

	if (c < 1) {
		g = (v - c) / (1 - c);
	}

	return [hwb[0], c * 100, g * 100];
};

convert$2.apple.rgb = function (apple) {
	return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
};

convert$2.rgb.apple = function (rgb) {
	return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
};

convert$2.gray.rgb = function (args) {
	return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert$2.gray.hsl = convert$2.gray.hsv = function (args) {
	return [0, 0, args[0]];
};

convert$2.gray.hwb = function (gray) {
	return [0, 100, gray[0]];
};

convert$2.gray.cmyk = function (gray) {
	return [0, 0, 0, gray[0]];
};

convert$2.gray.lab = function (gray) {
	return [gray[0], 0, 0];
};

convert$2.gray.hex = function (gray) {
	var val = Math.round(gray[0] / 100 * 255) & 0xFF;
	var integer = (val << 16) + (val << 8) + val;

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert$2.rgb.gray = function (rgb) {
	var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
	return [val / 255 * 100];
};

var conversions$1 = conversions$2.exports;

/*
	this function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

function buildGraph() {
	var graph = {};
	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
	var models = Object.keys(conversions$1);

	for (var len = models.length, i = 0; i < len; i++) {
		graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null
		};
	}

	return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
function deriveBFS(fromModel) {
	var graph = buildGraph();
	var queue = [fromModel]; // unshift -> queue -> pop

	graph[fromModel].distance = 0;

	while (queue.length) {
		var current = queue.pop();
		var adjacents = Object.keys(conversions$1[current]);

		for (var len = adjacents.length, i = 0; i < len; i++) {
			var adjacent = adjacents[i];
			var node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}

function link(from, to) {
	return function (args) {
		return to(from(args));
	};
}

function wrapConversion(toModel, graph) {
	var path = [graph[toModel].parent, toModel];
	var fn = conversions$1[graph[toModel].parent][toModel];

	var cur = graph[toModel].parent;
	while (graph[cur].parent) {
		path.unshift(graph[cur].parent);
		fn = link(conversions$1[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path;
	return fn;
}

var route$1 = function (fromModel) {
	var graph = deriveBFS(fromModel);
	var conversion = {};

	var models = Object.keys(graph);
	for (var len = models.length, i = 0; i < len; i++) {
		var toModel = models[i];
		var node = graph[toModel];

		if (node.parent === null) {
			// no possible conversion, or this node is the source model.
			continue;
		}

		conversion[toModel] = wrapConversion(toModel, graph);
	}

	return conversion;
};

var conversions = conversions$2.exports;
var route = route$1;

var convert$1 = {};

var models = Object.keys(conversions);

function wrapRaw(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		return fn(args);
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

function wrapRounded(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		var result = fn(args);

		// we're assuming the result is an array here.
		// see notice in conversions.js; don't use box types
		// in conversion functions.
		if (typeof result === 'object') {
			for (var len = result.length, i = 0; i < len; i++) {
				result[i] = Math.round(result[i]);
			}
		}

		return result;
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

models.forEach(function (fromModel) {
	convert$1[fromModel] = {};

	Object.defineProperty(convert$1[fromModel], 'channels', {value: conversions[fromModel].channels});
	Object.defineProperty(convert$1[fromModel], 'labels', {value: conversions[fromModel].labels});

	var routes = route(fromModel);
	var routeModels = Object.keys(routes);

	routeModels.forEach(function (toModel) {
		var fn = routes[toModel];

		convert$1[fromModel][toModel] = wrapRounded(fn);
		convert$1[fromModel][toModel].raw = wrapRaw(fn);
	});
});

var colorConvert = convert$1;

var colorString = colorString$1.exports;
var convert = colorConvert;

var _slice = [].slice;

var skippedModels = [
	// to be honest, I don't really feel like keyword belongs in color convert, but eh.
	'keyword',

	// gray conflicts with some method names, and has its own method defined.
	'gray',

	// shouldn't really be in color-convert either...
	'hex'
];

var hashedModelKeys = {};
Object.keys(convert).forEach(function (model) {
	hashedModelKeys[_slice.call(convert[model].labels).sort().join('')] = model;
});

var limiters = {};

function Color(obj, model) {
	if (!(this instanceof Color)) {
		return new Color(obj, model);
	}

	if (model && model in skippedModels) {
		model = null;
	}

	if (model && !(model in convert)) {
		throw new Error('Unknown model: ' + model);
	}

	var i;
	var channels;

	if (obj == null) { // eslint-disable-line no-eq-null,eqeqeq
		this.model = 'rgb';
		this.color = [0, 0, 0];
		this.valpha = 1;
	} else if (obj instanceof Color) {
		this.model = obj.model;
		this.color = obj.color.slice();
		this.valpha = obj.valpha;
	} else if (typeof obj === 'string') {
		var result = colorString.get(obj);
		if (result === null) {
			throw new Error('Unable to parse color from string: ' + obj);
		}

		this.model = result.model;
		channels = convert[this.model].channels;
		this.color = result.value.slice(0, channels);
		this.valpha = typeof result.value[channels] === 'number' ? result.value[channels] : 1;
	} else if (obj.length) {
		this.model = model || 'rgb';
		channels = convert[this.model].channels;
		var newArr = _slice.call(obj, 0, channels);
		this.color = zeroArray(newArr, channels);
		this.valpha = typeof obj[channels] === 'number' ? obj[channels] : 1;
	} else if (typeof obj === 'number') {
		// this is always RGB - can be converted later on.
		obj &= 0xFFFFFF;
		this.model = 'rgb';
		this.color = [
			(obj >> 16) & 0xFF,
			(obj >> 8) & 0xFF,
			obj & 0xFF
		];
		this.valpha = 1;
	} else {
		this.valpha = 1;

		var keys = Object.keys(obj);
		if ('alpha' in obj) {
			keys.splice(keys.indexOf('alpha'), 1);
			this.valpha = typeof obj.alpha === 'number' ? obj.alpha : 0;
		}

		var hashedKeys = keys.sort().join('');
		if (!(hashedKeys in hashedModelKeys)) {
			throw new Error('Unable to parse color from object: ' + JSON.stringify(obj));
		}

		this.model = hashedModelKeys[hashedKeys];

		var labels = convert[this.model].labels;
		var color = [];
		for (i = 0; i < labels.length; i++) {
			color.push(obj[labels[i]]);
		}

		this.color = zeroArray(color);
	}

	// perform limitations (clamping, etc.)
	if (limiters[this.model]) {
		channels = convert[this.model].channels;
		for (i = 0; i < channels; i++) {
			var limit = limiters[this.model][i];
			if (limit) {
				this.color[i] = limit(this.color[i]);
			}
		}
	}

	this.valpha = Math.max(0, Math.min(1, this.valpha));

	if (Object.freeze) {
		Object.freeze(this);
	}
}

Color.prototype = {
	toString: function () {
		return this.string();
	},

	toJSON: function () {
		return this[this.model]();
	},

	string: function (places) {
		var self = this.model in colorString.to ? this : this.rgb();
		self = self.round(typeof places === 'number' ? places : 1);
		var args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);
		return colorString.to[self.model](args);
	},

	percentString: function (places) {
		var self = this.rgb().round(typeof places === 'number' ? places : 1);
		var args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);
		return colorString.to.rgb.percent(args);
	},

	array: function () {
		return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);
	},

	object: function () {
		var result = {};
		var channels = convert[this.model].channels;
		var labels = convert[this.model].labels;

		for (var i = 0; i < channels; i++) {
			result[labels[i]] = this.color[i];
		}

		if (this.valpha !== 1) {
			result.alpha = this.valpha;
		}

		return result;
	},

	unitArray: function () {
		var rgb = this.rgb().color;
		rgb[0] /= 255;
		rgb[1] /= 255;
		rgb[2] /= 255;

		if (this.valpha !== 1) {
			rgb.push(this.valpha);
		}

		return rgb;
	},

	unitObject: function () {
		var rgb = this.rgb().object();
		rgb.r /= 255;
		rgb.g /= 255;
		rgb.b /= 255;

		if (this.valpha !== 1) {
			rgb.alpha = this.valpha;
		}

		return rgb;
	},

	round: function (places) {
		places = Math.max(places || 0, 0);
		return new Color(this.color.map(roundToPlace(places)).concat(this.valpha), this.model);
	},

	alpha: function (val) {
		if (arguments.length) {
			return new Color(this.color.concat(Math.max(0, Math.min(1, val))), this.model);
		}

		return this.valpha;
	},

	// rgb
	red: getset('rgb', 0, maxfn(255)),
	green: getset('rgb', 1, maxfn(255)),
	blue: getset('rgb', 2, maxfn(255)),

	hue: getset(['hsl', 'hsv', 'hsl', 'hwb', 'hcg'], 0, function (val) { return ((val % 360) + 360) % 360; }), // eslint-disable-line brace-style

	saturationl: getset('hsl', 1, maxfn(100)),
	lightness: getset('hsl', 2, maxfn(100)),

	saturationv: getset('hsv', 1, maxfn(100)),
	value: getset('hsv', 2, maxfn(100)),

	chroma: getset('hcg', 1, maxfn(100)),
	gray: getset('hcg', 2, maxfn(100)),

	white: getset('hwb', 1, maxfn(100)),
	wblack: getset('hwb', 2, maxfn(100)),

	cyan: getset('cmyk', 0, maxfn(100)),
	magenta: getset('cmyk', 1, maxfn(100)),
	yellow: getset('cmyk', 2, maxfn(100)),
	black: getset('cmyk', 3, maxfn(100)),

	x: getset('xyz', 0, maxfn(100)),
	y: getset('xyz', 1, maxfn(100)),
	z: getset('xyz', 2, maxfn(100)),

	l: getset('lab', 0, maxfn(100)),
	a: getset('lab', 1),
	b: getset('lab', 2),

	keyword: function (val) {
		if (arguments.length) {
			return new Color(val);
		}

		return convert[this.model].keyword(this.color);
	},

	hex: function (val) {
		if (arguments.length) {
			return new Color(val);
		}

		return colorString.to.hex(this.rgb().round().color);
	},

	rgbNumber: function () {
		var rgb = this.rgb().color;
		return ((rgb[0] & 0xFF) << 16) | ((rgb[1] & 0xFF) << 8) | (rgb[2] & 0xFF);
	},

	luminosity: function () {
		// http://www.w3.org/TR/WCAG20/#relativeluminancedef
		var rgb = this.rgb().color;

		var lum = [];
		for (var i = 0; i < rgb.length; i++) {
			var chan = rgb[i] / 255;
			lum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);
		}

		return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
	},

	contrast: function (color2) {
		// http://www.w3.org/TR/WCAG20/#contrast-ratiodef
		var lum1 = this.luminosity();
		var lum2 = color2.luminosity();

		if (lum1 > lum2) {
			return (lum1 + 0.05) / (lum2 + 0.05);
		}

		return (lum2 + 0.05) / (lum1 + 0.05);
	},

	level: function (color2) {
		var contrastRatio = this.contrast(color2);
		if (contrastRatio >= 7.1) {
			return 'AAA';
		}

		return (contrastRatio >= 4.5) ? 'AA' : '';
	},

	isDark: function () {
		// YIQ equation from http://24ways.org/2010/calculating-color-contrast
		var rgb = this.rgb().color;
		var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
		return yiq < 128;
	},

	isLight: function () {
		return !this.isDark();
	},

	negate: function () {
		var rgb = this.rgb();
		for (var i = 0; i < 3; i++) {
			rgb.color[i] = 255 - rgb.color[i];
		}
		return rgb;
	},

	lighten: function (ratio) {
		var hsl = this.hsl();
		hsl.color[2] += hsl.color[2] * ratio;
		return hsl;
	},

	darken: function (ratio) {
		var hsl = this.hsl();
		hsl.color[2] -= hsl.color[2] * ratio;
		return hsl;
	},

	saturate: function (ratio) {
		var hsl = this.hsl();
		hsl.color[1] += hsl.color[1] * ratio;
		return hsl;
	},

	desaturate: function (ratio) {
		var hsl = this.hsl();
		hsl.color[1] -= hsl.color[1] * ratio;
		return hsl;
	},

	whiten: function (ratio) {
		var hwb = this.hwb();
		hwb.color[1] += hwb.color[1] * ratio;
		return hwb;
	},

	blacken: function (ratio) {
		var hwb = this.hwb();
		hwb.color[2] += hwb.color[2] * ratio;
		return hwb;
	},

	grayscale: function () {
		// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
		var rgb = this.rgb().color;
		var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
		return Color.rgb(val, val, val);
	},

	fade: function (ratio) {
		return this.alpha(this.valpha - (this.valpha * ratio));
	},

	opaquer: function (ratio) {
		return this.alpha(this.valpha + (this.valpha * ratio));
	},

	rotate: function (degrees) {
		var hsl = this.hsl();
		var hue = hsl.color[0];
		hue = (hue + degrees) % 360;
		hue = hue < 0 ? 360 + hue : hue;
		hsl.color[0] = hue;
		return hsl;
	},

	mix: function (mixinColor, weight) {
		// ported from sass implementation in C
		// https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
		if (!mixinColor || !mixinColor.rgb) {
			throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
		}
		var color1 = mixinColor.rgb();
		var color2 = this.rgb();
		var p = weight === undefined ? 0.5 : weight;

		var w = 2 * p - 1;
		var a = color1.alpha() - color2.alpha();

		var w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
		var w2 = 1 - w1;

		return Color.rgb(
				w1 * color1.red() + w2 * color2.red(),
				w1 * color1.green() + w2 * color2.green(),
				w1 * color1.blue() + w2 * color2.blue(),
				color1.alpha() * p + color2.alpha() * (1 - p));
	}
};

// model conversion methods and static constructors
Object.keys(convert).forEach(function (model) {
	if (skippedModels.indexOf(model) !== -1) {
		return;
	}

	var channels = convert[model].channels;

	// conversion methods
	Color.prototype[model] = function () {
		if (this.model === model) {
			return new Color(this);
		}

		if (arguments.length) {
			return new Color(arguments, model);
		}

		var newAlpha = typeof arguments[channels] === 'number' ? channels : this.valpha;
		return new Color(assertArray(convert[this.model][model].raw(this.color)).concat(newAlpha), model);
	};

	// 'static' construction methods
	Color[model] = function (color) {
		if (typeof color === 'number') {
			color = zeroArray(_slice.call(arguments), channels);
		}
		return new Color(color, model);
	};
});

function roundTo(num, places) {
	return Number(num.toFixed(places));
}

function roundToPlace(places) {
	return function (num) {
		return roundTo(num, places);
	};
}

function getset(model, channel, modifier) {
	model = Array.isArray(model) ? model : [model];

	model.forEach(function (m) {
		(limiters[m] || (limiters[m] = []))[channel] = modifier;
	});

	model = model[0];

	return function (val) {
		var result;

		if (arguments.length) {
			if (modifier) {
				val = modifier(val);
			}

			result = this[model]();
			result.color[channel] = val;
			return result;
		}

		result = this[model]().color[channel];
		if (modifier) {
			result = modifier(result);
		}

		return result;
	};
}

function maxfn(max) {
	return function (v) {
		return Math.max(0, Math.min(max, v));
	};
}

function assertArray(val) {
	return Array.isArray(val) ? val : [val];
}

function zeroArray(arr, length) {
	for (var i = 0; i < length; i++) {
		if (typeof arr[i] !== 'number') {
			arr[i] = 0;
		}
	}

	return arr;
}

var color$1 = Color;

const fontConfig = {
  web: {
    regular: {
      fontFamily: 'Roboto, "Helvetica Neue", Helvetica, Arial, sans-serif',
      fontWeight: '400'
    },
    medium: {
      fontFamily: 'Roboto, "Helvetica Neue", Helvetica, Arial, sans-serif',
      fontWeight: '500'
    },
    light: {
      fontFamily: 'Roboto, "Helvetica Neue", Helvetica, Arial, sans-serif',
      fontWeight: '300'
    },
    thin: {
      fontFamily: 'Roboto, "Helvetica Neue", Helvetica, Arial, sans-serif',
      fontWeight: '100'
    }
  },
  ios: {
    regular: {
      fontFamily: 'System',
      fontWeight: '400'
    },
    medium: {
      fontFamily: 'System',
      fontWeight: '500'
    },
    light: {
      fontFamily: 'System',
      fontWeight: '300'
    },
    thin: {
      fontFamily: 'System',
      fontWeight: '100'
    }
  },
  default: {
    regular: {
      fontFamily: 'sans-serif',
      fontWeight: 'normal'
    },
    medium: {
      fontFamily: 'sans-serif-medium',
      fontWeight: 'normal'
    },
    light: {
      fontFamily: 'sans-serif-light',
      fontWeight: 'normal'
    },
    thin: {
      fontFamily: 'sans-serif-thin',
      fontWeight: 'normal'
    }
  }
};
function configureFonts(config) {
  const fonts = reactNative.Platform.select({ ...fontConfig,
    ...config
  });
  return fonts;
}

const DefaultTheme = {
  dark: false,
  roundness: 4,
  colors: {
    primary: '#6200ee',
    accent: '#03dac4',
    background: '#f6f6f6',
    surface: white,
    error: '#B00020',
    text: black,
    onSurface: '#000000',
    disabled: color$1(black).alpha(0.26).rgb().string(),
    placeholder: color$1(black).alpha(0.54).rgb().string(),
    backdrop: color$1(black).alpha(0.5).rgb().string(),
    notification: pinkA400
  },
  fonts: configureFonts(),
  animation: {
    scale: 1.0
  }
};

const {
  ThemeProvider: ThemeProvider$3,
  withTheme,
  useTheme: useTheme$5
} = createTheming(DefaultTheme);

function _extends$W() { _extends$W = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$W.apply(this, arguments); }
let MaterialCommunityIcons;

try {
  // Optionally require vector-icons
  MaterialCommunityIcons = require('react-native-vector-icons/MaterialCommunityIcons').default;
} catch (e) {
  let isErrorLogged = false; // Fallback component for icons

  MaterialCommunityIcons = _ref => {
    let {
      name,
      color,
      size,
      ...rest
    } = _ref;

    /* eslint-disable no-console */
    if (!isErrorLogged) {
      if (!/(Cannot find module|Module not found|Cannot resolve module)/.test(e.message)) {
        console.error(e);
      }

      console.warn(`Tried to use the icon '${name}' in a component from 'react-native-paper', but 'react-native-vector-icons/MaterialCommunityIcons' could not be loaded.`, `To remove this warning, try installing 'react-native-vector-icons' or use another method to specify icon: https://callstack.github.io/react-native-paper/icons.html.`);
      isErrorLogged = true;
    }

    return /*#__PURE__*/React__namespace.createElement(reactNative.Text, _extends$W({}, rest, {
      style: [styles$15.icon, {
        color,
        fontSize: size
      }] // @ts-expect-error: Text doesn't support this, but it seems to affect TouchableNativeFeedback
      ,
      pointerEvents: "none",
      selectable: false
    }), "\u25A1");
  };
}

const accessibilityProps = reactNative.Platform.OS === 'web' ? {
  role: 'img',
  focusable: false
} : {
  accessibilityElementsHidden: true,
  importantForAccessibility: 'no-hide-descendants'
};

const defaultIcon = _ref2 => {
  let {
    name,
    color,
    size,
    direction,
    allowFontScaling
  } = _ref2;
  return /*#__PURE__*/React__namespace.createElement(MaterialCommunityIcons, _extends$W({
    allowFontScaling: allowFontScaling,
    name: name,
    color: color,
    size: size,
    style: [{
      transform: [{
        scaleX: direction === 'rtl' ? -1 : 1
      }],
      lineHeight: size
    }, styles$15.icon],
    pointerEvents: "none",
    selectable: false
  }, accessibilityProps));
};

const styles$15 = reactNative.StyleSheet.create({
  icon: {
    backgroundColor: 'transparent'
  }
});

const {
  Provider,
  Consumer
} = /*#__PURE__*/React__namespace.createContext({
  icon: defaultIcon
});

function _defineProperty$4(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Portal host is the component which actually renders all Portals.
 */
class PortalManager extends React__namespace.PureComponent {
  constructor() {
    super(...arguments);

    _defineProperty$4(this, "state", {
      portals: []
    });

    _defineProperty$4(this, "mount", (key, children) => {
      this.setState(state => ({
        portals: [...state.portals, {
          key,
          children
        }]
      }));
    });

    _defineProperty$4(this, "update", (key, children) => this.setState(state => ({
      portals: state.portals.map(item => {
        if (item.key === key) {
          return { ...item,
            children
          };
        }

        return item;
      })
    })));

    _defineProperty$4(this, "unmount", key => this.setState(state => ({
      portals: state.portals.filter(item => item.key !== key)
    })));
  }

  render() {
    return this.state.portals.map(_ref => {
      let {
        key,
        children
      } = _ref;
      return /*#__PURE__*/React__namespace.createElement(reactNative.View, {
        key: key,
        collapsable: false
        /* Need collapsable=false here to clip the elevations, otherwise they appear above sibling components */
        ,
        pointerEvents: "box-none",
        style: reactNative.StyleSheet.absoluteFill
      }, children);
    });
  }

}

function _defineProperty$3(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
const PortalContext = /*#__PURE__*/React__namespace.createContext(null);
/**
 * Portal host renders all of its children `Portal` elements.
 * For example, you can wrap a screen in `Portal.Host` to render items above the screen.
 * If you're using the `Provider` component, it already includes `Portal.Host`.
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { Text } from 'react-native';
 * import { Portal } from 'react-native-paper';
 *
 * const MyComponent = () => (
 *   <Portal.Host>
 *     <Text>Content of the app</Text>
 *   </Portal.Host>
 * );
 *
 * export default MyComponent;
 * ```
 *
 * Here any `Portal` elements under `<App />` are rendered alongside `<App />` and will appear above `<App />` like a `Modal`.
 */

class PortalHost extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty$3(this, "setManager", manager => {
      this.manager = manager;
    });

    _defineProperty$3(this, "mount", children => {
      const key = this.nextKey++;

      if (this.manager) {
        this.manager.mount(key, children);
      } else {
        this.queue.push({
          type: 'mount',
          key,
          children
        });
      }

      return key;
    });

    _defineProperty$3(this, "update", (key, children) => {
      if (this.manager) {
        this.manager.update(key, children);
      } else {
        const op = {
          type: 'mount',
          key,
          children
        };
        const index = this.queue.findIndex(o => o.type === 'mount' || o.type === 'update' && o.key === key);

        if (index > -1) {
          this.queue[index] = op;
        } else {
          this.queue.push(op);
        }
      }
    });

    _defineProperty$3(this, "unmount", key => {
      if (this.manager) {
        this.manager.unmount(key);
      } else {
        this.queue.push({
          type: 'unmount',
          key
        });
      }
    });

    _defineProperty$3(this, "nextKey", 0);

    _defineProperty$3(this, "queue", []);

    _defineProperty$3(this, "manager", void 0);
  }

  componentDidMount() {
    const manager = this.manager;
    const queue = this.queue;

    while (queue.length && manager) {
      const action = queue.pop();

      if (action) {
        // eslint-disable-next-line default-case
        switch (action.type) {
          case 'mount':
            manager.mount(action.key, action.children);
            break;

          case 'update':
            manager.update(action.key, action.children);
            break;

          case 'unmount':
            manager.unmount(action.key);
            break;
        }
      }
    }
  }

  render() {
    return /*#__PURE__*/React__namespace.createElement(PortalContext.Provider, {
      value: {
        mount: this.mount,
        update: this.update,
        unmount: this.unmount
      }
    }, /*#__PURE__*/React__namespace.createElement(reactNative.View, {
      style: styles$14.container,
      collapsable: false,
      pointerEvents: "box-none"
    }, this.props.children), /*#__PURE__*/React__namespace.createElement(PortalManager, {
      ref: this.setManager
    }));
  }

}

_defineProperty$3(PortalHost, "displayName", 'Portal.Host');

const styles$14 = reactNative.StyleSheet.create({
  container: {
    flex: 1
  }
});

const DarkTheme = { ...DefaultTheme,
  dark: true,
  mode: 'adaptive',
  colors: { ...DefaultTheme.colors,
    primary: '#BB86FC',
    accent: '#03dac6',
    background: '#121212',
    surface: '#121212',
    error: '#CF6679',
    onSurface: '#FFFFFF',
    text: white,
    disabled: color$1(white).alpha(0.38).rgb().string(),
    placeholder: color$1(white).alpha(0.54).rgb().string(),
    backdrop: color$1(black).alpha(0.5).rgb().string(),
    notification: pinkA100
  }
};

function addEventListener(Module) {
  var _Module$addEventListe;

  for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    rest[_key - 1] = arguments[_key];
  }

  const [eventName, handler] = rest;
  let removed = false;
  const subscription = (_Module$addEventListe = Module.addEventListener(eventName, handler)) !== null && _Module$addEventListe !== void 0 ? _Module$addEventListe : {
    remove: () => {
      if (removed) {
        return;
      }

      Module.removeEventListener(eventName, handler);
      removed = true;
    }
  };
  return subscription;
}

const SHADOW_COLOR = black;
const SHADOW_OPACITY = 0.24;
function shadow() {
  let elevation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

  if (elevation instanceof reactNative.Animated.Value) {
    const inputRange = [0, 1, 2, 3, 8, 24];
    return {
      shadowColor: SHADOW_COLOR,
      shadowOffset: {
        width: new reactNative.Animated.Value(0),
        height: elevation.interpolate({
          inputRange,
          outputRange: [0, 0.5, 0.75, 2, 7, 23]
        })
      },
      shadowOpacity: elevation.interpolate({
        inputRange: [0, 1],
        outputRange: [0, SHADOW_OPACITY],
        extrapolate: 'clamp'
      }),
      shadowRadius: elevation.interpolate({
        inputRange,
        outputRange: [0, 0.75, 1.5, 3, 8, 24]
      })
    };
  } else {
    if (elevation === 0) {
      return {};
    }

    let height, radius;

    switch (elevation) {
      case 1:
        height = 0.5;
        radius = 0.75;
        break;

      case 2:
        height = 0.75;
        radius = 1.5;
        break;

      default:
        height = elevation - 1;
        radius = elevation;
    }

    return {
      shadowColor: SHADOW_COLOR,
      shadowOffset: {
        width: 0,
        height
      },
      shadowOpacity: SHADOW_OPACITY,
      shadowRadius: radius
    };
  }
}

const isAnimatedValue = it => it instanceof reactNative.Animated.Value;

function overlay(elevation) {
  let surfaceColor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DarkTheme.colors.surface;

  if (isAnimatedValue(elevation)) {
    const inputRange = [0, 1, 2, 3, 8, 24]; // @ts-expect-error: TS doesn't seem to refine the type correctly

    return elevation.interpolate({
      inputRange,
      outputRange: inputRange.map(elevation => {
        return calculateColor(surfaceColor, elevation);
      })
    });
  } // @ts-expect-error: TS doesn't seem to refine the type correctly


  return calculateColor(surfaceColor, elevation);
}

function calculateColor(surfaceColor) {
  let elevation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  let overlayTransparency;

  if (elevation >= 1 && elevation <= 24) {
    overlayTransparency = elevationOverlayTransparency[elevation];
  } else if (elevation > 24) {
    overlayTransparency = elevationOverlayTransparency[24];
  } else {
    overlayTransparency = elevationOverlayTransparency[1];
  }

  return color$1(surfaceColor).mix(color$1('white'), overlayTransparency * 0.01).hex();
}

const elevationOverlayTransparency = {
  1: 5,
  2: 7,
  3: 8,
  4: 9,
  5: 10,
  6: 11,
  7: 11.5,
  8: 12,
  9: 12.5,
  10: 13,
  11: 13.5,
  12: 14,
  13: 14.25,
  14: 14.5,
  15: 14.75,
  16: 15,
  17: 15.12,
  18: 15.24,
  19: 15.36,
  20: 15.48,
  21: 15.6,
  22: 15.72,
  23: 15.84,
  24: 16
};

function _extends$V() { _extends$V = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$V.apply(this, arguments); }

const isImageSource = source => // source is an object with uri
typeof source === 'object' && source !== null && Object.prototype.hasOwnProperty.call(source, 'uri') && typeof source.uri === 'string' || // source is a module, e.g. - require('image')
typeof source === 'number' || // image url on web
reactNative.Platform.OS === 'web' && typeof source === 'string' && (source.startsWith('data:image') || /\.(bmp|jpg|jpeg|png|gif|svg)$/.test(source));

const getIconId = source => {
  if (typeof source === 'object' && source !== null && Object.prototype.hasOwnProperty.call(source, 'uri') && typeof source.uri === 'string') {
    return source.uri;
  }

  return source;
};

const isValidIcon = source => typeof source === 'string' || typeof source === 'function' || isImageSource(source);
const isEqualIcon = (a, b) => a === b || getIconId(a) === getIconId(b);

const Icon = _ref => {
  let {
    source,
    color,
    size,
    theme,
    ...rest
  } = _ref;
  const direction = typeof source === 'object' && source.direction && source.source ? source.direction === 'auto' ? reactNative.I18nManager.isRTL ? 'rtl' : 'ltr' : source.direction : null;
  const s = typeof source === 'object' && source.direction && source.source ? source.source : source;
  const iconColor = color || theme.colors.text;

  if (isImageSource(s)) {
    return /*#__PURE__*/React__namespace.createElement(reactNative.Image, _extends$V({}, rest, {
      source: s,
      style: [{
        transform: [{
          scaleX: direction === 'rtl' ? -1 : 1
        }]
      }, // eslint-disable-next-line react-native/no-inline-styles
      {
        width: size,
        height: size,
        tintColor: color,
        resizeMode: 'contain'
      }]
    }, accessibilityProps));
  } else if (typeof s === 'string') {
    return /*#__PURE__*/React__namespace.createElement(Consumer, null, _ref2 => {
      let {
        icon
      } = _ref2;
      return icon({
        name: s,
        color: iconColor,
        size,
        direction
      });
    });
  } else if (typeof s === 'function') {
    return s({
      color: iconColor,
      size,
      direction
    });
  }

  return null;
};

var Icon$1 = withTheme(Icon);

function getContrastingColor(input, light, dark) {
  if (typeof input === 'string') {
    return color$1(input).isLight() ? dark : light;
  }

  return light;
}

function _extends$U() { _extends$U = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$U.apply(this, arguments); }
const defaultSize$3 = 64;

/**
 * Avatars can be used to represent people in a graphical way.
 *
 * <div class="screenshots">
 *   <figure>
 *     <img class="medium" src="screenshots/avatar-icon.png" />
 *   </figure>
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { Avatar } from 'react-native-paper';
 *
 * const MyComponent = () => (
 *   <Avatar.Icon size={24} icon="folder" />
 * );
 * ```
 */
const Avatar = _ref => {
  var _rest$color;

  let {
    icon,
    size = defaultSize$3,
    style,
    theme,
    ...rest
  } = _ref;
  const {
    backgroundColor = theme.colors.primary,
    ...restStyle
  } = reactNative.StyleSheet.flatten(style) || {};
  const textColor = (_rest$color = rest.color) !== null && _rest$color !== void 0 ? _rest$color : getContrastingColor(backgroundColor, white, 'rgba(0, 0, 0, .54)');
  return /*#__PURE__*/React__namespace.createElement(reactNative.View, _extends$U({
    style: [{
      width: size,
      height: size,
      borderRadius: size / 2,
      backgroundColor
    }, styles$13.container, restStyle]
  }, rest), /*#__PURE__*/React__namespace.createElement(Icon$1, {
    source: icon,
    color: textColor,
    size: size * 0.6
  }));
};

Avatar.displayName = 'Avatar.Icon';
const styles$13 = reactNative.StyleSheet.create({
  container: {
    justifyContent: 'center',
    alignItems: 'center'
  }
});
withTheme(Avatar);

function _extends$T() { _extends$T = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$T.apply(this, arguments); }
const defaultSize$2 = 64;

/**
 * Avatars can be used to represent people in a graphical way.
 *
 * <div class="screenshots">
 *   <figure>
 *     <img class="medium" src="screenshots/avatar-image.png" />
 *   </figure>
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { Avatar } from 'react-native-paper';
 *
 * const MyComponent = () => (
 *   <Avatar.Image size={24} source={require('../assets/avatar.png')} />
 * );
 * export default MyComponent
 * ```
 */
const AvatarImage = _ref => {
  let {
    size = defaultSize$2,
    source,
    style,
    onError,
    onLayout,
    onLoad,
    onLoadEnd,
    onLoadStart,
    onProgress,
    theme,
    ...rest
  } = _ref;
  const {
    colors
  } = theme;
  const {
    backgroundColor = colors.primary
  } = reactNative.StyleSheet.flatten(style) || {};
  return /*#__PURE__*/React__namespace.createElement(reactNative.View, _extends$T({
    style: [{
      width: size,
      height: size,
      borderRadius: size / 2,
      backgroundColor
    }, style]
  }, rest), typeof source === 'function' && source({
    size
  }), typeof source !== 'function' && /*#__PURE__*/React__namespace.createElement(reactNative.Image, {
    source: source,
    style: {
      width: size,
      height: size,
      borderRadius: size / 2
    },
    onError: onError,
    onLayout: onLayout,
    onLoad: onLoad,
    onLoadEnd: onLoadEnd,
    onLoadStart: onLoadStart,
    onProgress: onProgress
  }));
};

AvatarImage.displayName = 'Avatar.Image';
withTheme(AvatarImage);

function _extends$S() { _extends$S = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$S.apply(this, arguments); }

// @component-group Typography

/**
 * Text component which follows styles from the theme.
 *
 * @extends Text props https://reactnative.dev/docs/text#props
 */
const Text = (_ref, ref) => {
  let {
    style,
    theme,
    ...rest
  } = _ref;
  const root = React__namespace.useRef(null);
  React__namespace.useImperativeHandle(ref, () => ({
    setNativeProps: args => {
      var _root$current;

      return (_root$current = root.current) === null || _root$current === void 0 ? void 0 : _root$current.setNativeProps(args);
    }
  }));
  return /*#__PURE__*/React__namespace.createElement(reactNative.Text, _extends$S({}, rest, {
    ref: root,
    style: [{ ...theme.fonts.regular,
      color: theme.colors.text
    }, styles$12.text, style]
  }));
};

const styles$12 = reactNative.StyleSheet.create({
  text: {
    textAlign: 'left'
  }
});
var Text$1 = withTheme( /*#__PURE__*/React__namespace.forwardRef(Text));

function _extends$R() { _extends$R = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$R.apply(this, arguments); }
const defaultSize$1 = 64;

/**
 * Avatars can be used to represent people in a graphical way.
 *
 * <div class="screenshots">
 *   <figure>
 *     <img class="medium" src="screenshots/avatar-text.png" />
 *   </figure>
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { Avatar } from 'react-native-paper';
 *
 * const MyComponent = () => (
 *   <Avatar.Text size={24} label="XD" />
 * );
 * ```
 */
const AvatarText = _ref => {
  let {
    label,
    size = defaultSize$1,
    style,
    theme,
    labelStyle,
    color: customColor,
    ...rest
  } = _ref;
  const {
    backgroundColor = theme.colors.primary,
    ...restStyle
  } = reactNative.StyleSheet.flatten(style) || {};
  const textColor = customColor !== null && customColor !== void 0 ? customColor : getContrastingColor(backgroundColor, white, 'rgba(0, 0, 0, .54)');
  return /*#__PURE__*/React__namespace.createElement(reactNative.View, _extends$R({
    style: [{
      width: size,
      height: size,
      borderRadius: size / 2,
      backgroundColor
    }, styles$11.container, restStyle]
  }, rest), /*#__PURE__*/React__namespace.createElement(Text$1, {
    style: [styles$11.text, {
      color: textColor,
      fontSize: size / 2,
      lineHeight: size
    }, labelStyle],
    numberOfLines: 1
  }, label));
};

AvatarText.displayName = 'Avatar.Text';
const styles$11 = reactNative.StyleSheet.create({
  container: {
    justifyContent: 'center',
    alignItems: 'center'
  },
  text: {
    textAlign: 'center',
    textAlignVertical: 'center'
  }
});
withTheme(AvatarText);

function _extends$Q() { _extends$Q = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$Q.apply(this, arguments); }

/**
 * A wrapper for views that should respond to touches.
 * Provides a material "ink ripple" interaction effect for supported platforms (>= Android Lollipop).
 * On unsupported platforms, it falls back to a highlight effect.
 *
 * <div class="screenshots">
 *   <figure>
 *     <img class="medium" src="screenshots/touchable-ripple.gif" />
 *   </figure>
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { View } from 'react-native';
 * import { Text, TouchableRipple } from 'react-native-paper';
 *
 * const MyComponent = () => (
 *   <TouchableRipple
 *     onPress={() => console.log('Pressed')}
 *     rippleColor="rgba(0, 0, 0, .32)"
 *   >
 *     <Text>Press anywhere</Text>
 *   </TouchableRipple>
 * );
 *
 * export default MyComponent;
 * ```
 *
 * @extends TouchableWithoutFeedback props https://reactnative.dev/docs/touchablewithoutfeedback#props
 */
const TouchableRipple = _ref => {
  let {
    style,
    background: _background,
    borderless = false,
    disabled: disabledProp,
    rippleColor,
    underlayColor: _underlayColor,
    children,
    theme,
    ...rest
  } = _ref;

  const handlePressIn = e => {
    var _touches$;

    const {
      centered,
      onPressIn
    } = rest;
    onPressIn === null || onPressIn === void 0 ? void 0 : onPressIn(e);
    const {
      dark,
      colors
    } = theme;
    const calculatedRippleColor = rippleColor || color$1(colors.text).alpha(dark ? 0.32 : 0.2).rgb().string();
    const button = e.currentTarget;
    const style = window.getComputedStyle(button);
    const dimensions = button.getBoundingClientRect();
    let touchX;
    let touchY;
    const {
      changedTouches,
      touches
    } = e.nativeEvent;
    const touch = (_touches$ = touches === null || touches === void 0 ? void 0 : touches[0]) !== null && _touches$ !== void 0 ? _touches$ : changedTouches === null || changedTouches === void 0 ? void 0 : changedTouches[0]; // If centered or it was pressed using keyboard - enter or space

    if (centered || !touch) {
      touchX = dimensions.width / 2;
      touchY = dimensions.height / 2;
    } else {
      var _touch$locationX, _touch$locationY;

      touchX = (_touch$locationX = touch.locationX) !== null && _touch$locationX !== void 0 ? _touch$locationX : e.pageX;
      touchY = (_touch$locationY = touch.locationY) !== null && _touch$locationY !== void 0 ? _touch$locationY : e.pageY;
    } // Get the size of the button to determine how big the ripple should be


    const size = centered ? // If ripple is always centered, we don't need to make it too big
    Math.min(dimensions.width, dimensions.height) * 1.25 : // Otherwise make it twice as big so clicking on one end spreads ripple to other
    Math.max(dimensions.width, dimensions.height) * 2; // Create a container for our ripple effect so we don't need to change the parent's style

    const container = document.createElement('span');
    container.setAttribute('data-paper-ripple', '');
    Object.assign(container.style, {
      position: 'absolute',
      pointerEvents: 'none',
      top: '0',
      left: '0',
      right: '0',
      bottom: '0',
      borderTopLeftRadius: style.borderTopLeftRadius,
      borderTopRightRadius: style.borderTopRightRadius,
      borderBottomRightRadius: style.borderBottomRightRadius,
      borderBottomLeftRadius: style.borderBottomLeftRadius,
      overflow: centered ? 'visible' : 'hidden'
    }); // Create span to show the ripple effect

    const ripple = document.createElement('span');
    Object.assign(ripple.style, {
      position: 'absolute',
      pointerEvents: 'none',
      backgroundColor: calculatedRippleColor,
      borderRadius: '50%',

      /* Transition configuration */
      transitionProperty: 'transform opacity',
      transitionDuration: `${Math.min(size * 1.5, 350)}ms`,
      transitionTimingFunction: 'linear',
      transformOrigin: 'center',

      /* We'll animate these properties */
      transform: 'translate3d(-50%, -50%, 0) scale3d(0.1, 0.1, 0.1)',
      opacity: '0.5',
      // Position the ripple where cursor was
      left: `${touchX}px`,
      top: `${touchY}px`,
      width: `${size}px`,
      height: `${size}px`
    }); // Finally, append it to DOM

    container.appendChild(ripple);
    button.appendChild(container); // rAF runs in the same frame as the event handler
    // Use double rAF to ensure the transition class is added in next frame
    // This will make sure that the transition animation is triggered

    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        Object.assign(ripple.style, {
          transform: 'translate3d(-50%, -50%, 0) scale3d(1, 1, 1)',
          opacity: '1'
        });
      });
    });
  };

  const handlePressOut = e => {
    var _rest$onPressOut;

    (_rest$onPressOut = rest.onPressOut) === null || _rest$onPressOut === void 0 ? void 0 : _rest$onPressOut.call(rest, e);
    const containers = e.currentTarget.querySelectorAll('[data-paper-ripple]');
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        containers.forEach(container => {
          const ripple = container.firstChild;
          Object.assign(ripple.style, {
            transitionDuration: '250ms',
            opacity: 0
          }); // Finally remove the span after the transition

          setTimeout(() => {
            const {
              parentNode
            } = container;

            if (parentNode) {
              parentNode.removeChild(container);
            }
          }, 500);
        });
      });
    });
  };

  const disabled = disabledProp || !rest.onPress;
  return /*#__PURE__*/React__namespace.createElement(reactNative.TouchableWithoutFeedback, _extends$Q({}, rest, {
    onPressIn: handlePressIn,
    onPressOut: handlePressOut,
    disabled: disabled
  }), /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: [styles$10.touchable, borderless && styles$10.borderless, style]
  }, React__namespace.Children.only(children)));
};
/**
 * Whether ripple effect is supported.
 */


TouchableRipple.supported = true;
const styles$10 = reactNative.StyleSheet.create({
  touchable: {
    position: 'relative',
    ...(reactNative.Platform.OS === 'web' && {
      cursor: 'pointer'
    })
  },
  borderless: {
    overflow: 'hidden'
  }
});
var TouchableRipple$1 = withTheme(TouchableRipple);

const ListAccordionGroupContext = /*#__PURE__*/React__namespace.createContext(null);

/**
 * A component used to display an expandable list item.
 *
 * <div class="screenshots">
 *   <img class="medium" src="screenshots/list-accordion-1.png" />
 *   <img class="medium" src="screenshots/list-accordion-2.png" />
 *   <img class="medium" src="screenshots/list-accordion-3.png" />
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { List } from 'react-native-paper';
 *
 * const MyComponent = () => {
 *   const [expanded, setExpanded] = React.useState(true);
 *
 *   const handlePress = () => setExpanded(!expanded);
 *
 *   return (
 *     <List.Section title="Accordions">
 *       <List.Accordion
 *         title="Uncontrolled Accordion"
 *         left={props => <List.Icon {...props} icon="folder" />}>
 *         <List.Item title="First item" />
 *         <List.Item title="Second item" />
 *       </List.Accordion>
 *
 *       <List.Accordion
 *         title="Controlled Accordion"
 *         left={props => <List.Icon {...props} icon="folder" />}
 *         expanded={expanded}
 *         onPress={handlePress}>
 *         <List.Item title="First item" />
 *         <List.Item title="Second item" />
 *       </List.Accordion>
 *     </List.Section>
 *   );
 * };
 *
 * export default MyComponent;
 * ```
 */
const ListAccordion = _ref => {
  let {
    left,
    right,
    title,
    description,
    children,
    theme,
    titleStyle,
    descriptionStyle,
    titleNumberOfLines = 1,
    descriptionNumberOfLines = 2,
    style,
    id,
    testID,
    onPress,
    onLongPress,
    expanded: expandedProp,
    accessibilityLabel
  } = _ref;
  const [expanded, setExpanded] = React__namespace.useState(expandedProp || false);

  const handlePressAction = () => {
    onPress === null || onPress === void 0 ? void 0 : onPress();

    if (expandedProp === undefined) {
      // Only update state of the `expanded` prop was not passed
      // If it was passed, the component will act as a controlled component
      setExpanded(expanded => !expanded);
    }
  };

  const titleColor = color$1(theme.colors.text).alpha(0.87).rgb().string();
  const descriptionColor = color$1(theme.colors.text).alpha(0.54).rgb().string();
  const expandedInternal = expandedProp !== undefined ? expandedProp : expanded;
  const groupContext = React__namespace.useContext(ListAccordionGroupContext);

  if (groupContext !== null && !id) {
    throw new Error('List.Accordion is used inside a List.AccordionGroup without specifying an id prop.');
  }

  const isExpanded = groupContext ? groupContext.expandedId === id : expandedInternal;
  const handlePress = groupContext && id !== undefined ? () => groupContext.onAccordionPress(id) : handlePressAction;
  return /*#__PURE__*/React__namespace.createElement(reactNative.View, null, /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: {
      backgroundColor: theme.colors.background
    }
  }, /*#__PURE__*/React__namespace.createElement(TouchableRipple$1, {
    style: [styles$$.container, style],
    onPress: handlePress,
    onLongPress: onLongPress // @ts-expect-error We keep old a11y props for backwards compat with old RN versions
    ,
    accessibilityTraits: "button",
    accessibilityComponentType: "button",
    accessibilityRole: "button",
    accessibilityState: {
      expanded: isExpanded
    },
    accessibilityLabel: accessibilityLabel,
    testID: testID,
    delayPressIn: 0,
    borderless: true
  }, /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: styles$$.row,
    pointerEvents: "none"
  }, left ? left({
    color: isExpanded ? theme.colors.primary : descriptionColor
  }) : null, /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: [styles$$.item, styles$$.content]
  }, /*#__PURE__*/React__namespace.createElement(Text$1, {
    selectable: false,
    numberOfLines: titleNumberOfLines,
    style: [styles$$.title, {
      color: isExpanded ? theme.colors.primary : titleColor
    }, titleStyle]
  }, title), description ? /*#__PURE__*/React__namespace.createElement(Text$1, {
    selectable: false,
    numberOfLines: descriptionNumberOfLines,
    style: [styles$$.description, {
      color: descriptionColor
    }, descriptionStyle]
  }, description) : null), /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: [styles$$.item, description ? styles$$.multiline : undefined]
  }, right ? right({
    isExpanded: isExpanded
  }) : /*#__PURE__*/React__namespace.createElement(defaultIcon, {
    name: isExpanded ? 'chevron-up' : 'chevron-down',
    color: titleColor,
    size: 24,
    direction: reactNative.I18nManager.isRTL ? 'rtl' : 'ltr'
  }))))), isExpanded ? React__namespace.Children.map(children, child => {
    if (left && /*#__PURE__*/React__namespace.isValidElement(child) && !child.props.left && !child.props.right) {
      return /*#__PURE__*/React__namespace.cloneElement(child, {
        style: [styles$$.child, child.props.style]
      });
    }

    return child;
  }) : null);
};

ListAccordion.displayName = 'List.Accordion';
const styles$$ = reactNative.StyleSheet.create({
  container: {
    padding: 8
  },
  row: {
    flexDirection: 'row',
    alignItems: 'center'
  },
  multiline: {
    height: 40,
    alignItems: 'center',
    justifyContent: 'center'
  },
  title: {
    fontSize: 16
  },
  description: {
    fontSize: 14
  },
  item: {
    margin: 8
  },
  child: {
    paddingLeft: 64
  },
  content: {
    flex: 1,
    justifyContent: 'center'
  }
});
withTheme(ListAccordion);

reactNative.StyleSheet.create({
  item: {
    margin: 8,
    height: 40,
    width: 40,
    alignItems: 'center',
    justifyContent: 'center'
  }
});

function _extends$P() { _extends$P = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$P.apply(this, arguments); }

/**
 * A component to show tiles inside a List.
 *
 * <div class="screenshots">
 *   <img class="medium" src="screenshots/list-item-1.png" />
 *   <img class="medium" src="screenshots/list-item-2.png" />
 *   <img class="medium" src="screenshots/list-item-3.png" />
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { List } from 'react-native-paper';
 *
 * const MyComponent = () => (
 *   <List.Item
 *     title="First Item"
 *     description="Item description"
 *     left={props => <List.Icon {...props} icon="folder" />}
 *   />
 * );
 *
 * export default MyComponent;
 * ```
 *
 * @extends TouchableRipple props https://callstack.github.io/react-native-paper/touchable-ripple.html
 */
const ListItem = _ref => {
  let {
    left,
    right,
    title,
    description,
    onPress,
    theme,
    style,
    titleStyle,
    titleNumberOfLines = 1,
    descriptionNumberOfLines = 2,
    titleEllipsizeMode,
    descriptionEllipsizeMode,
    descriptionStyle,
    ...rest
  } = _ref;

  const renderDescription = (descriptionColor, description) => {
    return typeof description === 'function' ? description({
      selectable: false,
      ellipsizeMode: descriptionEllipsizeMode,
      color: descriptionColor,
      fontSize: styles$_.description.fontSize
    }) : /*#__PURE__*/React__namespace.createElement(Text$1, {
      selectable: false,
      numberOfLines: descriptionNumberOfLines,
      ellipsizeMode: descriptionEllipsizeMode,
      style: [styles$_.description, {
        color: descriptionColor
      }, descriptionStyle]
    }, description);
  };

  const renderTitle = () => {
    const titleColor = color$1(theme.colors.text).alpha(0.87).rgb().string();
    return typeof title === 'function' ? title({
      selectable: false,
      ellipsizeMode: titleEllipsizeMode,
      color: titleColor,
      fontSize: styles$_.title.fontSize
    }) : /*#__PURE__*/React__namespace.createElement(Text$1, {
      selectable: false,
      ellipsizeMode: titleEllipsizeMode,
      numberOfLines: titleNumberOfLines,
      style: [styles$_.title, {
        color: titleColor
      }, titleStyle]
    }, title);
  };

  const descriptionColor = color$1(theme.colors.text).alpha(0.54).rgb().string();
  return /*#__PURE__*/React__namespace.createElement(TouchableRipple$1, _extends$P({}, rest, {
    style: [styles$_.container, style],
    onPress: onPress
  }), /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: styles$_.row
  }, left ? left({
    color: descriptionColor,
    style: description ? styles$_.iconMarginLeft : { ...styles$_.iconMarginLeft,
      ...styles$_.marginVerticalNone
    }
  }) : null, /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: [styles$_.item, styles$_.content]
  }, renderTitle(), description ? renderDescription(descriptionColor, description) : null), right ? right({
    color: descriptionColor,
    style: description ? styles$_.iconMarginRight : { ...styles$_.iconMarginRight,
      ...styles$_.marginVerticalNone
    }
  }) : null));
};

ListItem.displayName = 'List.Item';
const styles$_ = reactNative.StyleSheet.create({
  container: {
    padding: 8
  },
  row: {
    flexDirection: 'row'
  },
  title: {
    fontSize: 16
  },
  description: {
    fontSize: 14
  },
  marginVerticalNone: {
    marginVertical: 0
  },
  iconMarginLeft: {
    marginLeft: 0,
    marginRight: 16
  },
  iconMarginRight: {
    marginRight: 0
  },
  item: {
    marginVertical: 6,
    paddingLeft: 8
  },
  content: {
    flex: 1,
    justifyContent: 'center'
  }
});
withTheme(ListItem);

function _extends$O() { _extends$O = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$O.apply(this, arguments); }

/**
 * A component used to display a header in lists.
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { List } from 'react-native-paper';
 *
 * const MyComponent = () => <List.Subheader>My List Title</List.Subheader>;
 *
 * export default MyComponent;
 * ```
 */
const ListSubheader = _ref => {
  let {
    style,
    theme,
    ...rest
  } = _ref;
  const {
    colors,
    fonts
  } = theme;
  const font = fonts.medium;
  const textColor = color$1(colors.text).alpha(0.54).rgb().string();
  return /*#__PURE__*/React__namespace.createElement(Text$1, _extends$O({
    numberOfLines: 1
  }, rest, {
    style: [styles$Z.container, {
      color: textColor,
      ...font
    }, style]
  }));
};

ListSubheader.displayName = 'List.Subheader';
const styles$Z = reactNative.StyleSheet.create({
  container: {
    paddingHorizontal: 16,
    paddingVertical: 13
  }
});
var ListSubheader$1 = withTheme(ListSubheader);

function _extends$N() { _extends$N = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$N.apply(this, arguments); }

/**
 * A component used to group list items.
 *
 * <div class="screenshots">
 *   <img src="screenshots/list-section.png" />
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { List } from 'react-native-paper';
 *
 * const MyComponent = () => (
 *   <List.Section>
 *     <List.Subheader>Some title</List.Subheader>
 *     <List.Item title="First Item" left={() => <List.Icon icon="folder" />} />
 *     <List.Item
 *       title="Second Item"
 *       left={() => <List.Icon color="#000" icon="folder" />}
 *     />
 *   </List.Section>
 * );
 *
 * export default MyComponent;
 * ```
 */
const ListSection = _ref => {
  let {
    children,
    title,
    titleStyle,
    style,
    ...rest
  } = _ref;
  return /*#__PURE__*/React__namespace.createElement(reactNative.View, _extends$N({}, rest, {
    style: [styles$Y.container, style]
  }), title ? /*#__PURE__*/React__namespace.createElement(ListSubheader$1, {
    style: titleStyle
  }, title) : null, children);
};

ListSection.displayName = 'List.Section';
const styles$Y = reactNative.StyleSheet.create({
  container: {
    marginVertical: 8
  }
});
withTheme(ListSection);

/**
 * A component used to show an action item with an icon and a label in a navigation drawer.
 *
 * <div class="screenshots">
 *   <figure>
 *     <img class="medium" src="screenshots/drawer-item.png" />
 *   </figure>
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { Drawer } from 'react-native-paper';
 *
 * const MyComponent = () => (
 *    <Drawer.Item
 *      style={{ backgroundColor: '#64ffda' }}
 *      icon="star"
 *      label="First Item"
 *    />
 * );
 *
 * export default MyComponent;
 * ```
 */
const DrawerItem = _ref => {
  let {
    icon,
    label,
    active,
    theme,
    style,
    onPress,
    accessibilityLabel,
    right,
    ...rest
  } = _ref;
  const {
    colors,
    roundness
  } = theme;
  const backgroundColor = active ? color$1(colors.primary).alpha(0.12).rgb().string() : 'transparent';
  const contentColor = active ? colors.primary : color$1(colors.text).alpha(0.68).rgb().string();
  const font = theme.fonts.medium;
  const labelMargin = icon ? 32 : 0;
  return /*#__PURE__*/React__namespace.createElement(reactNative.View, rest, /*#__PURE__*/React__namespace.createElement(TouchableRipple$1, {
    borderless: true,
    delayPressIn: 0,
    onPress: onPress,
    style: [styles$X.container, {
      backgroundColor,
      borderRadius: roundness
    }, style] // @ts-expect-error We keep old a11y props for backwards compat with old RN versions
    ,
    accessibilityTraits: active ? ['button', 'selected'] : 'button',
    accessibilityComponentType: "button",
    accessibilityRole: "button",
    accessibilityState: {
      selected: active
    },
    accessibilityLabel: accessibilityLabel
  }, /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: styles$X.wrapper
  }, /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: styles$X.content
  }, icon ? /*#__PURE__*/React__namespace.createElement(Icon$1, {
    source: icon,
    size: 24,
    color: contentColor
  }) : null, /*#__PURE__*/React__namespace.createElement(Text$1, {
    selectable: false,
    numberOfLines: 1,
    style: [styles$X.label, {
      color: contentColor,
      ...font,
      marginLeft: labelMargin
    }]
  }, label)), right === null || right === void 0 ? void 0 : right({
    color: contentColor
  }))));
};

DrawerItem.displayName = 'Drawer.Item';
const styles$X = reactNative.StyleSheet.create({
  container: {
    marginHorizontal: 10,
    marginVertical: 4
  },
  wrapper: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 8
  },
  content: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center'
  },
  label: {
    marginRight: 32
  }
});
withTheme(DrawerItem);

function _extends$M() { _extends$M = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$M.apply(this, arguments); }

/**
 * A divider is a thin, lightweight separator that groups content in lists and page layouts.
 *
 * <div class="screenshots">
 *  <figure>
 *    <img class="medium" src="screenshots/divider.png" />
 *  </figure>
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { View } from 'react-native';
 * import { Divider, Text } from 'react-native-paper';
 *
 * const MyComponent = () => (
 *   <View>
 *     <Text>Lemon</Text>
 *     <Divider />
 *     <Text>Mango</Text>
 *     <Divider />
 *   </View>
 * );
 *
 * export default MyComponent;
 * ```
 */
const Divider = _ref => {
  let {
    inset,
    style,
    theme,
    ...rest
  } = _ref;
  const {
    dark: isDarkTheme
  } = theme;
  return /*#__PURE__*/React__namespace.createElement(reactNative.View, _extends$M({}, rest, {
    style: [isDarkTheme ? styles$W.dark : styles$W.light, inset && styles$W.inset, style]
  }));
};

const styles$W = reactNative.StyleSheet.create({
  light: {
    backgroundColor: color$1(black).alpha(0.12).rgb().string(),
    height: reactNative.StyleSheet.hairlineWidth
  },
  dark: {
    backgroundColor: color$1(white).alpha(0.12).rgb().string(),
    height: reactNative.StyleSheet.hairlineWidth
  },
  inset: {
    marginLeft: 72
  }
});
var Divider$1 = withTheme(Divider);

function _extends$L() { _extends$L = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$L.apply(this, arguments); }

/**
 * A component to group content inside a navigation drawer.
 *
 * <div class="screenshots">
 *   <figure>
 *     <img class="medium" src="screenshots/drawer-section.png" />
 *   </figure>
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { Drawer } from 'react-native-paper';
 *
 * const MyComponent = () => {
 *   const [active, setActive] = React.useState('');
 *
 *
 *   return (
 *     <Drawer.Section title="Some title">
 *       <Drawer.Item
 *         label="First Item"
 *         active={active === 'first'}
 *         onPress={() => setActive('first')}
 *       />
 *       <Drawer.Item
 *         label="Second Item"
 *         active={active === 'second'}
 *         onPress={() => setActive('second')}
 *       />
 *     </Drawer.Section>
 *   );
 * };
 *
 * export default MyComponent;
 * ```
 */
const DrawerSection = _ref => {
  let {
    children,
    title,
    theme,
    style,
    ...rest
  } = _ref;
  const {
    colors,
    fonts
  } = theme;
  const titleColor = color$1(colors.text).alpha(0.54).rgb().string();
  const font = fonts.medium;
  return /*#__PURE__*/React__namespace.createElement(reactNative.View, _extends$L({
    style: [styles$V.container, style]
  }, rest), title && /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: styles$V.titleContainer
  }, /*#__PURE__*/React__namespace.createElement(Text$1, {
    numberOfLines: 1,
    style: [{
      color: titleColor,
      ...font
    }, styles$V.title]
  }, title)), children, /*#__PURE__*/React__namespace.createElement(Divider$1, {
    style: styles$V.divider
  }));
};

DrawerSection.displayName = 'Drawer.Section';
const styles$V = reactNative.StyleSheet.create({
  container: {
    marginBottom: 4
  },
  titleContainer: {
    height: 40,
    justifyContent: 'center'
  },
  title: {
    marginLeft: 16
  },
  divider: {
    marginTop: 4
  }
});
withTheme(DrawerSection);

function _extends$K() { _extends$K = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$K.apply(this, arguments); }

/**
 * Surface is a basic container that can give depth to an element with elevation shadow.
 * On dark theme with `adaptive` mode, surface is constructed by also placing a semi-transparent white overlay over a component surface.
 * See [Dark Theme](https://callstack.github.io/react-native-paper/theming.html#dark-theme) for more information.
 * Overlay and shadow can be applied by specifying the `elevation` property both on Android and iOS.
 *
 * <div class="screenshots">
 *   <img src="screenshots/surface-1.png" />
 *   <img src="screenshots/surface-2.png" />
 *   <img src="screenshots/surface-3.png" />
 * </div>
 *
 * <div class="screenshots">
 *   <img src="screenshots/surface-dark-1.png" />
 *   <img src="screenshots/surface-dark-2.png" />
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { Surface, Text } from 'react-native-paper';
 * import { StyleSheet } from 'react-native';
 *
 * const MyComponent = () => (
 *   <Surface style={styles.surface}>
 *      <Text>Surface</Text>
 *   </Surface>
 * );
 *
 * export default MyComponent;
 *
 * const styles = StyleSheet.create({
 *   surface: {
 *     padding: 8,
 *     height: 80,
 *     width: 80,
 *     alignItems: 'center',
 *     justifyContent: 'center',
 *     elevation: 4,
 *   },
 * });
 * ```
 */
const Surface = _ref => {
  let {
    style,
    theme,
    ...rest
  } = _ref;
  const {
    elevation = 4
  } = reactNative.StyleSheet.flatten(style) || {};
  const {
    dark: isDarkTheme,
    mode,
    colors
  } = theme;
  return /*#__PURE__*/React__namespace.createElement(reactNative.Animated.View, _extends$K({}, rest, {
    style: [{
      backgroundColor: isDarkTheme && mode === 'adaptive' ? overlay(elevation, colors.surface) : colors.surface
    }, elevation ? shadow(elevation) : null, style]
  }));
};

var Surface$1 = withTheme(Surface);

function _extends$J() { _extends$J = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$J.apply(this, arguments); }

/**
 * Text component which follows styles from the theme.
 *
 * @extends Text props https://reactnative.dev/docs/text#props
 */
function AnimatedText(_ref) {
  let {
    style,
    theme,
    ...rest
  } = _ref;
  const writingDirection = reactNative.I18nManager.isRTL ? 'rtl' : 'ltr';
  return /*#__PURE__*/React__namespace.createElement(reactNative.Animated.Text, _extends$J({}, rest, {
    style: [styles$U.text, { ...theme.fonts.regular,
      color: theme.colors.text,
      writingDirection
    }, style]
  }));
}

const styles$U = reactNative.StyleSheet.create({
  text: {
    textAlign: 'left'
  }
});
var AnimatedText$1 = withTheme(AnimatedText);

const getCombinedStyles = _ref => {
  let {
    isAnimatedFromRight,
    isIconStatic,
    distance,
    animFAB
  } = _ref;
  const {
    isRTL
  } = reactNative.I18nManager;
  const defaultPositionStyles = {
    left: -distance,
    right: undefined
  };
  const combinedStyles = {
    innerWrapper: { ...defaultPositionStyles
    },
    iconWrapper: { ...defaultPositionStyles
    },
    absoluteFill: {}
  };
  const animatedFromRight = isAnimatedFromRight && !isRTL;
  const animatedFromRightRTL = isAnimatedFromRight && isRTL;
  const animatedFromLeft = !isAnimatedFromRight && !isRTL;
  const animatedFromLeftRTL = !isAnimatedFromRight && isRTL;

  if (animatedFromRight) {
    combinedStyles.innerWrapper.transform = [{
      translateX: animFAB.interpolate({
        inputRange: [distance, 0],
        outputRange: [distance, 0]
      })
    }];
    combinedStyles.iconWrapper.transform = [{
      translateX: isIconStatic ? 0 : animFAB
    }];
    combinedStyles.absoluteFill.transform = [{
      translateX: animFAB.interpolate({
        inputRange: [distance, 0],
        outputRange: [Math.abs(distance) / 2, Math.abs(distance)]
      })
    }];
  } else if (animatedFromRightRTL) {
    combinedStyles.iconWrapper.transform = [{
      translateX: isIconStatic ? 0 : animFAB.interpolate({
        inputRange: [distance, 0],
        outputRange: [-distance, 0]
      })
    }];
    combinedStyles.innerWrapper.transform = [{
      translateX: animFAB.interpolate({
        inputRange: [distance, 0],
        outputRange: [-distance, 0]
      })
    }];
    combinedStyles.absoluteFill.transform = [{
      translateX: animFAB.interpolate({
        inputRange: [distance, 0],
        outputRange: [0, distance]
      })
    }];
  } else if (animatedFromLeft) {
    combinedStyles.iconWrapper.transform = [{
      translateX: isIconStatic ? distance : animFAB.interpolate({
        inputRange: [0, distance],
        outputRange: [distance, distance * 2]
      })
    }];
    combinedStyles.innerWrapper.transform = [{
      translateX: animFAB
    }];
    combinedStyles.absoluteFill.transform = [{
      translateX: animFAB.interpolate({
        inputRange: [0, distance],
        outputRange: [0, Math.abs(distance) / 2]
      })
    }];
  } else if (animatedFromLeftRTL) {
    combinedStyles.iconWrapper.transform = [{
      translateX: isIconStatic ? animFAB.interpolate({
        inputRange: [0, distance],
        outputRange: [-distance, -distance * 2]
      }) : -distance
    }];
    combinedStyles.innerWrapper.transform = [{
      translateX: animFAB.interpolate({
        inputRange: [0, distance],
        outputRange: [0, -distance]
      })
    }];
    combinedStyles.absoluteFill.transform = [{
      translateX: animFAB.interpolate({
        inputRange: [0, distance],
        outputRange: [0, -distance]
      })
    }];
  }

  return combinedStyles;
};

function _extends$I() { _extends$I = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$I.apply(this, arguments); }
const SIZE = 56;
const BORDER_RADIUS = SIZE / 2;
const SCALE = 0.9;

const AnimatedFAB = _ref => {
  let {
    icon,
    label,
    accessibilityLabel = label,
    accessibilityState,
    color: customColor,
    disabled,
    onPress,
    onLongPress,
    theme,
    style,
    visible = true,
    uppercase = true,
    testID,
    animateFrom = 'right',
    extended = false,
    iconMode = 'dynamic',
    ...rest
  } = _ref;
  const isIOS = reactNative.Platform.OS === 'ios';
  const isAnimatedFromRight = animateFrom === 'right';
  const isIconStatic = iconMode === 'static';
  const {
    isRTL
  } = reactNative.I18nManager;
  const {
    current: visibility
  } = React__namespace.useRef(new reactNative.Animated.Value(visible ? 1 : 0));
  const {
    current: animFAB
  } = React__namespace.useRef(new reactNative.Animated.Value(0));
  const {
    scale
  } = theme.animation;
  const [textWidth, setTextWidth] = React__namespace.useState(0);
  const [textHeight, setTextHeight] = React__namespace.useState(0);
  React__namespace.useEffect(() => {
    if (visible) {
      reactNative.Animated.timing(visibility, {
        toValue: 1,
        duration: 200 * scale,
        useNativeDriver: true
      }).start();
    } else {
      reactNative.Animated.timing(visibility, {
        toValue: 0,
        duration: 150 * scale,
        useNativeDriver: true
      }).start();
    }
  }, [visible, scale, visibility]);
  const disabledColor = color$1(theme.dark ? white : black).alpha(0.12).rgb().string();
  const {
    backgroundColor = disabled ? disabledColor : theme.colors.accent
  } = reactNative.StyleSheet.flatten(style) || {};
  let foregroundColor;

  if (typeof customColor !== 'undefined') {
    foregroundColor = customColor;
  } else if (disabled) {
    foregroundColor = color$1(theme.dark ? white : black).alpha(0.32).rgb().string();
  } else {
    foregroundColor = !color$1(backgroundColor).isLight() ? white : 'rgba(0, 0, 0, .54)';
  }

  const rippleColor = color$1(foregroundColor).alpha(0.32).rgb().string();
  const extendedWidth = textWidth + 1.5 * SIZE;
  const distance = isAnimatedFromRight ? -textWidth - BORDER_RADIUS : textWidth + BORDER_RADIUS;
  React__namespace.useEffect(() => {
    reactNative.Animated.timing(animFAB, {
      toValue: !extended ? 0 : distance,
      duration: 150 * scale,
      useNativeDriver: true,
      easing: reactNative.Easing.linear
    }).start();
  }, [animFAB, scale, distance, extended]);

  const onTextLayout = _ref2 => {
    let {
      nativeEvent
    } = _ref2;
    const currentWidth = Math.ceil(nativeEvent.lines[0].width);
    const currentHeight = Math.ceil(nativeEvent.lines[0].height);

    if (currentWidth !== textWidth || currentHeight !== textHeight) {
      setTextHeight(currentHeight);

      if (isIOS) {
        return setTextWidth(currentWidth - 12);
      }

      setTextWidth(currentWidth);
    }
  };

  const propForDirection = right => {
    if (isAnimatedFromRight) {
      return right;
    }

    return right.reverse();
  };

  const combinedStyles = getCombinedStyles({
    isAnimatedFromRight,
    isIconStatic,
    distance,
    animFAB
  });
  return /*#__PURE__*/React__namespace.createElement(Surface$1, _extends$I({}, rest, {
    style: [{
      opacity: visibility,
      transform: [{
        scale: visibility
      }],
      elevation: isIOS ? 6 : 0
    }, styles$T.container, disabled && styles$T.disabled, style]
  }), /*#__PURE__*/React__namespace.createElement(reactNative.Animated.View, {
    style: [{
      transform: [{
        scaleY: animFAB.interpolate({
          inputRange: propForDirection([distance, 0]),
          outputRange: propForDirection([SCALE, 1])
        })
      }]
    }, styles$T.standard]
  }, /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: [reactNative.StyleSheet.absoluteFill, styles$T.shadowWrapper]
  }, /*#__PURE__*/React__namespace.createElement(reactNative.Animated.View, {
    pointerEvents: "none",
    style: [reactNative.StyleSheet.absoluteFill, styles$T.shadow, {
      width: extendedWidth,
      opacity: animFAB.interpolate({
        inputRange: propForDirection([distance, 0.9 * distance, 0]),
        outputRange: propForDirection([1, 0.15, 0])
      })
    }]
  }), /*#__PURE__*/React__namespace.createElement(reactNative.Animated.View, {
    pointerEvents: "none",
    style: [reactNative.StyleSheet.absoluteFill, styles$T.shadow, {
      opacity: animFAB.interpolate({
        inputRange: propForDirection([distance, 0.9 * distance, 0]),
        outputRange: propForDirection([0, 0.85, 1])
      }),
      width: SIZE,
      borderRadius: animFAB.interpolate({
        inputRange: propForDirection([distance, 0]),
        outputRange: propForDirection([SIZE / (extendedWidth / SIZE), BORDER_RADIUS])
      })
    }, combinedStyles.absoluteFill]
  })), /*#__PURE__*/React__namespace.createElement(reactNative.Animated.View, {
    pointerEvents: "box-none",
    style: [styles$T.innerWrapper]
  }, /*#__PURE__*/React__namespace.createElement(reactNative.Animated.View, {
    style: [styles$T.standard, {
      width: extendedWidth,
      backgroundColor
    }, combinedStyles.innerWrapper]
  }, /*#__PURE__*/React__namespace.createElement(TouchableRipple$1, {
    borderless: true,
    onPress: onPress,
    onLongPress: onLongPress,
    rippleColor: rippleColor,
    disabled: disabled,
    accessibilityLabel: accessibilityLabel // @ts-expect-error We keep old a11y props for backwards compat with old RN versions
    ,
    accessibilityTraits: disabled ? ['button', 'disabled'] : 'button',
    accessibilityComponentType: "button",
    accessibilityRole: "button",
    accessibilityState: { ...accessibilityState,
      disabled
    },
    testID: testID,
    style: styles$T.touchable
  }, /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: [styles$T.standard, {
      width: extendedWidth
    }]
  }))))), /*#__PURE__*/React__namespace.createElement(reactNative.Animated.View, {
    style: [styles$T.iconWrapper, combinedStyles.iconWrapper],
    pointerEvents: "none"
  }, /*#__PURE__*/React__namespace.createElement(Icon$1, {
    source: icon,
    size: 24,
    color: foregroundColor
  })), /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    pointerEvents: "none"
  }, /*#__PURE__*/React__namespace.createElement(AnimatedText$1, {
    numberOfLines: 1,
    onTextLayout: isIOS ? onTextLayout : undefined,
    ellipsizeMode: 'tail',
    style: [{
      [isAnimatedFromRight || isRTL ? 'right' : 'left']: isIconStatic ? isIOS ? SIZE - 10 : SIZE - 12 : BORDER_RADIUS
    }, {
      minWidth: textWidth,
      top: -BORDER_RADIUS - textHeight / 2,
      opacity: animFAB.interpolate({
        inputRange: propForDirection([distance, 0.7 * distance, 0]),
        outputRange: propForDirection([1, 0, 0])
      }),
      transform: [{
        translateX: animFAB.interpolate({
          inputRange: propForDirection([distance, 0]),
          outputRange: propForDirection([0, SIZE])
        })
      }]
    }, styles$T.label, uppercase && styles$T.uppercaseLabel, {
      color: foregroundColor,
      ...theme.fonts.medium
    }]
  }, label)), !isIOS &&
  /*#__PURE__*/
  // Method `onTextLayout` on Android returns sizes of text visible on the screen,
  // however during render the text in `FAB` isn't fully visible. In order to get
  // proper text measurements there is a need to additionaly render that text, but
  // wrapped in absolutely positioned `ScrollView` which height is 0.
  React__namespace.createElement(reactNative.ScrollView, {
    style: styles$T.textPlaceholderContainer
  }, /*#__PURE__*/React__namespace.createElement(reactNative.Text, {
    onTextLayout: onTextLayout
  }, label)));
};

const styles$T = reactNative.StyleSheet.create({
  standard: {
    height: SIZE,
    borderRadius: BORDER_RADIUS
  },
  disabled: {
    elevation: 0
  },
  container: {
    position: 'absolute',
    backgroundColor: 'transparent',
    borderRadius: BORDER_RADIUS
  },
  innerWrapper: {
    flexDirection: 'row',
    overflow: 'hidden',
    borderRadius: BORDER_RADIUS
  },
  shadowWrapper: {
    elevation: 0
  },
  shadow: {
    elevation: 6,
    borderRadius: BORDER_RADIUS
  },
  touchable: {
    borderRadius: BORDER_RADIUS
  },
  iconWrapper: {
    alignItems: 'center',
    justifyContent: 'center',
    position: 'absolute',
    height: SIZE,
    width: SIZE
  },
  label: {
    position: 'absolute'
  },
  uppercaseLabel: {
    textTransform: 'uppercase'
  },
  textPlaceholderContainer: {
    height: 0,
    position: 'absolute'
  }
});
withTheme(AnimatedFAB);

function _extends$H() { _extends$H = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$H.apply(this, arguments); }
const defaultSize = 20;

/**
 * Badges are small status descriptors for UI elements.
 * A badge consists of a small circle, typically containing a number or other short set of characters, that appears in proximity to another object.
 *
 * <div class="screenshots">
 *   <figure>
 *     <img class="small" src="screenshots/badge-1.png" />
 *     <figcaption>Badge with content</figcaption>
 *   </figure>
 *   <figure>
 *     <img class="small" src="screenshots/badge-2.png" />
 *     <figcaption>Badge without content</figcaption>
 *   </figure>
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { Badge } from 'react-native-paper';
 *
 * const MyComponent = () => (
 *   <Badge>3</Badge>
 * );
 *
 * export default MyComponent;
 * ```
 */
const Badge = _ref => {
  let {
    children,
    size = defaultSize,
    style,
    theme,
    visible = true,
    ...rest
  } = _ref;
  const {
    current: opacity
  } = React__namespace.useRef(new reactNative.Animated.Value(visible ? 1 : 0));
  const isFirstRendering = React__namespace.useRef(true);
  const {
    animation: {
      scale
    }
  } = theme;
  React__namespace.useEffect(() => {
    // Do not run animation on very first rendering
    if (isFirstRendering.current) {
      isFirstRendering.current = false;
      return;
    }

    reactNative.Animated.timing(opacity, {
      toValue: visible ? 1 : 0,
      duration: 150 * scale,
      useNativeDriver: true
    }).start();
  }, [visible, opacity, scale]);
  const {
    backgroundColor = theme.colors.notification,
    ...restStyle
  } = reactNative.StyleSheet.flatten(style) || {};
  const textColor = getContrastingColor(backgroundColor, white, black);
  const borderRadius = size / 2;
  return /*#__PURE__*/React__namespace.createElement(reactNative.Animated.Text, _extends$H({
    numberOfLines: 1,
    style: [{
      opacity,
      backgroundColor,
      color: textColor,
      fontSize: size * 0.5,
      ...theme.fonts.regular,
      lineHeight: size,
      height: size,
      minWidth: size,
      borderRadius
    }, styles$S.container, restStyle]
  }, rest), children);
};

var Badge$1 = withTheme(Badge);
const styles$S = reactNative.StyleSheet.create({
  container: {
    alignSelf: 'flex-end',
    textAlign: 'center',
    textAlignVertical: 'center',
    paddingHorizontal: 4,
    overflow: 'hidden'
  }
});

function _extends$G() { _extends$G = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$G.apply(this, arguments); }
const DURATION = 2400;
/**
 * Activity indicator is used to present progress of some activity in the app.
 * It can be used as a drop-in for the ActivityIndicator shipped with React Native.
 *
 * <div class="screenshots">
 *   <img src="screenshots/activity-indicator.gif" style="width: 100px;" />
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { ActivityIndicator, Colors } from 'react-native-paper';
 *
 * const MyComponent = () => (
 *   <ActivityIndicator animating={true} color={Colors.red800} />
 * );
 *
 * export default MyComponent;
 * ```
 */

const ActivityIndicator = _ref => {
  let {
    animating = true,
    color: indicatorColor,
    hidesWhenStopped = true,
    size: indicatorSize = 'small',
    style,
    theme,
    ...rest
  } = _ref;
  const {
    current: timer
  } = React__namespace.useRef(new reactNative.Animated.Value(0));
  const {
    current: fade
  } = React__namespace.useRef(new reactNative.Animated.Value(!animating && hidesWhenStopped ? 0 : 1));
  const rotation = React__namespace.useRef(undefined);
  const {
    animation: {
      scale
    }
  } = theme;
  const startRotation = React__namespace.useCallback(() => {
    // Show indicator
    reactNative.Animated.timing(fade, {
      duration: 200 * scale,
      toValue: 1,
      isInteraction: false,
      useNativeDriver: true
    }).start(); // Circular animation in loop

    if (rotation.current) {
      timer.setValue(0); // $FlowFixMe

      reactNative.Animated.loop(rotation.current).start();
    }
  }, [scale, fade, timer]);

  const stopRotation = () => {
    if (rotation.current) {
      rotation.current.stop();
    }
  };

  React__namespace.useEffect(() => {
    if (rotation.current === undefined) {
      // Circular animation in loop
      rotation.current = reactNative.Animated.timing(timer, {
        duration: DURATION,
        easing: reactNative.Easing.linear,
        // Animated.loop does not work if useNativeDriver is true on web
        useNativeDriver: reactNative.Platform.OS !== 'web',
        toValue: 1,
        isInteraction: false
      });
    }

    if (animating) {
      startRotation();
    } else if (hidesWhenStopped) {
      // Hide indicator first and then stop rotation
      reactNative.Animated.timing(fade, {
        duration: 200 * scale,
        toValue: 0,
        useNativeDriver: true,
        isInteraction: false
      }).start(stopRotation);
    } else {
      stopRotation();
    }
  }, [animating, fade, hidesWhenStopped, startRotation, scale, timer]);
  const color = indicatorColor || theme.colors.primary;
  const size = typeof indicatorSize === 'string' ? indicatorSize === 'small' ? 24 : 48 : indicatorSize ? indicatorSize : 24;
  const frames = 60 * DURATION / 1000;
  const easing = reactNative.Easing.bezier(0.4, 0.0, 0.7, 1.0);
  const containerStyle = {
    width: size,
    height: size / 2,
    overflow: 'hidden'
  };
  return /*#__PURE__*/React__namespace.createElement(reactNative.View, _extends$G({
    style: [styles$R.container, style]
  }, rest, {
    accessible: true,
    accessibilityRole: "progressbar",
    accessibilityState: {
      busy: animating
    }
  }), /*#__PURE__*/React__namespace.createElement(reactNative.Animated.View, {
    style: [{
      width: size,
      height: size,
      opacity: fade
    }],
    collapsable: false
  }, [0, 1].map(index => {
    // Thanks to https://github.com/n4kz/react-native-indicators for the great work
    const inputRange = Array.from(new Array(frames), (_, frameIndex) => frameIndex / (frames - 1));
    const outputRange = Array.from(new Array(frames), (_, frameIndex) => {
      let progress = 2 * frameIndex / (frames - 1);
      const rotation = index ? +(360 - 15) : -(180 - 15);

      if (progress > 1.0) {
        progress = 2.0 - progress;
      }

      const direction = index ? -1 : +1;
      return `${direction * (180 - 30) * easing(progress) + rotation}deg`;
    });
    const layerStyle = {
      width: size,
      height: size,
      transform: [{
        rotate: timer.interpolate({
          inputRange: [0, 1],
          outputRange: [`${0 + 30 + 15}deg`, `${2 * 360 + 30 + 15}deg`]
        })
      }]
    };
    const viewportStyle = {
      width: size,
      height: size,
      transform: [{
        translateY: index ? -size / 2 : 0
      }, {
        rotate: timer.interpolate({
          inputRange,
          outputRange
        })
      }]
    };
    const offsetStyle = index ? {
      top: size / 2
    } : null;
    const lineStyle = {
      width: size,
      height: size,
      borderColor: color,
      borderWidth: size / 10,
      borderRadius: size / 2
    };
    return /*#__PURE__*/React__namespace.createElement(reactNative.Animated.View, {
      key: index,
      style: [styles$R.layer]
    }, /*#__PURE__*/React__namespace.createElement(reactNative.Animated.View, {
      style: layerStyle
    }, /*#__PURE__*/React__namespace.createElement(reactNative.Animated.View, {
      style: [containerStyle, offsetStyle],
      collapsable: false
    }, /*#__PURE__*/React__namespace.createElement(reactNative.Animated.View, {
      style: viewportStyle
    }, /*#__PURE__*/React__namespace.createElement(reactNative.Animated.View, {
      style: containerStyle,
      collapsable: false
    }, /*#__PURE__*/React__namespace.createElement(reactNative.Animated.View, {
      style: lineStyle
    }))))));
  })));
};

const styles$R = reactNative.StyleSheet.create({
  container: {
    justifyContent: 'center',
    alignItems: 'center'
  },
  layer: { ...reactNative.StyleSheet.absoluteFillObject,
    justifyContent: 'center',
    alignItems: 'center'
  }
});
var ActivityIndicator$1 = withTheme(ActivityIndicator);

function _extends$F() { _extends$F = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$F.apply(this, arguments); }

/**
 * A button is component that the user can press to trigger an action.
 *
 * <div class="screenshots">
 *   <figure>
 *     <img src="screenshots/button-1.png" />
 *     <figcaption>Text button</figcaption>
 *   </figure>
 *   <figure>
 *     <img src="screenshots/button-2.png" />
 *     <figcaption>Outlined button</figcaption>
 *   </figure>
 *   <figure>
 *     <img src="screenshots/button-3.png" />
 *     <figcaption>Contained button</figcaption>
 *   </figure>
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { Button } from 'react-native-paper';
 *
 * const MyComponent = () => (
 *   <Button icon="camera" mode="contained" onPress={() => console.log('Pressed')}>
 *     Press me
 *   </Button>
 * );
 *
 * export default MyComponent;
 * ```
 */
const Button = _ref => {
  var _StyleSheet$flatten;

  let {
    disabled,
    compact,
    mode = 'text',
    dark,
    loading,
    icon,
    color: buttonColor,
    children,
    uppercase = true,
    accessibilityLabel,
    accessibilityHint,
    onPress,
    onLongPress,
    style,
    theme,
    contentStyle,
    labelStyle,
    testID,
    accessible,
    ...rest
  } = _ref;
  const {
    current: elevation
  } = React__namespace.useRef(new reactNative.Animated.Value(disabled || mode !== 'contained' ? 0 : 2));
  React__namespace.useEffect(() => {
    elevation.setValue(disabled || mode !== 'contained' ? 0 : 2);
  }, [mode, elevation, disabled]);

  const handlePressIn = () => {
    if (mode === 'contained') {
      const {
        scale
      } = theme.animation;
      reactNative.Animated.timing(elevation, {
        toValue: 8,
        duration: 200 * scale,
        useNativeDriver: true
      }).start();
    }
  };

  const handlePressOut = () => {
    if (mode === 'contained') {
      const {
        scale
      } = theme.animation;
      reactNative.Animated.timing(elevation, {
        toValue: 2,
        duration: 150 * scale,
        useNativeDriver: true
      }).start();
    }
  };

  const {
    colors,
    roundness
  } = theme;
  const font = theme.fonts.medium;
  let backgroundColor, borderColor, textColor, borderWidth;

  if (mode === 'contained') {
    if (disabled) {
      backgroundColor = color$1(theme.dark ? white : black).alpha(0.12).rgb().string();
    } else if (buttonColor) {
      backgroundColor = buttonColor;
    } else {
      backgroundColor = colors.primary;
    }
  } else {
    backgroundColor = 'transparent';
  }

  if (mode === 'outlined') {
    borderColor = color$1(theme.dark ? white : black).alpha(0.29).rgb().string();
    borderWidth = reactNative.StyleSheet.hairlineWidth;
  } else {
    borderColor = 'transparent';
    borderWidth = 0;
  }

  if (disabled) {
    textColor = color$1(theme.dark ? white : black).alpha(0.32).rgb().string();
  } else if (mode === 'contained') {
    let isDark;

    if (typeof dark === 'boolean') {
      isDark = dark;
    } else {
      isDark = backgroundColor === 'transparent' ? false : !color$1(backgroundColor).isLight();
    }

    textColor = isDark ? white : black;
  } else if (buttonColor) {
    textColor = buttonColor;
  } else {
    textColor = colors.primary;
  }

  const rippleColor = color$1(textColor).alpha(0.32).rgb().string();
  const buttonStyle = {
    backgroundColor,
    borderColor,
    borderWidth,
    borderRadius: roundness
  };
  const touchableStyle = {
    borderRadius: style ? (reactNative.StyleSheet.flatten(style) || {}).borderRadius || roundness : roundness
  };
  const {
    color: customLabelColor,
    fontSize: customLabelSize
  } = reactNative.StyleSheet.flatten(labelStyle) || {};
  const textStyle = {
    color: textColor,
    ...font
  };
  const iconStyle = ((_StyleSheet$flatten = reactNative.StyleSheet.flatten(contentStyle)) === null || _StyleSheet$flatten === void 0 ? void 0 : _StyleSheet$flatten.flexDirection) === 'row-reverse' ? styles$Q.iconReverse : styles$Q.icon;
  return /*#__PURE__*/React__namespace.createElement(Surface$1, _extends$F({}, rest, {
    style: [styles$Q.button, compact && styles$Q.compact, {
      elevation
    }, buttonStyle, style]
  }), /*#__PURE__*/React__namespace.createElement(TouchableRipple$1, {
    borderless: true,
    delayPressIn: 0,
    onPress: onPress,
    onLongPress: onLongPress,
    onPressIn: handlePressIn,
    onPressOut: handlePressOut,
    accessibilityLabel: accessibilityLabel,
    accessibilityHint: accessibilityHint // @ts-expect-error We keep old a11y props for backwards compat with old RN versions
    ,
    accessibilityTraits: disabled ? ['button', 'disabled'] : 'button',
    accessibilityComponentType: "button",
    accessibilityRole: "button",
    accessibilityState: {
      disabled
    },
    accessible: accessible,
    disabled: disabled,
    rippleColor: rippleColor,
    style: touchableStyle,
    testID: testID
  }, /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: [styles$Q.content, contentStyle]
  }, icon && loading !== true ? /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: iconStyle
  }, /*#__PURE__*/React__namespace.createElement(Icon$1, {
    source: icon,
    size: customLabelSize !== null && customLabelSize !== void 0 ? customLabelSize : 16,
    color: typeof customLabelColor === 'string' ? customLabelColor : textColor
  })) : null, loading ? /*#__PURE__*/React__namespace.createElement(ActivityIndicator$1, {
    size: customLabelSize !== null && customLabelSize !== void 0 ? customLabelSize : 16,
    color: typeof customLabelColor === 'string' ? customLabelColor : textColor,
    style: iconStyle
  }) : null, /*#__PURE__*/React__namespace.createElement(Text$1, {
    selectable: false,
    numberOfLines: 1,
    style: [styles$Q.label, compact && styles$Q.compactLabel, uppercase && styles$Q.uppercaseLabel, textStyle, font, labelStyle]
  }, children))));
};

const styles$Q = reactNative.StyleSheet.create({
  button: {
    minWidth: 64,
    borderStyle: 'solid'
  },
  compact: {
    minWidth: 'auto'
  },
  content: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center'
  },
  icon: {
    marginLeft: 12,
    marginRight: -4
  },
  iconReverse: {
    marginRight: 12,
    marginLeft: -4
  },
  label: {
    textAlign: 'center',
    letterSpacing: 1,
    marginVertical: 9,
    marginHorizontal: 16
  },
  compactLabel: {
    marginHorizontal: 8
  },
  uppercaseLabel: {
    textTransform: 'uppercase'
  }
});
var Button$1 = withTheme(Button);

function _extends$E() { _extends$E = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$E.apply(this, arguments); }
const ELEVATION = 1;
const DEFAULT_MAX_WIDTH = 960;

/**
 * Banner displays a prominent message and related actions.
 *
 * <div class="screenshots">
 *   <img class="medium" src="screenshots/banner.gif" />
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { Image } from 'react-native';
 * import { Banner } from 'react-native-paper';
 *
 * const MyComponent = () => {
 *   const [visible, setVisible] = React.useState(true);
 *
 *   return (
 *     <Banner
 *       visible={visible}
 *       actions={[
 *         {
 *           label: 'Fix it',
 *           onPress: () => setVisible(false),
 *         },
 *         {
 *           label: 'Learn more',
 *           onPress: () => setVisible(false),
 *         },
 *       ]}
 *       icon={({size}) => (
 *         <Image
 *           source={{
 *             uri: 'https://avatars3.githubusercontent.com/u/17571969?s=400&v=4',
 *           }}
 *           style={{
 *             width: size,
 *             height: size,
 *           }}
 *         />
 *       )}>
 *       There was a problem processing a transaction on your credit card.
 *     </Banner>
 *   );
 * };
 *
 * export default MyComponent;
 * ```
 */
const Banner = _ref => {
  let {
    visible,
    icon,
    children,
    actions,
    contentStyle,
    style,
    theme,
    onShowAnimationFinished = () => {},
    onHideAnimationFinished = () => {},
    ...rest
  } = _ref;
  const {
    current: position
  } = React__namespace.useRef(new reactNative.Animated.Value(visible ? 1 : 0));
  const [layout, setLayout] = React__namespace.useState({
    height: 0,
    measured: false
  });
  const {
    scale
  } = theme.animation;
  React__namespace.useEffect(() => {
    if (visible) {
      // show
      reactNative.Animated.timing(position, {
        duration: 250 * scale,
        toValue: 1,
        useNativeDriver: false
      }).start(onShowAnimationFinished);
    } else {
      // hide
      reactNative.Animated.timing(position, {
        duration: 200 * scale,
        toValue: 0,
        useNativeDriver: false
      }).start(onHideAnimationFinished);
    }
  }, [visible, position, scale]);

  const handleLayout = _ref2 => {
    let {
      nativeEvent
    } = _ref2;
    const {
      height
    } = nativeEvent.layout;
    setLayout({
      height,
      measured: true
    });
  }; // The banner animation has 2 parts:
  // 1. Blank spacer element which animates its height to move the content
  // 2. Actual banner which animates its translateY
  // In initial render, we position everything normally and measure the height of the banner
  // Once we have the height, we apply the height to the spacer and switch the banner to position: absolute
  // We need this because we need to move the content below as if banner's height was being animated
  // However we can't animated banner's height directly as it'll also resize the content inside


  const height = reactNative.Animated.multiply(position, layout.height);
  const translateY = reactNative.Animated.multiply(reactNative.Animated.add(position, -1), layout.height);
  return /*#__PURE__*/React__namespace.createElement(Surface$1, _extends$E({}, rest, {
    style: [styles$P.container, shadow(ELEVATION), style],
    theme: theme
  }), /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: [styles$P.wrapper, contentStyle]
  }, /*#__PURE__*/React__namespace.createElement(reactNative.Animated.View, {
    style: {
      height
    }
  }), /*#__PURE__*/React__namespace.createElement(reactNative.Animated.View, {
    onLayout: handleLayout,
    style: [layout.measured || !visible ? // If we have measured banner's height or it's invisible,
    // Position it absolutely, the layout will be taken care of the spacer
    [styles$P.absolute, {
      transform: [{
        translateY
      }]
    }] : // Otherwise position it normally
    null, !layout.measured && !visible ? // If we haven't measured banner's height yet and it's invisible,
    // hide it with opacity: 0 so user doesn't see it
    {
      opacity: 0
    } : null]
  }, /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: styles$P.content
  }, icon ? /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: styles$P.icon
  }, /*#__PURE__*/React__namespace.createElement(Icon$1, {
    source: icon,
    size: 40
  })) : null, /*#__PURE__*/React__namespace.createElement(Text$1, {
    style: [styles$P.message, {
      color: theme.colors.text
    }],
    accessibilityLiveRegion: visible ? 'polite' : 'none',
    accessibilityRole: "alert"
  }, children)), /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: styles$P.actions
  }, actions.map((_ref3, i) => {
    let {
      label,
      ...others
    } = _ref3;
    return /*#__PURE__*/React__namespace.createElement(Button$1, _extends$E({
      key:
      /* eslint-disable-line react/no-array-index-key */
      i,
      compact: true,
      mode: "text",
      style: styles$P.button,
      color: theme.colors.primary
    }, others), label);
  })))));
};

const styles$P = reactNative.StyleSheet.create({
  container: {
    elevation: ELEVATION
  },
  wrapper: {
    overflow: 'hidden',
    alignSelf: 'center',
    width: '100%',
    maxWidth: DEFAULT_MAX_WIDTH
  },
  absolute: {
    position: 'absolute',
    top: 0,
    width: '100%'
  },
  content: {
    flexDirection: 'row',
    justifyContent: 'flex-start',
    marginHorizontal: 8,
    marginTop: 16,
    marginBottom: 0
  },
  icon: {
    margin: 8
  },
  message: {
    flex: 1,
    margin: 8
  },
  actions: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    margin: 4
  },
  button: {
    margin: 4
  }
});
withTheme(Banner);

function isIphoneX() {
    const dimen = reactNative.Dimensions.get('window');
    return (
        reactNative.Platform.OS === 'ios' &&
        !reactNative.Platform.isPad &&
        !reactNative.Platform.isTVOS &&
        ((dimen.height === 780 || dimen.width === 780)
          || (dimen.height === 812 || dimen.width === 812)
          || (dimen.height === 844 || dimen.width === 844)
          || (dimen.height === 896 || dimen.width === 896)
          || (dimen.height === 926 || dimen.width === 926))
    );
}

function ifIphoneX(iphoneXStyle, regularStyle) {
    if (isIphoneX()) {
        return iphoneXStyle;
    }
    return regularStyle;
}

function getStatusBarHeight(safe) {
    return reactNative.Platform.select({
        ios: ifIphoneX(safe ? 44 : 30, 20),
        android: reactNative.StatusBar.currentHeight,
        default: 0
    });
}

function getBottomSpace() {
    return isIphoneX() ? 34 : 0;
}

function useLazyRef(callback) {
  const lazyRef = React__namespace.useRef();

  if (lazyRef.current === undefined) {
    lazyRef.current = callback();
  }

  return lazyRef;
}

function useAnimatedValue(initialValue) {
  const {
    current
  } = useLazyRef(() => new reactNative.Animated.Value(initialValue));
  return current;
}

function useAnimatedValueArray(initialValues) {
  const refs = React__namespace.useRef([]);
  refs.current.length = initialValues.length;
  initialValues.forEach((initialValue, i) => {
    var _refs$current$i;

    refs.current[i] = (_refs$current$i = refs.current[i]) !== null && _refs$current$i !== void 0 ? _refs$current$i : new reactNative.Animated.Value(initialValue);
  });
  return refs.current;
}

function useLayout() {
  const [layout, setLayout] = React__namespace.useState({
    height: 0,
    width: 0,
    measured: false
  });
  const onLayout = React__namespace.useCallback(e => {
    const {
      height,
      width
    } = e.nativeEvent.layout;

    if (height === layout.height && width === layout.width) {
      return;
    }

    setLayout({
      height,
      width,
      measured: true
    });
  }, [layout.height, layout.width]);
  return [layout, onLayout];
}

function useIsKeyboardShown(_ref) {
  let {
    onShow,
    onHide
  } = _ref;
  React__namespace.useEffect(() => {
    let willShowSubscription;
    let willHideSubscription;
    let didShowSubscription;
    let didHideSubscription;

    if (reactNative.Platform.OS === 'ios') {
      willShowSubscription = reactNative.Keyboard.addListener('keyboardWillShow', onShow);
      willHideSubscription = reactNative.Keyboard.addListener('keyboardWillHide', onHide);
    } else {
      didShowSubscription = reactNative.Keyboard.addListener('keyboardDidShow', onShow);
      didHideSubscription = reactNative.Keyboard.addListener('keyboardDidHide', onHide);
    }

    return () => {
      if (reactNative.Platform.OS === 'ios') {
        var _willShowSubscription, _willHideSubscription;

        if ((_willShowSubscription = willShowSubscription) !== null && _willShowSubscription !== void 0 && _willShowSubscription.remove) {
          willShowSubscription.remove();
        } else {
          reactNative.Keyboard.removeListener('keyboardWillShow', onShow);
        }

        if ((_willHideSubscription = willHideSubscription) !== null && _willHideSubscription !== void 0 && _willHideSubscription.remove) {
          willHideSubscription.remove();
        } else {
          reactNative.Keyboard.removeListener('keyboardWillHide', onHide);
        }
      } else {
        var _didShowSubscription, _didHideSubscription;

        if ((_didShowSubscription = didShowSubscription) !== null && _didShowSubscription !== void 0 && _didShowSubscription.remove) {
          didShowSubscription.remove();
        } else {
          reactNative.Keyboard.removeListener('keyboardDidShow', onShow);
        }

        if ((_didHideSubscription = didHideSubscription) !== null && _didHideSubscription !== void 0 && _didHideSubscription.remove) {
          didHideSubscription.remove();
        } else {
          reactNative.Keyboard.removeListener('keyboardDidHide', onHide);
        }
      }
    };
  }, [onHide, onShow]);
}

function _extends$D() { _extends$D = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$D.apply(this, arguments); }

class BottomNavigationRouteScreen extends React__default["default"].Component {
  render() {
    const {
      style,
      index,
      children,
      visibility,
      ...rest
    } = this.props;
    const display = visibility === 0 ? 'none' : 'flex';
    return /*#__PURE__*/React__default["default"].createElement(reactNative.View, _extends$D({
      testID: `RouteScreen: ${index}`,
      style: [style, {
        display
      }]
    }, rest), children);
  }

}

var BottomNavigationRouteScreen$1 = reactNative.Animated.createAnimatedComponent(BottomNavigationRouteScreen);

function _extends$C() { _extends$C = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$C.apply(this, arguments); }
const MIN_RIPPLE_SCALE = 0.001; // Minimum scale is not 0 due to bug with animation

const MIN_TAB_WIDTH = 96;
const MAX_TAB_WIDTH = 168;
const BAR_HEIGHT = 56;
const BOTTOM_INSET$1 = getBottomSpace();
const FAR_FAR_AWAY = reactNative.Platform.OS === 'web' ? 0 : 9999;

const Touchable = _ref => {
  let {
    route: _0,
    style,
    children,
    borderless,
    centered,
    rippleColor,
    ...rest
  } = _ref;
  return TouchableRipple$1.supported ? /*#__PURE__*/React__namespace.createElement(TouchableRipple$1, _extends$C({}, rest, {
    disabled: rest.disabled || undefined,
    borderless: borderless,
    centered: centered,
    rippleColor: rippleColor,
    style: style
  }), children) : /*#__PURE__*/React__namespace.createElement(reactNative.TouchableWithoutFeedback, rest, /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: style
  }, children));
};

const SceneComponent = /*#__PURE__*/React__namespace.memo(_ref2 => {
  let {
    component,
    ...rest
  } = _ref2;
  return /*#__PURE__*/React__namespace.createElement(component, rest);
});
/**
 * Bottom navigation provides quick navigation between top-level views of an app with a bottom navigation bar.
 * It is primarily designed for use on mobile.
 *
 * For integration with React Navigation, you can use [react-navigation-material-bottom-tabs](https://github.com/react-navigation/react-navigation/tree/main/packages/material-bottom-tabs) and consult [createMaterialBottomTabNavigator](https://reactnavigation.org/docs/material-bottom-tab-navigator/) documentation.
 *
 * By default Bottom navigation uses primary color as a background, in dark theme with `adaptive` mode it will use surface colour instead.
 * See [Dark Theme](https://callstack.github.io/react-native-paper/theming.html#dark-theme) for more information.
 *
 * <div class="screenshots">
 *   <img class="medium" src="screenshots/bottom-navigation.gif" />
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { BottomNavigation, Text } from 'react-native-paper';
 *
 * const MusicRoute = () => <Text>Music</Text>;
 *
 * const AlbumsRoute = () => <Text>Albums</Text>;
 *
 * const RecentsRoute = () => <Text>Recents</Text>;
 *
 * const MyComponent = () => {
 *   const [index, setIndex] = React.useState(0);
 *   const [routes] = React.useState([
 *     { key: 'music', title: 'Music', icon: 'queue-music' },
 *     { key: 'albums', title: 'Albums', icon: 'album' },
 *     { key: 'recents', title: 'Recents', icon: 'history' },
 *   ]);
 *
 *   const renderScene = BottomNavigation.SceneMap({
 *     music: MusicRoute,
 *     albums: AlbumsRoute,
 *     recents: RecentsRoute,
 *   });
 *
 *   return (
 *     <BottomNavigation
 *       navigationState={{ index, routes }}
 *       onIndexChange={setIndex}
 *       renderScene={renderScene}
 *     />
 *   );
 * };
 *
 * export default MyComponent;
 * ```
 */

const BottomNavigation = _ref3 => {
  var _safeAreaInsets$left, _safeAreaInsets$right, _safeAreaInsets$botto;

  let {
    navigationState,
    renderScene,
    renderIcon,
    renderLabel,
    renderTouchable = props => /*#__PURE__*/React__namespace.createElement(Touchable, props),
    getLabelText = _ref4 => {
      let {
        route
      } = _ref4;
      return route.title;
    },
    getBadge = _ref5 => {
      let {
        route
      } = _ref5;
      return route.badge;
    },
    getColor = _ref6 => {
      let {
        route
      } = _ref6;
      return route.color;
    },
    getAccessibilityLabel = _ref7 => {
      let {
        route
      } = _ref7;
      return route.accessibilityLabel;
    },
    getTestID = _ref8 => {
      let {
        route
      } = _ref8;
      return route.testID;
    },
    activeColor,
    inactiveColor,
    keyboardHidesNavigationBar = true,
    barStyle,
    labeled = true,
    style,
    theme,
    sceneAnimationEnabled = false,
    onTabPress,
    onIndexChange,
    shifting = navigationState.routes.length > 3,
    safeAreaInsets,
    labelMaxFontSizeMultiplier = 1
  } = _ref3;
  const {
    scale
  } = theme.animation;
  const focusedKey = navigationState.routes[navigationState.index].key;
  /**
   * Visibility of the navigation bar, visible state is 1 and invisible is 0.
   */

  const visibleAnim = useAnimatedValue(1);
  /**
   * Active state of individual tab items, active state is 1 and inactive state is 0.
   */

  const tabsAnims = useAnimatedValueArray(navigationState.routes.map( // focused === 1, unfocused === 0
  (_, i) => i === navigationState.index ? 1 : 0));
  /**
   * The top offset for each tab item to position it offscreen.
   * Placing items offscreen helps to save memory usage for inactive screens with removeClippedSubviews.
   * We use animated values for this to prevent unnecessary re-renders.
   */

  const offsetsAnims = useAnimatedValueArray(navigationState.routes.map( // offscreen === 1, normal === 0
  (_, i) => i === navigationState.index ? 0 : 1));
  /**
   * Index of the currently active tab. Used for setting the background color.
   * We don't use the color as an animated value directly, because `setValue` seems to be buggy with colors.
   */

  const indexAnim = useAnimatedValue(navigationState.index);
  /**
   * Animation for the background color ripple, used to determine it's scale and opacity.
   */

  const rippleAnim = useAnimatedValue(MIN_RIPPLE_SCALE);
  /**
   * Layout of the navigation bar. The width is used to determine the size and position of the ripple.
   */

  const [layout, onLayout] = useLayout();
  /**
   * List of loaded tabs, tabs will be loaded when navigated to.
   */

  const [loaded, setLoaded] = React__namespace.useState([focusedKey]);

  if (!loaded.includes(focusedKey)) {
    // Set the current tab to be loaded if it was not loaded before
    setLoaded(loaded => [...loaded, focusedKey]);
  }
  /**
   * Track whether the keyboard is visible to show and hide the navigation bar.
   */


  const [keyboardVisible, setKeyboardVisible] = React__namespace.useState(false);
  const handleKeyboardShow = React__namespace.useCallback(() => {
    setKeyboardVisible(true);
    reactNative.Animated.timing(visibleAnim, {
      toValue: 0,
      duration: 150 * scale,
      useNativeDriver: true
    }).start();
  }, [scale, visibleAnim]);
  const handleKeyboardHide = React__namespace.useCallback(() => {
    reactNative.Animated.timing(visibleAnim, {
      toValue: 1,
      duration: 100 * scale,
      useNativeDriver: true
    }).start(() => {
      setKeyboardVisible(false);
    });
  }, [scale, visibleAnim]);
  const animateToIndex = React__namespace.useCallback(index => {
    // Reset the ripple to avoid glitch if it's currently animating
    rippleAnim.setValue(MIN_RIPPLE_SCALE);
    reactNative.Animated.parallel([reactNative.Animated.timing(rippleAnim, {
      toValue: 1,
      duration: shifting ? 400 * scale : 0,
      useNativeDriver: true
    }), ...navigationState.routes.map((_, i) => reactNative.Animated.timing(tabsAnims[i], {
      toValue: i === index ? 1 : 0,
      duration: shifting ? 150 * scale : 0,
      useNativeDriver: true
    }))]).start(_ref9 => {
      let {
        finished
      } = _ref9;
      // Workaround a bug in native animations where this is reset after first animation
      tabsAnims.map((tab, i) => tab.setValue(i === index ? 1 : 0)); // Update the index to change bar's background color and then hide the ripple

      indexAnim.setValue(index);
      rippleAnim.setValue(MIN_RIPPLE_SCALE);

      if (finished) {
        // Position all inactive screens offscreen to save memory usage
        // Only do it when animation has finished to avoid glitches mid-transition if switching fast
        offsetsAnims.forEach((offset, i) => {
          if (i === index) {
            offset.setValue(0);
          } else {
            offset.setValue(1);
          }
        });
      }
    });
  }, [indexAnim, shifting, navigationState.routes, offsetsAnims, rippleAnim, scale, tabsAnims]);
  React__namespace.useEffect(() => {
    // Workaround for native animated bug in react-native@^0.57
    // Context: https://github.com/callstack/react-native-paper/pull/637
    animateToIndex(navigationState.index); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  useIsKeyboardShown({
    onShow: handleKeyboardShow,
    onHide: handleKeyboardHide
  });
  const prevNavigationState = React__namespace.useRef();
  React__namespace.useEffect(() => {
    // Reset offsets of previous and current tabs before animation
    offsetsAnims.forEach((offset, i) => {
      var _prevNavigationState$;

      if (i === navigationState.index || i === ((_prevNavigationState$ = prevNavigationState.current) === null || _prevNavigationState$ === void 0 ? void 0 : _prevNavigationState$.index)) {
        offset.setValue(0);
      }
    });
    animateToIndex(navigationState.index);
  }, [navigationState.index, animateToIndex, offsetsAnims]);

  const handleTabPress = index => {
    const event = {
      route: navigationState.routes[index],
      defaultPrevented: false,
      preventDefault: () => {
        event.defaultPrevented = true;
      }
    };
    onTabPress === null || onTabPress === void 0 ? void 0 : onTabPress(event);

    if (event.defaultPrevented) {
      return;
    }

    if (index !== navigationState.index) {
      onIndexChange(index);
    }
  };

  const jumpTo = React__namespace.useCallback(key => {
    const index = navigationState.routes.findIndex(route => route.key === key);
    onIndexChange(index);
  }, [navigationState.routes, onIndexChange]);
  const {
    routes
  } = navigationState;
  const {
    colors,
    dark: isDarkTheme,
    mode
  } = theme;
  const {
    backgroundColor: customBackground,
    elevation = 4
  } = reactNative.StyleSheet.flatten(barStyle) || {};
  const approxBackgroundColor = customBackground ? customBackground : isDarkTheme && mode === 'adaptive' ? overlay(elevation, colors.surface) : colors.primary;
  const backgroundColor = shifting ? indexAnim.interpolate({
    inputRange: routes.map((_, i) => i),
    // FIXME: does outputRange support ColorValue or just strings?
    // @ts-expect-error
    outputRange: routes.map(route => getColor({
      route
    }) || approxBackgroundColor)
  }) : approxBackgroundColor;
  const isDark = typeof approxBackgroundColor === 'string' ? !color$1(approxBackgroundColor).isLight() : true;
  const textColor = isDark ? white : black;
  const activeTintColor = typeof activeColor !== 'undefined' ? activeColor : textColor;
  const inactiveTintColor = typeof inactiveColor !== 'undefined' ? inactiveColor : color$1(textColor).alpha(0.5).rgb().string();
  const touchColor = color$1(activeColor || activeTintColor).alpha(0.12).rgb().string();
  const maxTabWidth = routes.length > 3 ? MIN_TAB_WIDTH : MAX_TAB_WIDTH;
  const maxTabBarWidth = maxTabWidth * routes.length;
  const tabBarWidth = Math.min(layout.width, maxTabBarWidth);
  const tabWidth = tabBarWidth / routes.length;
  const rippleSize = layout.width / 4;
  const insets = {
    left: (_safeAreaInsets$left = safeAreaInsets === null || safeAreaInsets === void 0 ? void 0 : safeAreaInsets.left) !== null && _safeAreaInsets$left !== void 0 ? _safeAreaInsets$left : 0,
    right: (_safeAreaInsets$right = safeAreaInsets === null || safeAreaInsets === void 0 ? void 0 : safeAreaInsets.right) !== null && _safeAreaInsets$right !== void 0 ? _safeAreaInsets$right : 0,
    bottom: (_safeAreaInsets$botto = safeAreaInsets === null || safeAreaInsets === void 0 ? void 0 : safeAreaInsets.bottom) !== null && _safeAreaInsets$botto !== void 0 ? _safeAreaInsets$botto : BOTTOM_INSET$1
  };
  return /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: [styles$O.container, style]
  }, /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: [styles$O.content, {
      backgroundColor: colors.background
    }]
  }, routes.map((route, index) => {
    if (!loaded.includes(route.key)) {
      // Don't render a screen if we've never navigated to it
      return null;
    }

    const focused = navigationState.index === index;
    const opacity = sceneAnimationEnabled ? tabsAnims[index] : focused ? 1 : 0;
    const top = sceneAnimationEnabled ? offsetsAnims[index].interpolate({
      inputRange: [0, 1],
      outputRange: [0, FAR_FAR_AWAY]
    }) : focused ? 0 : FAR_FAR_AWAY;
    return /*#__PURE__*/React__namespace.createElement(BottomNavigationRouteScreen$1, {
      key: route.key,
      pointerEvents: focused ? 'auto' : 'none',
      accessibilityElementsHidden: !focused,
      importantForAccessibility: focused ? 'auto' : 'no-hide-descendants',
      index: index,
      visibility: opacity,
      style: [reactNative.StyleSheet.absoluteFill, {
        opacity
      }],
      collapsable: false,
      removeClippedSubviews: // On iOS, set removeClippedSubviews to true only when not focused
      // This is an workaround for a bug where the clipped view never re-appears
      reactNative.Platform.OS === 'ios' ? navigationState.index !== index : true
    }, /*#__PURE__*/React__namespace.createElement(reactNative.Animated.View, {
      style: [styles$O.content, {
        top
      }]
    }, renderScene({
      route,
      jumpTo
    })));
  })), /*#__PURE__*/React__namespace.createElement(Surface$1, {
    style: [styles$O.bar, keyboardHidesNavigationBar ? {
      // When the keyboard is shown, slide down the navigation bar
      transform: [{
        translateY: visibleAnim.interpolate({
          inputRange: [0, 1],
          outputRange: [layout.height, 0]
        })
      }],
      // Absolutely position the navigation bar so that the content is below it
      // This is needed to avoid gap at bottom when the navigation bar is hidden
      position: keyboardVisible ? 'absolute' : null
    } : null, barStyle],
    pointerEvents: layout.measured ? keyboardHidesNavigationBar && keyboardVisible ? 'none' : 'auto' : 'none',
    onLayout: onLayout
  }, /*#__PURE__*/React__namespace.createElement(reactNative.Animated.View, {
    style: [styles$O.barContent, {
      backgroundColor
    }]
  }, /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: [styles$O.items, {
      marginBottom: insets.bottom,
      marginHorizontal: Math.max(insets.left, insets.right),
      maxWidth: maxTabBarWidth
    }],
    accessibilityRole: 'tablist'
  }, shifting ? /*#__PURE__*/React__namespace.createElement(reactNative.Animated.View, {
    pointerEvents: "none",
    style: [styles$O.ripple, {
      // Since we have a single ripple, we have to reposition it so that it appears to expand from active tab.
      // We need to move it from the top to center of the navigation bar and from the left to the active tab.
      top: (BAR_HEIGHT - rippleSize) / 2,
      left: tabWidth * (navigationState.index + 0.5) - rippleSize / 2,
      height: rippleSize,
      width: rippleSize,
      borderRadius: rippleSize / 2,
      backgroundColor: getColor({
        route: routes[navigationState.index]
      }),
      transform: [{
        // Scale to twice the size  to ensure it covers the whole navigation bar
        scale: rippleAnim.interpolate({
          inputRange: [0, 1],
          outputRange: [0, 8]
        })
      }],
      opacity: rippleAnim.interpolate({
        inputRange: [0, MIN_RIPPLE_SCALE, 0.3, 1],
        outputRange: [0, 0, 1, 1]
      })
    }]
  }) : null, routes.map((route, index) => {
    const focused = navigationState.index === index;
    const active = tabsAnims[index]; // Scale the label up

    const scale = labeled && shifting ? active.interpolate({
      inputRange: [0, 1],
      outputRange: [0.5, 1]
    }) : 1; // Move down the icon to account for no-label in shifting and smaller label in non-shifting.

    const translateY = labeled ? shifting ? active.interpolate({
      inputRange: [0, 1],
      outputRange: [7, 0]
    }) : 0 : 7; // We render the active icon and label on top of inactive ones and cross-fade them on change.
    // This trick gives the illusion that we are animating between active and inactive colors.
    // This is to ensure that we can use native driver, as colors cannot be animated with native driver.

    const activeOpacity = active;
    const inactiveOpacity = active.interpolate({
      inputRange: [0, 1],
      outputRange: [1, 0]
    });
    const badge = getBadge({
      route
    });
    return renderTouchable({
      key: route.key,
      route,
      borderless: true,
      centered: true,
      rippleColor: touchColor,
      onPress: () => handleTabPress(index),
      testID: getTestID({
        route
      }),
      accessibilityLabel: getAccessibilityLabel({
        route
      }),
      // @ts-expect-error We keep old a11y props for backwards compat with old RN versions
      accessibilityTraits: focused ? ['button', 'selected'] : 'button',
      accessibilityComponentType: 'button',
      accessibilityRole: reactNative.Platform.OS === 'ios' ? 'button' : 'tab',
      accessibilityState: {
        selected: focused
      },
      style: styles$O.item,
      children: /*#__PURE__*/React__namespace.createElement(reactNative.View, {
        pointerEvents: "none"
      }, /*#__PURE__*/React__namespace.createElement(reactNative.Animated.View, {
        style: [styles$O.iconContainer, {
          transform: [{
            translateY
          }]
        }]
      }, /*#__PURE__*/React__namespace.createElement(reactNative.Animated.View, {
        style: [styles$O.iconWrapper, {
          opacity: activeOpacity
        }]
      }, renderIcon ? renderIcon({
        route,
        focused: true,
        color: activeTintColor
      }) : /*#__PURE__*/React__namespace.createElement(Icon$1, {
        source: route.icon,
        color: activeTintColor,
        size: 24
      })), /*#__PURE__*/React__namespace.createElement(reactNative.Animated.View, {
        style: [styles$O.iconWrapper, {
          opacity: inactiveOpacity
        }]
      }, renderIcon ? renderIcon({
        route,
        focused: false,
        color: inactiveTintColor
      }) : /*#__PURE__*/React__namespace.createElement(Icon$1, {
        source: route.icon,
        color: inactiveTintColor,
        size: 24
      })), /*#__PURE__*/React__namespace.createElement(reactNative.View, {
        style: [styles$O.badgeContainer, {
          right: (badge != null && typeof badge !== 'boolean' ? String(badge).length * -2 : 0) - 2
        }]
      }, typeof badge === 'boolean' ? /*#__PURE__*/React__namespace.createElement(Badge$1, {
        visible: badge,
        size: 8
      }) : /*#__PURE__*/React__namespace.createElement(Badge$1, {
        visible: badge != null,
        size: 16
      }, badge))), labeled ? /*#__PURE__*/React__namespace.createElement(reactNative.Animated.View, {
        style: [styles$O.labelContainer, {
          transform: [{
            scale
          }]
        }]
      }, /*#__PURE__*/React__namespace.createElement(reactNative.Animated.View, {
        style: [styles$O.labelWrapper, {
          opacity: activeOpacity
        }]
      }, renderLabel ? renderLabel({
        route,
        focused: true,
        color: activeTintColor
      }) : /*#__PURE__*/React__namespace.createElement(Text$1, {
        maxFontSizeMultiplier: labelMaxFontSizeMultiplier,
        style: [styles$O.label, {
          color: activeTintColor
        }]
      }, getLabelText({
        route
      }))), shifting ? null : /*#__PURE__*/React__namespace.createElement(reactNative.Animated.View, {
        style: [styles$O.labelWrapper, {
          opacity: inactiveOpacity
        }]
      }, renderLabel ? renderLabel({
        route,
        focused: false,
        color: inactiveTintColor
      }) : /*#__PURE__*/React__namespace.createElement(Text$1, {
        maxFontSizeMultiplier: labelMaxFontSizeMultiplier,
        selectable: false,
        style: [styles$O.label, {
          color: inactiveTintColor
        }]
      }, getLabelText({
        route
      })))) : /*#__PURE__*/React__namespace.createElement(reactNative.View, {
        style: styles$O.labelContainer
      }))
    });
  })))));
};
/**
 * Function which takes a map of route keys to components.
 * Pure components are used to minimize re-rendering of the pages.
 * This drastically improves the animation performance.
 */


BottomNavigation.SceneMap = scenes => {
  return _ref10 => {
    let {
      route,
      jumpTo
    } = _ref10;
    return /*#__PURE__*/React__namespace.createElement(SceneComponent, {
      key: route.key,
      component: scenes[route.key ? route.key : ''],
      route: route,
      jumpTo: jumpTo
    });
  };
};

withTheme(BottomNavigation);
const styles$O = reactNative.StyleSheet.create({
  container: {
    flex: 1,
    overflow: 'hidden'
  },
  content: {
    flex: 1
  },
  bar: {
    left: 0,
    right: 0,
    bottom: 0,
    elevation: 4
  },
  barContent: {
    alignItems: 'center',
    overflow: 'hidden'
  },
  items: {
    flexDirection: 'row',
    ...(reactNative.Platform.OS === 'web' ? {
      width: '100%'
    } : null)
  },
  item: {
    flex: 1,
    // Top padding is 6 and bottom padding is 10
    // The extra 4dp bottom padding is offset by label's height
    paddingVertical: 6
  },
  ripple: {
    position: 'absolute'
  },
  iconContainer: {
    height: 24,
    width: 24,
    marginTop: 2,
    marginHorizontal: 12,
    alignSelf: 'center'
  },
  iconWrapper: { ...reactNative.StyleSheet.absoluteFillObject,
    alignItems: 'center'
  },
  labelContainer: {
    height: 16,
    paddingBottom: 2
  },
  labelWrapper: { ...reactNative.StyleSheet.absoluteFillObject
  },
  // eslint-disable-next-line react-native/no-color-literals
  label: {
    fontSize: 12,
    height: BAR_HEIGHT,
    textAlign: 'center',
    backgroundColor: 'transparent',
    ...(reactNative.Platform.OS === 'web' ? {
      whiteSpace: 'nowrap',
      alignSelf: 'center'
    } : null)
  },
  badgeContainer: {
    position: 'absolute',
    left: 0,
    top: -2
  }
});

function _extends$B() { _extends$B = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$B.apply(this, arguments); }

/**
 * A component to show content inside a Card.
 *
 * <div class="screenshots">
 *   <figure>
 *     <img class="medium" src="screenshots/card-content-example.png" />
 *   </figure>
 * </div>
 *
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { Card, Title, Paragraph } from 'react-native-paper';
 *
 * const MyComponent = () => (
 *   <Card>
 *     <Card.Content>
 *       <Title>Card title</Title>
 *       <Paragraph>Card content</Paragraph>
 *     </Card.Content>
 *   </Card>
 * );
 *
 * export default MyComponent;
 * ```
 */
const CardContent = _ref => {
  let {
    index,
    total,
    siblings,
    style,
    ...rest
  } = _ref;
  const cover = 'withTheme(CardCover)';
  const title = 'withTheme(CardTitle)';
  let contentStyle, prev, next;

  if (typeof index === 'number' && siblings) {
    prev = siblings[index - 1];
    next = siblings[index + 1];
  }

  if (prev === cover && next === cover || prev === title && next === title || total === 1) {
    contentStyle = styles$N.only;
  } else if (index === 0) {
    if (next === cover || next === title) {
      contentStyle = styles$N.only;
    } else {
      contentStyle = styles$N.first;
    }
  } else if (typeof total === 'number' && index === total - 1) {
    if (prev === cover || prev === title) {
      contentStyle = styles$N.only;
    } else {
      contentStyle = styles$N.last;
    }
  } else if (prev === cover || prev === title) {
    contentStyle = styles$N.first;
  } else if (next === cover || next === title) {
    contentStyle = styles$N.last;
  }

  return /*#__PURE__*/React__namespace.createElement(reactNative.View, _extends$B({}, rest, {
    style: [styles$N.container, contentStyle, style]
  }));
};

CardContent.displayName = 'Card.Content';
const styles$N = reactNative.StyleSheet.create({
  container: {
    paddingHorizontal: 16
  },
  first: {
    paddingTop: 16
  },
  last: {
    paddingBottom: 16
  },
  only: {
    paddingVertical: 16
  }
});

function _extends$A() { _extends$A = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$A.apply(this, arguments); }

/**
 * A component to show a list of actions inside a Card.
 *
 * <div class="screenshots">
 *   <figure>
 *     <img class="medium" src="screenshots/card-actions.png" />
 *   </figure>
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { Card, Button } from 'react-native-paper';
 *
 * const MyComponent = () => (
 *   <Card>
 *     <Card.Actions>
 *       <Button>Cancel</Button>
 *       <Button>Ok</Button>
 *     </Card.Actions>
 *   </Card>
 * );
 *
 * export default MyComponent;
 * ```
 */
const CardActions = props => /*#__PURE__*/React__namespace.createElement(reactNative.View, _extends$A({}, props, {
  style: [styles$M.container, props.style]
}), React__namespace.Children.map(props.children, child => /*#__PURE__*/React__namespace.isValidElement(child) ? /*#__PURE__*/React__namespace.cloneElement(child, {
  compact: child.props.compact !== false
}) : child));

CardActions.displayName = 'Card.Actions';
const styles$M = reactNative.StyleSheet.create({
  container: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'flex-start',
    padding: 8
  }
});

function _extends$z() { _extends$z = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$z.apply(this, arguments); }

/**
 * A component to show a cover image inside a Card.
 *
 * <div class="screenshots">
 *   <figure>
 *     <img class="medium" src="screenshots/card-cover.png" />
 *   </figure>
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { Card } from 'react-native-paper';
 *
 * const MyComponent = () => (
 *   <Card>
 *     <Card.Cover source={{ uri: 'https://picsum.photos/700' }} />
 *   </Card>
 * );
 *
 * export default MyComponent;
 * ```
 *
 * @extends Image props https://reactnative.dev/docs/image#props
 */
const CardCover = _ref => {
  let {
    index,
    total,
    style,
    theme,
    ...rest
  } = _ref;
  const {
    roundness
  } = theme;
  let coverStyle;

  if (index === 0) {
    if (total === 1) {
      coverStyle = {
        borderRadius: roundness
      };
    } else {
      coverStyle = {
        borderTopLeftRadius: roundness,
        borderTopRightRadius: roundness
      };
    }
  } else if (typeof total === 'number' && index === total - 1) {
    coverStyle = {
      borderBottomLeftRadius: roundness
    };
  }

  return /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: [styles$L.container, coverStyle, style]
  }, /*#__PURE__*/React__namespace.createElement(reactNative.Image, _extends$z({}, rest, {
    style: [styles$L.image, coverStyle]
  })));
};

CardCover.displayName = 'Card.Cover';
const styles$L = reactNative.StyleSheet.create({
  container: {
    height: 195,
    backgroundColor: grey200,
    overflow: 'hidden'
  },
  image: {
    flex: 1,
    height: undefined,
    width: undefined,
    padding: 16,
    justifyContent: 'flex-end'
  }
});
var CardCover$1 = withTheme(CardCover); // @component-docs ignore-next-line

function _extends$y() { _extends$y = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$y.apply(this, arguments); }

const StyledText = _ref => {
  let {
    theme,
    alpha,
    family,
    style,
    ...rest
  } = _ref;
  const textColor = color$1(theme.colors.text).alpha(alpha).rgb().string();
  const font = theme.fonts[family];
  const writingDirection = reactNative.I18nManager.isRTL ? 'rtl' : 'ltr';
  return /*#__PURE__*/React__namespace.createElement(Text$1, _extends$y({}, rest, {
    style: [styles$K.text, {
      color: textColor,
      ...font,
      writingDirection
    }, style]
  }));
};

const styles$K = reactNative.StyleSheet.create({
  text: {
    textAlign: 'left'
  }
});
var StyledText$1 = withTheme(StyledText);

function _extends$x() { _extends$x = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$x.apply(this, arguments); }

// @component-group Typography

/**
 * Typography component for showing a caption.
 *
 * <div class="screenshots">
 *   <img src="screenshots/caption.png" />
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { Caption } from 'react-native-paper';
 *
 * const MyComponent = () => (
 *   <Caption>Caption</Caption>
 * );
 *
 * export default MyComponent;
 * ```
 */
const Caption = props => /*#__PURE__*/React__namespace.createElement(StyledText$1, _extends$x({}, props, {
  alpha: 0.54,
  family: "regular",
  style: [styles$J.text, props.style]
}));
const styles$J = reactNative.StyleSheet.create({
  text: {
    fontSize: 12,
    lineHeight: 20,
    marginVertical: 2,
    letterSpacing: 0.4
  }
});

function _extends$w() { _extends$w = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$w.apply(this, arguments); }

// @component-group Typography

/**
 * Typography component for showing a title.
 *
 * <div class="screenshots">
 *   <img src="screenshots/title.png" />
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { Title } from 'react-native-paper';
 *
 * const MyComponent = () => (
 *   <Title>Title</Title>
 * );
 *
 * export default MyComponent;
 * ```
 */
const Title = props => /*#__PURE__*/React__namespace.createElement(StyledText$1, _extends$w({}, props, {
  alpha: 0.87,
  family: "medium",
  style: [styles$I.text, props.style]
}));
const styles$I = reactNative.StyleSheet.create({
  text: {
    fontSize: 20,
    lineHeight: 30,
    marginVertical: 2,
    letterSpacing: 0.15
  }
});

const LEFT_SIZE = 40;
/**
 * A component to show a title, subtitle and an avatar inside a Card.
 *
 * <div class="screenshots">
 *   <img class="medium" src="screenshots/card-title-1.png" />
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { Avatar, Card, IconButton } from 'react-native-paper';
 *
 * const MyComponent = () => (
 *   <Card.Title
 *     title="Card Title"
 *     subtitle="Card Subtitle"
 *     left={(props) => <Avatar.Icon {...props} icon="folder" />}
 *     right={(props) => <IconButton {...props} icon="more-vert" onPress={() => {}} />}
 *   />
 * );
 *
 * export default MyComponent;
 * ```
 */

const CardTitle = _ref => {
  let {
    title,
    titleStyle,
    titleNumberOfLines = 1,
    subtitle,
    subtitleStyle,
    subtitleNumberOfLines = 1,
    left,
    leftStyle,
    right,
    rightStyle,
    style
  } = _ref;
  return /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: [styles$H.container, {
      minHeight: subtitle || left || right ? 72 : 50
    }, style]
  }, left ? /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: [styles$H.left, leftStyle]
  }, left({
    size: LEFT_SIZE
  })) : null, /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: [styles$H.titles]
  }, title ? /*#__PURE__*/React__namespace.createElement(Title, {
    style: [styles$H.title, {
      marginBottom: subtitle ? 0 : 2
    }, titleStyle],
    numberOfLines: titleNumberOfLines
  }, title) : null, subtitle ? /*#__PURE__*/React__namespace.createElement(Caption, {
    style: [styles$H.subtitle, subtitleStyle],
    numberOfLines: subtitleNumberOfLines
  }, subtitle) : null), /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: rightStyle
  }, right ? right({
    size: 24
  }) : null));
};

CardTitle.displayName = 'Card.Title';
const styles$H = reactNative.StyleSheet.create({
  container: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingLeft: 16
  },
  left: {
    justifyContent: 'center',
    marginRight: 16,
    height: LEFT_SIZE,
    width: LEFT_SIZE
  },
  titles: {
    flex: 1,
    flexDirection: 'column',
    justifyContent: 'center'
  },
  title: {
    minHeight: 30,
    paddingRight: 16
  },
  subtitle: {
    minHeight: 20,
    marginVertical: 0,
    paddingRight: 16
  }
});
var CardTitle$1 = withTheme(CardTitle); // @component-docs ignore-next-line

function _extends$v() { _extends$v = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$v.apply(this, arguments); }

/**
 * A card is a sheet of material that serves as an entry point to more detailed information.
 *
 * <div class="screenshots">
 *   <img class="medium" src="screenshots/card-1.png" />
 *   <img class="medium" src="screenshots/card-2.png" />
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { Avatar, Button, Card, Title, Paragraph } from 'react-native-paper';
 *
 * const LeftContent = props => <Avatar.Icon {...props} icon="folder" />
 *
 * const MyComponent = () => (
 *   <Card>
 *     <Card.Title title="Card Title" subtitle="Card Subtitle" left={LeftContent} />
 *     <Card.Content>
 *       <Title>Card title</Title>
 *       <Paragraph>Card content</Paragraph>
 *     </Card.Content>
 *     <Card.Cover source={{ uri: 'https://picsum.photos/700' }} />
 *     <Card.Actions>
 *       <Button>Cancel</Button>
 *       <Button>Ok</Button>
 *     </Card.Actions>
 *   </Card>
 * );
 *
 * export default MyComponent;
 * ```
 */
const Card = _ref => {
  let {
    elevation: cardElevation = 1,
    onLongPress,
    onPress,
    mode: cardMode = 'elevated',
    children,
    style,
    theme,
    testID,
    accessible,
    ...rest
  } = _ref;
  // Default animated value
  const {
    current: elevation
  } = React__namespace.useRef(new reactNative.Animated.Value(cardElevation)); // Dark adaptive animated value, used in case of toggling the theme,
  // it prevents animating the background with native drivers inside Surface

  const {
    current: elevationDarkAdaptive
  } = React__namespace.useRef(new reactNative.Animated.Value(cardElevation));
  const {
    animation,
    dark,
    mode,
    roundness
  } = theme;
  const prevDarkRef = React__namespace.useRef(dark);
  React__namespace.useEffect(() => {
    prevDarkRef.current = dark;
  });
  const prevDark = prevDarkRef.current;
  const isAdaptiveMode = mode === 'adaptive';
  const animationDuration = 150 * animation.scale;
  React__namespace.useEffect(() => {
    /**
     * Resets animations values if updating to dark adaptive mode,
     * otherwise, any card that is in the middle of animation while
     * toggling the theme will stay at that animated value until
     * the next press-in
     */
    if (dark && isAdaptiveMode && !prevDark) {
      elevation.setValue(cardElevation);
      elevationDarkAdaptive.setValue(cardElevation);
    }
  }, [prevDark, dark, isAdaptiveMode, cardElevation, elevation, elevationDarkAdaptive]);

  const runElevationAnimation = pressType => {
    const isPressTypeIn = pressType === 'in';

    if (dark && isAdaptiveMode) {
      reactNative.Animated.timing(elevationDarkAdaptive, {
        toValue: isPressTypeIn ? 8 : cardElevation,
        duration: animationDuration,
        useNativeDriver: false
      }).start();
    } else {
      reactNative.Animated.timing(elevation, {
        toValue: isPressTypeIn ? 8 : cardElevation,
        duration: animationDuration,
        useNativeDriver: true
      }).start();
    }
  };

  const handlePressIn = () => {
    runElevationAnimation('in');
  };

  const handlePressOut = () => {
    runElevationAnimation('out');
  };

  const total = React__namespace.Children.count(children);
  const siblings = React__namespace.Children.map(children, child => /*#__PURE__*/React__namespace.isValidElement(child) && child.type ? child.type.displayName : null);
  const borderColor = color$1(dark ? white : black).alpha(0.12).rgb().string();
  const computedElevation = dark && isAdaptiveMode ? elevationDarkAdaptive : elevation;
  return /*#__PURE__*/React__namespace.createElement(Surface$1, _extends$v({
    style: [{
      borderRadius: roundness,
      elevation: computedElevation,
      borderColor
    }, cardMode === 'outlined' ? styles$G.outlined : {}, style],
    theme: theme
  }, rest), /*#__PURE__*/React__namespace.createElement(reactNative.TouchableWithoutFeedback, {
    delayPressIn: 0,
    disabled: !(onPress || onLongPress),
    onLongPress: onLongPress,
    onPress: onPress,
    onPressIn: onPress || onLongPress ? handlePressIn : undefined,
    onPressOut: onPress || onLongPress ? handlePressOut : undefined,
    testID: testID,
    accessible: accessible
  }, /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: styles$G.innerContainer
  }, React__namespace.Children.map(children, (child, index) => /*#__PURE__*/React__namespace.isValidElement(child) ? /*#__PURE__*/React__namespace.cloneElement(child, {
    index,
    total,
    siblings
  }) : child))));
}; // @component ./CardContent.tsx


Card.Content = CardContent; // @component ./CardActions.tsx

Card.Actions = CardActions; // @component ./CardCover.tsx

Card.Cover = CardCover$1; // @component ./CardTitle.tsx

Card.Title = CardTitle$1;
const styles$G = reactNative.StyleSheet.create({
  innerContainer: {
    flexGrow: 1,
    flexShrink: 1
  },
  outlined: {
    elevation: 0,
    borderWidth: 1
  }
});
var Card$1 = withTheme(Card);

function _extends$u() { _extends$u = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$u.apply(this, arguments); }

/**
 * Checkboxes allow the selection of multiple options from a set.
 * This component follows platform guidelines for iOS, but can be used
 * on any platform.
 *
 * <div class="screenshots">
 *   <figure>
 *     <img src="screenshots/checkbox-enabled.ios.png" />
 *     <figcaption>Enabled</figcaption>
 *   </figure>
 *   <figure>
 *     <img src="screenshots/checkbox-disabled.ios.png" />
 *     <figcaption>Disabled</figcaption>
 *   </figure>
 * </div>
 */
const CheckboxIOS = _ref => {
  let {
    status,
    disabled,
    onPress,
    theme,
    testID,
    ...rest
  } = _ref;
  const checked = status === 'checked';
  const indeterminate = status === 'indeterminate';
  const checkedColor = disabled ? theme.colors.disabled : rest.color || theme.colors.accent;
  let rippleColor;

  if (disabled) {
    rippleColor = color$1(theme.colors.text).alpha(0.16).rgb().string();
  } else {
    rippleColor = color$1(checkedColor).fade(0.32).rgb().string();
  }

  const icon = indeterminate ? 'minus' : 'check';
  return /*#__PURE__*/React__namespace.createElement(TouchableRipple$1, _extends$u({}, rest, {
    borderless: true,
    rippleColor: rippleColor,
    onPress: onPress,
    disabled: disabled // @ts-expect-error We keep old a11y props for backwards compat with old RN versions
    ,
    accessibilityTraits: disabled ? ['button', 'disabled'] : 'button',
    accessibilityComponentType: "button",
    accessibilityRole: "checkbox",
    accessibilityState: {
      disabled,
      checked
    },
    accessibilityLiveRegion: "polite",
    style: styles$F.container,
    testID: testID
  }), /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: {
      opacity: indeterminate || checked ? 1 : 0
    }
  }, /*#__PURE__*/React__namespace.createElement(defaultIcon, {
    allowFontScaling: false,
    name: icon,
    size: 24,
    color: checkedColor,
    direction: "ltr"
  })));
};

CheckboxIOS.displayName = 'Checkbox.IOS';
const styles$F = reactNative.StyleSheet.create({
  container: {
    borderRadius: 18,
    padding: 6
  }
});
var CheckboxIOS$1 = withTheme(CheckboxIOS); // @component-docs ignore-next-line

withTheme(CheckboxIOS); // @component-docs ignore-next-line

function _extends$t() { _extends$t = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$t.apply(this, arguments); }
// From https://material.io/design/motion/speed.html#duration
const ANIMATION_DURATION$1 = 100;
/**
 * Checkboxes allow the selection of multiple options from a set.
 * This component follows platform guidelines for Android, but can be used
 * on any platform.
 *
 * <div class="screenshots">
 *   <figure>
 *     <img src="screenshots/checkbox-enabled.android.png" />
 *     <figcaption>Enabled</figcaption>
 *   </figure>
 *   <figure>
 *     <img src="screenshots/checkbox-disabled.android.png" />
 *     <figcaption>Disabled</figcaption>
 *   </figure>
 * </div>
 */

const CheckboxAndroid = _ref => {
  let {
    status,
    theme,
    disabled,
    onPress,
    testID,
    ...rest
  } = _ref;
  const {
    current: scaleAnim
  } = React__namespace.useRef(new reactNative.Animated.Value(1));
  const isFirstRendering = React__namespace.useRef(true);
  const {
    animation: {
      scale
    }
  } = theme;
  React__namespace.useEffect(() => {
    // Do not run animation on very first rendering
    if (isFirstRendering.current) {
      isFirstRendering.current = false;
      return;
    }

    const checked = status === 'checked';
    reactNative.Animated.sequence([reactNative.Animated.timing(scaleAnim, {
      toValue: 0.85,
      duration: checked ? ANIMATION_DURATION$1 * scale : 0,
      useNativeDriver: false
    }), reactNative.Animated.timing(scaleAnim, {
      toValue: 1,
      duration: checked ? ANIMATION_DURATION$1 * scale : ANIMATION_DURATION$1 * scale * 1.75,
      useNativeDriver: false
    })]).start();
  }, [status, scaleAnim, scale]);
  const checked = status === 'checked';
  const indeterminate = status === 'indeterminate';
  const checkedColor = rest.color || theme.colors.accent;
  const uncheckedColor = rest.uncheckedColor || color$1(theme.colors.text).alpha(theme.dark ? 0.7 : 0.54).rgb().string();
  let rippleColor, checkboxColor;

  if (disabled) {
    rippleColor = color$1(theme.colors.text).alpha(0.16).rgb().string();
    checkboxColor = theme.colors.disabled;
  } else {
    rippleColor = color$1(checkedColor).fade(0.32).rgb().string();
    checkboxColor = checked ? checkedColor : uncheckedColor;
  }

  const borderWidth = scaleAnim.interpolate({
    inputRange: [0.8, 1],
    outputRange: [7, 0]
  });
  const icon = indeterminate ? 'minus-box' : checked ? 'checkbox-marked' : 'checkbox-blank-outline';
  return /*#__PURE__*/React__namespace.createElement(TouchableRipple$1, _extends$t({}, rest, {
    borderless: true,
    rippleColor: rippleColor,
    onPress: onPress,
    disabled: disabled // @ts-expect-error We keep old a11y props for backwards compat with old RN versions
    ,
    accessibilityTraits: disabled ? ['button', 'disabled'] : 'button',
    accessibilityComponentType: "button",
    accessibilityRole: "checkbox",
    accessibilityState: {
      disabled,
      checked
    },
    accessibilityLiveRegion: "polite",
    style: styles$E.container,
    testID: testID
  }), /*#__PURE__*/React__namespace.createElement(reactNative.Animated.View, {
    style: {
      transform: [{
        scale: scaleAnim
      }]
    }
  }, /*#__PURE__*/React__namespace.createElement(defaultIcon, {
    allowFontScaling: false,
    name: icon,
    size: 24,
    color: checkboxColor,
    direction: "ltr"
  }), /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: [reactNative.StyleSheet.absoluteFill, styles$E.fillContainer]
  }, /*#__PURE__*/React__namespace.createElement(reactNative.Animated.View, {
    style: [styles$E.fill, {
      borderColor: checkboxColor
    }, {
      borderWidth
    }]
  }))));
};

CheckboxAndroid.displayName = 'Checkbox.Android';
const styles$E = reactNative.StyleSheet.create({
  container: {
    borderRadius: 18,
    width: 36,
    height: 36,
    padding: 6
  },
  fillContainer: {
    alignItems: 'center',
    justifyContent: 'center'
  },
  fill: {
    height: 14,
    width: 14
  }
});
var CheckboxAndroid$1 = withTheme(CheckboxAndroid); // @component-docs ignore-next-line

withTheme(CheckboxAndroid); // @component-docs ignore-next-line

/**
 * Checkboxes allow the selection of multiple options from a set.
 *
 * <div class="screenshots">
 *   <figure>
 *     <img src="screenshots/checkbox-enabled.android.png" />
 *     <figcaption>Android (enabled)</figcaption>
 *   </figure>
 *   <figure>
 *     <img src="screenshots/checkbox-disabled.android.png" />
 *     <figcaption>Android (disabled)</figcaption>
 *   </figure>
 *   <figure>
 *     <img src="screenshots/checkbox-enabled.ios.png" />
 *     <figcaption>iOS (enabled)</figcaption>
 *   </figure>
 *   <figure>
 *     <img src="screenshots/checkbox-disabled.ios.png" />
 *     <figcaption>iOS (disabled)</figcaption>
 *   </figure>
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { Checkbox } from 'react-native-paper';
 *
 * const MyComponent = () => {
 *   const [checked, setChecked] = React.useState(false);
 *
 *   return (
 *     <Checkbox
 *       status={checked ? 'checked' : 'unchecked'}
 *       onPress={() => {
 *         setChecked(!checked);
 *       }}
 *     />
 *   );
 * };
 *
 * export default MyComponent;
 * ```
 */
const Checkbox = props => reactNative.Platform.OS === 'ios' ? /*#__PURE__*/React__namespace.createElement(CheckboxIOS$1, props) : /*#__PURE__*/React__namespace.createElement(CheckboxAndroid$1, props);

var CheckboxComponent = withTheme(Checkbox); // @component-docs ignore-next-line

withTheme(Checkbox); // @component-docs ignore-next-line

/**
 * Checkbox.Item allows you to press the whole row (item) instead of only the Checkbox.
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { View } from 'react-native';
 * import { Checkbox } from 'react-native-paper';
 *
 * const MyComponent = () => (
 *   <View>
 *     <Checkbox.Item label="Item" status="checked" />
 *   </View>
 * );
 *
 * export default MyComponent;
 *```
 */
const CheckboxItem = _ref => {
  let {
    style,
    status,
    label,
    onPress,
    labelStyle,
    theme,
    testID,
    mode,
    position = 'trailing',
    disabled,
    ...props
  } = _ref;
  const checkboxProps = { ...props,
    status,
    theme,
    disabled
  };
  const isLeading = position === 'leading';
  let checkbox;

  if (mode === 'android') {
    checkbox = /*#__PURE__*/React__namespace.createElement(CheckboxAndroid$1, checkboxProps);
  } else if (mode === 'ios') {
    checkbox = /*#__PURE__*/React__namespace.createElement(CheckboxIOS$1, checkboxProps);
  } else {
    checkbox = /*#__PURE__*/React__namespace.createElement(CheckboxComponent, checkboxProps);
  }

  return /*#__PURE__*/React__namespace.createElement(TouchableRipple$1, {
    accessibilityLabel: label,
    accessibilityRole: "checkbox",
    accessibilityState: {
      checked: status === 'checked',
      disabled
    },
    onPress: onPress,
    testID: testID,
    disabled: disabled
  }, /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: [styles$D.container, style],
    pointerEvents: "none",
    importantForAccessibility: "no-hide-descendants"
  }, isLeading && checkbox, /*#__PURE__*/React__namespace.createElement(Text$1, {
    style: [styles$D.label, {
      color: disabled ? theme.colors.disabled : theme.colors.text,
      textAlign: isLeading ? 'right' : 'left'
    }, labelStyle]
  }, label), !isLeading && checkbox));
};

CheckboxItem.displayName = 'Checkbox.Item';
var CheckboxItem$1 = withTheme(CheckboxItem); // @component-docs ignore-next-line

withTheme(CheckboxItem); // @component-docs ignore-next-line
const styles$D = reactNative.StyleSheet.create({
  container: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingVertical: 8,
    paddingHorizontal: 16
  },
  label: {
    fontSize: 16,
    flexShrink: 1,
    flexGrow: 1
  }
});

Object.assign( // @component ./Checkbox.tsx
CheckboxComponent, {
  // @component ./CheckboxItem.tsx
  Item: CheckboxItem$1,
  // @component ./CheckboxAndroid.tsx
  Android: CheckboxAndroid$1,
  // @component ./CheckboxIOS.tsx
  IOS: CheckboxIOS$1
});

function _extends$s() { _extends$s = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$s.apply(this, arguments); }

/**
 * Chips can be used to display entities in small blocks.
 *
 * <div class="screenshots">
 *   <figure>
 *     <img class="medium" src="screenshots/chip-1.png" />
 *     <figcaption>Flat chip</figcaption>
 *   </figure>
 *   <figure>
 *     <img class="medium" src="screenshots/chip-2.png" />
 *     <figcaption>Outlined chip</figcaption>
 *   </figure>
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { Chip } from 'react-native-paper';
 *
 * const MyComponent = () => (
 *   <Chip icon="information" onPress={() => console.log('Pressed')}>Example Chip</Chip>
 * );
 *
 * export default MyComponent;
 * ```
 */
const Chip = _ref => {
  let {
    mode = 'flat',
    children,
    icon,
    avatar,
    selected = false,
    disabled = false,
    accessibilityLabel,
    closeIconAccessibilityLabel = 'Close',
    onPress,
    onLongPress,
    onClose,
    closeIcon,
    textStyle,
    style,
    theme,
    testID,
    selectedColor,
    ellipsizeMode,
    ...rest
  } = _ref;
  const {
    current: elevation
  } = React__namespace.useRef(new reactNative.Animated.Value(0));

  const handlePressIn = () => {
    const {
      scale
    } = theme.animation;
    reactNative.Animated.timing(elevation, {
      toValue: 4,
      duration: 200 * scale,
      useNativeDriver: true
    }).start();
  };

  const handlePressOut = () => {
    const {
      scale
    } = theme.animation;
    reactNative.Animated.timing(elevation, {
      toValue: 0,
      duration: 150 * scale,
      useNativeDriver: true
    }).start();
  };

  const {
    dark,
    colors
  } = theme;
  const defaultBackgroundColor = mode === 'outlined' ? colors.surface : dark ? '#383838' : '#ebebeb';
  const {
    backgroundColor = defaultBackgroundColor,
    borderRadius = 16
  } = reactNative.StyleSheet.flatten(style) || {};
  const borderColor = mode === 'outlined' ? color$1(selectedColor !== undefined ? selectedColor : color$1(dark ? white : black)).alpha(0.29).rgb().string() : backgroundColor;
  const textColor = disabled ? colors.disabled : color$1(selectedColor !== undefined ? selectedColor : colors.text).alpha(0.87).rgb().string();
  const iconColor = disabled ? colors.disabled : color$1(selectedColor !== undefined ? selectedColor : colors.text).alpha(0.54).rgb().string();
  const backgroundColorString = typeof backgroundColor === 'string' ? backgroundColor : defaultBackgroundColor;
  const selectedBackgroundColor = (dark ? color$1(backgroundColorString).lighten(mode === 'outlined' ? 0.2 : 0.4) : color$1(backgroundColorString).darken(mode === 'outlined' ? 0.08 : 0.2)).rgb().string();
  const underlayColor = selectedColor ? color$1(selectedColor).fade(0.5).rgb().string() : selectedBackgroundColor;
  const accessibilityTraits = ['button'];
  const accessibilityState = {
    selected,
    disabled
  };

  if (selected) {
    accessibilityTraits.push('selected');
  }

  if (disabled) {
    accessibilityTraits.push('disabled');
  }

  return /*#__PURE__*/React__namespace.createElement(Surface$1, _extends$s({
    style: [styles$C.container, {
      elevation: reactNative.Platform.OS === 'android' ? elevation : 0,
      backgroundColor: selected ? selectedBackgroundColor : backgroundColor,
      borderColor,
      borderRadius
    }, style]
  }, rest), /*#__PURE__*/React__namespace.createElement(TouchableRipple$1, {
    borderless: true,
    delayPressIn: 0,
    style: [{
      borderRadius
    }, styles$C.touchable],
    onPress: onPress,
    onLongPress: onLongPress,
    onPressIn: handlePressIn,
    onPressOut: handlePressOut,
    underlayColor: underlayColor,
    disabled: disabled,
    accessibilityLabel: accessibilityLabel // @ts-expect-error We keep old a11y props for backwards compat with old RN versions
    ,
    accessibilityTraits: accessibilityTraits,
    accessibilityComponentType: "button",
    accessibilityRole: "button",
    accessibilityState: accessibilityState,
    testID: testID
  }, /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: [styles$C.content, {
      paddingRight: onClose ? 32 : 4
    }]
  }, avatar && !icon ? /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: [styles$C.avatarWrapper, disabled && {
      opacity: 0.26
    }]
  }, /*#__PURE__*/React__namespace.isValidElement(avatar) ? /*#__PURE__*/React__namespace.cloneElement(avatar, {
    style: [styles$C.avatar, avatar.props.style]
  }) : avatar) : null, icon || selected ? /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: [styles$C.icon, avatar ? [styles$C.avatar, styles$C.avatarSelected] : null]
  }, icon ? /*#__PURE__*/React__namespace.createElement(Icon$1, {
    source: icon,
    color: avatar ? white : iconColor,
    size: 18
  }) : /*#__PURE__*/React__namespace.createElement(defaultIcon, {
    name: "check",
    color: avatar ? white : iconColor,
    size: 18,
    direction: "ltr"
  })) : null, /*#__PURE__*/React__namespace.createElement(Text$1, {
    selectable: false,
    numberOfLines: 1,
    style: [styles$C.text, { ...theme.fonts.regular,
      color: textColor,
      marginRight: onClose ? 0 : 8,
      marginLeft: avatar || icon || selected ? 4 : 8
    }, textStyle],
    ellipsizeMode: ellipsizeMode
  }, children))), onClose ? /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: styles$C.closeButtonStyle
  }, /*#__PURE__*/React__namespace.createElement(reactNative.TouchableWithoutFeedback, {
    onPress: onClose // @ts-expect-error We keep old a11y props for backwards compat with old RN versions
    ,
    accessibilityTraits: "button",
    accessibilityComponentType: "button",
    accessibilityRole: "button",
    accessibilityLabel: closeIconAccessibilityLabel
  }, /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: [styles$C.icon, styles$C.closeIcon]
  }, closeIcon ? /*#__PURE__*/React__namespace.createElement(Icon$1, {
    source: closeIcon,
    color: iconColor,
    size: 16
  }) : /*#__PURE__*/React__namespace.createElement(defaultIcon, {
    name: "close-circle",
    size: 16,
    color: iconColor,
    direction: "ltr"
  })))) : null);
};

const styles$C = reactNative.StyleSheet.create({
  container: {
    borderWidth: reactNative.StyleSheet.hairlineWidth,
    borderStyle: 'solid',
    flexDirection: reactNative.Platform.select({
      default: 'column',
      web: 'row'
    })
  },
  content: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingLeft: 4,
    position: 'relative',
    flexGrow: 1
  },
  icon: {
    padding: 4,
    alignSelf: 'center'
  },
  closeIcon: {
    marginRight: 4
  },
  text: {
    minHeight: 24,
    lineHeight: 24,
    textAlignVertical: 'center',
    marginVertical: 4
  },
  avatar: {
    width: 24,
    height: 24,
    borderRadius: 12
  },
  avatarWrapper: {
    marginRight: 4
  },
  avatarSelected: {
    position: 'absolute',
    top: 4,
    left: 4,
    backgroundColor: 'rgba(0, 0, 0, .29)'
  },
  closeButtonStyle: {
    position: 'absolute',
    right: 0,
    height: '100%',
    justifyContent: 'center',
    alignItems: 'center'
  },
  touchable: {
    flexGrow: 1
  }
});
withTheme(Chip);

function _extends$r() { _extends$r = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$r.apply(this, arguments); }

/**
 * A component to show a single cell inside of a table.
 *
 * <div class="screenshots">
 *   <figure>
 *     <img class="medium" src="screenshots/data-table-row-cell.png" />
 *   </figure>
 * </div>
 *
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { DataTable } from 'react-native-paper';
 *
 * const MyComponent = () => (
 *      <DataTable.Row>
 *        <DataTable.Cell numeric>1</DataTable.Cell>
 *        <DataTable.Cell numeric>2</DataTable.Cell>
 *        <DataTable.Cell numeric>3</DataTable.Cell>
 *        <DataTable.Cell numeric>4</DataTable.Cell>
 *      </DataTable.Row>
 * );
 *
 * export default MyComponent;
 * ```
 *
 * If you want to support multiline text, please use View instead, as multiline text doesn't comply with
 * MD Guidelines (https://github.com/callstack/react-native-paper/issues/2381).
 */
const DataTableCell = _ref => {
  let {
    children,
    textStyle,
    style,
    numeric,
    ...rest
  } = _ref;
  return /*#__PURE__*/React__namespace.createElement(TouchableRipple$1, _extends$r({}, rest, {
    style: [styles$B.container, numeric && styles$B.right, style]
  }), /*#__PURE__*/React__namespace.createElement(Text$1, {
    style: textStyle,
    numberOfLines: 1
  }, children));
};

DataTableCell.displayName = 'DataTable.Cell';
const styles$B = reactNative.StyleSheet.create({
  container: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center'
  },
  right: {
    justifyContent: 'flex-end'
  }
});

function _extends$q() { _extends$q = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$q.apply(this, arguments); }

/**
 * A component to display title in table header.
 *
 * <div class="screenshots">
 *   <figure>
 *     <img class="medium" src="screenshots/data-table-header.png" />
 *   </figure>
 * </div>
 *
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { DataTable } from 'react-native-paper';
 *
 * const MyComponent = () => (
 *       <DataTable>
 *         <DataTable.Header>
 *           <DataTable.Title
 *             sortDirection='descending'
 *           >
 *             Dessert
 *           </DataTable.Title>
 *           <DataTable.Title numeric>Calories</DataTable.Title>
 *           <DataTable.Title numeric>Fat (g)</DataTable.Title>
 *         </DataTable.Header>
 *       </DataTable>
 * );
 *
 * export default MyComponent;
 * ```
 */
const DataTableHeader = _ref => {
  let {
    children,
    style,
    theme,
    ...rest
  } = _ref;
  const borderBottomColor = color$1(theme.dark ? white : black).alpha(0.12).rgb().string();
  return /*#__PURE__*/React__namespace.createElement(reactNative.View, _extends$q({}, rest, {
    style: [styles$A.header, {
      borderBottomColor
    }, style]
  }), children);
};

DataTableHeader.displayName = 'DataTable.Header';
const styles$A = reactNative.StyleSheet.create({
  header: {
    flexDirection: 'row',
    height: 48,
    paddingHorizontal: 16,
    borderBottomWidth: reactNative.StyleSheet.hairlineWidth * 2
  }
});
withTheme(DataTableHeader); // @component-docs ignore-next-line

function _extends$p() { _extends$p = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$p.apply(this, arguments); }

/**
 * A component to display title in table header.
 *
 * <div class="screenshots">
 *   <figure>
 *     <img class="medium" src="screenshots/data-table-header.png" />
 *   </figure>
 * </div>
 *
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { DataTable } from 'react-native-paper';
 *
 * const MyComponent = () => (
 *       <DataTable>
 *         <DataTable.Header>
 *           <DataTable.Title
 *             sortDirection='descending'
 *           >
 *             Dessert
 *           </DataTable.Title>
 *           <DataTable.Title numeric>Calories</DataTable.Title>
 *           <DataTable.Title numeric>Fat (g)</DataTable.Title>
 *         </DataTable.Header>
 *       </DataTable>
 * );
 *
 * export default MyComponent;
 * ```
 */
const DataTableTitle = _ref => {
  let {
    numeric,
    children,
    onPress,
    sortDirection,
    theme,
    textStyle,
    style,
    numberOfLines = 1,
    ...rest
  } = _ref;
  const {
    current: spinAnim
  } = React__namespace.useRef(new reactNative.Animated.Value(sortDirection === 'ascending' ? 0 : 1));
  React__namespace.useEffect(() => {
    reactNative.Animated.timing(spinAnim, {
      toValue: sortDirection === 'ascending' ? 0 : 1,
      duration: 150,
      useNativeDriver: true
    }).start();
  }, [sortDirection, spinAnim]);
  const textColor = color$1(theme.colors.text).alpha(0.6).rgb().string();
  const spin = spinAnim.interpolate({
    inputRange: [0, 1],
    outputRange: ['0deg', '180deg']
  });
  const icon = sortDirection ? /*#__PURE__*/React__namespace.createElement(reactNative.Animated.View, {
    style: [styles$z.icon, {
      transform: [{
        rotate: spin
      }]
    }]
  }, /*#__PURE__*/React__namespace.createElement(defaultIcon, {
    name: "arrow-up",
    size: 16,
    color: theme.colors.text,
    direction: reactNative.I18nManager.isRTL ? 'rtl' : 'ltr'
  })) : null;
  return /*#__PURE__*/React__namespace.createElement(reactNative.TouchableWithoutFeedback, _extends$p({
    disabled: !onPress,
    onPress: onPress
  }, rest), /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: [styles$z.container, numeric && styles$z.right, style]
  }, icon, /*#__PURE__*/React__namespace.createElement(Text$1, {
    style: [styles$z.cell, // height must scale with numberOfLines
    {
      maxHeight: 24 * numberOfLines
    }, // if numberOfLines causes wrap, center is lost. Align directly, sensitive to numeric and RTL
    numberOfLines > 1 ? numeric ? reactNative.I18nManager.isRTL ? styles$z.leftText : styles$z.rightText : styles$z.centerText : {}, sortDirection ? styles$z.sorted : {
      color: textColor
    }, textStyle],
    numberOfLines: numberOfLines
  }, children)));
};

DataTableTitle.displayName = 'DataTable.Title';
const styles$z = reactNative.StyleSheet.create({
  container: {
    flex: 1,
    flexDirection: 'row',
    alignContent: 'center',
    paddingVertical: 12
  },
  rightText: {
    textAlign: 'right'
  },
  leftText: {
    textAlign: 'left'
  },
  centerText: {
    textAlign: 'center'
  },
  right: {
    justifyContent: 'flex-end'
  },
  cell: {
    lineHeight: 24,
    fontSize: 12,
    fontWeight: '500',
    alignItems: 'center'
  },
  sorted: {
    marginLeft: 8
  },
  icon: {
    height: 24,
    justifyContent: 'center'
  }
});
withTheme(DataTableTitle); // @component-docs ignore-next-line

const CrossFadeIcon = _ref => {
  let {
    color,
    size,
    source,
    theme
  } = _ref;
  const [currentIcon, setCurrentIcon] = React__namespace.useState(() => source);
  const [previousIcon, setPreviousIcon] = React__namespace.useState(null);
  const {
    current: fade
  } = React__namespace.useRef(new reactNative.Animated.Value(1));
  const {
    scale
  } = theme.animation;

  if (currentIcon !== source) {
    setPreviousIcon(() => currentIcon);
    setCurrentIcon(() => source);
  }

  React__namespace.useEffect(() => {
    if (isValidIcon(previousIcon) && !isEqualIcon(previousIcon, currentIcon)) {
      fade.setValue(1);
      reactNative.Animated.timing(fade, {
        duration: scale * 200,
        toValue: 0,
        useNativeDriver: true
      }).start();
    }
  }, [currentIcon, previousIcon, fade, scale]);
  const opacityPrev = fade;
  const opacityNext = previousIcon ? fade.interpolate({
    inputRange: [0, 1],
    outputRange: [1, 0]
  }) : 1;
  const rotatePrev = fade.interpolate({
    inputRange: [0, 1],
    outputRange: ['-90deg', '0deg']
  });
  const rotateNext = previousIcon ? fade.interpolate({
    inputRange: [0, 1],
    outputRange: ['0deg', '-180deg']
  }) : '0deg';
  return /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: [styles$y.content, {
      height: size,
      width: size
    }]
  }, previousIcon ? /*#__PURE__*/React__namespace.createElement(reactNative.Animated.View, {
    style: [styles$y.icon, {
      opacity: opacityPrev,
      transform: [{
        rotate: rotatePrev
      }]
    }]
  }, /*#__PURE__*/React__namespace.createElement(Icon$1, {
    source: previousIcon,
    size: size,
    color: color
  })) : null, /*#__PURE__*/React__namespace.createElement(reactNative.Animated.View, {
    style: [styles$y.icon, {
      opacity: opacityNext,
      transform: [{
        rotate: rotateNext
      }]
    }]
  }, /*#__PURE__*/React__namespace.createElement(Icon$1, {
    source: currentIcon,
    size: size,
    color: color
  })));
};

var CrossFadeIcon$1 = withTheme(CrossFadeIcon);
const styles$y = reactNative.StyleSheet.create({
  content: {
    alignItems: 'center',
    justifyContent: 'center'
  },
  icon: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
  }
});

function _extends$o() { _extends$o = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$o.apply(this, arguments); }

/**
 * An icon button is a button which displays only an icon without a label.
 * By default button has 150% size of the icon.
 *
 * <div class="screenshots">
 *   <figure>
 *     <img src="screenshots/icon-button-1.png" />
 *     <figcaption>Icon button</figcaption>
 *   </figure>
 *   <figure>
 *     <img src="screenshots/icon-button-2.png" />
 *     <figcaption>Pressed icon button</figcaption>
 *   </figure>
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { IconButton, Colors } from 'react-native-paper';
 *
 * const MyComponent = () => (
 *   <IconButton
 *     icon="camera"
 *     color={Colors.red500}
 *     size={20}
 *     onPress={() => console.log('Pressed')}
 *   />
 * );
 *
 * export default MyComponent;
 * ```
 *
 * @extends TouchableRipple props https://callstack.github.io/react-native-paper/touchable-ripple.html
 */
const IconButton = _ref => {
  let {
    icon,
    color: customColor,
    size = 24,
    accessibilityLabel,
    disabled,
    onPress,
    animated = false,
    theme,
    style,
    ...rest
  } = _ref;
  const iconColor = typeof customColor !== 'undefined' ? customColor : theme.colors.text;
  const rippleColor = color$1(iconColor).alpha(0.32).rgb().string();
  const IconComponent = animated ? CrossFadeIcon$1 : Icon$1;
  const buttonSize = size * 1.5;
  return /*#__PURE__*/React__namespace.createElement(TouchableRipple$1, _extends$o({
    borderless: true,
    centered: true,
    onPress: onPress,
    rippleColor: rippleColor,
    style: [styles$x.container, {
      width: buttonSize,
      height: buttonSize,
      borderRadius: buttonSize / 2
    }, disabled && styles$x.disabled, style],
    accessibilityLabel: accessibilityLabel // @ts-expect-error We keep old a11y props for backwards compat with old RN versions
    ,
    accessibilityTraits: disabled ? ['button', 'disabled'] : 'button',
    accessibilityComponentType: "button",
    accessibilityRole: "button",
    accessibilityState: {
      disabled
    },
    disabled: disabled,
    hitSlop: TouchableRipple$1.supported ? {
      top: 10,
      left: 10,
      bottom: 10,
      right: 10
    } : {
      top: 6,
      left: 6,
      bottom: 6,
      right: 6
    }
  }, rest), /*#__PURE__*/React__namespace.createElement(reactNative.View, null, /*#__PURE__*/React__namespace.createElement(IconComponent, {
    color: iconColor,
    source: icon,
    size: size
  })));
};

const styles$x = reactNative.StyleSheet.create({
  container: {
    alignItems: 'center',
    justifyContent: 'center',
    overflow: 'hidden',
    margin: 6
  },
  disabled: {
    opacity: 0.32
  }
});
var IconButton$1 = withTheme(IconButton);

function _defineProperty$2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
class PortalConsumer extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty$2(this, "key", void 0);
  }

  async componentDidMount() {
    this.checkManager(); // Delay updating to prevent React from going to infinite loop

    await Promise.resolve();
    this.key = this.props.manager.mount(this.props.children);
  }

  componentDidUpdate() {
    this.checkManager();
    this.props.manager.update(this.key, this.props.children);
  }

  componentWillUnmount() {
    this.checkManager();
    this.props.manager.unmount(this.key);
  }

  checkManager() {
    if (!this.props.manager) {
      throw new Error('Looks like you forgot to wrap your root component with `Provider` component from `react-native-paper`.\n\n' + "Please read our getting-started guide and make sure you've followed all the required steps.\n\n" + 'https://callstack.github.io/react-native-paper/getting-started.html');
    }
  }

  render() {
    return null;
  }

}

function _defineProperty$1(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Portal allows to render a component at a different place in the parent tree.
 * You can use it to render content which should appear above other elements, similar to `Modal`.
 * It requires a [`Portal.Host`](portal-host.html) component to be rendered somewhere in the parent tree.
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { Portal, Text } from 'react-native-paper';
 *
 * const MyComponent = () => (
 *   <Portal>
 *     <Text>This is rendered at a different place</Text>
 *   </Portal>
 * );
 *
 * export default MyComponent;
 * ```
 */
class Portal$1 extends React__namespace.Component {
  // @component ./PortalHost.tsx
  render() {
    const {
      children,
      theme
    } = this.props;
    return /*#__PURE__*/React__namespace.createElement(Consumer, null, settings => /*#__PURE__*/React__namespace.createElement(PortalContext.Consumer, null, manager => /*#__PURE__*/React__namespace.createElement(PortalConsumer, {
      manager: manager
    }, /*#__PURE__*/React__namespace.createElement(Provider, {
      value: settings
    }, /*#__PURE__*/React__namespace.createElement(ThemeProvider$3, {
      theme: theme
    }, children)))));
  }

}

_defineProperty$1(Portal$1, "Host", PortalHost);

var Portal$2 = withTheme(Portal$1);

/**
 * A component to show a single list item inside a Menu.
 *
 * <div class="screenshots">
 *   <figure>
 *     <img class="medium" src="screenshots/menu-item.png" />
 *   </figure>
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { View } from 'react-native';
 * import { Menu } from 'react-native-paper';
 *
 * const MyComponent = () => (
 *   <View style={{ flex: 1 }}>
 *     <Menu.Item icon="redo" onPress={() => {}} title="Redo" />
 *     <Menu.Item icon="undo" onPress={() => {}} title="Undo" />
 *     <Menu.Item icon="content-cut" onPress={() => {}} title="Cut" disabled />
 *     <Menu.Item icon="content-copy" onPress={() => {}} title="Copy" disabled />
 *     <Menu.Item icon="content-paste" onPress={() => {}} title="Paste" />
 *   </View>
 * );
 *
 * export default MyComponent;
 * ```
 */
const MenuItem = _ref => {
  let {
    icon,
    title,
    disabled,
    onPress,
    style,
    contentStyle,
    testID,
    titleStyle,
    accessibilityLabel,
    theme
  } = _ref;
  const disabledColor = color$1(theme.dark ? white : black).alpha(0.32).rgb().string();
  const titleColor = disabled ? disabledColor : color$1(theme.colors.text).alpha(0.87).rgb().string();
  const iconColor = disabled ? disabledColor : color$1(theme.colors.text).alpha(0.54).rgb().string();
  return /*#__PURE__*/React__namespace.createElement(TouchableRipple$1, {
    style: [styles$w.container, style],
    onPress: onPress,
    disabled: disabled,
    testID: testID,
    accessibilityLabel: accessibilityLabel,
    accessibilityRole: "menuitem",
    accessibilityState: {
      disabled
    }
  }, /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: styles$w.row
  }, icon ? /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: [styles$w.item, styles$w.icon],
    pointerEvents: "box-none"
  }, /*#__PURE__*/React__namespace.createElement(Icon$1, {
    source: icon,
    size: 24,
    color: iconColor
  })) : null, /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: [styles$w.item, styles$w.content, icon ? styles$w.widthWithIcon : null, contentStyle],
    pointerEvents: "none"
  }, /*#__PURE__*/React__namespace.createElement(Text$1, {
    selectable: false,
    numberOfLines: 1,
    style: [styles$w.title, {
      color: titleColor
    }, titleStyle]
  }, title))));
};

MenuItem.displayName = 'Menu.Item';
const minWidth$1 = 112;
const maxWidth$1 = 280;
const iconWidth = 40;
const styles$w = reactNative.StyleSheet.create({
  container: {
    paddingHorizontal: 8,
    minWidth: minWidth$1,
    maxWidth: maxWidth$1,
    height: 48,
    justifyContent: 'center'
  },
  row: {
    flexDirection: 'row'
  },
  icon: {
    width: iconWidth
  },
  title: {
    fontSize: 16
  },
  item: {
    marginHorizontal: 8
  },
  content: {
    justifyContent: 'center',
    minWidth: minWidth$1 - 16,
    maxWidth: maxWidth$1 - 16
  },
  widthWithIcon: {
    maxWidth: maxWidth$1 - (iconWidth + 48)
  }
});
var MenuItem$1 = withTheme(MenuItem);

var _NativeModules$Native, _NativeModules$Native2, _NativeModules$Native3, _NativeModules$Native4;
// status bar is translucent on Android. This should be replaced in the future
// with react-native-safe-area-context.

const estimatedStatusBarHeight = (_NativeModules$Native = (_NativeModules$Native2 = reactNative.NativeModules.NativeUnimoduleProxy) === null || _NativeModules$Native2 === void 0 ? void 0 : (_NativeModules$Native3 = _NativeModules$Native2.modulesConstants) === null || _NativeModules$Native3 === void 0 ? void 0 : (_NativeModules$Native4 = _NativeModules$Native3.ExponentConstants) === null || _NativeModules$Native4 === void 0 ? void 0 : _NativeModules$Native4.statusBarHeight) !== null && _NativeModules$Native !== void 0 ? _NativeModules$Native : 0;
const APPROX_STATUSBAR_HEIGHT = reactNative.Platform.select({
  android: estimatedStatusBarHeight,
  ios: reactNative.Platform.Version < 11 ? estimatedStatusBarHeight : 0
});

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// Minimum padding between the edge of the screen and the menu
const SCREEN_INDENT = 8; // From https://material.io/design/motion/speed.html#duration

const ANIMATION_DURATION = 250; // From the 'Standard easing' section of https://material.io/design/motion/speed.html#easing

const EASING = reactNative.Easing.bezier(0.4, 0, 0.2, 1);
/**
 * Menus display a list of choices on temporary elevated surfaces. Their placement varies based on the element that opens them.
 *
 *  <div class="screenshots">
 *   <img class="medium" src="screenshots/menu-1.png" />
 *   <img class="medium" src="screenshots/menu-2.png" />
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { View } from 'react-native';
 * import { Button, Menu, Divider, Provider } from 'react-native-paper';
 *
 * const MyComponent = () => {
 *   const [visible, setVisible] = React.useState(false);
 *
 *   const openMenu = () => setVisible(true);
 *
 *   const closeMenu = () => setVisible(false);
 *
 *   return (
 *     <Provider>
 *       <View
 *         style={{
 *           paddingTop: 50,
 *           flexDirection: 'row',
 *           justifyContent: 'center',
 *         }}>
 *         <Menu
 *           visible={visible}
 *           onDismiss={closeMenu}
 *           anchor={<Button onPress={openMenu}>Show menu</Button>}>
 *           <Menu.Item onPress={() => {}} title="Item 1" />
 *           <Menu.Item onPress={() => {}} title="Item 2" />
 *           <Divider />
 *           <Menu.Item onPress={() => {}} title="Item 3" />
 *         </Menu>
 *       </View>
 *     </Provider>
 *   );
 * };
 *
 * export default MyComponent;
 * ```
 */

class Menu extends React__namespace.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "state", {
      rendered: this.props.visible,
      top: 0,
      left: 0,
      menuLayout: {
        width: 0,
        height: 0
      },
      anchorLayout: {
        width: 0,
        height: 0
      },
      opacityAnimation: new reactNative.Animated.Value(0),
      scaleAnimation: new reactNative.Animated.ValueXY({
        x: 0,
        y: 0
      })
    });

    _defineProperty(this, "anchor", null);

    _defineProperty(this, "menu", null);

    _defineProperty(this, "backHandlerSubscription", void 0);

    _defineProperty(this, "dimensionsSubscription", void 0);

    _defineProperty(this, "isCoordinate", anchor => ! /*#__PURE__*/React__namespace.isValidElement(anchor) && typeof (anchor === null || anchor === void 0 ? void 0 : anchor.x) === 'number' && typeof (anchor === null || anchor === void 0 ? void 0 : anchor.y) === 'number');

    _defineProperty(this, "measureMenuLayout", () => new Promise(resolve => {
      if (this.menu) {
        this.menu.measureInWindow((x, y, width, height) => {
          resolve({
            x,
            y,
            width,
            height
          });
        });
      }
    }));

    _defineProperty(this, "measureAnchorLayout", () => new Promise(resolve => {
      const {
        anchor
      } = this.props;

      if (this.isCoordinate(anchor)) {
        resolve({
          x: anchor.x,
          y: anchor.y,
          width: 0,
          height: 0
        });
        return;
      }

      if (this.anchor) {
        this.anchor.measureInWindow((x, y, width, height) => {
          resolve({
            x,
            y,
            width,
            height
          });
        });
      }
    }));

    _defineProperty(this, "updateVisibility", async () => {
      // Menu is rendered in Portal, which updates items asynchronously
      // We need to do the same here so that the ref is up-to-date
      await Promise.resolve();

      if (this.props.visible) {
        this.show();
      } else {
        this.hide();
      }
    });

    _defineProperty(this, "isBrowser", () => reactNative.Platform.OS === 'web' && 'document' in global);

    _defineProperty(this, "focusFirstDOMNode", el => {
      if (el && this.isBrowser()) {
        // When in the browser, we want to focus the first focusable item on toggle
        // For example, when menu is shown, focus the first item in the menu
        // And when menu is dismissed, send focus back to the button to resume tabbing
        const node = reactNative.findNodeHandle(el);
        const focusableNode = node.querySelector( // This is a rough list of selectors that can be focused
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
        focusableNode === null || focusableNode === void 0 ? void 0 : focusableNode.focus();
      }
    });

    _defineProperty(this, "handleDismiss", () => {
      if (this.props.visible) {
        this.props.onDismiss();
      }

      return true;
    });

    _defineProperty(this, "handleKeypress", e => {
      if (e.key === 'Escape') {
        this.props.onDismiss();
      }
    });

    _defineProperty(this, "attachListeners", () => {
      this.backHandlerSubscription = addEventListener(reactNative.BackHandler, 'hardwareBackPress', this.handleDismiss);
      this.dimensionsSubscription = addEventListener(reactNative.Dimensions, 'change', this.handleDismiss);
      this.isBrowser() && document.addEventListener('keyup', this.handleKeypress);
    });

    _defineProperty(this, "removeListeners", () => {
      var _this$backHandlerSubs, _this$dimensionsSubsc;

      (_this$backHandlerSubs = this.backHandlerSubscription) === null || _this$backHandlerSubs === void 0 ? void 0 : _this$backHandlerSubs.remove();
      (_this$dimensionsSubsc = this.dimensionsSubscription) === null || _this$dimensionsSubsc === void 0 ? void 0 : _this$dimensionsSubsc.remove();
      this.isBrowser() && document.removeEventListener('keyup', this.handleKeypress);
    });

    _defineProperty(this, "show", async () => {
      const windowLayout = reactNative.Dimensions.get('window');
      const [menuLayout, anchorLayout] = await Promise.all([this.measureMenuLayout(), this.measureAnchorLayout()]); // When visible is true for first render
      // native views can be still not rendered and
      // measureMenuLayout/measureAnchorLayout functions
      // return wrong values e.g { x:0, y: 0, width: 0, height: 0 }
      // so we have to wait until views are ready
      // and rerun this function to show menu

      if (!windowLayout.width || !windowLayout.height || !menuLayout.width || !menuLayout.height || !anchorLayout.width && !this.isCoordinate(this.props.anchor) || !anchorLayout.height && !this.isCoordinate(this.props.anchor)) {
        requestAnimationFrame(this.show);
        return;
      }

      this.setState(() => ({
        left: anchorLayout.x,
        top: anchorLayout.y,
        anchorLayout: {
          height: anchorLayout.height,
          width: anchorLayout.width
        },
        menuLayout: {
          width: menuLayout.width,
          height: menuLayout.height
        }
      }), () => {
        this.attachListeners();
        const {
          animation
        } = this.props.theme;
        reactNative.Animated.parallel([reactNative.Animated.timing(this.state.scaleAnimation, {
          toValue: {
            x: menuLayout.width,
            y: menuLayout.height
          },
          duration: ANIMATION_DURATION * animation.scale,
          easing: EASING,
          useNativeDriver: true
        }), reactNative.Animated.timing(this.state.opacityAnimation, {
          toValue: 1,
          duration: ANIMATION_DURATION * animation.scale,
          easing: EASING,
          useNativeDriver: true
        })]).start(_ref => {
          let {
            finished
          } = _ref;

          if (finished) {
            this.focusFirstDOMNode(this.menu);
          }
        });
      });
    });

    _defineProperty(this, "hide", () => {
      this.removeListeners();
      const {
        animation
      } = this.props.theme;
      reactNative.Animated.timing(this.state.opacityAnimation, {
        toValue: 0,
        duration: ANIMATION_DURATION * animation.scale,
        easing: EASING,
        useNativeDriver: true
      }).start(_ref2 => {
        let {
          finished
        } = _ref2;

        if (finished) {
          this.setState({
            menuLayout: {
              width: 0,
              height: 0
            },
            rendered: false
          });
          this.state.scaleAnimation.setValue({
            x: 0,
            y: 0
          });
          this.focusFirstDOMNode(this.anchor);
        }
      });
    });
  }

  static getDerivedStateFromProps(nextProps, prevState) {
    if (nextProps.visible && !prevState.rendered) {
      return {
        rendered: true
      };
    }

    return null;
  }

  componentDidUpdate(prevProps) {
    if (prevProps.visible !== this.props.visible) {
      this.updateVisibility();
    }
  }

  componentWillUnmount() {
    this.removeListeners();
  }

  render() {
    const {
      visible,
      anchor,
      contentStyle,
      style,
      children,
      theme,
      statusBarHeight,
      onDismiss,
      overlayAccessibilityLabel
    } = this.props;
    const {
      rendered,
      menuLayout,
      anchorLayout,
      opacityAnimation,
      scaleAnimation
    } = this.state;
    let {
      left,
      top
    } = this.state; // I don't know why but on Android measure function is wrong by 24

    const additionalVerticalValue = reactNative.Platform.select({
      android: statusBarHeight,
      default: 0
    });
    const scaleTransforms = [{
      scaleX: scaleAnimation.x.interpolate({
        inputRange: [0, menuLayout.width],
        outputRange: [0, 1]
      })
    }, {
      scaleY: scaleAnimation.y.interpolate({
        inputRange: [0, menuLayout.height],
        outputRange: [0, 1]
      })
    }];
    const windowLayout = reactNative.Dimensions.get('window'); // We need to translate menu while animating scale to imitate transform origin for scale animation

    const positionTransforms = []; // Check if menu fits horizontally and if not align it to right.

    if (left <= windowLayout.width - menuLayout.width - SCREEN_INDENT) {
      positionTransforms.push({
        translateX: scaleAnimation.x.interpolate({
          inputRange: [0, menuLayout.width],
          outputRange: [-(menuLayout.width / 2), 0]
        })
      }); // Check if menu position has enough space from left side

      if (left < SCREEN_INDENT) {
        left = SCREEN_INDENT;
      }
    } else {
      positionTransforms.push({
        translateX: scaleAnimation.x.interpolate({
          inputRange: [0, menuLayout.width],
          outputRange: [menuLayout.width / 2, 0]
        })
      });
      left += anchorLayout.width - menuLayout.width;
      const right = left + menuLayout.width; // Check if menu position has enough space from right side

      if (right > windowLayout.width - SCREEN_INDENT) {
        left = windowLayout.width - SCREEN_INDENT - menuLayout.width;
      }
    } // If the menu is larger than available vertical space,
    // calculate the height of scrollable view


    let scrollableMenuHeight = 0; // Check if the menu should be scrollable

    if ( // Check if the menu overflows from bottom side
    top >= windowLayout.height - menuLayout.height - SCREEN_INDENT - additionalVerticalValue && // And bottom side of the screen has more space than top side
    top <= windowLayout.height - top) {
      // Scrollable menu should be below the anchor (expands downwards)
      scrollableMenuHeight = windowLayout.height - top - SCREEN_INDENT - additionalVerticalValue;
    } else if ( // Check if the menu overflows from bottom side
    top >= windowLayout.height - menuLayout.height - SCREEN_INDENT - additionalVerticalValue && // And top side of the screen has more space than bottom side
    top >= windowLayout.height - top && // And menu overflows from top side
    top <= menuLayout.height - anchorLayout.height + SCREEN_INDENT - additionalVerticalValue) {
      // Scrollable menu should be above the anchor (expands upwards)
      scrollableMenuHeight = top + anchorLayout.height - SCREEN_INDENT + additionalVerticalValue;
    } // Scrollable menu max height


    scrollableMenuHeight = scrollableMenuHeight > windowLayout.height - 2 * SCREEN_INDENT ? windowLayout.height - 2 * SCREEN_INDENT : scrollableMenuHeight; // Menu is typically positioned below the element that generates it
    // So first check if it fits below the anchor (expands downwards)

    if ( // Check if menu fits vertically
    top <= windowLayout.height - menuLayout.height - SCREEN_INDENT - additionalVerticalValue || // Or if the menu overflows from bottom side
    top >= windowLayout.height - menuLayout.height - SCREEN_INDENT - additionalVerticalValue && // And bottom side of the screen has more space than top side
    top <= windowLayout.height - top) {
      positionTransforms.push({
        translateY: scaleAnimation.y.interpolate({
          inputRange: [0, menuLayout.height],
          outputRange: [-((scrollableMenuHeight || menuLayout.height) / 2), 0]
        })
      }); // Check if menu position has enough space from top side

      if (top < SCREEN_INDENT) {
        top = SCREEN_INDENT;
      }
    } else {
      positionTransforms.push({
        translateY: scaleAnimation.y.interpolate({
          inputRange: [0, menuLayout.height],
          outputRange: [(scrollableMenuHeight || menuLayout.height) / 2, 0]
        })
      });
      top += anchorLayout.height - (scrollableMenuHeight || menuLayout.height);
      const bottom = top + (scrollableMenuHeight || menuLayout.height) + additionalVerticalValue; // Check if menu position has enough space from bottom side

      if (bottom > windowLayout.height - SCREEN_INDENT) {
        top = scrollableMenuHeight === windowLayout.height - 2 * SCREEN_INDENT ? -SCREEN_INDENT * 2 : windowLayout.height - menuLayout.height - SCREEN_INDENT - additionalVerticalValue;
      }
    }

    const shadowMenuContainerStyle = {
      opacity: opacityAnimation,
      transform: scaleTransforms,
      borderRadius: theme.roundness,
      ...(scrollableMenuHeight ? {
        height: scrollableMenuHeight
      } : {})
    };
    const positionStyle = {
      top: this.isCoordinate(anchor) ? top : top + additionalVerticalValue,
      ...(reactNative.I18nManager.isRTL ? {
        right: left
      } : {
        left
      })
    };
    return /*#__PURE__*/React__namespace.createElement(reactNative.View, {
      ref: ref => {
        this.anchor = ref;
      },
      collapsable: false
    }, this.isCoordinate(anchor) ? null : anchor, rendered ? /*#__PURE__*/React__namespace.createElement(Portal$2, null, /*#__PURE__*/React__namespace.createElement(reactNative.TouchableWithoutFeedback, {
      accessibilityLabel: overlayAccessibilityLabel,
      accessibilityRole: "button",
      onPress: onDismiss
    }, /*#__PURE__*/React__namespace.createElement(reactNative.View, {
      style: reactNative.StyleSheet.absoluteFill
    })), /*#__PURE__*/React__namespace.createElement(reactNative.View, {
      ref: ref => {
        this.menu = ref;
      },
      collapsable: false,
      accessibilityViewIsModal: visible,
      style: [styles$v.wrapper, positionStyle, style],
      pointerEvents: visible ? 'box-none' : 'none',
      onAccessibilityEscape: onDismiss
    }, /*#__PURE__*/React__namespace.createElement(reactNative.Animated.View, {
      style: {
        transform: positionTransforms
      }
    }, /*#__PURE__*/React__namespace.createElement(Surface$1, {
      style: [styles$v.shadowMenuContainer, shadowMenuContainerStyle, contentStyle]
    }, scrollableMenuHeight && /*#__PURE__*/React__namespace.createElement(reactNative.ScrollView, null, children) || /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, children))))) : null);
  }

}

_defineProperty(Menu, "Item", MenuItem$1);

_defineProperty(Menu, "defaultProps", {
  statusBarHeight: APPROX_STATUSBAR_HEIGHT,
  overlayAccessibilityLabel: 'Close menu'
});

const styles$v = reactNative.StyleSheet.create({
  wrapper: {
    position: 'absolute'
  },
  shadowMenuContainer: {
    opacity: 0,
    paddingVertical: 8,
    elevation: 8
  }
});
var Menu$1 = withTheme(Menu);

function _extends$n() { _extends$n = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$n.apply(this, arguments); }

const PaginationControls = _ref => {
  let {
    page,
    numberOfPages,
    onPageChange,
    showFastPaginationControls
  } = _ref;
  const {
    colors
  } = useTheme$5();
  return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, showFastPaginationControls ? /*#__PURE__*/React__namespace.createElement(IconButton$1, {
    icon: _ref2 => {
      let {
        size,
        color
      } = _ref2;
      return /*#__PURE__*/React__namespace.createElement(defaultIcon, {
        name: "page-first",
        color: color,
        size: size,
        direction: reactNative.I18nManager.isRTL ? 'rtl' : 'ltr'
      });
    },
    color: colors.text,
    disabled: page === 0,
    onPress: () => onPageChange(0),
    accessibilityLabel: "page-first"
  }) : null, /*#__PURE__*/React__namespace.createElement(IconButton$1, {
    icon: _ref3 => {
      let {
        size,
        color
      } = _ref3;
      return /*#__PURE__*/React__namespace.createElement(defaultIcon, {
        name: "chevron-left",
        color: color,
        size: size,
        direction: reactNative.I18nManager.isRTL ? 'rtl' : 'ltr'
      });
    },
    color: colors.text,
    disabled: page === 0,
    onPress: () => onPageChange(page - 1),
    accessibilityLabel: "chevron-left"
  }), /*#__PURE__*/React__namespace.createElement(IconButton$1, {
    icon: _ref4 => {
      let {
        size,
        color
      } = _ref4;
      return /*#__PURE__*/React__namespace.createElement(defaultIcon, {
        name: "chevron-right",
        color: color,
        size: size,
        direction: reactNative.I18nManager.isRTL ? 'rtl' : 'ltr'
      });
    },
    color: colors.text,
    disabled: numberOfPages === 0 || page === numberOfPages - 1,
    onPress: () => onPageChange(page + 1),
    accessibilityLabel: "chevron-right"
  }), showFastPaginationControls ? /*#__PURE__*/React__namespace.createElement(IconButton$1, {
    icon: _ref5 => {
      let {
        size,
        color
      } = _ref5;
      return /*#__PURE__*/React__namespace.createElement(defaultIcon, {
        name: "page-last",
        color: color,
        size: size,
        direction: reactNative.I18nManager.isRTL ? 'rtl' : 'ltr'
      });
    },
    color: colors.text,
    disabled: numberOfPages === 0 || page === numberOfPages - 1,
    onPress: () => onPageChange(numberOfPages - 1),
    accessibilityLabel: "page-last"
  }) : null);
};

const PaginationDropdown = _ref6 => {
  let {
    numberOfItemsPerPageList,
    numberOfItemsPerPage,
    onItemsPerPageChange
  } = _ref6;
  const {
    colors
  } = useTheme$5();
  const [showSelect, toggleSelect] = React__namespace.useState(false);
  return /*#__PURE__*/React__namespace.createElement(Menu$1, {
    visible: showSelect,
    onDismiss: () => toggleSelect(!showSelect),
    anchor: /*#__PURE__*/React__namespace.createElement(Button$1, {
      mode: "outlined",
      onPress: () => toggleSelect(true),
      style: styles$u.button,
      icon: "menu-down",
      contentStyle: styles$u.contentStyle
    }, `${numberOfItemsPerPage}`)
  }, numberOfItemsPerPageList === null || numberOfItemsPerPageList === void 0 ? void 0 : numberOfItemsPerPageList.map(option => /*#__PURE__*/React__namespace.createElement(Menu$1.Item, {
    key: option,
    titleStyle: option === numberOfItemsPerPage && {
      color: colors.primary
    },
    onPress: () => {
      onItemsPerPageChange === null || onItemsPerPageChange === void 0 ? void 0 : onItemsPerPageChange(option);
      toggleSelect(false);
    },
    title: option
  })));
};
/**
 * A component to show pagination for data table.
 *
 * <div class="screenshots">
 *   <figure>
 *     <img class="medium" src="screenshots/data-table-pagination.png" />
 *   </figure>
 * </div>
 *
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { DataTable } from 'react-native-paper';
 *
 * const numberOfItemsPerPageList = [2, 3, 4];
 *
 * const items = [
 *   {
 *     key: 1,
 *     name: 'Page 1',
 *   },
 *   {
 *     key: 2,
 *     name: 'Page 2',
 *   },
 *   {
 *     key: 3,
 *     name: 'Page 3',
 *   },
 * ];
 *
 * const MyComponent = () => {
 *   const [page, setPage] = React.useState(0);
 *   const [numberOfItemsPerPage, onItemsPerPageChange] = React.useState(numberOfItemsPerPageList[0]);
 *   const from = page * numberOfItemsPerPage;
 *   const to = Math.min((page + 1) * numberOfItemsPerPage, items.length);
 *
 *   React.useEffect(() => {
 *      setPage(0);
 *   }, [numberOfItemsPerPage]);
 *
 *   return (
 *     <DataTable>
 *       <DataTable.Pagination
 *         page={page}
 *         numberOfPages={Math.ceil(items.length / numberOfItemsPerPage)}
 *         onPageChange={page => setPage(page)}
 *         label={`${from + 1}-${to} of ${items.length}`}
 *         showFastPaginationControls
 *         numberOfItemsPerPageList={numberOfItemsPerPageList}
 *         numberOfItemsPerPage={numberOfItemsPerPage}
 *         onItemsPerPageChange={onItemsPerPageChange}
 *         selectPageDropdownLabel={'Rows per page'}
 *       />
 *     </DataTable>
 *   );
 * };
 *
 * export default MyComponent;
 * ```
 */


const DataTablePagination = _ref7 => {
  let {
    label,
    accessibilityLabel,
    page,
    numberOfPages,
    onPageChange,
    style,
    theme,
    showFastPaginationControls = false,
    numberOfItemsPerPageList,
    numberOfItemsPerPage,
    onItemsPerPageChange,
    selectPageDropdownLabel,
    selectPageDropdownAccessibilityLabel,
    ...rest
  } = _ref7;
  const labelColor = color$1(theme.colors.text).alpha(0.6).rgb().string();
  return /*#__PURE__*/React__namespace.createElement(reactNative.View, _extends$n({}, rest, {
    style: [styles$u.container, style],
    accessibilityLabel: "pagination-container"
  }), numberOfItemsPerPageList && numberOfItemsPerPage && onItemsPerPageChange && /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    accessibilityLabel: "Options Select",
    style: styles$u.optionsContainer
  }, /*#__PURE__*/React__namespace.createElement(Text$1, {
    style: [styles$u.label, {
      color: labelColor
    }],
    numberOfLines: 3,
    accessibilityLabel: selectPageDropdownAccessibilityLabel || 'selectPageDropdownLabel'
  }, selectPageDropdownLabel), /*#__PURE__*/React__namespace.createElement(PaginationDropdown, {
    numberOfItemsPerPageList: numberOfItemsPerPageList,
    numberOfItemsPerPage: numberOfItemsPerPage,
    onItemsPerPageChange: onItemsPerPageChange
  })), /*#__PURE__*/React__namespace.createElement(Text$1, {
    style: [styles$u.label, {
      color: labelColor
    }],
    numberOfLines: 3,
    accessibilityLabel: accessibilityLabel || 'label'
  }, label), /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: styles$u.iconsContainer
  }, /*#__PURE__*/React__namespace.createElement(PaginationControls, {
    showFastPaginationControls: showFastPaginationControls,
    onPageChange: onPageChange,
    page: page,
    numberOfPages: numberOfPages
  })));
};

DataTablePagination.displayName = 'DataTable.Pagination';
const styles$u = reactNative.StyleSheet.create({
  container: {
    justifyContent: 'flex-end',
    flexDirection: 'row',
    alignItems: 'center',
    paddingLeft: 16,
    flexWrap: 'wrap'
  },
  optionsContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginVertical: 6
  },
  label: {
    fontSize: 12,
    marginRight: 16
  },
  button: {
    textAlign: 'center',
    marginRight: 16
  },
  iconsContainer: {
    flexDirection: 'row'
  },
  contentStyle: {
    flexDirection: 'row-reverse'
  }
});
withTheme(DataTablePagination); // @component-docs ignore-next-line

function _extends$m() { _extends$m = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$m.apply(this, arguments); }

/**
 * A component to show a single row inside of a table.
 *
 * <div class="screenshots">
 *   <figure>
 *     <img class="medium" src="screenshots/data-table-row-cell.png" />
 *   </figure>
 * </div>
 *
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { DataTable } from 'react-native-paper';
 *
 * const MyComponent = () => (
 *      <DataTable.Row>
 *        <DataTable.Cell numeric>1</DataTable.Cell>
 *        <DataTable.Cell numeric>2</DataTable.Cell>
 *        <DataTable.Cell numeric>3</DataTable.Cell>
 *        <DataTable.Cell numeric>4</DataTable.Cell>
 *      </DataTable.Row>
 * );
 *
 * export default MyComponent;
 * ```
 */
const DataTableRow = _ref => {
  let {
    onPress,
    style,
    theme,
    children,
    pointerEvents,
    ...rest
  } = _ref;
  const borderBottomColor = color$1(theme.dark ? white : black).alpha(0.12).rgb().string();
  return /*#__PURE__*/React__namespace.createElement(TouchableRipple$1, _extends$m({}, rest, {
    onPress: onPress,
    style: [styles$t.container, {
      borderBottomColor
    }, style]
  }), /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: styles$t.content,
    pointerEvents: pointerEvents
  }, children));
};

DataTableRow.displayName = 'DataTable.Row';
const styles$t = reactNative.StyleSheet.create({
  container: {
    borderStyle: 'solid',
    borderBottomWidth: reactNative.StyleSheet.hairlineWidth,
    minHeight: 48,
    paddingHorizontal: 16
  },
  content: {
    flex: 1,
    flexDirection: 'row'
  }
});
withTheme(DataTableRow); // @component-docs ignore-next-line

reactNative.StyleSheet.create({
  container: {
    width: '100%'
  }
});

const DEFAULT_DURATION = 220;
const TOP_INSET = getStatusBarHeight(true);
const BOTTOM_INSET = getBottomSpace();
/**
 * The Modal component is a simple way to present content above an enclosing view.
 * To render the `Modal` above other components, you'll need to wrap it with the [`Portal`](portal.html) component.
 *
 * <div class="screenshots">
 *   <figure>
 *     <img class="medium" src="screenshots/modal.gif" />
 *   </figure>
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { Modal, Portal, Text, Button, Provider } from 'react-native-paper';
 *
 * const MyComponent = () => {
 *   const [visible, setVisible] = React.useState(false);
 *
 *   const showModal = () => setVisible(true);
 *   const hideModal = () => setVisible(false);
 *   const containerStyle = {backgroundColor: 'white', padding: 20};
 *
 *   return (
 *     <Provider>
 *       <Portal>
 *         <Modal visible={visible} onDismiss={hideModal} contentContainerStyle={containerStyle}>
 *           <Text>Example Modal.  Click outside this area to dismiss.</Text>
 *         </Modal>
 *       </Portal>
 *       <Button style={{marginTop: 30}} onPress={showModal}>
 *         Show
 *       </Button>
 *     </Provider>
 *   );
 * };
 *
 * export default MyComponent;
 * ```
 */

function Modal(_ref) {
  let {
    dismissable = true,
    visible = false,
    overlayAccessibilityLabel = 'Close modal',
    onDismiss,
    children,
    contentContainerStyle,
    style
  } = _ref;
  const visibleRef = React__namespace.useRef(visible);
  React__namespace.useEffect(() => {
    visibleRef.current = visible;
  });
  const {
    colors,
    animation
  } = useTheme$5();
  const opacity = useAnimatedValue(visible ? 1 : 0);
  const [rendered, setRendered] = React__namespace.useState(visible);

  if (visible && !rendered) {
    setRendered(true);
  }

  const handleBack = () => {
    if (dismissable) {
      hideModal();
    }

    return true;
  };

  const subscription = React__namespace.useRef(undefined);

  const showModal = () => {
    var _subscription$current;

    (_subscription$current = subscription.current) === null || _subscription$current === void 0 ? void 0 : _subscription$current.remove();
    subscription.current = addEventListener(reactNative.BackHandler, 'hardwareBackPress', handleBack);
    const {
      scale
    } = animation;
    reactNative.Animated.timing(opacity, {
      toValue: 1,
      duration: scale * DEFAULT_DURATION,
      easing: reactNative.Easing.out(reactNative.Easing.cubic),
      useNativeDriver: true
    }).start();
  };

  const removeListeners = () => {
    var _subscription$current2;

    if ((_subscription$current2 = subscription.current) !== null && _subscription$current2 !== void 0 && _subscription$current2.remove) {
      var _subscription$current3;

      (_subscription$current3 = subscription.current) === null || _subscription$current3 === void 0 ? void 0 : _subscription$current3.remove();
    } else {
      reactNative.BackHandler.removeEventListener('hardwareBackPress', handleBack);
    }
  };

  const hideModal = () => {
    removeListeners();
    const {
      scale
    } = animation;
    reactNative.Animated.timing(opacity, {
      toValue: 0,
      duration: scale * DEFAULT_DURATION,
      easing: reactNative.Easing.out(reactNative.Easing.cubic),
      useNativeDriver: true
    }).start(_ref2 => {
      let {
        finished
      } = _ref2;

      if (!finished) {
        return;
      }

      if (visible && onDismiss) {
        onDismiss();
      }

      if (visibleRef.current) {
        showModal();
      } else {
        setRendered(false);
      }
    });
  };

  const prevVisible = React__namespace.useRef(null);
  React__namespace.useEffect(() => {
    if (prevVisible.current !== visible) {
      if (visible) {
        showModal();
      } else {
        hideModal();
      }
    }

    prevVisible.current = visible;
  });
  React__namespace.useEffect(() => {
    return removeListeners;
  }, []);
  if (!rendered) return null;
  return /*#__PURE__*/React__namespace.createElement(reactNative.Animated.View, {
    pointerEvents: visible ? 'auto' : 'none',
    accessibilityViewIsModal: true,
    accessibilityLiveRegion: "polite",
    style: reactNative.StyleSheet.absoluteFill,
    onAccessibilityEscape: hideModal
  }, /*#__PURE__*/React__namespace.createElement(reactNative.TouchableWithoutFeedback, {
    accessibilityLabel: overlayAccessibilityLabel,
    accessibilityRole: "button",
    disabled: !dismissable,
    onPress: dismissable ? hideModal : undefined,
    importantForAccessibility: "no"
  }, /*#__PURE__*/React__namespace.createElement(reactNative.Animated.View, {
    style: [styles$s.backdrop, {
      backgroundColor: colors.backdrop,
      opacity
    }]
  })), /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: [styles$s.wrapper, {
      marginTop: TOP_INSET,
      marginBottom: BOTTOM_INSET
    }, style],
    pointerEvents: "box-none"
  }, /*#__PURE__*/React__namespace.createElement(Surface$1, {
    style: [{
      opacity
    }, styles$s.content, contentContainerStyle]
  }, children)));
}
const styles$s = reactNative.StyleSheet.create({
  backdrop: {
    flex: 1
  },
  wrapper: { ...reactNative.StyleSheet.absoluteFillObject,
    justifyContent: 'center'
  },
  content: {
    backgroundColor: 'transparent',
    justifyContent: 'center'
  }
});

function _extends$l() { _extends$l = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$l.apply(this, arguments); }

/**
 * A component to show content in a Dialog.
 *
 * <div class="screenshots">
 *   <figure>
 *     <img class="medium" src="screenshots/dialog-content.png" />
 *   </figure>
 * </div>
 *
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { Paragraph, Dialog, Portal } from 'react-native-paper';
 *
 * const MyComponent = () => {
 *   const [visible, setVisible] = React.useState(false);
 *
 *   const hideDialog = () => setVisible(false);
 *
 *   return (
 *     <Portal>
 *       <Dialog visible={visible} onDismiss={hideDialog}>
 *         <Dialog.Content>
 *           <Paragraph>This is simple dialog</Paragraph>
 *         </Dialog.Content>
 *       </Dialog>
 *     </Portal>
 *   );
 * };
 *
 * export default MyComponent;
 * ```
 */
const DialogContent = props => /*#__PURE__*/React__namespace.createElement(reactNative.View, _extends$l({}, props, {
  style: [styles$r.container, props.style]
}), props.children);

DialogContent.displayName = 'Dialog.Content';
const styles$r = reactNative.StyleSheet.create({
  container: {
    paddingBottom: 24,
    paddingHorizontal: 24
  }
});

function _extends$k() { _extends$k = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$k.apply(this, arguments); }

/**
 * A component to show a list of actions in a Dialog.
 *
 * <div class="screenshots">
 *   <figure>
 *     <img class="medium" src="screenshots/dialog-actions.png" />
 *   </figure>
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { Button, Dialog, Portal } from 'react-native-paper';
 *
 * const MyComponent = () => {
 *   const [visible, setVisible] = React.useState(false);
 *
 *   const hideDialog = () => setVisible(false);
 *
 *   return (
 *     <Portal>
 *       <Dialog visible={visible} onDismiss={hideDialog}>
 *         <Dialog.Actions>
 *           <Button onPress={() => console.log('Cancel')}>Cancel</Button>
 *           <Button onPress={() => console.log('Ok')}>Ok</Button>
 *         </Dialog.Actions>
 *       </Dialog>
 *     </Portal>
 *   );
 * };
 *
 * export default MyComponent;
 * ```
 */
const DialogActions = props => /*#__PURE__*/React__namespace.createElement(reactNative.View, _extends$k({}, props, {
  style: [styles$q.container, props.style]
}), React__namespace.Children.map(props.children, child => /*#__PURE__*/React__namespace.isValidElement(child) ? /*#__PURE__*/React__namespace.cloneElement(child, {
  compact: true
}) : child));

DialogActions.displayName = 'Dialog.Actions';
const styles$q = reactNative.StyleSheet.create({
  container: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'flex-end',
    padding: 8
  }
});

function _extends$j() { _extends$j = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$j.apply(this, arguments); }

/**
 * A component to show a title in a Dialog.
 *
 * <div class="screenshots">
 *   <figure>
 *     <img class="medium" src="screenshots/dialog-title.png" />
 *   </figure>
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { Paragraph, Dialog, Portal } from 'react-native-paper';
 *
 * const MyComponent = () => {
 *   const [visible, setVisible] = React.useState(false);
 *
 *   const hideDialog = () => setVisible(false);
 *
 *   return (
 *     <Portal>
 *       <Dialog visible={visible} onDismiss={hideDialog}>
 *         <Dialog.Title>This is a title</Dialog.Title>
 *         <Dialog.Content>
 *           <Paragraph>This is simple dialog</Paragraph>
 *         </Dialog.Content>
 *       </Dialog>
 *     </Portal>
 *   );
 * };
 *
 * export default MyComponent;
 * ```
 */
const DialogTitle = _ref => {
  let {
    children,
    theme,
    style,
    ...rest
  } = _ref;
  return /*#__PURE__*/React__namespace.createElement(Title // @ts-expect-error We keep old a11y props for backwards compat with old RN versions
  , _extends$j({
    accessibilityTraits: "header",
    accessibilityRole: "header",
    style: [styles$p.text, {
      color: theme.colors.text
    }, style]
  }, rest), children);
};

DialogTitle.displayName = 'Dialog.Title';
const styles$p = reactNative.StyleSheet.create({
  text: {
    marginTop: 22,
    marginBottom: 18,
    marginHorizontal: 24
  }
});
var DialogTitle$1 = withTheme(DialogTitle); // @component-docs ignore-next-line

function _extends$i() { _extends$i = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$i.apply(this, arguments); }

/**
 * A component to show a scrollable content in a Dialog. The component only provides appropriate styling.
 * For the scrollable content you can use `ScrollView`, `FlatList` etc. depending on your requirement.
 *
 * <div class="screenshots">
 *   <figure>
 *     <img class="medium" src="screenshots/dialog-scroll-area.gif" />
 *   </figure>
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { ScrollView } from 'react-native';
 * import { Dialog, Portal, Text } from 'react-native-paper';
 *
 * const MyComponent = () => {
 *   const [visible, setVisible] = React.useState(false);
 *
 *   const hideDialog = () => setVisible(false);
 *
 *   return (
 *     <Portal>
 *       <Dialog visible={visible} onDismiss={hideDialog}>
 *         <Dialog.ScrollArea>
 *           <ScrollView contentContainerStyle={{paddingHorizontal: 24}}>
 *             <Text>This is a scrollable area</Text>
 *           </ScrollView>
 *         </Dialog.ScrollArea>
 *       </Dialog>
 *     </Portal>
 *   );
 * };
 *
 * export default MyComponent;
 * ```
 */
const DialogScrollArea = props => /*#__PURE__*/React__namespace.createElement(reactNative.View, _extends$i({}, props, {
  style: [styles$o.container, props.style]
}), props.children);

DialogScrollArea.displayName = 'Dialog.ScrollArea';
const styles$o = reactNative.StyleSheet.create({
  container: {
    borderColor: 'rgba(0, 0, 0, .12)',
    borderTopWidth: reactNative.StyleSheet.hairlineWidth,
    borderBottomWidth: reactNative.StyleSheet.hairlineWidth,
    paddingHorizontal: 24,
    flexGrow: 1,
    flexShrink: 1
  }
});

const DIALOG_ELEVATION = 24;
/**
 * Dialogs inform users about a specific task and may contain critical information, require decisions, or involve multiple tasks.
 * To render the `Dialog` above other components, you'll need to wrap it with the [`Portal`](portal.html) component.
 *
 *  <div class="screenshots">
 *   <img class="medium" src="screenshots/dialog-1.png" />
 *   <img class="medium" src="screenshots/dialog-2.png" />
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { View } from 'react-native';
 * import { Button, Paragraph, Dialog, Portal, Provider } from 'react-native-paper';
 *
 * const MyComponent = () => {
 *   const [visible, setVisible] = React.useState(false);
 *
 *   const showDialog = () => setVisible(true);
 *
 *   const hideDialog = () => setVisible(false);
 *
 *   return (
 *     <Provider>
 *       <View>
 *         <Button onPress={showDialog}>Show Dialog</Button>
 *         <Portal>
 *           <Dialog visible={visible} onDismiss={hideDialog}>
 *             <Dialog.Title>Alert</Dialog.Title>
 *             <Dialog.Content>
 *               <Paragraph>This is simple dialog</Paragraph>
 *             </Dialog.Content>
 *             <Dialog.Actions>
 *               <Button onPress={hideDialog}>Done</Button>
 *             </Dialog.Actions>
 *           </Dialog>
 *         </Portal>
 *       </View>
 *     </Provider>
 *   );
 * };
 *
 * export default MyComponent;
 * ```
 */

const Dialog = _ref => {
  let {
    children,
    dismissable = true,
    onDismiss,
    visible = false,
    style,
    theme
  } = _ref;
  return /*#__PURE__*/React__namespace.createElement(Modal, {
    dismissable: dismissable,
    onDismiss: onDismiss,
    visible: visible,
    contentContainerStyle: [{
      borderRadius: theme.roundness,
      backgroundColor: theme.dark && theme.mode === 'adaptive' ? overlay(DIALOG_ELEVATION, theme.colors.surface) : theme.colors.surface
    }, styles$n.container, style]
  }, React__namespace.Children.toArray(children).filter(child => child != null && typeof child !== 'boolean').map((child, i) => {
    if (i === 0 && /*#__PURE__*/React__namespace.isValidElement(child) && child.type === DialogContent) {
      // Dialog content is the first item, so we add a top padding
      return /*#__PURE__*/React__namespace.cloneElement(child, {
        style: [{
          paddingTop: 24
        }, child.props.style]
      });
    }

    return child;
  }));
}; // @component ./DialogContent.tsx


Dialog.Content = DialogContent; // @component ./DialogActions.tsx

Dialog.Actions = DialogActions; // @component ./DialogTitle.tsx

Dialog.Title = DialogTitle$1; // @component ./DialogScrollArea.tsx

Dialog.ScrollArea = DialogScrollArea;
const styles$n = reactNative.StyleSheet.create({
  container: {
    /**
     * This prevents the shadow from being clipped on Android since Android
     * doesn't support `overflow: visible`.
     * One downside for this fix is that it will disable clicks on the area
     * of the shadow around the dialog, consequently, if you click around the
     * dialog (44 pixel from the top and bottom) it won't be dismissed.
     */
    marginVertical: reactNative.Platform.OS === 'android' ? 44 : 0,
    marginHorizontal: 26,
    elevation: DIALOG_ELEVATION,
    justifyContent: 'flex-start'
  }
});
withTheme(Dialog);

function _extends$h() { _extends$h = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$h.apply(this, arguments); }

/**
 * A floating action button represents the primary action in an application.
 *
 * <div class="screenshots">
 *   <img src="screenshots/fab-1.png" />
 *   <img src="screenshots/fab-2.png" />
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { StyleSheet } from 'react-native';
 * import { FAB } from 'react-native-paper';
 *
 * const MyComponent = () => (
 *   <FAB
 *     style={styles.fab}
 *     small
 *     icon="plus"
 *     onPress={() => console.log('Pressed')}
 *   />
 * );
 *
 * const styles = StyleSheet.create({
 *   fab: {
 *     position: 'absolute',
 *     margin: 16,
 *     right: 0,
 *     bottom: 0,
 *   },
 * })
 *
 * export default MyComponent;
 * ```
 */
const FAB = _ref => {
  let {
    small,
    icon,
    label,
    accessibilityLabel = label,
    accessibilityState,
    animated = true,
    color: customColor,
    disabled,
    onPress,
    onLongPress,
    theme,
    style,
    visible = true,
    uppercase = true,
    loading,
    testID,
    ...rest
  } = _ref;
  const {
    current: visibility
  } = React__namespace.useRef(new reactNative.Animated.Value(visible ? 1 : 0));
  const {
    scale
  } = theme.animation;
  React__namespace.useEffect(() => {
    if (visible) {
      reactNative.Animated.timing(visibility, {
        toValue: 1,
        duration: 200 * scale,
        useNativeDriver: true
      }).start();
    } else {
      reactNative.Animated.timing(visibility, {
        toValue: 0,
        duration: 150 * scale,
        useNativeDriver: true
      }).start();
    }
  }, [visible, scale, visibility]);
  const IconComponent = animated ? CrossFadeIcon$1 : Icon$1;
  const disabledColor = color$1(theme.dark ? white : black).alpha(0.12).rgb().string();
  const {
    backgroundColor = disabled ? disabledColor : theme.colors.accent
  } = reactNative.StyleSheet.flatten(style) || {};
  let foregroundColor;

  if (typeof customColor !== 'undefined') {
    foregroundColor = customColor;
  } else if (disabled) {
    foregroundColor = color$1(theme.dark ? white : black).alpha(0.32).rgb().string();
  } else {
    foregroundColor = getContrastingColor(backgroundColor, white, 'rgba(0, 0, 0, .54)');
  }

  const rippleColor = color$1(foregroundColor).alpha(0.32).rgb().string();
  return /*#__PURE__*/React__namespace.createElement(Surface$1, _extends$h({}, rest, {
    style: [{
      backgroundColor,
      opacity: visibility,
      transform: [{
        scale: visibility
      }]
    }, styles$m.container, disabled && styles$m.disabled, style],
    pointerEvents: visible ? 'auto' : 'none'
  }), /*#__PURE__*/React__namespace.createElement(TouchableRipple$1, {
    borderless: true,
    onPress: onPress,
    onLongPress: onLongPress,
    rippleColor: rippleColor,
    disabled: disabled,
    accessibilityLabel: accessibilityLabel // @ts-expect-error We keep old a11y props for backwards compat with old RN versions
    ,
    accessibilityTraits: disabled ? ['button', 'disabled'] : 'button',
    accessibilityComponentType: "button",
    accessibilityRole: "button",
    accessibilityState: { ...accessibilityState,
      disabled
    },
    style: styles$m.touchable,
    testID: testID
  }, /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: [styles$m.content, label ? styles$m.extended : small ? styles$m.small : styles$m.standard],
    pointerEvents: "none"
  }, icon && loading !== true ? /*#__PURE__*/React__namespace.createElement(IconComponent, {
    source: icon,
    size: 24,
    color: foregroundColor
  }) : null, loading ? /*#__PURE__*/React__namespace.createElement(ActivityIndicator$1, {
    size: 18,
    color: foregroundColor
  }) : null, label ? /*#__PURE__*/React__namespace.createElement(Text$1, {
    selectable: false,
    style: [styles$m.label, uppercase && styles$m.uppercaseLabel, {
      color: foregroundColor,
      ...theme.fonts.medium
    }]
  }, label) : null)));
};

const styles$m = reactNative.StyleSheet.create({
  container: {
    borderRadius: 28,
    elevation: 6
  },
  touchable: {
    borderRadius: 28
  },
  standard: {
    height: 56,
    width: 56
  },
  small: {
    height: 40,
    width: 40
  },
  extended: {
    height: 48,
    paddingHorizontal: 16
  },
  content: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center'
  },
  label: {
    marginHorizontal: 8
  },
  uppercaseLabel: {
    textTransform: 'uppercase'
  },
  disabled: {
    elevation: 0
  }
});
var FABComponent = withTheme(FAB); // @component-docs ignore-next-line

withTheme(FAB); // @component-docs ignore-next-line

/**
 * A component to display a stack of FABs with related actions in a speed dial.
 * To render the group above other components, you'll need to wrap it with the [`Portal`](portal.html) component.
 *
 * <div class="screenshots">
 *   <img src="screenshots/fab-group.png" />
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { FAB, Portal, Provider } from 'react-native-paper';
 *
 * const MyComponent = () => {
 *   const [state, setState] = React.useState({ open: false });
 *
 *   const onStateChange = ({ open }) => setState({ open });
 *
 *   const { open } = state;
 *
 *   return (
 *     <Provider>
 *       <Portal>
 *         <FAB.Group
 *           open={open}
 *           icon={open ? 'calendar-today' : 'plus'}
 *           actions={[
 *             { icon: 'plus', onPress: () => console.log('Pressed add') },
 *             {
 *               icon: 'star',
 *               label: 'Star',
 *               onPress: () => console.log('Pressed star'),
 *             },
 *             {
 *               icon: 'email',
 *               label: 'Email',
 *               onPress: () => console.log('Pressed email'),
 *             },
 *             {
 *               icon: 'bell',
 *               label: 'Remind',
 *               onPress: () => console.log('Pressed notifications'),
 *               small: false,
 *             },
 *           ]}
 *           onStateChange={onStateChange}
 *           onPress={() => {
 *             if (open) {
 *               // do something if the speed dial is open
 *             }
 *           }}
 *         />
 *       </Portal>
 *     </Provider>
 *   );
 * };
 *
 * export default MyComponent;
 * ```
 */
const FABGroup = _ref => {
  let {
    actions,
    icon,
    open,
    onPress,
    accessibilityLabel,
    theme,
    style,
    fabStyle,
    visible,
    testID,
    onStateChange,
    color: colorProp
  } = _ref;
  const {
    current: backdrop
  } = React__namespace.useRef(new reactNative.Animated.Value(0));
  const animations = React__namespace.useRef(actions.map(() => new reactNative.Animated.Value(open ? 1 : 0)));
  const [prevActions, setPrevActions] = React__namespace.useState(null);
  const {
    scale
  } = theme.animation;
  React__namespace.useEffect(() => {
    if (open) {
      reactNative.Animated.parallel([reactNative.Animated.timing(backdrop, {
        toValue: 1,
        duration: 250 * scale,
        useNativeDriver: true
      }), reactNative.Animated.stagger(50 * scale, animations.current.map(animation => reactNative.Animated.timing(animation, {
        toValue: 1,
        duration: 150 * scale,
        useNativeDriver: true
      })).reverse())]).start();
    } else {
      reactNative.Animated.parallel([reactNative.Animated.timing(backdrop, {
        toValue: 0,
        duration: 200 * scale,
        useNativeDriver: true
      }), ...animations.current.map(animation => reactNative.Animated.timing(animation, {
        toValue: 0,
        duration: 150 * scale,
        useNativeDriver: true
      }))]).start();
    }
  }, [open, actions, backdrop, scale]);

  const close = () => onStateChange({
    open: false
  });

  const toggle = () => onStateChange({
    open: !open
  });

  const {
    colors
  } = theme;
  const labelColor = theme.dark ? colors.text : color$1(colors.text).fade(0.54).rgb().string();
  const backdropOpacity = open ? backdrop.interpolate({
    inputRange: [0, 0.5, 1],
    outputRange: [0, 1, 1]
  }) : backdrop;
  const opacities = animations.current;
  const scales = opacities.map(opacity => open ? opacity.interpolate({
    inputRange: [0, 1],
    outputRange: [0.8, 1]
  }) : 1);

  if (actions.length !== (prevActions === null || prevActions === void 0 ? void 0 : prevActions.length)) {
    animations.current = actions.map((_, i) => animations.current[i] || new reactNative.Animated.Value(open ? 1 : 0));
    setPrevActions(actions);
  }

  return /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    pointerEvents: "box-none",
    style: [styles$l.container, style]
  }, /*#__PURE__*/React__namespace.createElement(reactNative.TouchableWithoutFeedback, {
    onPress: close
  }, /*#__PURE__*/React__namespace.createElement(reactNative.Animated.View, {
    pointerEvents: open ? 'auto' : 'none',
    style: [styles$l.backdrop, {
      opacity: backdropOpacity,
      backgroundColor: colors.backdrop
    }]
  })), /*#__PURE__*/React__namespace.createElement(reactNative.SafeAreaView, {
    pointerEvents: "box-none",
    style: styles$l.safeArea
  }, /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    pointerEvents: open ? 'box-none' : 'none'
  }, actions.map((it, i) => {
    var _it$labelTextColor;

    return /*#__PURE__*/React__namespace.createElement(reactNative.View, {
      key: i // eslint-disable-line react/no-array-index-key
      ,
      style: [styles$l.item, {
        marginHorizontal: typeof it.small === 'undefined' || it.small ? 24 : 16
      }],
      pointerEvents: open ? 'box-none' : 'none'
    }, it.label && /*#__PURE__*/React__namespace.createElement(reactNative.View, null, /*#__PURE__*/React__namespace.createElement(Card$1, {
      style: [styles$l.label, {
        transform: [{
          scale: scales[i]
        }],
        opacity: opacities[i]
      }, it.labelStyle],
      onPress: () => {
        it.onPress();
        close();
      },
      accessibilityLabel: it.accessibilityLabel !== 'undefined' ? it.accessibilityLabel : it.label // @ts-expect-error We keep old a11y props for backwards compat with old RN versions
      ,
      accessibilityTraits: "button",
      accessibilityComponentType: "button",
      accessibilityRole: "button"
    }, /*#__PURE__*/React__namespace.createElement(Text$1, {
      style: {
        color: (_it$labelTextColor = it.labelTextColor) !== null && _it$labelTextColor !== void 0 ? _it$labelTextColor : labelColor
      }
    }, it.label))), /*#__PURE__*/React__namespace.createElement(FABComponent, {
      small: typeof it.small !== 'undefined' ? it.small : true,
      icon: it.icon,
      color: it.color,
      style: [{
        transform: [{
          scale: scales[i]
        }],
        opacity: opacities[i],
        backgroundColor: theme.colors.surface
      }, it.style],
      onPress: () => {
        it.onPress();
        close();
      },
      accessibilityLabel: typeof it.accessibilityLabel !== 'undefined' ? it.accessibilityLabel : it.label // @ts-expect-error We keep old a11y props for backwards compat with old RN versions
      ,
      accessibilityTraits: "button",
      accessibilityComponentType: "button",
      accessibilityRole: "button",
      testID: it.testID,
      visible: open
    }));
  })), /*#__PURE__*/React__namespace.createElement(FABComponent, {
    onPress: () => {
      onPress === null || onPress === void 0 ? void 0 : onPress();
      toggle();
    },
    icon: icon,
    color: colorProp,
    accessibilityLabel: accessibilityLabel // @ts-expect-error We keep old a11y props for backwards compat with old RN versions
    ,
    accessibilityTraits: "button",
    accessibilityComponentType: "button",
    accessibilityRole: "button",
    accessibilityState: {
      expanded: open
    },
    style: [styles$l.fab, fabStyle],
    visible: visible,
    testID: testID
  })));
};

FABGroup.displayName = 'FAB.Group';
var FABGroup$1 = withTheme(FABGroup); // @component-docs ignore-next-line

withTheme(FABGroup); // @component-docs ignore-next-line
const styles$l = reactNative.StyleSheet.create({
  safeArea: {
    alignItems: 'flex-end'
  },
  container: { ...reactNative.StyleSheet.absoluteFillObject,
    justifyContent: 'flex-end'
  },
  fab: {
    marginHorizontal: 16,
    marginBottom: 16,
    marginTop: 0
  },
  backdrop: { ...reactNative.StyleSheet.absoluteFillObject
  },
  label: {
    borderRadius: 5,
    paddingHorizontal: 12,
    paddingVertical: 6,
    marginVertical: 8,
    marginHorizontal: 16,
    elevation: 2
  },
  item: {
    marginBottom: 16,
    flexDirection: 'row',
    justifyContent: 'flex-end',
    alignItems: 'center'
  }
});

Object.assign( // @component ./FAB.tsx
FABComponent, {
  // @component ./FABGroup.tsx
  Group: FABGroup$1
});

function _extends$g() { _extends$g = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$g.apply(this, arguments); }

/**
 * Helper text is used in conjuction with input elements to provide additional hints for the user.
 *
 * <div class="screenshots">
 *   <img class="medium" src="screenshots/helper-text.gif" />
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { View } from 'react-native';
 * import { HelperText, TextInput } from 'react-native-paper';
 *
 * const MyComponent = () => {
 *   const [text, setText] = React.useState('');
 *
 *    const onChangeText = text => setText(text);
 *
 *   const hasErrors = () => {
 *     return !text.includes('@');
 *   };
 *
 *  return (
 *     <View>
 *       <TextInput label="Email" value={text} onChangeText={onChangeText} />
 *       <HelperText type="error" visible={hasErrors()}>
 *         Email address is invalid!
 *       </HelperText>
 *     </View>
 *   );
 * };
 *
 * export default MyComponent;
 * ```
 */
const HelperText = _ref => {
  let {
    style,
    type = 'info',
    visible = true,
    theme,
    onLayout,
    padding = 'normal',
    ...rest
  } = _ref;
  const {
    current: shown
  } = React__namespace.useRef(new reactNative.Animated.Value(visible ? 1 : 0));
  let {
    current: textHeight
  } = React__namespace.useRef(0);
  const {
    scale
  } = theme.animation;
  const {
    maxFontSizeMultiplier = 1.5
  } = rest;
  React__namespace.useEffect(() => {
    if (visible) {
      // show text
      reactNative.Animated.timing(shown, {
        toValue: 1,
        duration: 150 * scale,
        useNativeDriver: true
      }).start();
    } else {
      // hide text
      reactNative.Animated.timing(shown, {
        toValue: 0,
        duration: 180 * scale,
        useNativeDriver: true
      }).start();
    }
  }, [visible, scale, shown]);

  const handleTextLayout = e => {
    onLayout === null || onLayout === void 0 ? void 0 : onLayout(e);
    textHeight = e.nativeEvent.layout.height;
  };

  const {
    colors,
    dark
  } = theme;
  const textColor = type === 'error' ? colors.error : color$1(colors.text).alpha(dark ? 0.7 : 0.54).rgb().string();
  return /*#__PURE__*/React__namespace.createElement(AnimatedText$1, _extends$g({
    onLayout: handleTextLayout,
    style: [styles$k.text, padding !== 'none' ? styles$k.padding : {}, {
      color: textColor,
      opacity: shown,
      transform: visible && type === 'error' ? [{
        translateY: shown.interpolate({
          inputRange: [0, 1],
          outputRange: [-textHeight / 2, 0]
        })
      }] : []
    }, style],
    maxFontSizeMultiplier: maxFontSizeMultiplier
  }, rest), rest.children);
};

const styles$k = reactNative.StyleSheet.create({
  text: {
    fontSize: 12,
    paddingVertical: 4
  },
  padding: {
    paddingHorizontal: 12
  }
});
withTheme(HelperText);

function _extends$f() { _extends$f = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$f.apply(this, arguments); }
const INDETERMINATE_DURATION = 2000;
const INDETERMINATE_MAX_WIDTH = 0.6;
const {
  isRTL
} = reactNative.I18nManager;
/**
 * Progress bar is an indicator used to present progress of some activity in the app.
 *
 * <div class="screenshots">
 *   <img src="screenshots/progress-bar.png" />
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { ProgressBar, Colors } from 'react-native-paper';
 *
 * const MyComponent = () => (
 *   <ProgressBar progress={0.5} color={Colors.red800} />
 * );
 *
 * export default MyComponent;
 * ```
 */

const ProgressBar = _ref => {
  let {
    color,
    indeterminate,
    style,
    progress = 0,
    visible = true,
    theme,
    ...rest
  } = _ref;
  const {
    current: timer
  } = React__namespace.useRef(new reactNative.Animated.Value(0));
  const {
    current: fade
  } = React__namespace.useRef(new reactNative.Animated.Value(0));
  const [width, setWidth] = React__namespace.useState(0);
  const [prevWidth, setPrevWidth] = React__namespace.useState(0);
  const indeterminateAnimation = React__namespace.useRef(null);
  const {
    scale
  } = theme.animation;
  const startAnimation = React__namespace.useCallback(() => {
    // Show progress bar
    reactNative.Animated.timing(fade, {
      duration: 200 * scale,
      toValue: 1,
      useNativeDriver: true,
      isInteraction: false
    }).start(); // Animate progress bar

    if (indeterminate) {
      if (!indeterminateAnimation.current) {
        indeterminateAnimation.current = reactNative.Animated.timing(timer, {
          duration: INDETERMINATE_DURATION,
          toValue: 1,
          // Animated.loop does not work if useNativeDriver is true on web
          useNativeDriver: reactNative.Platform.OS !== 'web',
          isInteraction: false
        });
      } // Reset timer to the beginning


      timer.setValue(0);
      reactNative.Animated.loop(indeterminateAnimation.current).start();
    } else {
      reactNative.Animated.timing(timer, {
        duration: 200 * scale,
        toValue: progress ? progress : 0,
        useNativeDriver: true,
        isInteraction: false
      }).start();
    }
  }, [scale, timer, progress, indeterminate, fade]);
  const stopAnimation = React__namespace.useCallback(() => {
    // Stop indeterminate animation
    if (indeterminateAnimation.current) {
      indeterminateAnimation.current.stop();
    }

    reactNative.Animated.timing(fade, {
      duration: 200 * scale,
      toValue: 0,
      useNativeDriver: true,
      isInteraction: false
    }).start();
  }, [fade, scale]);
  React__namespace.useEffect(() => {
    if (visible) startAnimation();else stopAnimation();
  }, [visible, startAnimation, stopAnimation]);
  React__namespace.useEffect(() => {
    // Start animation the very first time when previously the width was unclear
    if (visible && prevWidth === 0) {
      startAnimation();
    }
  }, [prevWidth, startAnimation, visible]);

  const onLayout = event => {
    setPrevWidth(width);
    setWidth(event.nativeEvent.layout.width);
  };

  const tintColor = color || theme.colors.primary;
  const trackTintColor = color$1(tintColor).alpha(0.38).rgb().string();
  return /*#__PURE__*/React__namespace.createElement(reactNative.View, _extends$f({
    onLayout: onLayout
  }, rest, {
    accessible: true,
    accessibilityRole: "progressbar",
    accessibilityState: {
      busy: visible
    },
    accessibilityValue: indeterminate ? {} : {
      min: 0,
      max: 100,
      now: progress * 100
    }
  }), /*#__PURE__*/React__namespace.createElement(reactNative.Animated.View, {
    style: [styles$j.container, {
      backgroundColor: trackTintColor,
      opacity: fade
    }, style]
  }, width ? /*#__PURE__*/React__namespace.createElement(reactNative.Animated.View, {
    style: [styles$j.progressBar, {
      width,
      backgroundColor: tintColor,
      transform: [{
        translateX: timer.interpolate(indeterminate ? {
          inputRange: [0, 0.5, 1],
          outputRange: [(isRTL ? 1 : -1) * 0.5 * width, (isRTL ? 1 : -1) * 0.5 * INDETERMINATE_MAX_WIDTH * width, (isRTL ? -1 : 1) * 0.7 * width]
        } : {
          inputRange: [0, 1],
          outputRange: [(isRTL ? 1 : -1) * 0.5 * width, 0]
        })
      }, {
        // Workaround for workaround for https://github.com/facebook/react-native/issues/6278
        scaleX: timer.interpolate(indeterminate ? {
          inputRange: [0, 0.5, 1],
          outputRange: [0.0001, INDETERMINATE_MAX_WIDTH, 0.0001]
        } : {
          inputRange: [0, 1],
          outputRange: [0.0001, 1]
        })
      }]
    }]
  }) : null));
};

const styles$j = reactNative.StyleSheet.create({
  container: {
    height: 4,
    overflow: 'hidden'
  },
  progressBar: {
    flex: 1
  }
});
withTheme(ProgressBar);

const RadioButtonContext = /*#__PURE__*/React__namespace.createContext(null);
/**
 * Radio button group allows to control a group of radio buttons.
 *
 * <div class="screenshots">
 *   <figure>
 *     <img class="medium" src="screenshots/radio-button-group-android.gif" />
 *  <figcaption>Android</figcaption>
 *   </figure>
 *   <figure>
 *     <img class="medium" src="screenshots/radio-button-group-ios.gif" />
 *  <figcaption>iOS</figcaption>
 *   </figure>
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { View } from 'react-native';
 * import { RadioButton, Text } from 'react-native-paper';
 *
 * const MyComponent = () => {
 *   const [value, setValue] = React.useState('first');
 *
 *   return (
 *     <RadioButton.Group onValueChange={newValue => setValue(newValue)} value={value}>
 *       <View>
 *         <Text>First</Text>
 *         <RadioButton value="first" />
 *       </View>
 *       <View>
 *         <Text>Second</Text>
 *         <RadioButton value="second" />
 *       </View>
 *     </RadioButton.Group>
 *   );
 * };
 *
 * export default MyComponent;
 *```
 */

const RadioButtonGroup = _ref => {
  let {
    value,
    onValueChange,
    children
  } = _ref;
  return /*#__PURE__*/React__namespace.createElement(RadioButtonContext.Provider, {
    value: {
      value,
      onValueChange
    }
  }, /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    accessibilityRole: "radiogroup"
  }, children));
};

RadioButtonGroup.displayName = 'RadioButton.Group';

const handlePress = _ref => {
  let {
    onPress,
    value,
    onValueChange
  } = _ref;

  if (onPress && onValueChange) {
    console.warn(`onPress in the scope of RadioButtonGroup will not be executed, use onValueChange instead`);
  }

  onValueChange ? onValueChange(value) : onPress === null || onPress === void 0 ? void 0 : onPress();
};
const isChecked = _ref2 => {
  let {
    value,
    status,
    contextValue
  } = _ref2;

  if (contextValue !== undefined && contextValue !== null) {
    return contextValue === value ? 'checked' : 'unchecked';
  } else {
    return status;
  }
};

function _extends$e() { _extends$e = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$e.apply(this, arguments); }
const BORDER_WIDTH = 2;
/**
 * Radio buttons allow the selection a single option from a set.
 * This component follows platform guidelines for Android, but can be used
 * on any platform.
 *
 * <div class="screenshots">
 *   <figure>
 *     <img src="screenshots/radio-enabled.android.png" />
 *     <figcaption>Enabled</figcaption>
 *   </figure>
 *   <figure>
 *     <img src="screenshots/radio-disabled.android.png" />
 *     <figcaption>Disabled</figcaption>
 *   </figure>
 * </div>
 */

const RadioButtonAndroid = _ref => {
  let {
    disabled,
    onPress,
    theme,
    value,
    status,
    testID,
    ...rest
  } = _ref;
  const {
    current: borderAnim
  } = React__namespace.useRef(new reactNative.Animated.Value(BORDER_WIDTH));
  const {
    current: radioAnim
  } = React__namespace.useRef(new reactNative.Animated.Value(1));
  const isFirstRendering = React__namespace.useRef(true);
  const {
    scale
  } = theme.animation;
  React__namespace.useEffect(() => {
    // Do not run animation on very first rendering
    if (isFirstRendering.current) {
      isFirstRendering.current = false;
      return;
    }

    if (status === 'checked') {
      radioAnim.setValue(1.2);
      reactNative.Animated.timing(radioAnim, {
        toValue: 1,
        duration: 150 * scale,
        useNativeDriver: true
      }).start();
    } else {
      borderAnim.setValue(10);
      reactNative.Animated.timing(borderAnim, {
        toValue: BORDER_WIDTH,
        duration: 150 * scale,
        useNativeDriver: false
      }).start();
    }
  }, [status, borderAnim, radioAnim, scale]);
  const checkedColor = rest.color || theme.colors.accent;
  const uncheckedColor = rest.uncheckedColor || color$1(theme.colors.text).alpha(theme.dark ? 0.7 : 0.54).rgb().string();
  let rippleColor, radioColor;
  return /*#__PURE__*/React__namespace.createElement(RadioButtonContext.Consumer, null, context => {
    const checked = isChecked({
      contextValue: context === null || context === void 0 ? void 0 : context.value,
      status,
      value
    }) === 'checked';

    if (disabled) {
      rippleColor = color$1(theme.colors.text).alpha(0.16).rgb().string();
      radioColor = theme.colors.disabled;
    } else {
      rippleColor = color$1(checkedColor).fade(0.32).rgb().string();
      radioColor = checked ? checkedColor : uncheckedColor;
    }

    return /*#__PURE__*/React__namespace.createElement(TouchableRipple$1, _extends$e({}, rest, {
      borderless: true,
      rippleColor: rippleColor,
      onPress: disabled ? undefined : () => {
        handlePress({
          onPress,
          onValueChange: context === null || context === void 0 ? void 0 : context.onValueChange,
          value
        });
      } // @ts-expect-error We keep old a11y props for backwards compat with old RN versions
      ,
      accessibilityTraits: disabled ? ['button', 'disabled'] : 'button',
      accessibilityComponentType: checked ? 'radiobutton_checked' : 'radiobutton_unchecked',
      accessibilityRole: "radio",
      accessibilityState: {
        disabled,
        checked
      },
      accessibilityLiveRegion: "polite",
      style: styles$i.container,
      testID: testID
    }), /*#__PURE__*/React__namespace.createElement(reactNative.Animated.View, {
      style: [styles$i.radio, {
        borderColor: radioColor,
        borderWidth: borderAnim
      }]
    }, checked ? /*#__PURE__*/React__namespace.createElement(reactNative.View, {
      style: [reactNative.StyleSheet.absoluteFill, styles$i.radioContainer]
    }, /*#__PURE__*/React__namespace.createElement(reactNative.Animated.View, {
      style: [styles$i.dot, {
        backgroundColor: radioColor,
        transform: [{
          scale: radioAnim
        }]
      }]
    })) : null));
  });
};

RadioButtonAndroid.displayName = 'RadioButton.Android';
const styles$i = reactNative.StyleSheet.create({
  container: {
    borderRadius: 18
  },
  radioContainer: {
    alignItems: 'center',
    justifyContent: 'center'
  },
  radio: {
    height: 20,
    width: 20,
    borderRadius: 10,
    margin: 8
  },
  dot: {
    height: 10,
    width: 10,
    borderRadius: 5
  }
});
var RadioButtonAndroid$1 = withTheme(RadioButtonAndroid); // @component-docs ignore-next-line

withTheme(RadioButtonAndroid); // @component-docs ignore-next-line

function _extends$d() { _extends$d = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$d.apply(this, arguments); }

/**
 * Radio buttons allow the selection a single option from a set.
 * This component follows platform guidelines for iOS, but can be used
 * on any platform.
 *
 * <div class="screenshots">
 *   <figure>
 *     <img src="screenshots/radio-enabled.ios.png" />
 *     <figcaption>Enabled</figcaption>
 *   </figure>
 *   <figure>
 *     <img src="screenshots/radio-disabled.ios.png" />
 *     <figcaption>Disabled</figcaption>
 *   </figure>
 * </div>
 */
const RadioButtonIOS = _ref => {
  let {
    disabled,
    onPress,
    theme,
    status,
    value,
    testID,
    ...rest
  } = _ref;
  const checkedColor = disabled ? theme.colors.disabled : rest.color || theme.colors.accent;
  let rippleColor;

  if (disabled) {
    rippleColor = color$1(theme.colors.text).alpha(0.16).rgb().string();
  } else {
    rippleColor = color$1(checkedColor).fade(0.32).rgb().string();
  }

  return /*#__PURE__*/React__namespace.createElement(RadioButtonContext.Consumer, null, context => {
    const checked = isChecked({
      contextValue: context === null || context === void 0 ? void 0 : context.value,
      status,
      value
    }) === 'checked';
    return /*#__PURE__*/React__namespace.createElement(TouchableRipple$1, _extends$d({}, rest, {
      borderless: true,
      rippleColor: rippleColor,
      onPress: disabled ? undefined : () => {
        handlePress({
          onPress,
          value,
          onValueChange: context === null || context === void 0 ? void 0 : context.onValueChange
        });
      } // @ts-expect-error We keep old a11y props for backwards compat with old RN versions
      ,
      accessibilityTraits: disabled ? ['button', 'disabled'] : 'button',
      accessibilityComponentType: checked ? 'radiobutton_checked' : 'radiobutton_unchecked',
      accessibilityRole: "radio",
      accessibilityState: {
        disabled,
        checked
      },
      accessibilityLiveRegion: "polite",
      style: styles$h.container,
      testID: testID
    }), /*#__PURE__*/React__namespace.createElement(reactNative.View, {
      style: {
        opacity: checked ? 1 : 0
      }
    }, /*#__PURE__*/React__namespace.createElement(defaultIcon, {
      allowFontScaling: false,
      name: "check",
      size: 24,
      color: checkedColor,
      direction: "ltr"
    })));
  });
};

RadioButtonIOS.displayName = 'RadioButton.IOS';
const styles$h = reactNative.StyleSheet.create({
  container: {
    borderRadius: 18,
    padding: 6
  }
});
var RadioButtonIOS$1 = withTheme(RadioButtonIOS); // @component-docs ignore-next-line

withTheme(RadioButtonIOS); // @component-docs ignore-next-line

/**
 * Radio buttons allow the selection a single option from a set.
 *
 * <div class="screenshots">
 *   <figure>
 *     <img src="screenshots/radio-enabled.android.png" />
 *     <figcaption>Android (enabled)</figcaption>
 *   </figure>
 *   <figure>
 *     <img src="screenshots/radio-disabled.android.png" />
 *     <figcaption>Android (disabled)</figcaption>
 *   </figure>
 *   <figure>
 *     <img src="screenshots/radio-enabled.ios.png" />
 *     <figcaption>iOS (enabled)</figcaption>
 *   </figure>
 *   <figure>
 *     <img src="screenshots/radio-disabled.ios.png" />
 *     <figcaption>iOS (disabled)</figcaption>
 *   </figure>
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { View } from 'react-native';
 * import { RadioButton } from 'react-native-paper';
 *
 * const MyComponent = () => {
 *   const [checked, setChecked] = React.useState('first');
 *
 *   return (
 *     <View>
 *       <RadioButton
 *         value="first"
 *         status={ checked === 'first' ? 'checked' : 'unchecked' }
 *         onPress={() => setChecked('first')}
 *       />
 *       <RadioButton
 *         value="second"
 *         status={ checked === 'second' ? 'checked' : 'unchecked' }
 *         onPress={() => setChecked('second')}
 *       />
 *     </View>
 *   );
 * };
 *
 * export default MyComponent;
 * ```
 */
const RadioButton = props => {
  const Button = reactNative.Platform.select({
    default: RadioButtonAndroid$1,
    ios: RadioButtonIOS$1
  });
  return /*#__PURE__*/React__namespace.createElement(Button, props);
};

var RadioButtonComponent = withTheme(RadioButton); // @component-docs ignore-next-line

withTheme(RadioButton); // @component-docs ignore-next-line

/**
 * RadioButton.Item allows you to press the whole row (item) instead of only the RadioButton.
 *
 * <div class="screenshots">
 *   <figure>
 *     <img class="medium" src="screenshots/radio-item.ios.png" />
 *     <figcaption>Pressed</figcaption>
 *   </figure>
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { RadioButton } from 'react-native-paper';
 *
 * const MyComponent = () => {
 *   const [value, setValue] = React.useState('first');
 *
 *   return (
 *     <RadioButton.Group onValueChange={value => setValue(value)} value={value}>
 *       <RadioButton.Item label="First item" value="first" />
 *       <RadioButton.Item label="Second item" value="second" />
 *     </RadioButton.Group>
 *   );
 * };
 *
 * export default MyComponent;
 *```
 */
const RadioButtonItem = _ref => {
  let {
    value,
    label,
    style,
    labelStyle,
    onPress,
    disabled,
    color,
    uncheckedColor,
    status,
    theme: {
      colors
    },
    accessibilityLabel,
    testID,
    mode,
    position = 'trailing'
  } = _ref;
  const radioButtonProps = {
    value,
    disabled,
    status,
    color,
    uncheckedColor
  };
  const isLeading = position === 'leading';
  let radioButton;

  if (mode === 'android') {
    radioButton = /*#__PURE__*/React__namespace.createElement(RadioButtonAndroid$1, radioButtonProps);
  } else if (mode === 'ios') {
    radioButton = /*#__PURE__*/React__namespace.createElement(RadioButtonIOS$1, radioButtonProps);
  } else {
    radioButton = /*#__PURE__*/React__namespace.createElement(RadioButtonComponent, radioButtonProps);
  }

  return /*#__PURE__*/React__namespace.createElement(RadioButtonContext.Consumer, null, context => {
    return /*#__PURE__*/React__namespace.createElement(TouchableRipple$1, {
      onPress: disabled ? undefined : () => handlePress({
        onPress: onPress,
        onValueChange: context === null || context === void 0 ? void 0 : context.onValueChange,
        value
      }),
      accessibilityLabel: accessibilityLabel,
      testID: testID
    }, /*#__PURE__*/React__namespace.createElement(reactNative.View, {
      style: [styles$g.container, style],
      pointerEvents: "none"
    }, isLeading && radioButton, /*#__PURE__*/React__namespace.createElement(Text$1, {
      style: [styles$g.label, {
        color: colors.text,
        textAlign: isLeading ? 'right' : 'left'
      }, labelStyle]
    }, label), !isLeading && radioButton));
  });
};

RadioButtonItem.displayName = 'RadioButton.Item';
var RadioButtonItem$1 = withTheme(RadioButtonItem); // @component-docs ignore-next-line

withTheme(RadioButtonItem); // @component-docs ignore-next-line
const styles$g = reactNative.StyleSheet.create({
  container: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingVertical: 8,
    paddingHorizontal: 16
  },
  label: {
    fontSize: 16,
    flexShrink: 1,
    flexGrow: 1
  }
});

Object.assign( // @component ./RadioButton.tsx
RadioButtonComponent, {
  // @component ./RadioButtonGroup.tsx
  Group: RadioButtonGroup,
  // @component ./RadioButtonAndroid.tsx
  Android: RadioButtonAndroid$1,
  // @component ./RadioButtonIOS.tsx
  IOS: RadioButtonIOS$1,
  // @component ./RadioButtonItem.tsx
  Item: RadioButtonItem$1
});

function _extends$c() { _extends$c = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$c.apply(this, arguments); }

/**
 * Searchbar is a simple input box where users can type search queries.
 *
 * <div class="screenshots">
 *   <img class="medium" src="screenshots/searchbar.png" />
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { Searchbar } from 'react-native-paper';
 *
 * const MyComponent = () => {
 *   const [searchQuery, setSearchQuery] = React.useState('');
 *
 *   const onChangeSearch = query => setSearchQuery(query);
 *
 *   return (
 *     <Searchbar
 *       placeholder="Search"
 *       onChangeText={onChangeSearch}
 *       value={searchQuery}
 *     />
 *   );
 * };
 *
 * export default MyComponent;

 * ```
 */
const Searchbar = /*#__PURE__*/React__namespace.forwardRef((_ref, ref) => {
  let {
    clearAccessibilityLabel = 'clear',
    clearIcon,
    icon,
    iconColor: customIconColor,
    inputStyle,
    onIconPress,
    placeholder,
    searchAccessibilityLabel = 'search',
    style,
    theme,
    value,
    ...rest
  } = _ref;
  const root = React__namespace.useRef(null);
  React__namespace.useImperativeHandle(ref, () => {
    const input = root.current;

    if (input) {
      return {
        focus: () => input.focus(),
        clear: () => input.clear(),
        setNativeProps: args => input.setNativeProps(args),
        isFocused: () => input.isFocused(),
        blur: () => input.blur()
      };
    }

    const noop = () => {
      throw new Error('TextInput is not available');
    };

    return {
      focus: noop,
      clear: noop,
      setNativeProps: noop,
      isFocused: noop,
      blur: noop
    };
  });

  const handleClearPress = () => {
    var _root$current, _rest$onChangeText;

    (_root$current = root.current) === null || _root$current === void 0 ? void 0 : _root$current.clear();
    (_rest$onChangeText = rest.onChangeText) === null || _rest$onChangeText === void 0 ? void 0 : _rest$onChangeText.call(rest, '');
  };

  const {
    colors,
    roundness,
    dark,
    fonts
  } = theme;
  const textColor = colors.text;
  const font = fonts.regular;
  const iconColor = customIconColor || (dark ? textColor : color$1(textColor).alpha(0.54).rgb().string());
  const rippleColor = color$1(textColor).alpha(0.32).rgb().string();
  return /*#__PURE__*/React__namespace.createElement(Surface$1, {
    style: [{
      borderRadius: roundness,
      elevation: 4
    }, styles$f.container, style]
  }, /*#__PURE__*/React__namespace.createElement(IconButton$1 // @ts-expect-error We keep old a11y props for backwards compat with old RN versions
  , {
    accessibilityTraits: "button",
    accessibilityComponentType: "button",
    accessibilityRole: "button",
    borderless: true,
    rippleColor: rippleColor,
    onPress: onIconPress,
    color: iconColor,
    icon: icon || (_ref2 => {
      let {
        size,
        color
      } = _ref2;
      return /*#__PURE__*/React__namespace.createElement(defaultIcon, {
        name: "magnify",
        color: color,
        size: size,
        direction: reactNative.I18nManager.isRTL ? 'rtl' : 'ltr'
      });
    }),
    accessibilityLabel: searchAccessibilityLabel
  }), /*#__PURE__*/React__namespace.createElement(reactNative.TextInput, _extends$c({
    style: [styles$f.input, {
      color: textColor,
      ...font,
      ...reactNative.Platform.select({
        web: {
          outline: 'none'
        }
      })
    }, inputStyle],
    placeholder: placeholder || '',
    placeholderTextColor: colors.placeholder,
    selectionColor: colors.primary,
    underlineColorAndroid: "transparent",
    returnKeyType: "search",
    keyboardAppearance: dark ? 'dark' : 'light' // @ts-expect-error We keep old a11y props for backwards compat with old RN versions
    ,
    accessibilityTraits: "search",
    accessibilityRole: "search",
    ref: root,
    value: value
  }, rest)), /*#__PURE__*/React__namespace.createElement(IconButton$1, {
    borderless: true,
    disabled: !value,
    accessibilityLabel: clearAccessibilityLabel,
    color: value ? iconColor : 'rgba(255, 255, 255, 0)',
    rippleColor: rippleColor,
    onPress: handleClearPress,
    icon: clearIcon || (_ref3 => {
      let {
        size,
        color
      } = _ref3;
      return /*#__PURE__*/React__namespace.createElement(defaultIcon, {
        name: "close",
        color: color,
        size: size,
        direction: reactNative.I18nManager.isRTL ? 'rtl' : 'ltr'
      });
    }) // @ts-expect-error We keep old a11y props for backwards compat with old RN versions
    ,
    accessibilityTraits: "button",
    accessibilityComponentType: "button",
    accessibilityRole: "button"
  }));
});
const styles$f = reactNative.StyleSheet.create({
  container: {
    flexDirection: 'row',
    alignItems: 'center'
  },
  input: {
    flex: 1,
    fontSize: 18,
    paddingLeft: 8,
    alignSelf: 'stretch',
    textAlign: reactNative.I18nManager.isRTL ? 'right' : 'left',
    minWidth: 0
  }
});
withTheme(Searchbar);

function _extends$b() { _extends$b = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$b.apply(this, arguments); }
const DURATION_SHORT = 4000;
const DURATION_MEDIUM = 7000;
const DURATION_LONG = 10000;
/**
 * Snackbars provide brief feedback about an operation through a message at the bottom of the screen.
 * Snackbar by default uses `onSurface` color from theme.
 * <div class="screenshots">
 *   <img class="medium" src="screenshots/snackbar.gif" />
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { View, StyleSheet } from 'react-native';
 * import { Button, Snackbar } from 'react-native-paper';
 *
 * const MyComponent = () => {
 *   const [visible, setVisible] = React.useState(false);
 *
 *   const onToggleSnackBar = () => setVisible(!visible);
 *
 *   const onDismissSnackBar = () => setVisible(false);
 *
 *   return (
 *     <View style={styles.container}>
 *       <Button onPress={onToggleSnackBar}>{visible ? 'Hide' : 'Show'}</Button>
 *       <Snackbar
 *         visible={visible}
 *         onDismiss={onDismissSnackBar}
 *         action={{
 *           label: 'Undo',
 *           onPress: () => {
 *             // Do something
 *           },
 *         }}>
 *         Hey there! I'm a Snackbar.
 *       </Snackbar>
 *     </View>
 *   );
 * };
 *
 * const styles = StyleSheet.create({
 *   container: {
 *     flex: 1,
 *     justifyContent: 'space-between',
 *   },
 * });
 *
 * export default MyComponent;
 * ```
 */

const Snackbar = _ref => {
  let {
    visible,
    action,
    duration = DURATION_MEDIUM,
    onDismiss,
    children,
    wrapperStyle,
    style,
    theme,
    ...rest
  } = _ref;
  const {
    current: opacity
  } = React__namespace.useRef(new reactNative.Animated.Value(0.0));
  const [hidden, setHidden] = React__namespace.useState(!visible);
  const hideTimeout = React__namespace.useRef(undefined);
  const {
    scale
  } = theme.animation;
  React__namespace.useEffect(() => {
    return () => {
      if (hideTimeout.current) clearTimeout(hideTimeout.current);
    };
  }, []);
  React__namespace.useLayoutEffect(() => {
    if (visible) {
      // show
      if (hideTimeout.current) clearTimeout(hideTimeout.current);
      setHidden(false);
      reactNative.Animated.timing(opacity, {
        toValue: 1,
        duration: 200 * scale,
        useNativeDriver: true
      }).start(_ref2 => {
        let {
          finished
        } = _ref2;

        if (finished) {
          const isInfinity = duration === Number.POSITIVE_INFINITY || duration === Number.NEGATIVE_INFINITY;

          if (finished && !isInfinity) {
            hideTimeout.current = setTimeout(onDismiss, duration);
          }
        }
      });
    } else {
      // hide
      if (hideTimeout.current) clearTimeout(hideTimeout.current);
      reactNative.Animated.timing(opacity, {
        toValue: 0,
        duration: 100 * scale,
        useNativeDriver: true
      }).start(_ref3 => {
        let {
          finished
        } = _ref3;
        if (finished) setHidden(true);
      });
    }
  }, [visible, duration, opacity, scale, onDismiss]);
  const {
    colors,
    roundness
  } = theme;
  if (hidden) return null;
  const {
    style: actionStyle,
    label: actionLabel,
    onPress: onPressAction,
    ...actionProps
  } = action || {};
  return /*#__PURE__*/React__namespace.createElement(reactNative.SafeAreaView, {
    pointerEvents: "box-none",
    style: [styles$e.wrapper, wrapperStyle]
  }, /*#__PURE__*/React__namespace.createElement(Surface$1, _extends$b({
    pointerEvents: "box-none",
    accessibilityLiveRegion: "polite",
    style: [styles$e.container, {
      borderRadius: roundness,
      opacity: opacity,
      transform: [{
        scale: visible ? opacity.interpolate({
          inputRange: [0, 1],
          outputRange: [0.9, 1]
        }) : 1
      }]
    }, {
      backgroundColor: colors.onSurface
    }, style]
  }, rest), /*#__PURE__*/React__namespace.createElement(Text$1, {
    style: [styles$e.content, {
      marginRight: action ? 0 : 16,
      color: colors.surface
    }]
  }, children), action ? /*#__PURE__*/React__namespace.createElement(Button$1, _extends$b({
    onPress: () => {
      onPressAction === null || onPressAction === void 0 ? void 0 : onPressAction();
      onDismiss();
    },
    style: [styles$e.button, actionStyle],
    color: colors.accent,
    compact: true,
    mode: "text"
  }, actionProps), actionLabel) : null));
};
/**
 * Show the Snackbar for a short duration.
 */


Snackbar.DURATION_SHORT = DURATION_SHORT;
/**
 * Show the Snackbar for a medium duration.
 */

Snackbar.DURATION_MEDIUM = DURATION_MEDIUM;
/**
 * Show the Snackbar for a long duration.
 */

Snackbar.DURATION_LONG = DURATION_LONG;
const styles$e = reactNative.StyleSheet.create({
  wrapper: {
    position: 'absolute',
    bottom: 0,
    width: '100%'
  },
  container: {
    elevation: 6,
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    margin: 8,
    borderRadius: 4
  },
  content: {
    marginLeft: 16,
    marginVertical: 14,
    flexWrap: 'wrap',
    flex: 1
  },
  button: {
    marginHorizontal: 8,
    marginVertical: 6
  }
});
withTheme(Snackbar);

function _extends$a() { _extends$a = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$a.apply(this, arguments); }
const version = reactNative.NativeModules.PlatformConstants ? reactNative.NativeModules.PlatformConstants.reactNativeVersion : undefined;

/**
 * Switch is a visual toggle between two mutually exclusive states — on and off.
 *
 * <div class="screenshots">
 *   <figure>
 *     <img src="screenshots/switch-enabled.android.png" />
 *     <figcaption>Android (enabled)</figcaption>
 *   </figure>
 *   <figure>
 *     <img src="screenshots/switch-disabled.android.png" />
 *     <figcaption>Android (disabled)</figcaption>
 *   </figure>
 *   <figure>
 *     <img src="screenshots/switch-enabled.ios.png" />
 *     <figcaption>iOS (enabled)</figcaption>
 *   </figure>
 *   <figure>
 *     <img src="screenshots/switch-disabled.ios.png" />
 *     <figcaption>iOS (disabled)</figcaption>
 *   </figure>
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { Switch } from 'react-native-paper';
 *
 * const MyComponent = () => {
 *   const [isSwitchOn, setIsSwitchOn] = React.useState(false);
 *
 *   const onToggleSwitch = () => setIsSwitchOn(!isSwitchOn);
 *
 *   return <Switch value={isSwitchOn} onValueChange={onToggleSwitch} />;
 * };
 *
 * export default MyComponent;
 * ```
 */
const Switch = _ref => {
  let {
    value,
    disabled,
    onValueChange,
    color,
    theme,
    ...rest
  } = _ref;
  const checkedColor = color || theme.colors.accent;
  const onTintColor = reactNative.Platform.OS === 'ios' ? checkedColor : disabled ? theme.dark ? color$1(white).alpha(0.1).rgb().string() : color$1(black).alpha(0.12).rgb().string() : color$1(checkedColor).alpha(0.5).rgb().string();
  const thumbTintColor = reactNative.Platform.OS === 'ios' ? undefined : disabled ? theme.dark ? grey800 : grey400 : value ? checkedColor : theme.dark ? grey400 : grey50;
  const props = version && version.major === 0 && version.minor <= 56 ? {
    onTintColor,
    thumbTintColor
  } : reactNative.Platform.OS === 'web' ? {
    activeTrackColor: onTintColor,
    thumbColor: thumbTintColor,
    activeThumbColor: checkedColor
  } : {
    thumbColor: thumbTintColor,
    trackColor: {
      true: onTintColor,
      false: ''
    }
  };
  return /*#__PURE__*/React__namespace.createElement(reactNative.Switch, _extends$a({
    value: value,
    disabled: disabled,
    onValueChange: disabled ? undefined : onValueChange
  }, props, rest));
};

withTheme(Switch);

function _extends$9() { _extends$9 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$9.apply(this, arguments); }

/**
 * A component used to display a title and optional subtitle in an appbar.
 *
 * <div class="screenshots">
 *   <figure>
 *     <img class="medium" src="screenshots/appbar-content.png" />
 *   </figure>
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { Appbar } from 'react-native-paper';
 *
 * const MyComponent = () => (
 *     <Appbar.Header>
 *        <Appbar.Content title="Title" subtitle={'Subtitle'} />
 *     </Appbar.Header>
 * );
 *
 * export default MyComponent;
 * ```
 */
const AppbarContent = _ref => {
  let {
    color: titleColor = white,
    subtitle,
    subtitleStyle,
    onPress,
    style,
    titleRef,
    titleStyle,
    theme,
    title,
    ...rest
  } = _ref;
  const {
    fonts
  } = theme;
  const subtitleColor = color$1(titleColor).alpha(0.7).rgb().string();
  return /*#__PURE__*/React__namespace.createElement(reactNative.TouchableWithoutFeedback, {
    onPress: onPress,
    disabled: !onPress
  }, /*#__PURE__*/React__namespace.createElement(reactNative.View, _extends$9({
    style: [styles$d.container, style]
  }, rest), /*#__PURE__*/React__namespace.createElement(Text$1, {
    ref: titleRef,
    style: [{
      color: titleColor,
      ...(reactNative.Platform.OS === 'ios' ? fonts.regular : fonts.medium)
    }, styles$d.title, titleStyle],
    numberOfLines: 1,
    accessible: true,
    accessibilityTraits: "header" // @ts-expect-error React Native doesn't accept 'heading' as it's web-only
    ,
    accessibilityRole: reactNative.Platform.OS === 'web' ? 'heading' : 'header'
  }, title), subtitle ? /*#__PURE__*/React__namespace.createElement(Text$1, {
    style: [styles$d.subtitle, {
      color: subtitleColor
    }, subtitleStyle],
    numberOfLines: 1
  }, subtitle) : null));
};

AppbarContent.displayName = 'Appbar.Content';
const styles$d = reactNative.StyleSheet.create({
  container: {
    flex: 1,
    paddingHorizontal: 12
  },
  title: {
    fontSize: reactNative.Platform.OS === 'ios' ? 17 : 20
  },
  subtitle: {
    fontSize: reactNative.Platform.OS === 'ios' ? 11 : 14
  }
});
var AppbarContent$1 = withTheme(AppbarContent); // @component-docs ignore-next-line

withTheme(AppbarContent); // @component-docs ignore-next-line

function _extends$8() { _extends$8 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$8.apply(this, arguments); }

/**
 * A component used to display an action item in the appbar.
 * <div class="screenshots">
 *   <figure>
 *     <img class="medium" src="screenshots/appbar-action-android.png" />
 *       <figcaption>Android</figcaption>
 *   </figure>
 * </div>
 *
 * <div class="screenshots">
 *   <figure>
 *     <img class="medium" src="screenshots/appbar-action-ios.png" />
 *       <figcaption>iOS</figcaption>
 *   </figure>
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { Appbar } from 'react-native-paper';
 * import { Platform } from 'react-native';
 *
 * const MORE_ICON = Platform.OS === 'ios' ? 'dots-horizontal' : 'dots-vertical';
 *
 * const MyComponent = () => (
 *     <Appbar.Header>
 *        <Appbar.Content title="Title" subtitle={'Subtitle'} />
 *         <Appbar.Action icon="magnify" onPress={() => {}} />
 *         <Appbar.Action icon={MORE_ICON} onPress={() => {}} />
 *     </Appbar.Header>
 * );
 *
 * export default MyComponent;
 * ```
 */
const AppbarAction = _ref => {
  let {
    size = 24,
    color: iconColor = color$1(black).alpha(0.54).rgb().string(),
    icon,
    disabled,
    onPress,
    accessibilityLabel,
    ...rest
  } = _ref;
  return /*#__PURE__*/React__namespace.createElement(IconButton$1, _extends$8({
    size: size,
    onPress: onPress,
    color: iconColor,
    icon: icon,
    disabled: disabled,
    accessibilityLabel: accessibilityLabel,
    animated: true
  }, rest));
};

AppbarAction.displayName = 'Appbar.Action';

const AppbarBackIcon = _ref => {
  let {
    size,
    color
  } = _ref;
  const iosIconSize = size - 3;
  return reactNative.Platform.OS === 'ios' ? /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: [styles$c.wrapper, {
      width: size,
      height: size,
      transform: [{
        scaleX: reactNative.I18nManager.isRTL ? -1 : 1
      }]
    }]
  }, /*#__PURE__*/React__namespace.createElement(reactNative.Image, {
    source: require('../../assets/back-chevron.png'),
    style: [styles$c.icon, {
      tintColor: color,
      width: iosIconSize,
      height: iosIconSize
    }]
  })) : /*#__PURE__*/React__namespace.createElement(defaultIcon, {
    name: "arrow-left",
    color: color,
    size: size,
    direction: reactNative.I18nManager.isRTL ? 'rtl' : 'ltr'
  });
};

const styles$c = reactNative.StyleSheet.create({
  wrapper: {
    alignItems: 'center',
    justifyContent: 'center'
  },
  icon: {
    resizeMode: 'contain'
  }
});

function _extends$7() { _extends$7 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$7.apply(this, arguments); }

/**
 * A component used to display a back button in the appbar.
 *
 * <div class="screenshots">
 *   <figure>
 *     <img class="medium" src="screenshots/appbar-backaction-android.png" />
 *     <figcaption>Android</figcaption>
 *   </figure>
 * </div>
 *
 * <div class="screenshots">
 *   <figure>
 *     <img class="medium" src="screenshots/appbar-backaction-ios.png" />
 *     <figcaption>iOS</figcaption>
 *   </figure>
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { Appbar } from 'react-native-paper';
 *
 *
 * const MyComponent = () => (
 *     <Appbar.Header>
 *       <Appbar.BackAction onPress={() => {}} />
 *     </Appbar.Header>
 * );
 *
 * export default MyComponent;
 * ```
 */
const AppbarBackAction = _ref => {
  let {
    accessibilityLabel = 'Back',
    ...rest
  } = _ref;
  return /*#__PURE__*/React__namespace.createElement(AppbarAction, _extends$7({
    accessibilityLabel: accessibilityLabel
  }, rest, {
    icon: AppbarBackIcon
  }));
};

AppbarBackAction.displayName = 'Appbar.BackAction';

function _extends$6() { _extends$6 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$6.apply(this, arguments); }
const DEFAULT_APPBAR_HEIGHT = 56;
/**
 * A component to display action items in a bar. It can be placed at the top or bottom.
 * The top bar usually contains the screen title, controls such as navigation buttons, menu button etc.
 * The bottom bar usually provides access to a drawer and up to four actions.
 *
 * By default Appbar uses primary color as a background, in dark theme with `adaptive` mode it will use surface colour instead.
 * See [Dark Theme](https://callstack.github.io/react-native-paper/theming.html#dark-theme) for more informations
 *
 * <div class="screenshots">
 *   <img class="medium" src="screenshots/appbar.png" />
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { Appbar } from 'react-native-paper';
 * import { StyleSheet } from 'react-native';
 *
 * const MyComponent = () => (
 *  <Appbar style={styles.bottom}>
 *    <Appbar.Action
 *      icon="archive"
 *      onPress={() => console.log('Pressed archive')}
 *     />
 *     <Appbar.Action icon="mail" onPress={() => console.log('Pressed mail')} />
 *     <Appbar.Action icon="label" onPress={() => console.log('Pressed label')} />
 *     <Appbar.Action
 *       icon="delete"
 *       onPress={() => console.log('Pressed delete')}
 *     />
 *   </Appbar>
 *  );
 *
 * export default MyComponent
 *
 * const styles = StyleSheet.create({
 *   bottom: {
 *     position: 'absolute',
 *     left: 0,
 *     right: 0,
 *     bottom: 0,
 *   },
 * });
 * ```
 */

const Appbar = _ref => {
  let {
    children,
    dark,
    style,
    theme,
    ...rest
  } = _ref;
  const {
    colors,
    dark: isDarkTheme,
    mode
  } = theme;
  const {
    backgroundColor: customBackground,
    elevation = 4,
    ...restStyle
  } = reactNative.StyleSheet.flatten(style) || {};
  let isDark;
  const backgroundColor = customBackground ? customBackground : isDarkTheme && mode === 'adaptive' ? overlay(elevation, colors.surface) : colors.primary;

  if (typeof dark === 'boolean') {
    isDark = dark;
  } else {
    isDark = backgroundColor === 'transparent' ? false : typeof backgroundColor === 'string' ? !color$1(backgroundColor).isLight() : true;
  }

  let shouldCenterContent = false;
  let shouldAddLeftSpacing = false;
  let shouldAddRightSpacing = false;

  if (reactNative.Platform.OS === 'ios') {
    let hasAppbarContent = false;
    let leftItemsCount = 0;
    let rightItemsCount = 0;
    React__namespace.Children.forEach(children, child => {
      if ( /*#__PURE__*/React__namespace.isValidElement(child)) {
        if (child.type === AppbarContent$1) {
          hasAppbarContent = true;
        } else if (hasAppbarContent) {
          rightItemsCount++;
        } else {
          leftItemsCount++;
        }
      }
    });
    shouldCenterContent = hasAppbarContent && leftItemsCount < 2 && rightItemsCount < 2;
    shouldAddLeftSpacing = shouldCenterContent && leftItemsCount === 0;
    shouldAddRightSpacing = shouldCenterContent && rightItemsCount === 0;
  }

  return /*#__PURE__*/React__namespace.createElement(Surface$1, _extends$6({
    style: [{
      backgroundColor
    }, styles$b.appbar, {
      elevation
    }, restStyle]
  }, rest), shouldAddLeftSpacing ? /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: styles$b.spacing
  }) : null, React__namespace.Children.toArray(children).filter(child => child != null && typeof child !== 'boolean').map((child, i) => {
    if (! /*#__PURE__*/React__namespace.isValidElement(child) || ![AppbarContent$1, AppbarAction, AppbarBackAction].includes( // @ts-expect-error: TypeScript complains about the type of type but it doesn't matter
    child.type)) {
      return child;
    }

    const props = {
      color: typeof child.props.color !== 'undefined' ? child.props.color : isDark ? white : black
    };

    if (child.type === AppbarContent$1) {
      props.style = [// Since content is not first item, add extra left margin
      i !== 0 && {
        marginLeft: 8
      }, shouldCenterContent && {
        alignItems: 'center'
      }, child.props.style];
    }

    return /*#__PURE__*/React__namespace.cloneElement(child, props);
  }), shouldAddRightSpacing ? /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: styles$b.spacing
  }) : null);
};

const styles$b = reactNative.StyleSheet.create({
  appbar: {
    height: DEFAULT_APPBAR_HEIGHT,
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 4,
    elevation: 4
  },
  spacing: {
    width: 48
  }
});
var AppbarComponent = withTheme(Appbar); // @component-docs ignore-next-line

const AppbarWithTheme = withTheme(Appbar); // @component-docs ignore-next-line

function _extends$5() { _extends$5 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$5.apply(this, arguments); }

/**
 * A component to use as a header at the top of the screen.
 * It can contain the screen title, controls such as navigation buttons, menu button etc.
 *
 * <div class="screenshots">
 *   <figure>
 *     <img class="medium" src="screenshots/appbar-header.android.png" />
 *     <figcaption>Android</figcaption>
 *   </figure>
 *   <figure>
 *     <img class="medium" src="screenshots/appbar-header.ios.png" />
 *     <figcaption>iOS</figcaption>
 *   </figure>
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { Appbar } from 'react-native-paper';
 *
 * const MyComponent = () => {
 *   const _goBack = () => console.log('Went back');
 *
 *   const _handleSearch = () => console.log('Searching');
 *
 *   const _handleMore = () => console.log('Shown more');
 *
 *   return (
 *     <Appbar.Header>
 *       <Appbar.BackAction onPress={_goBack} />
 *       <Appbar.Content title="Title" subtitle="Subtitle" />
 *       <Appbar.Action icon="magnify" onPress={_handleSearch} />
 *       <Appbar.Action icon="dots-vertical" onPress={_handleMore} />
 *     </Appbar.Header>
 *   );
 * };
 *
 * export default MyComponent;
 * ```
 */
const AppbarHeader = props => {
  const {
    // Don't use default props since we check it to know whether we should use SafeAreaView
    statusBarHeight = APPROX_STATUSBAR_HEIGHT,
    style,
    dark,
    ...rest
  } = props;
  const {
    dark: isDarkTheme,
    colors,
    mode
  } = rest.theme;
  const {
    height = DEFAULT_APPBAR_HEIGHT,
    elevation = 4,
    backgroundColor: customBackground,
    zIndex = 0,
    ...restStyle
  } = reactNative.StyleSheet.flatten(style) || {};
  const backgroundColor = customBackground ? customBackground : isDarkTheme && mode === 'adaptive' ? overlay(elevation, colors.surface) : colors.primary; // Let the user override the behaviour

  const Wrapper = typeof props.statusBarHeight === 'number' ? reactNative.View : reactNative.SafeAreaView;
  return /*#__PURE__*/React__namespace.createElement(Wrapper, {
    style: [{
      backgroundColor,
      zIndex,
      elevation
    }, shadow(elevation)]
  }, /*#__PURE__*/React__namespace.createElement(AppbarWithTheme, _extends$5({
    style: [{
      height,
      backgroundColor,
      marginTop: statusBarHeight
    }, styles$a.appbar, restStyle],
    dark: dark
  }, rest)));
};

AppbarHeader.displayName = 'Appbar.Header';
const styles$a = reactNative.StyleSheet.create({
  appbar: {
    elevation: 0
  }
});
var AppbarHeader$1 = withTheme(AppbarHeader); // @component-docs ignore-next-line

withTheme(AppbarHeader); // @component-docs ignore-next-line

Object.assign( // @component ./Appbar.tsx
AppbarComponent, {
  // @component ./AppbarContent.tsx
  Content: AppbarContent$1,
  // @component ./AppbarAction.tsx
  Action: AppbarAction,
  // @component ./AppbarBackAction.tsx
  BackAction: AppbarBackAction,
  // @component ./AppbarHeader.tsx
  Header: AppbarHeader$1
});

function _extends$4() { _extends$4 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$4.apply(this, arguments); }
const ICON_SIZE = 24;
const ICON_OFFSET = 12;
const StyleContext = /*#__PURE__*/React__default["default"].createContext({
  style: {},
  isTextInputFocused: false,
  forceFocus: () => {}
});

const IconAdornment = _ref => {
  let {
    icon,
    topPosition,
    side,
    isTextInputFocused,
    forceFocus
  } = _ref;
  const style = {
    top: topPosition,
    [side]: ICON_OFFSET
  };
  const contextState = {
    style,
    isTextInputFocused,
    forceFocus
  };
  return /*#__PURE__*/React__default["default"].createElement(StyleContext.Provider, {
    value: contextState
  }, icon);
};
/**
 * A component to render a leading / trailing icon in the TextInput
 *
 * <div class="screenshots">
 *   <figure>
 *     <img class="medium" src="screenshots/textinput-flat.icon.png" />
 *   </figure>
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { TextInput } from 'react-native-paper';
 *
 * const MyComponent = () => {
 *   const [text, setText] = React.useState('');
 *
 *   return (
 *     <TextInput
 *       label="Password"
 *       secureTextEntry
 *       right={<TextInput.Icon name="eye" />}
 *     />
 *   );
 * };
 *
 * export default MyComponent;
 * ```
 */


const TextInputIcon = _ref2 => {
  let {
    name,
    onPress,
    forceTextInputFocus,
    color,
    ...rest
  } = _ref2;
  const {
    style,
    isTextInputFocused,
    forceFocus
  } = React__default["default"].useContext(StyleContext);
  const onPressWithFocusControl = React__default["default"].useCallback(() => {
    if (forceTextInputFocus && !isTextInputFocused) {
      forceFocus();
    }

    onPress === null || onPress === void 0 ? void 0 : onPress();
  }, [forceTextInputFocus, forceFocus, isTextInputFocused, onPress]);
  return /*#__PURE__*/React__default["default"].createElement(reactNative.View, {
    style: [styles$9.container, style]
  }, /*#__PURE__*/React__default["default"].createElement(IconButton$1, _extends$4({
    icon: name,
    style: styles$9.iconButton,
    size: ICON_SIZE,
    onPress: onPressWithFocusControl,
    color: typeof color === 'function' ? color(isTextInputFocused) : color
  }, rest)));
};

TextInputIcon.displayName = 'TextInput.Icon';
TextInputIcon.defaultProps = {
  forceTextInputFocus: true
};
const styles$9 = reactNative.StyleSheet.create({
  container: {
    position: 'absolute',
    width: ICON_SIZE,
    height: ICON_SIZE,
    justifyContent: 'center',
    alignItems: 'center'
  },
  iconButton: {
    margin: 0
  }
});

let AdornmentType;

(function (AdornmentType) {
  AdornmentType["Icon"] = "icon";
  AdornmentType["Affix"] = "affix";
})(AdornmentType || (AdornmentType = {}));

let AdornmentSide;

(function (AdornmentSide) {
  AdornmentSide["Right"] = "right";
  AdornmentSide["Left"] = "left";
})(AdornmentSide || (AdornmentSide = {}));

let InputMode;

(function (InputMode) {
  InputMode["Outlined"] = "outlined";
  InputMode["Flat"] = "flat";
})(InputMode || (InputMode = {}));

const AFFIX_OFFSET = 12;
const AffixContext = /*#__PURE__*/React__default["default"].createContext({
  textStyle: {
    fontFamily: '',
    color: ''
  },
  topPosition: null,
  side: AdornmentSide.Left
});

const AffixAdornment = _ref => {
  let {
    affix,
    side,
    textStyle,
    topPosition,
    onLayout,
    visible,
    paddingHorizontal,
    maxFontSizeMultiplier
  } = _ref;
  return /*#__PURE__*/React__default["default"].createElement(AffixContext.Provider, {
    value: {
      side,
      textStyle,
      topPosition,
      onLayout,
      visible,
      paddingHorizontal,
      maxFontSizeMultiplier
    }
  }, affix);
};
/**
 * A component to render a leading / trailing text in the TextInput
 *
 * <div class="screenshots">
 *   <figure>
 *     <img class="medium" src="screenshots/textinput-outline.affix.png" />
 *   </figure>
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { TextInput } from 'react-native-paper';
 *
 * const MyComponent = () => {
 *   const [text, setText] = React.useState('');
 *
 *   return (
 *     <TextInput
 *       mode="outlined"
 *       label="Outlined input"
 *       placeholder="Type something"
 *       right={<TextInput.Affix text="/100" />}
 *     />
 *   );
 * };
 *
 * export default MyComponent;
 * ```
 */


const TextInputAffix = _ref2 => {
  let {
    text,
    textStyle: labelStyle,
    theme
  } = _ref2;
  const {
    textStyle,
    onLayout,
    topPosition,
    side,
    visible,
    paddingHorizontal,
    maxFontSizeMultiplier
  } = React__default["default"].useContext(AffixContext);
  const textColor = color$1(theme.colors.text).alpha(theme.dark ? 0.7 : 0.54).rgb().string();
  const offset = typeof paddingHorizontal === 'number' ? paddingHorizontal : AFFIX_OFFSET;
  const style = {
    top: topPosition,
    [side]: offset
  };
  return /*#__PURE__*/React__default["default"].createElement(reactNative.Animated.View, {
    style: [styles$8.container, style, {
      opacity: (visible === null || visible === void 0 ? void 0 : visible.interpolate({
        inputRange: [0, 1],
        outputRange: [1, 0]
      })) || 1
    }],
    onLayout: onLayout
  }, /*#__PURE__*/React__default["default"].createElement(reactNative.Text, {
    maxFontSizeMultiplier: maxFontSizeMultiplier,
    style: [{
      color: textColor
    }, textStyle, labelStyle]
  }, text));
};

TextInputAffix.displayName = 'TextInput.Affix';
const styles$8 = reactNative.StyleSheet.create({
  container: {
    position: 'absolute',
    justifyContent: 'center',
    alignItems: 'center'
  }
});
var TextInputAffix$1 = withTheme(TextInputAffix); // @component-docs ignore-next-line

const MAXIMIZED_LABEL_FONT_SIZE = 16;
const MINIMIZED_LABEL_FONT_SIZE = 12;
const LABEL_WIGGLE_X_OFFSET = 4;
const LABEL_PADDING_HORIZONTAL = 12;
const ADORNMENT_SIZE = 24;
const ADORNMENT_OFFSET = 12;
const FLAT_INPUT_OFFSET = 8; // extra space to avoid overlapping input's text and icon

const OUTLINED_INPUT_OFFSET = 8;

function _extends$3() { _extends$3 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$3.apply(this, arguments); }
function getAdornmentConfig(_ref) {
  let {
    left,
    right
  } = _ref;
  let adornmentConfig = [];

  if (left || right) {
    [{
      side: AdornmentSide.Left,
      adornment: left
    }, {
      side: AdornmentSide.Right,
      adornment: right
    }].forEach(_ref2 => {
      let {
        side,
        adornment
      } = _ref2;

      if (adornment && /*#__PURE__*/React__default["default"].isValidElement(adornment)) {
        let type;

        if (adornment.type === TextInputAffix$1) {
          type = AdornmentType.Affix;
        } else if (adornment.type === TextInputIcon) {
          type = AdornmentType.Icon;
        }

        adornmentConfig.push({
          side,
          type
        });
      }
    });
  }

  return adornmentConfig;
}
function getAdornmentStyleAdjustmentForNativeInput(_ref3) {
  let {
    adornmentConfig,
    leftAffixWidth,
    rightAffixWidth,
    paddingHorizontal,
    inputOffset = 0,
    mode
  } = _ref3;

  if (adornmentConfig.length) {
    const adornmentStyleAdjustmentForNativeInput = adornmentConfig.map(_ref4 => {
      let {
        type,
        side
      } = _ref4;
      const isLeftSide = side === AdornmentSide.Left;
      const inputModeAdornemntOffset = mode === InputMode.Outlined ? ADORNMENT_OFFSET + OUTLINED_INPUT_OFFSET : ADORNMENT_OFFSET;
      const paddingKey = `padding${captalize(side)}`;
      const affixWidth = isLeftSide ? leftAffixWidth : rightAffixWidth;
      const padding = typeof paddingHorizontal === 'number' ? paddingHorizontal : inputModeAdornemntOffset;
      const offset = affixWidth + padding;
      const isAffix = type === AdornmentType.Affix;
      const marginKey = `margin${captalize(side)}`;
      return {
        [marginKey]: isAffix ? 0 : offset,
        [paddingKey]: isAffix ? offset : inputOffset
      };
    });
    const allStyleAdjustmentsMerged = adornmentStyleAdjustmentForNativeInput.reduce((mergedStyles, currentStyle) => {
      return { ...mergedStyles,
        ...currentStyle
      };
    }, {});
    return allStyleAdjustmentsMerged;
  } else {
    return [{}];
  }
}

const captalize = text => text.charAt(0).toUpperCase() + text.slice(1);

const TextInputAdornment = _ref5 => {
  let {
    adornmentConfig,
    left,
    right,
    onAffixChange,
    textStyle,
    visible,
    topPosition,
    isTextInputFocused,
    forceFocus,
    paddingHorizontal,
    maxFontSizeMultiplier
  } = _ref5;

  if (adornmentConfig.length) {
    return /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, adornmentConfig.map(_ref6 => {
      let {
        type,
        side
      } = _ref6;
      let inputAdornmentComponent;

      if (side === AdornmentSide.Left) {
        inputAdornmentComponent = left;
      } else if (side === AdornmentSide.Right) {
        inputAdornmentComponent = right;
      }

      const commonProps = {
        key: side,
        side: side,
        testID: `${side}-${type}-adornment`,
        isTextInputFocused,
        paddingHorizontal
      };

      if (type === AdornmentType.Icon) {
        return /*#__PURE__*/React__default["default"].createElement(IconAdornment, _extends$3({}, commonProps, {
          icon: inputAdornmentComponent,
          topPosition: topPosition[AdornmentType.Icon],
          forceFocus: forceFocus
        }));
      } else if (type === AdornmentType.Affix) {
        return /*#__PURE__*/React__default["default"].createElement(AffixAdornment, _extends$3({}, commonProps, {
          topPosition: topPosition[AdornmentType.Affix][side],
          affix: inputAdornmentComponent,
          textStyle: textStyle,
          onLayout: onAffixChange[side],
          visible: visible,
          maxFontSizeMultiplier: maxFontSizeMultiplier
        }));
      } else {
        return null;
      }
    }));
  } else {
    return null;
  }
};

const InputLabel = props => {
  const {
    parentState,
    labelBackground
  } = props;
  const {
    label,
    error,
    onLayoutAnimatedText,
    hasActiveOutline,
    activeColor,
    placeholderStyle,
    baseLabelTranslateX,
    baseLabelTranslateY,
    font,
    fontSize,
    fontWeight,
    placeholderOpacity,
    wiggleOffsetX,
    labelScale,
    topPosition,
    paddingOffset,
    placeholderColor,
    errorColor,
    labelTranslationXOffset,
    maxFontSizeMultiplier
  } = props.labelProps;
  const labelTranslationX = {
    transform: [{
      // Offset label scale since RN doesn't support transform origin
      translateX: parentState.labeled.interpolate({
        inputRange: [0, 1],
        outputRange: [baseLabelTranslateX, labelTranslationXOffset || 0]
      })
    }]
  };
  const labelStyle = { ...font,
    fontSize,
    fontWeight,
    transform: [{
      // Wiggle the label when there's an error
      translateX: parentState.error.interpolate({
        inputRange: [0, 0.5, 1],
        outputRange: [0, parentState.value && error ? wiggleOffsetX : 0, 0]
      })
    }, {
      // Move label to top
      translateY: parentState.labeled.interpolate({
        inputRange: [0, 1],
        outputRange: [baseLabelTranslateY, 0]
      })
    }, {
      // Make label smaller
      scale: parentState.labeled.interpolate({
        inputRange: [0, 1],
        outputRange: [labelScale, 1]
      })
    }]
  };
  return label ?
  /*#__PURE__*/
  // Position colored placeholder and gray placeholder on top of each other and crossfade them
  // This gives the effect of animating the color, but allows us to use native driver
  React__default["default"].createElement(reactNative.Animated.View, {
    pointerEvents: "none",
    style: [reactNative.StyleSheet.absoluteFill, styles$7.labelContainer, {
      opacity: // Hide the label in minimized state until we measure it's width
      parentState.value || parentState.focused ? parentState.labelLayout.measured ? 1 : 0 : 1
    }, labelTranslationX]
  }, labelBackground === null || labelBackground === void 0 ? void 0 : labelBackground({
    parentState,
    labelStyle,
    labelProps: props.labelProps,
    maxFontSizeMultiplier: maxFontSizeMultiplier
  }), /*#__PURE__*/React__default["default"].createElement(AnimatedText$1, {
    onLayout: onLayoutAnimatedText,
    style: [placeholderStyle, {
      top: topPosition
    }, labelStyle, paddingOffset || {}, {
      color: activeColor,
      opacity: parentState.labeled.interpolate({
        inputRange: [0, 1],
        outputRange: [hasActiveOutline ? 1 : 0, 0]
      })
    }],
    numberOfLines: 1,
    maxFontSizeMultiplier: maxFontSizeMultiplier
  }, label), /*#__PURE__*/React__default["default"].createElement(AnimatedText$1, {
    style: [placeholderStyle, {
      top: topPosition
    }, labelStyle, paddingOffset, {
      color: error && errorColor ? errorColor : placeholderColor,
      opacity: placeholderOpacity
    }],
    numberOfLines: 1,
    maxFontSizeMultiplier: maxFontSizeMultiplier
  }, label)) : null;
};

const styles$7 = reactNative.StyleSheet.create({
  labelContainer: {
    zIndex: 3
  }
});

const LabelBackground = _ref => {
  let {
    parentState,
    labelProps: {
      placeholderStyle,
      baseLabelTranslateX,
      topPosition,
      hasActiveOutline,
      label,
      backgroundColor,
      roundness
    },
    labelStyle,
    maxFontSizeMultiplier
  } = _ref;
  const hasFocus = hasActiveOutline || parentState.value;
  const opacity = parentState.labeled.interpolate({
    inputRange: [0, 1],
    outputRange: [hasFocus ? 1 : 0, 0]
  });
  const labelTranslationX = {
    transform: [{
      translateX: parentState.labeled.interpolate({
        inputRange: [0, 1],
        outputRange: [-baseLabelTranslateX, 0]
      })
    }]
  };
  return label ? [/*#__PURE__*/React__namespace.createElement(reactNative.Animated.View, {
    key: "labelBackground-view",
    pointerEvents: "none",
    style: [reactNative.StyleSheet.absoluteFill, styles$6.view, {
      backgroundColor,
      maxHeight: Math.max(roundness / 3, 2),
      opacity,
      bottom: Math.max(roundness, 2)
    }, labelTranslationX]
  }), /*#__PURE__*/React__namespace.createElement(AnimatedText$1, {
    key: "labelBackground-text",
    style: [placeholderStyle, labelStyle, styles$6.outlinedLabel, {
      top: topPosition + 1,
      backgroundColor,
      opacity,
      transform: [...labelStyle.transform, {
        scaleY: parentState.labeled.interpolate({
          inputRange: [0, 1],
          outputRange: [0.2, 1]
        })
      }],
      maxWidth: parentState.labelLayout.width - 2 * placeholderStyle.paddingHorizontal
    }],
    numberOfLines: 1,
    maxFontSizeMultiplier: maxFontSizeMultiplier
  }, label)] : null;
};
const styles$6 = reactNative.StyleSheet.create({
  view: {
    position: 'absolute',
    top: 6,
    left: 10,
    width: 12
  },
  outlinedLabel: {
    position: 'absolute',
    left: 18,
    paddingHorizontal: 0,
    color: 'transparent'
  }
});

const calculateLabelTopPosition = function (labelHeight) {
  let height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  let optionalPadding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  const customHeight = height > 0 ? height : 0;
  return Math.floor((customHeight - labelHeight) / 2 + optionalPadding);
};
const calculateInputHeight = function (labelHeight) {
  let height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  let minHeight = arguments.length > 2 ? arguments[2] : undefined;
  const finalHeight = height > 0 ? height : labelHeight;
  if (height > 0) return height;
  return finalHeight < minHeight ? minHeight : finalHeight;
};
const calculatePadding = props => {
  const {
    height,
    multiline = false
  } = props;
  let result = 0;

  if (multiline) {
    if (height && multiline) {
      result = calculateTextAreaPadding(props);
    } else {
      result = calculateInputPadding(props);
    }
  }

  return Math.max(0, result);
};

const calculateTextAreaPadding = props => {
  const {
    dense
  } = props;
  return dense ? 10 : 20;
};

const calculateInputPadding = _ref => {
  let {
    topPosition,
    fontSize,
    multiline,
    scale,
    dense,
    offset,
    isAndroid
  } = _ref;
  const refFontSize = scale * fontSize;
  let result = Math.floor(topPosition / 2);
  result = result + Math.floor((refFontSize - fontSize) / 2) - (scale < 1 ? offset / 2 : 0);
  if (multiline && isAndroid) result = Math.min(dense ? offset / 2 : offset, result);
  return result;
};

const adjustPaddingOut = _ref2 => {
  let {
    pad,
    multiline,
    label,
    scale,
    height,
    fontSize,
    lineHeight,
    dense,
    offset,
    isAndroid
  } = _ref2;
  const fontHeight = lineHeight !== null && lineHeight !== void 0 ? lineHeight : fontSize;
  const refFontHeight = scale * fontSize;
  let result = pad;

  if (height && !multiline) {
    return {
      paddingTop: Math.max(0, (height - fontHeight) / 2),
      paddingBottom: Math.max(0, (height - fontHeight) / 2)
    };
  }

  if (!isAndroid && multiline) {
    if (dense) {
      if (label) {
        result += scale < 1 ? Math.min(offset, refFontHeight / 2 * scale) : 0;
      } else {
        result += 0;
      }
    }

    if (!dense) {
      if (label) {
        result += scale < 1 ? Math.min(offset, refFontHeight * scale) : Math.min(offset / 2, refFontHeight * scale);
      } else {
        result += scale < 1 ? Math.min(offset / 2, refFontHeight * scale) : 0;
      }
    }

    result = Math.floor(result);
  }

  return {
    paddingTop: result,
    paddingBottom: result
  };
};
const adjustPaddingFlat = _ref3 => {
  let {
    pad,
    scale,
    multiline,
    label,
    height,
    offset,
    dense,
    fontSize,
    isAndroid,
    styles
  } = _ref3;
  let result = pad;
  let topResult = result;
  let bottomResult = result;
  const {
    paddingTop,
    paddingBottom
  } = styles;
  const refFontSize = scale * fontSize;

  if (!multiline) {
    // do not modify padding if input is not multiline
    if (label) {
      // return const style for flat input with label
      return {
        paddingTop,
        paddingBottom
      };
    } // return pad for flat input without label


    return {
      paddingTop: result,
      paddingBottom: result
    };
  }

  if (label) {
    // add paddings passed from styles
    topResult = paddingTop;
    bottomResult = paddingBottom; // adjust top padding for iOS

    if (!isAndroid) {
      if (dense) {
        topResult += scale < 1 ? Math.min(result, refFontSize * scale) - result / 2 : Math.min(result, refFontSize * scale) - result / 2;
      }

      if (!dense) {
        topResult += scale < 1 ? Math.min(offset / 2, refFontSize * scale) : Math.min(result, refFontSize * scale) - offset / 2;
      }
    }

    topResult = Math.floor(topResult);
  } else {
    if (height) {
      // center text when height is passed
      return {
        paddingTop: Math.max(0, (height - fontSize) / 2),
        paddingBottom: Math.max(0, (height - fontSize) / 2)
      };
    } // adjust paddings for iOS if no label


    if (!isAndroid) {
      if (dense) {
        result += scale < 1 ? Math.min(offset / 2, fontSize / 2 * scale) : Math.min(offset / 2, scale);
      }

      if (!dense) {
        result += scale < 1 ? Math.min(offset, fontSize * scale) : Math.min(fontSize, offset / 2 * scale);
      }

      result = Math.floor(result);
      topResult = result;
      bottomResult = result;
    }
  }

  return {
    paddingTop: Math.max(0, topResult),
    paddingBottom: Math.max(0, bottomResult)
  };
};
const interpolatePlaceholder = (labeled, hasActiveOutline) => labeled.interpolate({
  inputRange: [0, 1],
  outputRange: [hasActiveOutline ? 0 : 1, 1]
});
function calculateFlatAffixTopPosition(_ref4) {
  let {
    height,
    paddingTop,
    paddingBottom,
    affixHeight
  } = _ref4;
  const inputHeightWithoutPadding = height - paddingTop - paddingBottom;
  const halfOfTheInputHeightDecreasedByAffixHeight = (inputHeightWithoutPadding - affixHeight) / 2;
  return paddingTop + halfOfTheInputHeightDecreasedByAffixHeight;
}
function calculateOutlinedIconAndAffixTopPosition(_ref5) {
  let {
    height,
    affixHeight,
    labelYOffset
  } = _ref5;
  return (height - affixHeight + labelYOffset) / 2;
}
const calculateFlatInputHorizontalPadding = _ref6 => {
  let {
    adornmentConfig
  } = _ref6;
  let paddingLeft = LABEL_PADDING_HORIZONTAL;
  let paddingRight = LABEL_PADDING_HORIZONTAL;
  adornmentConfig.forEach(_ref7 => {
    let {
      type,
      side
    } = _ref7;

    if (type === AdornmentType.Icon && side === AdornmentSide.Left) {
      paddingLeft = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;
    } else if (side === AdornmentSide.Right) {
      if (type === AdornmentType.Affix) {
        paddingRight = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;
      } else if (type === AdornmentType.Icon) {
        paddingRight = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;
      }
    }
  });
  return {
    paddingLeft,
    paddingRight
  };
};

const OUTLINE_MINIMIZED_LABEL_Y_OFFSET = -6;
const LABEL_PADDING_TOP$1 = 8;
const MIN_HEIGHT$1 = 64;
const MIN_DENSE_HEIGHT$1 = 48;
const INPUT_PADDING_HORIZONTAL = 14;

const TextInputOutlined = _ref => {
  let {
    disabled = false,
    editable = true,
    label,
    error = false,
    selectionColor,
    underlineColor: _underlineColor,
    outlineColor: customOutlineColor,
    activeOutlineColor,
    dense,
    style,
    theme,
    render = props => /*#__PURE__*/React__namespace.createElement(reactNative.TextInput, props),
    multiline = false,
    parentState,
    innerRef,
    onFocus,
    forceFocus,
    onBlur,
    onChangeText,
    onLayoutAnimatedText,
    onLeftAffixLayoutChange,
    onRightAffixLayoutChange,
    left,
    right,
    placeholderTextColor,
    ...rest
  } = _ref;
  const adornmentConfig = getAdornmentConfig({
    left,
    right
  });
  const {
    colors,
    fonts
  } = theme;
  const font = fonts.regular;
  const hasActiveOutline = parentState.focused || error;
  const {
    fontSize: fontSizeStyle,
    fontWeight,
    lineHeight,
    height,
    backgroundColor = colors.background,
    textAlign,
    ...viewStyle
  } = reactNative.StyleSheet.flatten(style) || {};
  const fontSize = fontSizeStyle || MAXIMIZED_LABEL_FONT_SIZE;
  let inputTextColor, activeColor, outlineColor, placeholderColor, errorColor;

  if (disabled) {
    const isTransparent = color$1(customOutlineColor).alpha() === 0;
    inputTextColor = activeColor = color$1(colors.text).alpha(0.54).rgb().string();
    placeholderColor = colors.disabled;
    outlineColor = isTransparent ? customOutlineColor : colors.disabled;
  } else {
    inputTextColor = colors.text;
    activeColor = error ? colors.error : activeOutlineColor || colors.primary;
    placeholderColor = colors.placeholder;
    outlineColor = customOutlineColor || colors.placeholder;
    errorColor = colors.error;
  }

  const labelScale = MINIMIZED_LABEL_FONT_SIZE / fontSize;
  const fontScale = MAXIMIZED_LABEL_FONT_SIZE / fontSize;
  const labelWidth = parentState.labelLayout.width;
  const labelHeight = parentState.labelLayout.height;
  const labelHalfWidth = labelWidth / 2;
  const labelHalfHeight = labelHeight / 2;
  const baseLabelTranslateX = (reactNative.I18nManager.isRTL ? 1 : -1) * (labelHalfWidth - labelScale * labelWidth / 2 - (fontSize - MINIMIZED_LABEL_FONT_SIZE) * labelScale);
  let labelTranslationXOffset = 0;
  const isAdornmentLeftIcon = adornmentConfig.some(_ref2 => {
    let {
      side,
      type
    } = _ref2;
    return side === AdornmentSide.Left && type === AdornmentType.Icon;
  });

  if (isAdornmentLeftIcon) {
    labelTranslationXOffset = (reactNative.I18nManager.isRTL ? -1 : 1) * (ADORNMENT_SIZE + ADORNMENT_OFFSET - 8);
  }

  const minInputHeight = (dense ? MIN_DENSE_HEIGHT$1 : MIN_HEIGHT$1) - LABEL_PADDING_TOP$1;
  const inputHeight = calculateInputHeight(labelHeight, height, minInputHeight);
  const topPosition = calculateLabelTopPosition(labelHeight, inputHeight, LABEL_PADDING_TOP$1);

  if (height && typeof height !== 'number') {
    // eslint-disable-next-line
    console.warn('Currently we support only numbers in height prop');
  }

  const paddingSettings = {
    height: height ? +height : null,
    labelHalfHeight,
    offset: LABEL_PADDING_TOP$1,
    multiline: multiline ? multiline : null,
    dense: dense ? dense : null,
    topPosition,
    fontSize,
    lineHeight,
    label,
    scale: fontScale,
    isAndroid: reactNative.Platform.OS === 'android',
    styles: reactNative.StyleSheet.flatten(dense ? styles$5.inputOutlinedDense : styles$5.inputOutlined)
  };
  const pad = calculatePadding(paddingSettings);
  const paddingOut = adjustPaddingOut({ ...paddingSettings,
    pad
  });
  const baseLabelTranslateY = -labelHalfHeight - (topPosition + OUTLINE_MINIMIZED_LABEL_Y_OFFSET);
  const placeholderOpacity = hasActiveOutline ? interpolatePlaceholder(parentState.labeled, hasActiveOutline) : parentState.labelLayout.measured ? 1 : 0;
  const labelProps = {
    label,
    onLayoutAnimatedText,
    placeholderOpacity,
    error,
    placeholderStyle: styles$5.placeholder,
    baseLabelTranslateY,
    baseLabelTranslateX,
    font,
    fontSize,
    fontWeight,
    labelScale,
    wiggleOffsetX: LABEL_WIGGLE_X_OFFSET,
    topPosition,
    hasActiveOutline,
    activeColor,
    placeholderColor,
    backgroundColor: backgroundColor,
    errorColor,
    labelTranslationXOffset,
    roundness: theme.roundness,
    maxFontSizeMultiplier: rest.maxFontSizeMultiplier
  };
  const minHeight = height || (dense ? MIN_DENSE_HEIGHT$1 : MIN_HEIGHT$1);
  const {
    leftLayout,
    rightLayout
  } = parentState;
  const leftAffixTopPosition = calculateOutlinedIconAndAffixTopPosition({
    height: minHeight,
    affixHeight: leftLayout.height || 0,
    labelYOffset: -OUTLINE_MINIMIZED_LABEL_Y_OFFSET
  });
  const rightAffixTopPosition = calculateOutlinedIconAndAffixTopPosition({
    height: minHeight,
    affixHeight: rightLayout.height || 0,
    labelYOffset: -OUTLINE_MINIMIZED_LABEL_Y_OFFSET
  });
  const iconTopPosition = calculateOutlinedIconAndAffixTopPosition({
    height: minHeight,
    affixHeight: ADORNMENT_SIZE,
    labelYOffset: -OUTLINE_MINIMIZED_LABEL_Y_OFFSET
  });
  const rightAffixWidth = right ? rightLayout.width || ADORNMENT_SIZE : ADORNMENT_SIZE;
  const leftAffixWidth = left ? leftLayout.width || ADORNMENT_SIZE : ADORNMENT_SIZE;
  const adornmentStyleAdjustmentForNativeInput = getAdornmentStyleAdjustmentForNativeInput({
    adornmentConfig,
    rightAffixWidth,
    leftAffixWidth,
    mode: 'outlined'
  });
  const affixTopPosition = {
    [AdornmentSide.Left]: leftAffixTopPosition,
    [AdornmentSide.Right]: rightAffixTopPosition
  };
  const onAffixChange = {
    [AdornmentSide.Left]: onLeftAffixLayoutChange,
    [AdornmentSide.Right]: onRightAffixLayoutChange
  };
  let adornmentProps = {
    adornmentConfig,
    forceFocus,
    topPosition: {
      [AdornmentType.Icon]: iconTopPosition,
      [AdornmentType.Affix]: affixTopPosition
    },
    onAffixChange,
    isTextInputFocused: parentState.focused,
    maxFontSizeMultiplier: rest.maxFontSizeMultiplier
  };

  if (adornmentConfig.length) {
    adornmentProps = { ...adornmentProps,
      left,
      right,
      textStyle: { ...font,
        fontSize,
        fontWeight
      },
      visible: parentState.labeled
    };
  }

  return /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: viewStyle
  }, /*#__PURE__*/React__namespace.createElement(Outline, {
    theme: theme,
    hasActiveOutline: hasActiveOutline,
    focused: parentState.focused,
    activeColor: activeColor,
    outlineColor: outlineColor,
    backgroundColor: backgroundColor
  }), /*#__PURE__*/React__namespace.createElement(reactNative.View, null, /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: [styles$5.labelContainer, {
      paddingTop: LABEL_PADDING_TOP$1,
      minHeight
    }]
  }, /*#__PURE__*/React__namespace.createElement(InputLabel, {
    parentState: parentState,
    labelProps: labelProps,
    labelBackground: LabelBackground,
    maxFontSizeMultiplier: rest.maxFontSizeMultiplier
  }), render === null || render === void 0 ? void 0 : render({
    testID: 'text-input-outlined',
    ...rest,
    ref: innerRef,
    onChangeText,
    placeholder: label ? parentState.placeholder : rest.placeholder,
    placeholderTextColor: placeholderTextColor || placeholderColor,
    editable: !disabled && editable,
    selectionColor: typeof selectionColor === 'undefined' ? activeColor : selectionColor,
    onFocus,
    onBlur,
    underlineColorAndroid: 'transparent',
    multiline,
    style: [styles$5.input, !multiline || multiline && height ? {
      height: inputHeight
    } : {}, paddingOut, { ...font,
      fontSize,
      fontWeight,
      color: inputTextColor,
      textAlignVertical: multiline ? 'top' : 'center',
      textAlign: textAlign ? textAlign : reactNative.I18nManager.isRTL ? 'right' : 'left'
    }, reactNative.Platform.OS === 'web' && {
      outline: 'none'
    }, adornmentStyleAdjustmentForNativeInput]
  })), /*#__PURE__*/React__namespace.createElement(TextInputAdornment, adornmentProps)));
};

const Outline = _ref3 => {
  let {
    theme,
    hasActiveOutline,
    activeColor,
    outlineColor,
    focused,
    backgroundColor
  } = _ref3;
  return /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    testID: "text-input-outline",
    pointerEvents: "none",
    style: [styles$5.outline, // eslint-disable-next-line react-native/no-inline-styles
    {
      backgroundColor,
      borderRadius: theme.roundness,
      borderWidth: focused ? 2 : 1,
      borderColor: hasActiveOutline ? activeColor : outlineColor
    }]
  });
};

const styles$5 = reactNative.StyleSheet.create({
  placeholder: {
    position: 'absolute',
    left: 0,
    paddingHorizontal: INPUT_PADDING_HORIZONTAL
  },
  outline: {
    position: 'absolute',
    left: 0,
    right: 0,
    top: 6,
    bottom: 0
  },
  labelContainer: {
    paddingBottom: 0
  },
  input: {
    flexGrow: 1,
    paddingHorizontal: INPUT_PADDING_HORIZONTAL,
    margin: 0,
    zIndex: 1
  },
  inputOutlined: {
    paddingTop: 8,
    paddingBottom: 8
  },
  inputOutlinedDense: {
    paddingTop: 4,
    paddingBottom: 4
  }
});

const MINIMIZED_LABEL_Y_OFFSET = -18;
const LABEL_PADDING_TOP = 30;
const LABEL_PADDING_TOP_DENSE = 24;
const MIN_HEIGHT = 64;
const MIN_DENSE_HEIGHT_WL = 52;
const MIN_DENSE_HEIGHT = 40;

const TextInputFlat = _ref => {
  let {
    disabled = false,
    editable = true,
    label,
    error = false,
    selectionColor,
    underlineColor,
    activeUnderlineColor,
    dense,
    style,
    theme,
    render = props => /*#__PURE__*/React__namespace.createElement(reactNative.TextInput, props),
    multiline = false,
    parentState,
    innerRef,
    onFocus,
    forceFocus,
    onBlur,
    onChangeText,
    onLayoutAnimatedText,
    onLeftAffixLayoutChange,
    onRightAffixLayoutChange,
    left,
    right,
    placeholderTextColor,
    ...rest
  } = _ref;
  const isAndroid = reactNative.Platform.OS === 'android';
  const {
    colors,
    fonts
  } = theme;
  const font = fonts.regular;
  const hasActiveOutline = parentState.focused || error;
  const {
    fontSize: fontSizeStyle,
    fontWeight,
    height,
    paddingHorizontal,
    textAlign,
    ...viewStyle
  } = reactNative.StyleSheet.flatten(style) || {};
  const fontSize = fontSizeStyle || MAXIMIZED_LABEL_FONT_SIZE;
  const isPaddingHorizontalPassed = paddingHorizontal !== undefined && typeof paddingHorizontal === 'number';
  const adornmentConfig = getAdornmentConfig({
    left,
    right
  });
  let {
    paddingLeft,
    paddingRight
  } = calculateFlatInputHorizontalPadding({
    adornmentConfig
  });

  if (isPaddingHorizontalPassed) {
    paddingLeft = paddingHorizontal;
    paddingRight = paddingHorizontal;
  }

  const {
    leftLayout,
    rightLayout
  } = parentState;
  const rightAffixWidth = right ? rightLayout.width || ADORNMENT_SIZE : ADORNMENT_SIZE;
  const leftAffixWidth = left ? leftLayout.width || ADORNMENT_SIZE : ADORNMENT_SIZE;
  const adornmentStyleAdjustmentForNativeInput = getAdornmentStyleAdjustmentForNativeInput({
    adornmentConfig,
    rightAffixWidth,
    leftAffixWidth,
    paddingHorizontal,
    inputOffset: FLAT_INPUT_OFFSET,
    mode: InputMode.Flat
  });
  let inputTextColor, activeColor, underlineColorCustom, placeholderColor, errorColor;

  if (disabled) {
    inputTextColor = activeColor = color$1(colors.text).alpha(0.54).rgb().string();
    placeholderColor = colors.disabled;
    underlineColorCustom = 'transparent';
  } else {
    inputTextColor = colors.text;
    activeColor = error ? colors.error : activeUnderlineColor || colors.primary;
    placeholderColor = colors.placeholder;
    errorColor = colors.error;
    underlineColorCustom = underlineColor || colors.disabled;
  }

  const containerStyle = {
    backgroundColor: theme.dark ? color$1(colors.background).lighten(0.24).rgb().string() : color$1(colors.background).darken(0.06).rgb().string(),
    borderTopLeftRadius: theme.roundness,
    borderTopRightRadius: theme.roundness
  };
  const labelScale = MINIMIZED_LABEL_FONT_SIZE / fontSize;
  const fontScale = MAXIMIZED_LABEL_FONT_SIZE / fontSize;
  const labelWidth = parentState.labelLayout.width;
  const labelHeight = parentState.labelLayout.height;
  const labelHalfWidth = labelWidth / 2;
  const labelHalfHeight = labelHeight / 2;
  const baseLabelTranslateX = (reactNative.I18nManager.isRTL ? 1 : -1) * (labelHalfWidth - labelScale * labelWidth / 2) + (1 - labelScale) * (reactNative.I18nManager.isRTL ? -1 : 1) * paddingLeft;
  const minInputHeight = dense ? (label ? MIN_DENSE_HEIGHT_WL : MIN_DENSE_HEIGHT) - LABEL_PADDING_TOP_DENSE : MIN_HEIGHT - LABEL_PADDING_TOP;
  const inputHeight = calculateInputHeight(labelHeight, height, minInputHeight);
  const topPosition = calculateLabelTopPosition(labelHeight, inputHeight, multiline && height ? 0 : !height ? minInputHeight / 2 : 0);

  if (height && typeof height !== 'number') {
    // eslint-disable-next-line
    console.warn('Currently we support only numbers in height prop');
  }

  const paddingSettings = {
    height: height ? +height : null,
    labelHalfHeight,
    offset: FLAT_INPUT_OFFSET,
    multiline: multiline ? multiline : null,
    dense: dense ? dense : null,
    topPosition,
    fontSize,
    label,
    scale: fontScale,
    isAndroid,
    styles: reactNative.StyleSheet.flatten(dense ? styles$4.inputFlatDense : styles$4.inputFlat)
  };
  const pad = calculatePadding(paddingSettings);
  const paddingFlat = adjustPaddingFlat({ ...paddingSettings,
    pad
  });
  const baseLabelTranslateY = -labelHalfHeight - (topPosition + MINIMIZED_LABEL_Y_OFFSET);
  const placeholderOpacity = hasActiveOutline ? interpolatePlaceholder(parentState.labeled, hasActiveOutline) : parentState.labelLayout.measured ? 1 : 0;
  const minHeight = height || (dense ? label ? MIN_DENSE_HEIGHT_WL : MIN_DENSE_HEIGHT : MIN_HEIGHT);
  const flatHeight = inputHeight + (!height ? dense ? LABEL_PADDING_TOP_DENSE : LABEL_PADDING_TOP : 0);
  const iconTopPosition = (flatHeight - ADORNMENT_SIZE) / 2;
  const leftAffixTopPosition = leftLayout.height ? calculateFlatAffixTopPosition({
    height: flatHeight,
    ...paddingFlat,
    affixHeight: leftLayout.height
  }) : null;
  const rightAffixTopPosition = rightLayout.height ? calculateFlatAffixTopPosition({
    height: flatHeight,
    ...paddingFlat,
    affixHeight: rightLayout.height
  }) : null;
  const labelProps = {
    label,
    onLayoutAnimatedText,
    placeholderOpacity,
    error,
    placeholderStyle: styles$4.placeholder,
    baseLabelTranslateY,
    baseLabelTranslateX,
    font,
    fontSize,
    fontWeight,
    labelScale,
    wiggleOffsetX: LABEL_WIGGLE_X_OFFSET,
    topPosition,
    paddingOffset: {
      paddingLeft,
      paddingRight
    },
    hasActiveOutline,
    activeColor,
    placeholderColor,
    errorColor,
    roundness: theme.roundness,
    maxFontSizeMultiplier: rest.maxFontSizeMultiplier
  };
  const affixTopPosition = {
    [AdornmentSide.Left]: leftAffixTopPosition,
    [AdornmentSide.Right]: rightAffixTopPosition
  };
  const onAffixChange = {
    [AdornmentSide.Left]: onLeftAffixLayoutChange,
    [AdornmentSide.Right]: onRightAffixLayoutChange
  };
  let adornmentProps = {
    paddingHorizontal,
    adornmentConfig,
    forceFocus,
    topPosition: {
      [AdornmentType.Affix]: affixTopPosition,
      [AdornmentType.Icon]: iconTopPosition
    },
    onAffixChange,
    isTextInputFocused: parentState.focused,
    maxFontSizeMultiplier: rest.maxFontSizeMultiplier
  };

  if (adornmentConfig.length) {
    adornmentProps = { ...adornmentProps,
      left,
      right,
      textStyle: { ...font,
        fontSize,
        fontWeight
      },
      visible: parentState.labeled
    };
  }

  return /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: [containerStyle, viewStyle]
  }, /*#__PURE__*/React__namespace.createElement(Underline, {
    parentState: parentState,
    underlineColorCustom: underlineColorCustom,
    error: error,
    colors: colors,
    activeColor: activeColor
  }), /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: [styles$4.labelContainer, {
      minHeight
    }]
  }, !isAndroid && multiline && label &&
  /*#__PURE__*/
  // Workaround for: https://github.com/callstack/react-native-paper/issues/2799
  // Patch for a multiline TextInput with fixed height, which allow to avoid covering input label with its value.
  React__namespace.createElement(reactNative.View, {
    testID: "patch-container",
    pointerEvents: "none",
    style: [reactNative.StyleSheet.absoluteFill, dense ? styles$4.densePatchContainer : styles$4.patchContainer, {
      backgroundColor: viewStyle.backgroundColor || containerStyle.backgroundColor,
      left: paddingLeft,
      right: paddingRight
    }]
  }), /*#__PURE__*/React__namespace.createElement(InputLabel, {
    parentState: parentState,
    labelProps: labelProps
  }), render === null || render === void 0 ? void 0 : render({
    testID: 'text-input-flat',
    ...rest,
    ref: innerRef,
    onChangeText,
    placeholder: label ? parentState.placeholder : rest.placeholder,
    placeholderTextColor: placeholderTextColor !== null && placeholderTextColor !== void 0 ? placeholderTextColor : placeholderColor,
    editable: !disabled && editable,
    selectionColor: typeof selectionColor === 'undefined' ? activeColor : selectionColor,
    onFocus,
    onBlur,
    underlineColorAndroid: 'transparent',
    multiline,
    style: [styles$4.input, {
      paddingLeft,
      paddingRight
    }, !multiline || multiline && height ? {
      height: flatHeight
    } : {}, paddingFlat, { ...font,
      fontSize,
      fontWeight,
      color: inputTextColor,
      textAlignVertical: multiline ? 'top' : 'center',
      textAlign: textAlign ? textAlign : reactNative.I18nManager.isRTL ? 'right' : 'left'
    }, reactNative.Platform.OS === 'web' && {
      outline: 'none'
    }, adornmentStyleAdjustmentForNativeInput]
  })), /*#__PURE__*/React__namespace.createElement(TextInputAdornment, adornmentProps));
};

const Underline = _ref2 => {
  let {
    parentState,
    error,
    colors,
    activeColor,
    underlineColorCustom
  } = _ref2;
  let backgroundColor = parentState.focused ? activeColor : underlineColorCustom;
  if (error) backgroundColor = colors.error;
  return /*#__PURE__*/React__namespace.createElement(reactNative.Animated.View, {
    style: [styles$4.underline, {
      backgroundColor,
      // Underlines is thinner when input is not focused
      transform: [{
        scaleY: parentState.focused ? 1 : 0.5
      }]
    }]
  });
};

const styles$4 = reactNative.StyleSheet.create({
  placeholder: {
    position: 'absolute',
    left: 0
  },
  underline: {
    position: 'absolute',
    left: 0,
    right: 0,
    bottom: 0,
    height: 2,
    zIndex: 1
  },
  labelContainer: {
    paddingTop: 0,
    paddingBottom: 0
  },
  input: {
    flexGrow: 1,
    margin: 0
  },
  inputFlat: {
    paddingTop: 24,
    paddingBottom: 4
  },
  inputFlatDense: {
    paddingTop: 22,
    paddingBottom: 2
  },
  patchContainer: {
    height: 24,
    zIndex: 2
  },
  densePatchContainer: {
    height: 22,
    zIndex: 2
  }
});

function _extends$2() { _extends$2 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$2.apply(this, arguments); }
const BLUR_ANIMATION_DURATION = 180;
const FOCUS_ANIMATION_DURATION = 150;

/**
 * A component to allow users to input text.
 *
 * <div class="screenshots">
 *   <figure>
 *     <img class="medium" src="screenshots/textinput-flat.focused.png" />
 *     <figcaption>Flat (focused)</figcaption>
 *   </figure>
 *   <figure>
 *     <img class="medium" src="screenshots/textinput-flat.disabled.png" />
 *     <figcaption>Flat (disabled)</figcaption>
 *   </figure>
 *   <figure>
 *     <img class="medium" src="screenshots/textinput-outlined.focused.png" />
 *     <figcaption>Outlined (focused)</figcaption>
 *   </figure>
 *   <figure>
 *     <img class="medium" src="screenshots/textinput-outlined.disabled.png" />
 *     <figcaption>Outlined (disabled)</figcaption>
 *   </figure>
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { TextInput } from 'react-native-paper';
 *
 * const MyComponent = () => {
 *   const [text, setText] = React.useState("");
 *
 *   return (
 *     <TextInput
 *       label="Email"
 *       value={text}
 *       onChangeText={text => setText(text)}
 *     />
 *   );
 * };
 *
 * export default MyComponent;
 * ```
 *
 * @extends TextInput props https://reactnative.dev/docs/textinput#props
 */
const TextInput = /*#__PURE__*/React__namespace.forwardRef((_ref, ref) => {
  let {
    mode = 'flat',
    dense = false,
    disabled = false,
    error: errorProp = false,
    multiline = false,
    editable = true,
    render = props => /*#__PURE__*/React__namespace.createElement(reactNative.TextInput, props),
    ...rest
  } = _ref;
  const isControlled = rest.value !== undefined;
  const validInputValue = isControlled ? rest.value : rest.defaultValue;
  const {
    current: labeled
  } = React__namespace.useRef(new reactNative.Animated.Value(validInputValue ? 0 : 1));
  const {
    current: error
  } = React__namespace.useRef(new reactNative.Animated.Value(errorProp ? 1 : 0));
  const [focused, setFocused] = React__namespace.useState(false);
  const [placeholder, setPlaceholder] = React__namespace.useState('');
  const [uncontrolledValue, setUncontrolledValue] = React__namespace.useState(validInputValue); // Use value from props instead of local state when input is controlled

  const value = isControlled ? rest.value : uncontrolledValue;
  const [labelLayout, setLabelLayout] = React__namespace.useState({
    measured: false,
    width: 0,
    height: 0
  });
  const [leftLayout, setLeftLayout] = React__namespace.useState({
    width: null,
    height: null
  });
  const [rightLayout, setRightLayout] = React__namespace.useState({
    width: null,
    height: null
  });
  const timer = React__namespace.useRef();
  const root = React__namespace.useRef();
  const {
    scale
  } = rest.theme.animation;
  React__namespace.useImperativeHandle(ref, () => ({
    focus: () => {
      var _root$current;

      return (_root$current = root.current) === null || _root$current === void 0 ? void 0 : _root$current.focus();
    },
    clear: () => {
      var _root$current2;

      return (_root$current2 = root.current) === null || _root$current2 === void 0 ? void 0 : _root$current2.clear();
    },
    setNativeProps: args => {
      var _root$current3;

      return (_root$current3 = root.current) === null || _root$current3 === void 0 ? void 0 : _root$current3.setNativeProps(args);
    },
    isFocused: () => {
      var _root$current4;

      return ((_root$current4 = root.current) === null || _root$current4 === void 0 ? void 0 : _root$current4.isFocused()) || false;
    },
    blur: () => {
      var _root$current5;

      return (_root$current5 = root.current) === null || _root$current5 === void 0 ? void 0 : _root$current5.blur();
    },
    forceFocus: () => {
      var _root$current6;

      return (_root$current6 = root.current) === null || _root$current6 === void 0 ? void 0 : _root$current6.focus();
    }
  }));
  React__namespace.useEffect(() => {
    // When the input has an error, we wiggle the label and apply error styles
    if (errorProp) {
      // show error
      reactNative.Animated.timing(error, {
        toValue: 1,
        duration: FOCUS_ANIMATION_DURATION * scale,
        // To prevent this - https://github.com/callstack/react-native-paper/issues/941
        useNativeDriver: true
      }).start();
    } else {
      // hide error
      {
        reactNative.Animated.timing(error, {
          toValue: 0,
          duration: BLUR_ANIMATION_DURATION * scale,
          // To prevent this - https://github.com/callstack/react-native-paper/issues/941
          useNativeDriver: true
        }).start();
      }
    }
  }, [errorProp, scale, error]);
  React__namespace.useEffect(() => {
    // Show placeholder text only if the input is focused, or there's no label
    // We don't show placeholder if there's a label because the label acts as placeholder
    // When focused, the label moves up, so we can show a placeholder
    if (focused || !rest.label) {
      // Set the placeholder in a delay to offset the label animation
      // If we show it immediately, they'll overlap and look ugly
      timer.current = setTimeout(() => setPlaceholder(rest.placeholder), 50);
    } else {
      // hidePlaceholder
      setPlaceholder('');
    }

    return () => {
      if (timer.current) {
        clearTimeout(timer.current);
      }
    };
  }, [focused, rest.label, rest.placeholder]);
  React__namespace.useEffect(() => {
    // The label should be minimized if the text input is focused, or has text
    // In minimized mode, the label moves up and becomes small
    // workaround for animated regression for react native > 0.61
    // https://github.com/callstack/react-native-paper/pull/1440
    if (value || focused) {
      // minimize label
      reactNative.Animated.timing(labeled, {
        toValue: 0,
        duration: BLUR_ANIMATION_DURATION * scale,
        // To prevent this - https://github.com/callstack/react-native-paper/issues/941
        useNativeDriver: true
      }).start();
    } else {
      // restore label
      {
        reactNative.Animated.timing(labeled, {
          toValue: 1,
          duration: FOCUS_ANIMATION_DURATION * scale,
          // To prevent this - https://github.com/callstack/react-native-paper/issues/941
          useNativeDriver: true
        }).start();
      }
    }
  }, [focused, value, labeled, scale]);

  const onLeftAffixLayoutChange = event => {
    setLeftLayout({
      height: event.nativeEvent.layout.height,
      width: event.nativeEvent.layout.width
    });
  };

  const onRightAffixLayoutChange = event => {
    setRightLayout({
      width: event.nativeEvent.layout.width,
      height: event.nativeEvent.layout.height
    });
  };

  const handleFocus = args => {
    var _rest$onFocus;

    if (disabled || !editable) {
      return;
    }

    setFocused(true);
    (_rest$onFocus = rest.onFocus) === null || _rest$onFocus === void 0 ? void 0 : _rest$onFocus.call(rest, args);
  };

  const handleBlur = args => {
    var _rest$onBlur;

    if (!editable) {
      return;
    }

    setFocused(false);
    (_rest$onBlur = rest.onBlur) === null || _rest$onBlur === void 0 ? void 0 : _rest$onBlur.call(rest, args);
  };

  const handleChangeText = value => {
    var _rest$onChangeText;

    if (!editable || disabled) {
      return;
    }

    if (!isControlled) {
      // Keep track of value in local state when input is not controlled
      setUncontrolledValue(value);
    }

    (_rest$onChangeText = rest.onChangeText) === null || _rest$onChangeText === void 0 ? void 0 : _rest$onChangeText.call(rest, value);
  };

  const handleLayoutAnimatedText = e => {
    setLabelLayout({
      width: e.nativeEvent.layout.width,
      height: e.nativeEvent.layout.height,
      measured: true
    });
  };

  const forceFocus = () => {
    var _root$current7;

    return (_root$current7 = root.current) === null || _root$current7 === void 0 ? void 0 : _root$current7.focus();
  };

  const {
    maxFontSizeMultiplier = 1.5
  } = rest;

  if (mode === 'outlined') {
    return /*#__PURE__*/React__namespace.createElement(TextInputOutlined, _extends$2({
      dense: dense,
      disabled: disabled,
      error: errorProp,
      multiline: multiline,
      editable: editable,
      render: render
    }, rest, {
      value: value,
      parentState: {
        labeled,
        error,
        focused,
        placeholder,
        value,
        labelLayout,
        leftLayout,
        rightLayout
      },
      innerRef: ref => {
        root.current = ref;
      },
      onFocus: handleFocus,
      forceFocus: forceFocus,
      onBlur: handleBlur,
      onChangeText: handleChangeText,
      onLayoutAnimatedText: handleLayoutAnimatedText,
      onLeftAffixLayoutChange: onLeftAffixLayoutChange,
      onRightAffixLayoutChange: onRightAffixLayoutChange,
      maxFontSizeMultiplier: maxFontSizeMultiplier
    }));
  }

  return /*#__PURE__*/React__namespace.createElement(TextInputFlat, _extends$2({
    dense: dense,
    disabled: disabled,
    error: errorProp,
    multiline: multiline,
    editable: editable,
    render: render
  }, rest, {
    value: value,
    parentState: {
      labeled,
      error,
      focused,
      placeholder,
      value,
      labelLayout,
      leftLayout,
      rightLayout
    },
    innerRef: ref => {
      root.current = ref;
    },
    onFocus: handleFocus,
    forceFocus: forceFocus,
    onBlur: handleBlur,
    onChangeText: handleChangeText,
    onLayoutAnimatedText: handleLayoutAnimatedText,
    onLeftAffixLayoutChange: onLeftAffixLayoutChange,
    onRightAffixLayoutChange: onRightAffixLayoutChange,
    maxFontSizeMultiplier: maxFontSizeMultiplier
  }));
}); // @component ./Adornment/TextInputIcon.tsx

TextInput.Icon = TextInputIcon; // @component ./Adornment/TextInputAffix.tsx
// @ts-ignore Types of property 'theme' are incompatible.

TextInput.Affix = TextInputAffix$1;
var TextInput$1 = withTheme(TextInput);

const ToggleButtonGroupContext = /*#__PURE__*/React__namespace.createContext(null);
/**
 * Toggle group allows to control a group of toggle buttons.</br>
 * It doesn't change the appearance of the toggle buttons. If you want to group them in a row, check out <a href="toggle-button-row.html">`ToggleButton.Row`</a>.
 *
 * <div class="screenshots">
 *   <figure>
 *     <img class="medium" src="screenshots/toggle-button-group.gif" />
 *   </figure>
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { ToggleButton } from 'react-native-paper';
 *
 * const MyComponent = () => {
 *   const [value, setValue] = React.useState('left');
 *
 *   return (
 *     <ToggleButton.Group
 *       onValueChange={value => setValue(value)}
 *       value={value}>
 *       <ToggleButton icon="format-align-left" value="left" />
 *       <ToggleButton icon="format-align-right" value="right" />
 *     </ToggleButton.Group>
 *   );
 * };
 *
 * export default MyComponent;
 *```
 */

const ToggleButtonGroup = _ref => {
  let {
    value,
    onValueChange,
    children
  } = _ref;
  return /*#__PURE__*/React__namespace.createElement(ToggleButtonGroupContext.Provider, {
    value: {
      value,
      onValueChange
    }
  }, children);
};

ToggleButtonGroup.displayName = 'ToggleButton.Group';

function _extends$1() { _extends$1 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$1.apply(this, arguments); }

/**
 * Toggle buttons can be used to group related options. To emphasize groups of related toggle buttons,
 * a group should share a common container.
 *
 * <div class="screenshots">
 *   <img class="medium" src="screenshots/toggle-button.png" />
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { ToggleButton } from 'react-native-paper';
 *
 * const ToggleButtonExample = () => {
 *   const [status, setStatus] = React.useState('checked');
 *
 *   const onButtonToggle = value => {
 *     setStatus(status === 'checked' ? 'unchecked' : 'checked');
 *   };
 *
 *   return (
 *     <ToggleButton
 *       icon="bluetooth"
 *       value="bluetooth"
 *       status={status}
 *       onPress={onButtonToggle}
 *     />
 *   );
 * };
 *
 * export default ToggleButtonExample;
 *
 * ```
 */
const ToggleButton = _ref => {
  let {
    icon,
    size,
    theme,
    accessibilityLabel,
    disabled,
    style,
    value,
    status,
    onPress,
    ...rest
  } = _ref;
  const borderRadius = theme.roundness;
  return /*#__PURE__*/React__namespace.createElement(ToggleButtonGroupContext.Consumer, null, context => {
    let backgroundColor;
    const checked = context && context.value === value || status === 'checked';

    if (checked) {
      backgroundColor = theme.dark ? 'rgba(255, 255, 255, .12)' : 'rgba(0, 0, 0, .08)';
    } else {
      backgroundColor = 'transparent';
    }

    return /*#__PURE__*/React__namespace.createElement(IconButton$1, _extends$1({
      borderless: false,
      icon: icon,
      onPress: e => {
        if (onPress) {
          onPress(e);
        }

        if (context) {
          context.onValueChange(!checked ? value : null);
        }
      },
      size: size,
      accessibilityLabel: accessibilityLabel,
      accessibilityState: {
        disabled,
        selected: checked
      },
      disabled: disabled,
      style: [styles$3.content, {
        backgroundColor,
        borderRadius,
        borderColor: color$1(theme.dark ? white : black).alpha(0.29).rgb().string()
      }, style]
    }, rest));
  });
};

const styles$3 = reactNative.StyleSheet.create({
  content: {
    width: 42,
    height: 42,
    margin: 0
  }
});
var ToggleButtonComponent = withTheme(ToggleButton); // @component-docs ignore-next-line

withTheme(ToggleButton); // @component-docs ignore-next-line

/**
 * Toggle button row renders a group of toggle buttons in a row.
 *
 * <div class="screenshots">
 *   <figure>
 *     <img class="medium" src="screenshots/toggle-button-row.gif" />
 *   </figure>
 * </div>
 *
 * ## Usage
 * ```js
 * import * as React from 'react';
 * import { ToggleButton } from 'react-native-paper';
 *
 * const MyComponent = () => {
 *   const [value, setValue] = React.useState('left');
 *
 *   return (
 *     <ToggleButton.Row onValueChange={value => setValue(value)} value={value}>
 *       <ToggleButton icon="format-align-left" value="left" />
 *       <ToggleButton icon="format-align-right" value="right" />
 *     </ToggleButton.Row>
 *   );
 * };
 *
 * export default MyComponent;
 *
 *```
 */
const ToggleButtonRow = _ref => {
  let {
    value,
    onValueChange,
    children,
    style
  } = _ref;
  const count = React__namespace.Children.count(children);
  return /*#__PURE__*/React__namespace.createElement(ToggleButtonGroup, {
    value: value,
    onValueChange: onValueChange
  }, /*#__PURE__*/React__namespace.createElement(reactNative.View, {
    style: [styles$2.row, style]
  }, React__namespace.Children.map(children, (child, i) => {
    // @ts-expect-error: TypeScript complains about child.type but it doesn't matter
    if (child && child.type === ToggleButtonComponent) {
      // @ts-expect-error: We're sure that child is a React Element
      return /*#__PURE__*/React__namespace.cloneElement(child, {
        style: [styles$2.button, i === 0 ? styles$2.first : i === count - 1 ? styles$2.last : styles$2.middle, // @ts-expect-error: We're sure that child is a React Element
        child.props.style]
      });
    }

    return child;
  })));
};

ToggleButtonRow.displayName = 'ToggleButton.Row';
const styles$2 = reactNative.StyleSheet.create({
  row: {
    flexDirection: 'row'
  },
  button: {
    borderWidth: reactNative.StyleSheet.hairlineWidth
  },
  first: {
    borderTopRightRadius: 0,
    borderBottomRightRadius: 0
  },
  middle: {
    borderRadius: 0,
    borderLeftWidth: 0
  },
  last: {
    borderLeftWidth: 0,
    borderTopLeftRadius: 0,
    borderBottomLeftRadius: 0
  }
});

Object.assign( // @component ./ToggleButton.tsx
ToggleButtonComponent, {
  // @component ./ToggleButtonGroup.tsx
  Group: ToggleButtonGroup,
  // @component ./ToggleButtonRow.tsx
  Row: ToggleButtonRow
});

reactNative.StyleSheet.create({
  text: {
    fontSize: 24,
    lineHeight: 32,
    marginVertical: 2,
    letterSpacing: 0
  }
});

reactNative.StyleSheet.create({
  text: {
    fontSize: 14,
    lineHeight: 20,
    marginVertical: 2,
    letterSpacing: 0.25
  }
});

reactNative.StyleSheet.create({
  text: {
    fontSize: 16,
    lineHeight: 24,
    marginVertical: 2,
    letterSpacing: 0.5
  }
});

var lightTheme = {
    background: {
        primary: white$1,
        secondary: aliceBlue,
        tertiary: lightGray,
        highlight: lavendar,
        lowLight: darkNavy,
        error: mistyRose,
        warning: orange$1,
        page: ghostWhite,
    },
    text: {
        primary: 'black',
        secondary: grey$1,
        highlight: dodgerBlue,
        error: crimson,
        warning: orange$1,
    },
};
/**
 * Keeping as a reference for the time being until
 * this new theme format is more better adopted
 */
// backgroundPrimary: white,
// backgroundPage: ghostWhite,
// backgroundSecondary: aliceBlue,
// backgroundModal: white,
// backgroundHeader: white,
// backgroundError: mistyRose,
// textMuted: grey,
// textError: crimson,
// textWarning: orange,
// highlight: dodgerBlue,
// backgroundGrey: solitudeGrey,
// backgroundBlue: darkNavy,

var ThemeCtx = React$3.createContext({
    theme: lightTheme,
    setTheme: function () { return null; },
});
var ThemeProvider$2 = function (_a) {
    var children = _a.children;
    var _b = React$3.useState(lightTheme), theme = _b[0], setTheme = _b[1];
    return (jsxRuntime.exports.jsx(ThemeCtx.Provider, __assign({ value: { theme: theme, setTheme: setTheme } }, { children: children })));
};

var ModalCtx = React$3.createContext({
    open: false,
    opts: {},
    setOpen: function () { return null; },
    renderer: function () { return null; },
    setRenderer: function () { return null; }
});

var useTheme$4 = function () {
    var theme = React$3.useContext(ThemeCtx).theme;
    return theme;
};
var useModal = function () { return React$3.useContext(ModalCtx); };

var TextField = function (_a) {
    var value = _a.value, onChangeText = _a.onChangeText, label = _a.label, placeholder = _a.placeholder, style = _a.style, capitalize = _a.capitalize, onBlur = _a.onBlur, onFocus = _a.onFocus, render = _a.render, disabled = _a.disabled;
    var theme = useTheme$4();
    return (jsxRuntime.exports.jsx(TextInput$1, __assign({}, {
        children: undefined,
        autoComplete: undefined,
        disabled: disabled,
        render: render,
        onFocus: onFocus,
        onBlur: onBlur,
        autoCapitalize: capitalize ? "characters" : undefined,
        label: label,
        style: [{ backgroundColor: "transparent" }, style],
        value: value,
        onChangeText: function (val) { return onChangeText(val.trim()); },
        placeholder: placeholder,
        activeOutlineColor: theme.background.highlight,
        activeUnderlineColor: theme.background.highlight,
    })));
};

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

var propTypes = {exports: {}};

var reactIs$1 = {exports: {}};

var reactIs_production_min$1 = {};

/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactIs_production_min$1;

function requireReactIs_production_min$1 () {
	if (hasRequiredReactIs_production_min$1) return reactIs_production_min$1;
	hasRequiredReactIs_production_min$1 = 1;
var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?
	Symbol.for("react.suspense_list"):60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.block"):60121,w=b?Symbol.for("react.fundamental"):60117,x=b?Symbol.for("react.responder"):60118,y=b?Symbol.for("react.scope"):60119;
	function z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}reactIs_production_min$1.AsyncMode=l;reactIs_production_min$1.ConcurrentMode=m;reactIs_production_min$1.ContextConsumer=k;reactIs_production_min$1.ContextProvider=h;reactIs_production_min$1.Element=c;reactIs_production_min$1.ForwardRef=n;reactIs_production_min$1.Fragment=e;reactIs_production_min$1.Lazy=t;reactIs_production_min$1.Memo=r;reactIs_production_min$1.Portal=d;
	reactIs_production_min$1.Profiler=g;reactIs_production_min$1.StrictMode=f;reactIs_production_min$1.Suspense=p;reactIs_production_min$1.isAsyncMode=function(a){return A(a)||z(a)===l};reactIs_production_min$1.isConcurrentMode=A;reactIs_production_min$1.isContextConsumer=function(a){return z(a)===k};reactIs_production_min$1.isContextProvider=function(a){return z(a)===h};reactIs_production_min$1.isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===c};reactIs_production_min$1.isForwardRef=function(a){return z(a)===n};reactIs_production_min$1.isFragment=function(a){return z(a)===e};reactIs_production_min$1.isLazy=function(a){return z(a)===t};
	reactIs_production_min$1.isMemo=function(a){return z(a)===r};reactIs_production_min$1.isPortal=function(a){return z(a)===d};reactIs_production_min$1.isProfiler=function(a){return z(a)===g};reactIs_production_min$1.isStrictMode=function(a){return z(a)===f};reactIs_production_min$1.isSuspense=function(a){return z(a)===p};
	reactIs_production_min$1.isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};reactIs_production_min$1.typeOf=z;
	return reactIs_production_min$1;
}

var reactIs_development$1 = {};

/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactIs_development$1;

function requireReactIs_development$1 () {
	if (hasRequiredReactIs_development$1) return reactIs_development$1;
	hasRequiredReactIs_development$1 = 1;



	if (process.env.NODE_ENV !== "production") {
	  (function() {

	// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.
	var hasSymbol = typeof Symbol === 'function' && Symbol.for;
	var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
	var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
	var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
	var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
	var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
	var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
	var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
	// (unstable) APIs that have been removed. Can we remove the symbols?

	var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
	var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
	var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
	var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
	var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
	var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
	var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
	var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
	var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
	var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
	var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

	function isValidElementType(type) {
	  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
	  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
	}

	function typeOf(object) {
	  if (typeof object === 'object' && object !== null) {
	    var $$typeof = object.$$typeof;

	    switch ($$typeof) {
	      case REACT_ELEMENT_TYPE:
	        var type = object.type;

	        switch (type) {
	          case REACT_ASYNC_MODE_TYPE:
	          case REACT_CONCURRENT_MODE_TYPE:
	          case REACT_FRAGMENT_TYPE:
	          case REACT_PROFILER_TYPE:
	          case REACT_STRICT_MODE_TYPE:
	          case REACT_SUSPENSE_TYPE:
	            return type;

	          default:
	            var $$typeofType = type && type.$$typeof;

	            switch ($$typeofType) {
	              case REACT_CONTEXT_TYPE:
	              case REACT_FORWARD_REF_TYPE:
	              case REACT_LAZY_TYPE:
	              case REACT_MEMO_TYPE:
	              case REACT_PROVIDER_TYPE:
	                return $$typeofType;

	              default:
	                return $$typeof;
	            }

	        }

	      case REACT_PORTAL_TYPE:
	        return $$typeof;
	    }
	  }

	  return undefined;
	} // AsyncMode is deprecated along with isAsyncMode

	var AsyncMode = REACT_ASYNC_MODE_TYPE;
	var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
	var ContextConsumer = REACT_CONTEXT_TYPE;
	var ContextProvider = REACT_PROVIDER_TYPE;
	var Element = REACT_ELEMENT_TYPE;
	var ForwardRef = REACT_FORWARD_REF_TYPE;
	var Fragment = REACT_FRAGMENT_TYPE;
	var Lazy = REACT_LAZY_TYPE;
	var Memo = REACT_MEMO_TYPE;
	var Portal = REACT_PORTAL_TYPE;
	var Profiler = REACT_PROFILER_TYPE;
	var StrictMode = REACT_STRICT_MODE_TYPE;
	var Suspense = REACT_SUSPENSE_TYPE;
	var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

	function isAsyncMode(object) {
	  {
	    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
	      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

	      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
	    }
	  }

	  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
	}
	function isConcurrentMode(object) {
	  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
	}
	function isContextConsumer(object) {
	  return typeOf(object) === REACT_CONTEXT_TYPE;
	}
	function isContextProvider(object) {
	  return typeOf(object) === REACT_PROVIDER_TYPE;
	}
	function isElement(object) {
	  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	}
	function isForwardRef(object) {
	  return typeOf(object) === REACT_FORWARD_REF_TYPE;
	}
	function isFragment(object) {
	  return typeOf(object) === REACT_FRAGMENT_TYPE;
	}
	function isLazy(object) {
	  return typeOf(object) === REACT_LAZY_TYPE;
	}
	function isMemo(object) {
	  return typeOf(object) === REACT_MEMO_TYPE;
	}
	function isPortal(object) {
	  return typeOf(object) === REACT_PORTAL_TYPE;
	}
	function isProfiler(object) {
	  return typeOf(object) === REACT_PROFILER_TYPE;
	}
	function isStrictMode(object) {
	  return typeOf(object) === REACT_STRICT_MODE_TYPE;
	}
	function isSuspense(object) {
	  return typeOf(object) === REACT_SUSPENSE_TYPE;
	}

	reactIs_development$1.AsyncMode = AsyncMode;
	reactIs_development$1.ConcurrentMode = ConcurrentMode;
	reactIs_development$1.ContextConsumer = ContextConsumer;
	reactIs_development$1.ContextProvider = ContextProvider;
	reactIs_development$1.Element = Element;
	reactIs_development$1.ForwardRef = ForwardRef;
	reactIs_development$1.Fragment = Fragment;
	reactIs_development$1.Lazy = Lazy;
	reactIs_development$1.Memo = Memo;
	reactIs_development$1.Portal = Portal;
	reactIs_development$1.Profiler = Profiler;
	reactIs_development$1.StrictMode = StrictMode;
	reactIs_development$1.Suspense = Suspense;
	reactIs_development$1.isAsyncMode = isAsyncMode;
	reactIs_development$1.isConcurrentMode = isConcurrentMode;
	reactIs_development$1.isContextConsumer = isContextConsumer;
	reactIs_development$1.isContextProvider = isContextProvider;
	reactIs_development$1.isElement = isElement;
	reactIs_development$1.isForwardRef = isForwardRef;
	reactIs_development$1.isFragment = isFragment;
	reactIs_development$1.isLazy = isLazy;
	reactIs_development$1.isMemo = isMemo;
	reactIs_development$1.isPortal = isPortal;
	reactIs_development$1.isProfiler = isProfiler;
	reactIs_development$1.isStrictMode = isStrictMode;
	reactIs_development$1.isSuspense = isSuspense;
	reactIs_development$1.isValidElementType = isValidElementType;
	reactIs_development$1.typeOf = typeOf;
	  })();
	}
	return reactIs_development$1;
}

var hasRequiredReactIs;

function requireReactIs () {
	if (hasRequiredReactIs) return reactIs$1.exports;
	hasRequiredReactIs = 1;
	(function (module) {

		if (process.env.NODE_ENV === 'production') {
		  module.exports = requireReactIs_production_min$1();
		} else {
		  module.exports = requireReactIs_development$1();
		}
} (reactIs$1));
	return reactIs$1.exports;
}

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var ReactPropTypesSecret_1;
var hasRequiredReactPropTypesSecret;

function requireReactPropTypesSecret () {
	if (hasRequiredReactPropTypesSecret) return ReactPropTypesSecret_1;
	hasRequiredReactPropTypesSecret = 1;

	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

	ReactPropTypesSecret_1 = ReactPropTypesSecret;
	return ReactPropTypesSecret_1;
}

var has;
var hasRequiredHas;

function requireHas () {
	if (hasRequiredHas) return has;
	hasRequiredHas = 1;
	has = Function.call.bind(Object.prototype.hasOwnProperty);
	return has;
}

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var checkPropTypes_1;
var hasRequiredCheckPropTypes;

function requireCheckPropTypes () {
	if (hasRequiredCheckPropTypes) return checkPropTypes_1;
	hasRequiredCheckPropTypes = 1;

	var printWarning = function() {};

	if (process.env.NODE_ENV !== 'production') {
	  var ReactPropTypesSecret = requireReactPropTypesSecret();
	  var loggedTypeFailures = {};
	  var has = requireHas();

	  printWarning = function(text) {
	    var message = 'Warning: ' + text;
	    if (typeof console !== 'undefined') {
	      console.error(message);
	    }
	    try {
	      // --- Welcome to debugging React ---
	      // This error was thrown as a convenience so that you can use this stack
	      // to find the callsite that caused this warning to fire.
	      throw new Error(message);
	    } catch (x) { /**/ }
	  };
	}

	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?Function} getStack Returns the component stack.
	 * @private
	 */
	function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
	  if (process.env.NODE_ENV !== 'production') {
	    for (var typeSpecName in typeSpecs) {
	      if (has(typeSpecs, typeSpecName)) {
	        var error;
	        // Prop type validation may throw. In case they do, we don't want to
	        // fail the render phase where it didn't fail before. So we log it.
	        // After these have been cleaned up, we'll let them throw.
	        try {
	          // This is intentionally an invariant that gets caught. It's the same
	          // behavior as without this statement except with a better message.
	          if (typeof typeSpecs[typeSpecName] !== 'function') {
	            var err = Error(
	              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
	              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' +
	              'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.'
	            );
	            err.name = 'Invariant Violation';
	            throw err;
	          }
	          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
	        } catch (ex) {
	          error = ex;
	        }
	        if (error && !(error instanceof Error)) {
	          printWarning(
	            (componentName || 'React class') + ': type specification of ' +
	            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
	            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
	            'You may have forgotten to pass an argument to the type checker ' +
	            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
	            'shape all require an argument).'
	          );
	        }
	        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	          // Only monitor this failure once because there tends to be a lot of the
	          // same error.
	          loggedTypeFailures[error.message] = true;

	          var stack = getStack ? getStack() : '';

	          printWarning(
	            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
	          );
	        }
	      }
	    }
	  }
	}

	/**
	 * Resets warning cache when testing.
	 *
	 * @private
	 */
	checkPropTypes.resetWarningCache = function() {
	  if (process.env.NODE_ENV !== 'production') {
	    loggedTypeFailures = {};
	  }
	};

	checkPropTypes_1 = checkPropTypes;
	return checkPropTypes_1;
}

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var factoryWithTypeCheckers;
var hasRequiredFactoryWithTypeCheckers;

function requireFactoryWithTypeCheckers () {
	if (hasRequiredFactoryWithTypeCheckers) return factoryWithTypeCheckers;
	hasRequiredFactoryWithTypeCheckers = 1;

	var ReactIs = requireReactIs();
	var assign = requireObjectAssign();

	var ReactPropTypesSecret = requireReactPropTypesSecret();
	var has = requireHas();
	var checkPropTypes = requireCheckPropTypes();

	var printWarning = function() {};

	if (process.env.NODE_ENV !== 'production') {
	  printWarning = function(text) {
	    var message = 'Warning: ' + text;
	    if (typeof console !== 'undefined') {
	      console.error(message);
	    }
	    try {
	      // --- Welcome to debugging React ---
	      // This error was thrown as a convenience so that you can use this stack
	      // to find the callsite that caused this warning to fire.
	      throw new Error(message);
	    } catch (x) {}
	  };
	}

	function emptyFunctionThatReturnsNull() {
	  return null;
	}

	factoryWithTypeCheckers = function(isValidElement, throwOnDirectAccess) {
	  /* global Symbol */
	  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

	  /**
	   * Returns the iterator method function contained on the iterable object.
	   *
	   * Be sure to invoke the function with the iterable as context:
	   *
	   *     var iteratorFn = getIteratorFn(myIterable);
	   *     if (iteratorFn) {
	   *       var iterator = iteratorFn.call(myIterable);
	   *       ...
	   *     }
	   *
	   * @param {?object} maybeIterable
	   * @return {?function}
	   */
	  function getIteratorFn(maybeIterable) {
	    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	    if (typeof iteratorFn === 'function') {
	      return iteratorFn;
	    }
	  }

	  /**
	   * Collection of methods that allow declaration and validation of props that are
	   * supplied to React components. Example usage:
	   *
	   *   var Props = require('ReactPropTypes');
	   *   var MyArticle = React.createClass({
	   *     propTypes: {
	   *       // An optional string prop named "description".
	   *       description: Props.string,
	   *
	   *       // A required enum prop named "category".
	   *       category: Props.oneOf(['News','Photos']).isRequired,
	   *
	   *       // A prop named "dialog" that requires an instance of Dialog.
	   *       dialog: Props.instanceOf(Dialog).isRequired
	   *     },
	   *     render: function() { ... }
	   *   });
	   *
	   * A more formal specification of how these methods are used:
	   *
	   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	   *   decl := ReactPropTypes.{type}(.isRequired)?
	   *
	   * Each and every declaration produces a function with the same signature. This
	   * allows the creation of custom validation functions. For example:
	   *
	   *  var MyLink = React.createClass({
	   *    propTypes: {
	   *      // An optional string or URI prop named "href".
	   *      href: function(props, propName, componentName) {
	   *        var propValue = props[propName];
	   *        if (propValue != null && typeof propValue !== 'string' &&
	   *            !(propValue instanceof URI)) {
	   *          return new Error(
	   *            'Expected a string or an URI for ' + propName + ' in ' +
	   *            componentName
	   *          );
	   *        }
	   *      }
	   *    },
	   *    render: function() {...}
	   *  });
	   *
	   * @internal
	   */

	  var ANONYMOUS = '<<anonymous>>';

	  // Important!
	  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
	  var ReactPropTypes = {
	    array: createPrimitiveTypeChecker('array'),
	    bigint: createPrimitiveTypeChecker('bigint'),
	    bool: createPrimitiveTypeChecker('boolean'),
	    func: createPrimitiveTypeChecker('function'),
	    number: createPrimitiveTypeChecker('number'),
	    object: createPrimitiveTypeChecker('object'),
	    string: createPrimitiveTypeChecker('string'),
	    symbol: createPrimitiveTypeChecker('symbol'),

	    any: createAnyTypeChecker(),
	    arrayOf: createArrayOfTypeChecker,
	    element: createElementTypeChecker(),
	    elementType: createElementTypeTypeChecker(),
	    instanceOf: createInstanceTypeChecker,
	    node: createNodeChecker(),
	    objectOf: createObjectOfTypeChecker,
	    oneOf: createEnumTypeChecker,
	    oneOfType: createUnionTypeChecker,
	    shape: createShapeTypeChecker,
	    exact: createStrictShapeTypeChecker,
	  };

	  /**
	   * inlined Object.is polyfill to avoid requiring consumers ship their own
	   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	   */
	  /*eslint-disable no-self-compare*/
	  function is(x, y) {
	    // SameValue algorithm
	    if (x === y) {
	      // Steps 1-5, 7-10
	      // Steps 6.b-6.e: +0 != -0
	      return x !== 0 || 1 / x === 1 / y;
	    } else {
	      // Step 6.a: NaN == NaN
	      return x !== x && y !== y;
	    }
	  }
	  /*eslint-enable no-self-compare*/

	  /**
	   * We use an Error-like object for backward compatibility as people may call
	   * PropTypes directly and inspect their output. However, we don't use real
	   * Errors anymore. We don't inspect their stack anyway, and creating them
	   * is prohibitively expensive if they are created too often, such as what
	   * happens in oneOfType() for any type before the one that matched.
	   */
	  function PropTypeError(message, data) {
	    this.message = message;
	    this.data = data && typeof data === 'object' ? data: {};
	    this.stack = '';
	  }
	  // Make `instanceof Error` still work for returned errors.
	  PropTypeError.prototype = Error.prototype;

	  function createChainableTypeChecker(validate) {
	    if (process.env.NODE_ENV !== 'production') {
	      var manualPropTypeCallCache = {};
	      var manualPropTypeWarningCount = 0;
	    }
	    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
	      componentName = componentName || ANONYMOUS;
	      propFullName = propFullName || propName;

	      if (secret !== ReactPropTypesSecret) {
	        if (throwOnDirectAccess) {
	          // New behavior only for users of `prop-types` package
	          var err = new Error(
	            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
	            'Use `PropTypes.checkPropTypes()` to call them. ' +
	            'Read more at http://fb.me/use-check-prop-types'
	          );
	          err.name = 'Invariant Violation';
	          throw err;
	        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
	          // Old behavior for people using React.PropTypes
	          var cacheKey = componentName + ':' + propName;
	          if (
	            !manualPropTypeCallCache[cacheKey] &&
	            // Avoid spamming the console because they are often not actionable except for lib authors
	            manualPropTypeWarningCount < 3
	          ) {
	            printWarning(
	              'You are manually calling a React.PropTypes validation ' +
	              'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' +
	              'and will throw in the standalone `prop-types` package. ' +
	              'You may be seeing this warning due to a third-party PropTypes ' +
	              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
	            );
	            manualPropTypeCallCache[cacheKey] = true;
	            manualPropTypeWarningCount++;
	          }
	        }
	      }
	      if (props[propName] == null) {
	        if (isRequired) {
	          if (props[propName] === null) {
	            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
	          }
	          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
	        }
	        return null;
	      } else {
	        return validate(props, propName, componentName, location, propFullName);
	      }
	    }

	    var chainedCheckType = checkType.bind(null, false);
	    chainedCheckType.isRequired = checkType.bind(null, true);

	    return chainedCheckType;
	  }

	  function createPrimitiveTypeChecker(expectedType) {
	    function validate(props, propName, componentName, location, propFullName, secret) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== expectedType) {
	        // `propValue` being instance of, say, date/regexp, pass the 'object'
	        // check, but we can offer a more precise error message here rather than
	        // 'of type `object`'.
	        var preciseType = getPreciseType(propValue);

	        return new PropTypeError(
	          'Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'),
	          {expectedType: expectedType}
	        );
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createAnyTypeChecker() {
	    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
	  }

	  function createArrayOfTypeChecker(typeChecker) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (typeof typeChecker !== 'function') {
	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
	      }
	      var propValue = props[propName];
	      if (!Array.isArray(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	      }
	      for (var i = 0; i < propValue.length; i++) {
	        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
	        if (error instanceof Error) {
	          return error;
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createElementTypeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      if (!isValidElement(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createElementTypeTypeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      if (!ReactIs.isValidElementType(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createInstanceTypeChecker(expectedClass) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (!(props[propName] instanceof expectedClass)) {
	        var expectedClassName = expectedClass.name || ANONYMOUS;
	        var actualClassName = getClassName(props[propName]);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createEnumTypeChecker(expectedValues) {
	    if (!Array.isArray(expectedValues)) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (arguments.length > 1) {
	          printWarning(
	            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
	            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
	          );
	        } else {
	          printWarning('Invalid argument supplied to oneOf, expected an array.');
	        }
	      }
	      return emptyFunctionThatReturnsNull;
	    }

	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      for (var i = 0; i < expectedValues.length; i++) {
	        if (is(propValue, expectedValues[i])) {
	          return null;
	        }
	      }

	      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
	        var type = getPreciseType(value);
	        if (type === 'symbol') {
	          return String(value);
	        }
	        return value;
	      });
	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createObjectOfTypeChecker(typeChecker) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (typeof typeChecker !== 'function') {
	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
	      }
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	      }
	      for (var key in propValue) {
	        if (has(propValue, key)) {
	          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	          if (error instanceof Error) {
	            return error;
	          }
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createUnionTypeChecker(arrayOfTypeCheckers) {
	    if (!Array.isArray(arrayOfTypeCheckers)) {
	      process.env.NODE_ENV !== 'production' ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
	      return emptyFunctionThatReturnsNull;
	    }

	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	      var checker = arrayOfTypeCheckers[i];
	      if (typeof checker !== 'function') {
	        printWarning(
	          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
	          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
	        );
	        return emptyFunctionThatReturnsNull;
	      }
	    }

	    function validate(props, propName, componentName, location, propFullName) {
	      var expectedTypes = [];
	      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	        var checker = arrayOfTypeCheckers[i];
	        var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
	        if (checkerResult == null) {
	          return null;
	        }
	        if (checkerResult.data && has(checkerResult.data, 'expectedType')) {
	          expectedTypes.push(checkerResult.data.expectedType);
	        }
	      }
	      var expectedTypesMessage = (expectedTypes.length > 0) ? ', expected one of type [' + expectedTypes.join(', ') + ']': '';
	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`' + expectedTypesMessage + '.'));
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createNodeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (!isNode(props[propName])) {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function invalidValidatorError(componentName, location, propFullName, key, type) {
	    return new PropTypeError(
	      (componentName || 'React class') + ': ' + location + ' type `' + propFullName + '.' + key + '` is invalid; ' +
	      'it must be a function, usually from the `prop-types` package, but received `' + type + '`.'
	    );
	  }

	  function createShapeTypeChecker(shapeTypes) {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	      }
	      for (var key in shapeTypes) {
	        var checker = shapeTypes[key];
	        if (typeof checker !== 'function') {
	          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
	        }
	        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	        if (error) {
	          return error;
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createStrictShapeTypeChecker(shapeTypes) {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	      }
	      // We need to check all keys in case some are required but missing from props.
	      var allKeys = assign({}, props[propName], shapeTypes);
	      for (var key in allKeys) {
	        var checker = shapeTypes[key];
	        if (has(shapeTypes, key) && typeof checker !== 'function') {
	          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
	        }
	        if (!checker) {
	          return new PropTypeError(
	            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
	            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
	            '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  ')
	          );
	        }
	        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	        if (error) {
	          return error;
	        }
	      }
	      return null;
	    }

	    return createChainableTypeChecker(validate);
	  }

	  function isNode(propValue) {
	    switch (typeof propValue) {
	      case 'number':
	      case 'string':
	      case 'undefined':
	        return true;
	      case 'boolean':
	        return !propValue;
	      case 'object':
	        if (Array.isArray(propValue)) {
	          return propValue.every(isNode);
	        }
	        if (propValue === null || isValidElement(propValue)) {
	          return true;
	        }

	        var iteratorFn = getIteratorFn(propValue);
	        if (iteratorFn) {
	          var iterator = iteratorFn.call(propValue);
	          var step;
	          if (iteratorFn !== propValue.entries) {
	            while (!(step = iterator.next()).done) {
	              if (!isNode(step.value)) {
	                return false;
	              }
	            }
	          } else {
	            // Iterator will provide entry [k,v] tuples rather than values.
	            while (!(step = iterator.next()).done) {
	              var entry = step.value;
	              if (entry) {
	                if (!isNode(entry[1])) {
	                  return false;
	                }
	              }
	            }
	          }
	        } else {
	          return false;
	        }

	        return true;
	      default:
	        return false;
	    }
	  }

	  function isSymbol(propType, propValue) {
	    // Native Symbol.
	    if (propType === 'symbol') {
	      return true;
	    }

	    // falsy value can't be a Symbol
	    if (!propValue) {
	      return false;
	    }

	    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
	    if (propValue['@@toStringTag'] === 'Symbol') {
	      return true;
	    }

	    // Fallback for non-spec compliant Symbols which are polyfilled.
	    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
	      return true;
	    }

	    return false;
	  }

	  // Equivalent of `typeof` but with special handling for array and regexp.
	  function getPropType(propValue) {
	    var propType = typeof propValue;
	    if (Array.isArray(propValue)) {
	      return 'array';
	    }
	    if (propValue instanceof RegExp) {
	      // Old webkits (at least until Android 4.0) return 'function' rather than
	      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	      // passes PropTypes.object.
	      return 'object';
	    }
	    if (isSymbol(propType, propValue)) {
	      return 'symbol';
	    }
	    return propType;
	  }

	  // This handles more types than `getPropType`. Only used for error messages.
	  // See `createPrimitiveTypeChecker`.
	  function getPreciseType(propValue) {
	    if (typeof propValue === 'undefined' || propValue === null) {
	      return '' + propValue;
	    }
	    var propType = getPropType(propValue);
	    if (propType === 'object') {
	      if (propValue instanceof Date) {
	        return 'date';
	      } else if (propValue instanceof RegExp) {
	        return 'regexp';
	      }
	    }
	    return propType;
	  }

	  // Returns a string that is postfixed to a warning about an invalid type.
	  // For example, "undefined" or "of type array"
	  function getPostfixForTypeWarning(value) {
	    var type = getPreciseType(value);
	    switch (type) {
	      case 'array':
	      case 'object':
	        return 'an ' + type;
	      case 'boolean':
	      case 'date':
	      case 'regexp':
	        return 'a ' + type;
	      default:
	        return type;
	    }
	  }

	  // Returns class name of the object, if any.
	  function getClassName(propValue) {
	    if (!propValue.constructor || !propValue.constructor.name) {
	      return ANONYMOUS;
	    }
	    return propValue.constructor.name;
	  }

	  ReactPropTypes.checkPropTypes = checkPropTypes;
	  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
	  ReactPropTypes.PropTypes = ReactPropTypes;

	  return ReactPropTypes;
	};
	return factoryWithTypeCheckers;
}

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var factoryWithThrowingShims;
var hasRequiredFactoryWithThrowingShims;

function requireFactoryWithThrowingShims () {
	if (hasRequiredFactoryWithThrowingShims) return factoryWithThrowingShims;
	hasRequiredFactoryWithThrowingShims = 1;

	var ReactPropTypesSecret = requireReactPropTypesSecret();

	function emptyFunction() {}
	function emptyFunctionWithReset() {}
	emptyFunctionWithReset.resetWarningCache = emptyFunction;

	factoryWithThrowingShims = function() {
	  function shim(props, propName, componentName, location, propFullName, secret) {
	    if (secret === ReactPropTypesSecret) {
	      // It is still safe when called from React.
	      return;
	    }
	    var err = new Error(
	      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
	      'Use PropTypes.checkPropTypes() to call them. ' +
	      'Read more at http://fb.me/use-check-prop-types'
	    );
	    err.name = 'Invariant Violation';
	    throw err;
	  }	  shim.isRequired = shim;
	  function getShim() {
	    return shim;
	  }	  // Important!
	  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
	  var ReactPropTypes = {
	    array: shim,
	    bigint: shim,
	    bool: shim,
	    func: shim,
	    number: shim,
	    object: shim,
	    string: shim,
	    symbol: shim,

	    any: shim,
	    arrayOf: getShim,
	    element: shim,
	    elementType: shim,
	    instanceOf: getShim,
	    node: shim,
	    objectOf: getShim,
	    oneOf: getShim,
	    oneOfType: getShim,
	    shape: getShim,
	    exact: getShim,

	    checkPropTypes: emptyFunctionWithReset,
	    resetWarningCache: emptyFunction
	  };

	  ReactPropTypes.PropTypes = ReactPropTypes;

	  return ReactPropTypes;
	};
	return factoryWithThrowingShims;
}

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (process.env.NODE_ENV !== 'production') {
  var ReactIs = requireReactIs();

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  propTypes.exports = requireFactoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  propTypes.exports = requireFactoryWithThrowingShims()();
}

function toVal(mix) {
	var k, y, str='';

	if (typeof mix === 'string' || typeof mix === 'number') {
		str += mix;
	} else if (typeof mix === 'object') {
		if (Array.isArray(mix)) {
			for (k=0; k < mix.length; k++) {
				if (mix[k]) {
					if (y = toVal(mix[k])) {
						str && (str += ' ');
						str += y;
					}
				}
			}
		} else {
			for (k in mix) {
				if (mix[k]) {
					str && (str += ' ');
					str += k;
				}
			}
		}
	}

	return str;
}

function clsx () {
	var i=0, tmp, x, str='';
	while (i < arguments.length) {
		if (tmp = arguments[i++]) {
			if (x = toVal(tmp)) {
				str && (str += ' ');
				str += x;
			}
		}
	}
	return str;
}

function chainPropTypes(propType1, propType2) {
  if (process.env.NODE_ENV === 'production') {
    return () => null;
  }

  return function validate(...args) {
    return propType1(...args) || propType2(...args);
  };
}

function isPlainObject(item) {
  return item !== null && typeof item === 'object' && item.constructor === Object;
}
function deepmerge(target, source, options = {
  clone: true
}) {
  const output = options.clone ? _extends({}, target) : target;

  if (isPlainObject(target) && isPlainObject(source)) {
    Object.keys(source).forEach(key => {
      // Avoid prototype pollution
      if (key === '__proto__') {
        return;
      }

      if (isPlainObject(source[key]) && key in target && isPlainObject(target[key])) {
        // Since `output` is a clone of `target` and we have narrowed `target` in this block we can cast to the same type.
        output[key] = deepmerge(target[key], source[key], options);
      } else {
        output[key] = source[key];
      }
    });
  }

  return output;
}

function isClassComponent$1(elementType) {
  // elementType.prototype?.isReactComponent
  const {
    prototype = {}
  } = elementType;
  return Boolean(prototype.isReactComponent);
}

function acceptingRef(props, propName, componentName, location, propFullName) {
  const element = props[propName];
  const safePropName = propFullName || propName;

  if (element == null || // When server-side rendering React doesn't warn either.
  // This is not an accurate check for SSR.
  // This is only in place for emotion compat.
  // TODO: Revisit once https://github.com/facebook/react/issues/20047 is resolved.
  typeof window === 'undefined') {
    return null;
  }

  let warningHint;
  const elementType = element.type;
  /**
   * Blacklisting instead of whitelisting
   *
   * Blacklisting will miss some components, such as React.Fragment. Those will at least
   * trigger a warning in React.
   * We can't whitelist because there is no safe way to detect React.forwardRef
   * or class components. "Safe" means there's no public API.
   *
   */

  if (typeof elementType === 'function' && !isClassComponent$1(elementType)) {
    warningHint = 'Did you accidentally use a plain function component for an element instead?';
  }

  if (warningHint !== undefined) {
    return new Error(`Invalid ${location} \`${safePropName}\` supplied to \`${componentName}\`. ` + `Expected an element that can hold a ref. ${warningHint} ` + 'For more information see https://mui.com/r/caveat-with-refs-guide');
  }

  return null;
}

const elementAcceptingRef = chainPropTypes(propTypes.exports.element, acceptingRef);
elementAcceptingRef.isRequired = chainPropTypes(propTypes.exports.element.isRequired, acceptingRef);

function isClassComponent(elementType) {
  // elementType.prototype?.isReactComponent
  const {
    prototype = {}
  } = elementType;
  return Boolean(prototype.isReactComponent);
}

function elementTypeAcceptingRef(props, propName, componentName, location, propFullName) {
  const propValue = props[propName];
  const safePropName = propFullName || propName;

  if (propValue == null || // When server-side rendering React doesn't warn either.
  // This is not an accurate check for SSR.
  // This is only in place for emotion compat.
  // TODO: Revisit once https://github.com/facebook/react/issues/20047 is resolved.
  typeof window === 'undefined') {
    return null;
  }

  let warningHint;
  /**
   * Blacklisting instead of whitelisting
   *
   * Blacklisting will miss some components, such as React.Fragment. Those will at least
   * trigger a warning in React.
   * We can't whitelist because there is no safe way to detect React.forwardRef
   * or class components. "Safe" means there's no public API.
   *
   */

  if (typeof propValue === 'function' && !isClassComponent(propValue)) {
    warningHint = 'Did you accidentally provide a plain function component instead?';
  }

  if (warningHint !== undefined) {
    return new Error(`Invalid ${location} \`${safePropName}\` supplied to \`${componentName}\`. ` + `Expected an element type that can hold a ref. ${warningHint} ` + 'For more information see https://mui.com/r/caveat-with-refs-guide');
  }

  return null;
}

chainPropTypes(propTypes.exports.elementType, elementTypeAcceptingRef);

// This module is based on https://github.com/airbnb/prop-types-exact repository.
// However, in order to reduce the number of dependencies and to remove some extra safe checks
// the module was forked.
const specialProperty = 'exact-prop: \u200b';
function exactProp(propTypes) {
  if (process.env.NODE_ENV === 'production') {
    return propTypes;
  }

  return _extends({}, propTypes, {
    [specialProperty]: props => {
      const unsupportedProps = Object.keys(props).filter(prop => !propTypes.hasOwnProperty(prop));

      if (unsupportedProps.length > 0) {
        return new Error(`The following props are not supported: ${unsupportedProps.map(prop => `\`${prop}\``).join(', ')}. Please remove them.`);
      }

      return null;
    }
  });
}

/**
 * WARNING: Don't import this directly.
 * Use `MuiError` from `@mui/utils/macros/MuiError.macro` instead.
 * @param {number} code
 */
function formatMuiErrorMessage(code) {
  // Apply babel-plugin-transform-template-literals in loose mode
  // loose mode is safe iff we're concatenating primitives
  // see https://babeljs.io/docs/en/babel-plugin-transform-template-literals#loose

  /* eslint-disable prefer-template */
  let url = 'https://mui.com/production-error/?code=' + code;

  for (let i = 1; i < arguments.length; i += 1) {
    // rest params over-transpile for this case
    // eslint-disable-next-line prefer-rest-params
    url += '&args[]=' + encodeURIComponent(arguments[i]);
  }

  return 'Minified MUI error #' + code + '; visit ' + url + ' for the full message.';
  /* eslint-enable prefer-template */
}

var reactIs = {exports: {}};

var reactIs_production_min = {};

/** @license React v17.0.2
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactIs_production_min;

function requireReactIs_production_min () {
	if (hasRequiredReactIs_production_min) return reactIs_production_min;
	hasRequiredReactIs_production_min = 1;
var b=60103,c=60106,d=60107,e=60108,f=60114,g=60109,h=60110,k=60112,l=60113,m=60120,n=60115,p=60116,q=60121,r=60122,u=60117,v=60129,w=60131;
	if("function"===typeof Symbol&&Symbol.for){var x=Symbol.for;b=x("react.element");c=x("react.portal");d=x("react.fragment");e=x("react.strict_mode");f=x("react.profiler");g=x("react.provider");h=x("react.context");k=x("react.forward_ref");l=x("react.suspense");m=x("react.suspense_list");n=x("react.memo");p=x("react.lazy");q=x("react.block");r=x("react.server.block");u=x("react.fundamental");v=x("react.debug_trace_mode");w=x("react.legacy_hidden");}
	function y(a){if("object"===typeof a&&null!==a){var t=a.$$typeof;switch(t){case b:switch(a=a.type,a){case d:case f:case e:case l:case m:return a;default:switch(a=a&&a.$$typeof,a){case h:case k:case p:case n:case g:return a;default:return t}}case c:return t}}}var z=g,A=b,B=k,C=d,D=p,E=n,F=c,G=f,H=e,I=l;reactIs_production_min.ContextConsumer=h;reactIs_production_min.ContextProvider=z;reactIs_production_min.Element=A;reactIs_production_min.ForwardRef=B;reactIs_production_min.Fragment=C;reactIs_production_min.Lazy=D;reactIs_production_min.Memo=E;reactIs_production_min.Portal=F;reactIs_production_min.Profiler=G;reactIs_production_min.StrictMode=H;
	reactIs_production_min.Suspense=I;reactIs_production_min.isAsyncMode=function(){return !1};reactIs_production_min.isConcurrentMode=function(){return !1};reactIs_production_min.isContextConsumer=function(a){return y(a)===h};reactIs_production_min.isContextProvider=function(a){return y(a)===g};reactIs_production_min.isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===b};reactIs_production_min.isForwardRef=function(a){return y(a)===k};reactIs_production_min.isFragment=function(a){return y(a)===d};reactIs_production_min.isLazy=function(a){return y(a)===p};reactIs_production_min.isMemo=function(a){return y(a)===n};
	reactIs_production_min.isPortal=function(a){return y(a)===c};reactIs_production_min.isProfiler=function(a){return y(a)===f};reactIs_production_min.isStrictMode=function(a){return y(a)===e};reactIs_production_min.isSuspense=function(a){return y(a)===l};reactIs_production_min.isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===d||a===f||a===v||a===e||a===l||a===m||a===w||"object"===typeof a&&null!==a&&(a.$$typeof===p||a.$$typeof===n||a.$$typeof===g||a.$$typeof===h||a.$$typeof===k||a.$$typeof===u||a.$$typeof===q||a[0]===r)?!0:!1};
	reactIs_production_min.typeOf=y;
	return reactIs_production_min;
}

var reactIs_development = {};

/** @license React v17.0.2
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactIs_development;

function requireReactIs_development () {
	if (hasRequiredReactIs_development) return reactIs_development;
	hasRequiredReactIs_development = 1;

	if (process.env.NODE_ENV !== "production") {
	  (function() {

	// ATTENTION
	// When adding new symbols to this file,
	// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
	// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.
	var REACT_ELEMENT_TYPE = 0xeac7;
	var REACT_PORTAL_TYPE = 0xeaca;
	var REACT_FRAGMENT_TYPE = 0xeacb;
	var REACT_STRICT_MODE_TYPE = 0xeacc;
	var REACT_PROFILER_TYPE = 0xead2;
	var REACT_PROVIDER_TYPE = 0xeacd;
	var REACT_CONTEXT_TYPE = 0xeace;
	var REACT_FORWARD_REF_TYPE = 0xead0;
	var REACT_SUSPENSE_TYPE = 0xead1;
	var REACT_SUSPENSE_LIST_TYPE = 0xead8;
	var REACT_MEMO_TYPE = 0xead3;
	var REACT_LAZY_TYPE = 0xead4;
	var REACT_BLOCK_TYPE = 0xead9;
	var REACT_SERVER_BLOCK_TYPE = 0xeada;
	var REACT_FUNDAMENTAL_TYPE = 0xead5;
	var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
	var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

	if (typeof Symbol === 'function' && Symbol.for) {
	  var symbolFor = Symbol.for;
	  REACT_ELEMENT_TYPE = symbolFor('react.element');
	  REACT_PORTAL_TYPE = symbolFor('react.portal');
	  REACT_FRAGMENT_TYPE = symbolFor('react.fragment');
	  REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
	  REACT_PROFILER_TYPE = symbolFor('react.profiler');
	  REACT_PROVIDER_TYPE = symbolFor('react.provider');
	  REACT_CONTEXT_TYPE = symbolFor('react.context');
	  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
	  REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
	  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
	  REACT_MEMO_TYPE = symbolFor('react.memo');
	  REACT_LAZY_TYPE = symbolFor('react.lazy');
	  REACT_BLOCK_TYPE = symbolFor('react.block');
	  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
	  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
	  symbolFor('react.scope');
	  symbolFor('react.opaque.id');
	  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
	  symbolFor('react.offscreen');
	  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
	}

	// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

	var enableScopeAPI = false; // Experimental Create Event Handle API.

	function isValidElementType(type) {
	  if (typeof type === 'string' || typeof type === 'function') {
	    return true;
	  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


	  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {
	    return true;
	  }

	  if (typeof type === 'object' && type !== null) {
	    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
	      return true;
	    }
	  }

	  return false;
	}

	function typeOf(object) {
	  if (typeof object === 'object' && object !== null) {
	    var $$typeof = object.$$typeof;

	    switch ($$typeof) {
	      case REACT_ELEMENT_TYPE:
	        var type = object.type;

	        switch (type) {
	          case REACT_FRAGMENT_TYPE:
	          case REACT_PROFILER_TYPE:
	          case REACT_STRICT_MODE_TYPE:
	          case REACT_SUSPENSE_TYPE:
	          case REACT_SUSPENSE_LIST_TYPE:
	            return type;

	          default:
	            var $$typeofType = type && type.$$typeof;

	            switch ($$typeofType) {
	              case REACT_CONTEXT_TYPE:
	              case REACT_FORWARD_REF_TYPE:
	              case REACT_LAZY_TYPE:
	              case REACT_MEMO_TYPE:
	              case REACT_PROVIDER_TYPE:
	                return $$typeofType;

	              default:
	                return $$typeof;
	            }

	        }

	      case REACT_PORTAL_TYPE:
	        return $$typeof;
	    }
	  }

	  return undefined;
	}
	var ContextConsumer = REACT_CONTEXT_TYPE;
	var ContextProvider = REACT_PROVIDER_TYPE;
	var Element = REACT_ELEMENT_TYPE;
	var ForwardRef = REACT_FORWARD_REF_TYPE;
	var Fragment = REACT_FRAGMENT_TYPE;
	var Lazy = REACT_LAZY_TYPE;
	var Memo = REACT_MEMO_TYPE;
	var Portal = REACT_PORTAL_TYPE;
	var Profiler = REACT_PROFILER_TYPE;
	var StrictMode = REACT_STRICT_MODE_TYPE;
	var Suspense = REACT_SUSPENSE_TYPE;
	var hasWarnedAboutDeprecatedIsAsyncMode = false;
	var hasWarnedAboutDeprecatedIsConcurrentMode = false; // AsyncMode should be deprecated

	function isAsyncMode(object) {
	  {
	    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
	      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

	      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 18+.');
	    }
	  }

	  return false;
	}
	function isConcurrentMode(object) {
	  {
	    if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
	      hasWarnedAboutDeprecatedIsConcurrentMode = true; // Using console['warn'] to evade Babel and ESLint

	      console['warn']('The ReactIs.isConcurrentMode() alias has been deprecated, ' + 'and will be removed in React 18+.');
	    }
	  }

	  return false;
	}
	function isContextConsumer(object) {
	  return typeOf(object) === REACT_CONTEXT_TYPE;
	}
	function isContextProvider(object) {
	  return typeOf(object) === REACT_PROVIDER_TYPE;
	}
	function isElement(object) {
	  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	}
	function isForwardRef(object) {
	  return typeOf(object) === REACT_FORWARD_REF_TYPE;
	}
	function isFragment(object) {
	  return typeOf(object) === REACT_FRAGMENT_TYPE;
	}
	function isLazy(object) {
	  return typeOf(object) === REACT_LAZY_TYPE;
	}
	function isMemo(object) {
	  return typeOf(object) === REACT_MEMO_TYPE;
	}
	function isPortal(object) {
	  return typeOf(object) === REACT_PORTAL_TYPE;
	}
	function isProfiler(object) {
	  return typeOf(object) === REACT_PROFILER_TYPE;
	}
	function isStrictMode(object) {
	  return typeOf(object) === REACT_STRICT_MODE_TYPE;
	}
	function isSuspense(object) {
	  return typeOf(object) === REACT_SUSPENSE_TYPE;
	}

	reactIs_development.ContextConsumer = ContextConsumer;
	reactIs_development.ContextProvider = ContextProvider;
	reactIs_development.Element = Element;
	reactIs_development.ForwardRef = ForwardRef;
	reactIs_development.Fragment = Fragment;
	reactIs_development.Lazy = Lazy;
	reactIs_development.Memo = Memo;
	reactIs_development.Portal = Portal;
	reactIs_development.Profiler = Profiler;
	reactIs_development.StrictMode = StrictMode;
	reactIs_development.Suspense = Suspense;
	reactIs_development.isAsyncMode = isAsyncMode;
	reactIs_development.isConcurrentMode = isConcurrentMode;
	reactIs_development.isContextConsumer = isContextConsumer;
	reactIs_development.isContextProvider = isContextProvider;
	reactIs_development.isElement = isElement;
	reactIs_development.isForwardRef = isForwardRef;
	reactIs_development.isFragment = isFragment;
	reactIs_development.isLazy = isLazy;
	reactIs_development.isMemo = isMemo;
	reactIs_development.isPortal = isPortal;
	reactIs_development.isProfiler = isProfiler;
	reactIs_development.isStrictMode = isStrictMode;
	reactIs_development.isSuspense = isSuspense;
	reactIs_development.isValidElementType = isValidElementType;
	reactIs_development.typeOf = typeOf;
	  })();
	}
	return reactIs_development;
}

(function (module) {

	if (process.env.NODE_ENV === 'production') {
	  module.exports = requireReactIs_production_min();
	} else {
	  module.exports = requireReactIs_development();
	}
} (reactIs));

// https://github.com/JamesMGreene/Function.name/blob/58b314d4a983110c3682f1228f845d39ccca1817/Function.name.js#L3

const fnNameMatchRegex = /^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^(\s/]*)\s*/;
function getFunctionName(fn) {
  const match = `${fn}`.match(fnNameMatchRegex);
  const name = match && match[1];
  return name || '';
}

function getFunctionComponentName(Component, fallback = '') {
  return Component.displayName || Component.name || getFunctionName(Component) || fallback;
}

function getWrappedName(outerType, innerType, wrapperName) {
  const functionName = getFunctionComponentName(innerType);
  return outerType.displayName || (functionName !== '' ? `${wrapperName}(${functionName})` : wrapperName);
}
/**
 * cherry-pick from
 * https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/shared/getComponentName.js
 * originally forked from recompose/getDisplayName with added IE11 support
 */


function getDisplayName(Component) {
  if (Component == null) {
    return undefined;
  }

  if (typeof Component === 'string') {
    return Component;
  }

  if (typeof Component === 'function') {
    return getFunctionComponentName(Component, 'Component');
  } // TypeScript can't have components as objects but they exist in the form of `memo` or `Suspense`


  if (typeof Component === 'object') {
    switch (Component.$$typeof) {
      case reactIs.exports.ForwardRef:
        return getWrappedName(Component, Component.render, 'ForwardRef');

      case reactIs.exports.Memo:
        return getWrappedName(Component, Component.type, 'memo');

      default:
        return undefined;
    }
  }

  return undefined;
}

function HTMLElementType(props, propName, componentName, location, propFullName) {
  if (process.env.NODE_ENV === 'production') {
    return null;
  }

  const propValue = props[propName];
  const safePropName = propFullName || propName;

  if (propValue == null) {
    return null;
  }

  if (propValue && propValue.nodeType !== 1) {
    return new Error(`Invalid ${location} \`${safePropName}\` supplied to \`${componentName}\`. ` + `Expected an HTMLElement.`);
  }

  return null;
}

/* eslint-disable */
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();

const refType = propTypes.exports.oneOfType([propTypes.exports.func, propTypes.exports.object]);

// It should to be noted that this function isn't equivalent to `text-transform: capitalize`.
//
// A strict capitalization should uppercase the first letter of each word in the sentence.
// We only handle the first word.
function capitalize(string) {
  if (typeof string !== 'string') {
    throw new Error(process.env.NODE_ENV !== "production" ? `MUI: \`capitalize(string)\` expects a string argument.` : formatMuiErrorMessage(7));
  }

  return string.charAt(0).toUpperCase() + string.slice(1);
}

/**
 * Safe chained function.
 *
 * Will only create a new function if needed,
 * otherwise will pass back existing functions or null.
 */
function createChainedFunction(...funcs) {
  return funcs.reduce((acc, func) => {
    if (func == null) {
      return acc;
    }

    return function chainedFunction(...args) {
      acc.apply(this, args);
      func.apply(this, args);
    };
  }, () => {});
}

// Corresponds to 10 frames at 60 Hz.
// A few bytes payload overhead when lodash/debounce is ~3 kB and debounce ~300 B.
function debounce$1(func, wait = 166) {
  let timeout;

  function debounced(...args) {
    const later = () => {
      func.apply(this, args);
    };

    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  }

  debounced.clear = () => {
    clearTimeout(timeout);
  };

  return debounced;
}

function ownerDocument(node) {
  return node && node.ownerDocument || document;
}

function ownerWindow(node) {
  const doc = ownerDocument(node);
  return doc.defaultView || window;
}

/**
 * TODO v5: consider making it private
 *
 * passes {value} to {ref}
 *
 * WARNING: Be sure to only call this inside a callback that is passed as a ref.
 * Otherwise, make sure to cleanup the previous {ref} if it changes. See
 * https://github.com/mui/material-ui/issues/13539
 *
 * Useful if you want to expose the ref of an inner component to the public API
 * while still using it inside the component.
 * @param ref A ref callback or ref object. If anything falsy, this is a no-op.
 */
function setRef(ref, value) {
  if (typeof ref === 'function') {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
}

const useEnhancedEffect = typeof window !== 'undefined' ? React__namespace.useLayoutEffect : React__namespace.useEffect;

let globalId = 0;

function useGlobalId(idOverride) {
  const [defaultId, setDefaultId] = React__namespace.useState(idOverride);
  const id = idOverride || defaultId;
  React__namespace.useEffect(() => {
    if (defaultId == null) {
      // Fallback to this default id when possible.
      // Use the incrementing value for client-side rendering only.
      // We can't use it server-side.
      // If you want to use random values please consider the Birthday Problem: https://en.wikipedia.org/wiki/Birthday_problem
      globalId += 1;
      setDefaultId(`mui-${globalId}`);
    }
  }, [defaultId]);
  return id;
} // eslint-disable-next-line no-useless-concat -- Workaround for https://github.com/webpack/webpack/issues/14814


const maybeReactUseId = React__namespace['useId' + ''];
/**
 *
 * @example <div id={useId()} />
 * @param idOverride
 * @returns {string}
 */

function useId(idOverride) {
  if (maybeReactUseId !== undefined) {
    const reactId = maybeReactUseId();
    return idOverride != null ? idOverride : reactId;
  } // eslint-disable-next-line react-hooks/rules-of-hooks -- `React.useId` is invariant at runtime.


  return useGlobalId(idOverride);
}

/* eslint-disable react-hooks/rules-of-hooks, react-hooks/exhaustive-deps */
function useControlled({
  controlled,
  default: defaultProp,
  name,
  state = 'value'
}) {
  // isControlled is ignored in the hook dependency lists as it should never change.
  const {
    current: isControlled
  } = React__namespace.useRef(controlled !== undefined);
  const [valueState, setValue] = React__namespace.useState(defaultProp);
  const value = isControlled ? controlled : valueState;

  if (process.env.NODE_ENV !== 'production') {
    React__namespace.useEffect(() => {
      if (isControlled !== (controlled !== undefined)) {
        console.error([`MUI: A component is changing the ${isControlled ? '' : 'un'}controlled ${state} state of ${name} to be ${isControlled ? 'un' : ''}controlled.`, 'Elements should not switch from uncontrolled to controlled (or vice versa).', `Decide between using a controlled or uncontrolled ${name} ` + 'element for the lifetime of the component.', "The nature of the state is determined during the first render. It's considered controlled if the value is not `undefined`.", 'More info: https://fb.me/react-controlled-components'].join('\n'));
      }
    }, [state, name, controlled]);
    const {
      current: defaultValue
    } = React__namespace.useRef(defaultProp);
    React__namespace.useEffect(() => {
      if (!isControlled && defaultValue !== defaultProp) {
        console.error([`MUI: A component is changing the default ${state} state of an uncontrolled ${name} after being initialized. ` + `To suppress this warning opt to use a controlled ${name}.`].join('\n'));
      }
    }, [JSON.stringify(defaultProp)]);
  }

  const setValueIfUncontrolled = React__namespace.useCallback(newValue => {
    if (!isControlled) {
      setValue(newValue);
    }
  }, []);
  return [value, setValueIfUncontrolled];
}

/**
 * https://github.com/facebook/react/issues/14099#issuecomment-440013892
 */

function useEventCallback(fn) {
  const ref = React__namespace.useRef(fn);
  useEnhancedEffect(() => {
    ref.current = fn;
  });
  return React__namespace.useCallback((...args) => // @ts-expect-error hide `this`
  // tslint:disable-next-line:ban-comma-operator
  (0, ref.current)(...args), []);
}

function useForkRef(refA, refB) {
  /**
   * This will create a new function if the ref props change and are defined.
   * This means react will call the old forkRef with `null` and the new forkRef
   * with the ref. Cleanup naturally emerges from this behavior.
   */
  return React__namespace.useMemo(() => {
    if (refA == null && refB == null) {
      return null;
    }

    return refValue => {
      setRef(refA, refValue);
      setRef(refB, refValue);
    };
  }, [refA, refB]);
}

// based on https://github.com/WICG/focus-visible/blob/v4.1.5/src/focus-visible.js
let hadKeyboardEvent = true;
let hadFocusVisibleRecently = false;
let hadFocusVisibleRecentlyTimeout;
const inputTypesWhitelist = {
  text: true,
  search: true,
  url: true,
  tel: true,
  email: true,
  password: true,
  number: true,
  date: true,
  month: true,
  week: true,
  time: true,
  datetime: true,
  'datetime-local': true
};
/**
 * Computes whether the given element should automatically trigger the
 * `focus-visible` class being added, i.e. whether it should always match
 * `:focus-visible` when focused.
 * @param {Element} node
 * @returns {boolean}
 */

function focusTriggersKeyboardModality(node) {
  const {
    type,
    tagName
  } = node;

  if (tagName === 'INPUT' && inputTypesWhitelist[type] && !node.readOnly) {
    return true;
  }

  if (tagName === 'TEXTAREA' && !node.readOnly) {
    return true;
  }

  if (node.isContentEditable) {
    return true;
  }

  return false;
}
/**
 * Keep track of our keyboard modality state with `hadKeyboardEvent`.
 * If the most recent user interaction was via the keyboard;
 * and the key press did not include a meta, alt/option, or control key;
 * then the modality is keyboard. Otherwise, the modality is not keyboard.
 * @param {KeyboardEvent} event
 */


function handleKeyDown$1(event) {
  if (event.metaKey || event.altKey || event.ctrlKey) {
    return;
  }

  hadKeyboardEvent = true;
}
/**
 * If at any point a user clicks with a pointing device, ensure that we change
 * the modality away from keyboard.
 * This avoids the situation where a user presses a key on an already focused
 * element, and then clicks on a different element, focusing it with a
 * pointing device, while we still think we're in keyboard modality.
 */


function handlePointerDown() {
  hadKeyboardEvent = false;
}

function handleVisibilityChange() {
  if (this.visibilityState === 'hidden') {
    // If the tab becomes active again, the browser will handle calling focus
    // on the element (Safari actually calls it twice).
    // If this tab change caused a blur on an element with focus-visible,
    // re-apply the class when the user switches back to the tab.
    if (hadFocusVisibleRecently) {
      hadKeyboardEvent = true;
    }
  }
}

function prepare(doc) {
  doc.addEventListener('keydown', handleKeyDown$1, true);
  doc.addEventListener('mousedown', handlePointerDown, true);
  doc.addEventListener('pointerdown', handlePointerDown, true);
  doc.addEventListener('touchstart', handlePointerDown, true);
  doc.addEventListener('visibilitychange', handleVisibilityChange, true);
}

function isFocusVisible(event) {
  const {
    target
  } = event;

  try {
    return target.matches(':focus-visible');
  } catch (error) {// Browsers not implementing :focus-visible will throw a SyntaxError.
    // We use our own heuristic for those browsers.
    // Rethrow might be better if it's not the expected error but do we really
    // want to crash if focus-visible malfunctioned?
  } // No need for validFocusTarget check. The user does that by attaching it to
  // focusable events only.


  return hadKeyboardEvent || focusTriggersKeyboardModality(target);
}

function useIsFocusVisible() {
  const ref = React__namespace.useCallback(node => {
    if (node != null) {
      prepare(node.ownerDocument);
    }
  }, []);
  const isFocusVisibleRef = React__namespace.useRef(false);
  /**
   * Should be called if a blur event is fired
   */

  function handleBlurVisible() {
    // checking against potential state variable does not suffice if we focus and blur synchronously.
    // React wouldn't have time to trigger a re-render so `focusVisible` would be stale.
    // Ideally we would adjust `isFocusVisible(event)` to look at `relatedTarget` for blur events.
    // This doesn't work in IE11 due to https://github.com/facebook/react/issues/3751
    // TODO: check again if React releases their internal changes to focus event handling (https://github.com/facebook/react/pull/19186).
    if (isFocusVisibleRef.current) {
      // To detect a tab/window switch, we look for a blur event followed
      // rapidly by a visibility change.
      // If we don't see a visibility change within 100ms, it's probably a
      // regular focus change.
      hadFocusVisibleRecently = true;
      window.clearTimeout(hadFocusVisibleRecentlyTimeout);
      hadFocusVisibleRecentlyTimeout = window.setTimeout(() => {
        hadFocusVisibleRecently = false;
      }, 100);
      isFocusVisibleRef.current = false;
      return true;
    }

    return false;
  }
  /**
   * Should be called if a blur event is fired
   */


  function handleFocusVisible(event) {
    if (isFocusVisible(event)) {
      isFocusVisibleRef.current = true;
      return true;
    }

    return false;
  }

  return {
    isFocusVisibleRef,
    onFocus: handleFocusVisible,
    onBlur: handleBlurVisible,
    ref
  };
}

// A change of the browser zoom change the scrollbar size.
// Credit https://github.com/twbs/bootstrap/blob/488fd8afc535ca3a6ad4dc581f5e89217b6a36ac/js/src/util/scrollbar.js#L14-L18
function getScrollbarSize(doc) {
  // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes
  const documentWidth = doc.documentElement.clientWidth;
  return Math.abs(window.innerWidth - documentWidth);
}

const usePreviousProps = value => {
  const ref = React__namespace.useRef({});
  React__namespace.useEffect(() => {
    ref.current = value;
  });
  return ref.current;
};

const visuallyHidden = {
  border: 0,
  clip: 'rect(0 0 0 0)',
  height: '1px',
  margin: -1,
  overflow: 'hidden',
  padding: 0,
  position: 'absolute',
  whiteSpace: 'nowrap',
  width: '1px'
};

function getTypeByValue(value) {
  const valueType = typeof value;

  switch (valueType) {
    case 'number':
      if (Number.isNaN(value)) {
        return 'NaN';
      }

      if (!Number.isFinite(value)) {
        return 'Infinity';
      }

      if (value !== Math.floor(value)) {
        return 'float';
      }

      return 'number';

    case 'object':
      if (value === null) {
        return 'null';
      }

      return value.constructor.name;

    default:
      return valueType;
  }
} // IE 11 support

function ponyfillIsInteger(x) {
  // eslint-disable-next-line no-restricted-globals
  return typeof x === 'number' && isFinite(x) && Math.floor(x) === x;
}

const isInteger = Number.isInteger || ponyfillIsInteger;

function requiredInteger(props, propName, componentName, location) {
  const propValue = props[propName];

  if (propValue == null || !isInteger(propValue)) {
    const propType = getTypeByValue(propValue);
    return new RangeError(`Invalid ${location} \`${propName}\` of type \`${propType}\` supplied to \`${componentName}\`, expected \`integer\`.`);
  }

  return null;
}

function validator(props, propName, ...other) {
  const propValue = props[propName];

  if (propValue === undefined) {
    return null;
  }

  return requiredInteger(props, propName, ...other);
}

function validatorNoop() {
  return null;
}

validator.isRequired = requiredInteger;
validatorNoop.isRequired = validatorNoop;
var integerPropType = process.env.NODE_ENV === 'production' ? validatorNoop : validator;

/**
 * Add keys, values of `defaultProps` that does not exist in `props`
 * @param {object} defaultProps
 * @param {object} props
 * @returns {object} resolved props
 */
function resolveProps(defaultProps, props) {
  const output = _extends({}, props);

  Object.keys(defaultProps).forEach(propName => {
    if (output[propName] === undefined) {
      output[propName] = defaultProps[propName];
    }
  });
  return output;
}

function composeClasses(slots, getUtilityClass, classes) {
  const output = {};
  Object.keys(slots).forEach( // `Objet.keys(slots)` can't be wider than `T` because we infer `T` from `slots`.
  // @ts-expect-error https://github.com/microsoft/TypeScript/pull/12253#issuecomment-263132208
  slot => {
    output[slot] = slots[slot].reduce((acc, key) => {
      if (key) {
        if (classes && classes[key]) {
          acc.push(classes[key]);
        }

        acc.push(getUtilityClass(key));
      }

      return acc;
    }, []).join(' ');
  });
  return output;
}

const defaultGenerator = componentName => componentName;

const createClassNameGenerator = () => {
  let generate = defaultGenerator;
  return {
    configure(generator) {
      generate = generator;
    },

    generate(componentName) {
      return generate(componentName);
    },

    reset() {
      generate = defaultGenerator;
    }

  };
};

const ClassNameGenerator = createClassNameGenerator();

const globalStateClassesMapping = {
  active: 'Mui-active',
  checked: 'Mui-checked',
  completed: 'Mui-completed',
  disabled: 'Mui-disabled',
  error: 'Mui-error',
  expanded: 'Mui-expanded',
  focused: 'Mui-focused',
  focusVisible: 'Mui-focusVisible',
  required: 'Mui-required',
  selected: 'Mui-selected'
};
function generateUtilityClass(componentName, slot) {
  const globalStateClass = globalStateClassesMapping[slot];
  return globalStateClass || `${ClassNameGenerator.generate(componentName)}-${slot}`;
}

function generateUtilityClasses(componentName, slots) {
  const result = {};
  slots.forEach(slot => {
    result[slot] = generateUtilityClass(componentName, slot);
  });
  return result;
}

/**
 * Determines if a given element is a DOM element name (i.e. not a React component).
 */
function isHostComponent(element) {
  return typeof element === 'string';
}

/**
 * Appends the ownerState object to the props, merging with the existing one if necessary.
 *
 * @param elementType Type of the element that owns the `existingProps`. If the element is a DOM node, `ownerState` are not applied.
 * @param existingProps Props of the element.
 * @param ownerState
 */

function appendOwnerState(elementType, existingProps = {}, ownerState) {
  if (isHostComponent(elementType)) {
    return existingProps;
  }

  return _extends({}, existingProps, {
    ownerState: _extends({}, existingProps.ownerState, ownerState)
  });
}

function areArraysEqual(array1, array2, itemComparer = (a, b) => a === b) {
  return array1.length === array2.length && array1.every((value, index) => itemComparer(value, array2[index]));
}

/**
 * Extracts event handlers from a given object.
 * A prop is considered an event handler if it is a function and its name starts with `on`.
 *
 * @param object An object to extract event handlers from.
 * @param excludeKeys An array of keys to exclude from the returned object.
 */
function extractEventHandlers(object, excludeKeys = []) {
  if (object === undefined) {
    return {};
  }

  const result = {};
  Object.keys(object).filter(prop => prop.match(/^on[A-Z]/) && typeof object[prop] === 'function' && !excludeKeys.includes(prop)).forEach(prop => {
    result[prop] = object[prop];
  });
  return result;
}

function useBadge(parameters) {
  const {
    badgeContent: badgeContentProp,
    invisible: invisibleProp = false,
    max: maxProp = 99,
    showZero = false
  } = parameters;
  const prevProps = usePreviousProps({
    badgeContent: badgeContentProp,
    max: maxProp
  });
  let invisible = invisibleProp;

  if (invisibleProp === false && badgeContentProp === 0 && !showZero) {
    invisible = true;
  }

  const {
    badgeContent,
    max = maxProp
  } = invisible ? prevProps : parameters;
  const displayValue = badgeContent && Number(badgeContent) > max ? `${max}+` : badgeContent;
  return {
    badgeContent,
    invisible,
    max,
    displayValue
  };
}

function getBadgeUnstyledUtilityClass(slot) {
  return generateUtilityClass('BaseBadge', slot);
}
generateUtilityClasses('BaseBadge', ['root', 'badge', 'invisible']);

const _excluded$z = ["badgeContent", "component", "children", "className", "components", "componentsProps", "invisible", "max", "showZero"];

const useUtilityClasses$e = ownerState => {
  const {
    invisible
  } = ownerState;
  const slots = {
    root: ['root'],
    badge: ['badge', invisible && 'invisible']
  };
  return composeClasses(slots, getBadgeUnstyledUtilityClass, undefined);
};
/**
 *
 * Demos:
 *
 * - [Badge](https://mui.com/base/react-badge/)
 *
 * API:
 *
 * - [BadgeUnstyled API](https://mui.com/base/api/badge-unstyled/)
 */


const BadgeUnstyled = /*#__PURE__*/React__namespace.forwardRef(function BadgeUnstyled(props, ref) {
  var _componentsProps$root, _componentsProps$badg;

  const {
    component,
    children,
    className,
    components = {},
    componentsProps = {},
    max: maxProp = 99,
    showZero = false
  } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$z);

  const {
    badgeContent,
    max,
    displayValue,
    invisible
  } = useBadge(_extends({}, props, {
    max: maxProp
  }));

  const ownerState = _extends({}, props, {
    badgeContent,
    invisible,
    max,
    showZero
  });

  const classes = useUtilityClasses$e(ownerState);
  const Root = component || components.Root || 'span';
  const rootProps = appendOwnerState(Root, _extends({}, other, componentsProps.root, {
    ref,
    className: clsx(classes.root, (_componentsProps$root = componentsProps.root) == null ? void 0 : _componentsProps$root.className, className)
  }), ownerState);
  const Badge = components.Badge || 'span';
  const badgeProps = appendOwnerState(Badge, _extends({}, componentsProps.badge, {
    className: clsx(classes.badge, (_componentsProps$badg = componentsProps.badge) == null ? void 0 : _componentsProps$badg.className)
  }), ownerState);
  return /*#__PURE__*/jsxRuntime.exports.jsxs(Root, _extends({}, rootProps, {
    children: [children, /*#__PURE__*/jsxRuntime.exports.jsx(Badge, _extends({}, badgeProps, {
      children: displayValue
    }))]
  }));
});
process.env.NODE_ENV !== "production" ? BadgeUnstyled.propTypes
/* remove-proptypes */
= {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------

  /**
   * The content rendered within the badge.
   */
  badgeContent: propTypes.exports.node,

  /**
   * The badge will be added relative to this node.
   */
  children: propTypes.exports.node,

  /**
   * @ignore
   */
  className: propTypes.exports.string,

  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: propTypes.exports.elementType,

  /**
   * The components used for each slot inside the Badge.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  components: propTypes.exports.shape({
    Badge: propTypes.exports.elementType,
    Root: propTypes.exports.elementType
  }),

  /**
   * The props used for each slot inside the Badge.
   * @default {}
   */
  componentsProps: propTypes.exports.shape({
    badge: propTypes.exports.object,
    root: propTypes.exports.object
  }),

  /**
   * If `true`, the badge is invisible.
   * @default false
   */
  invisible: propTypes.exports.bool,

  /**
   * Max count to show.
   * @default 99
   */
  max: propTypes.exports.number,

  /**
   * Controls whether the badge is hidden when `badgeContent` is zero.
   * @default false
   */
  showZero: propTypes.exports.bool
} : void 0;

function getButtonUnstyledUtilityClass(slot) {
  return generateUtilityClass('ButtonUnstyled', slot);
}
generateUtilityClasses('ButtonUnstyled', ['root', 'active', 'disabled', 'focusVisible']);

function useButton(parameters) {
  const {
    disabled = false,
    focusableWhenDisabled,
    href,
    ref,
    tabIndex,
    to,
    type
  } = parameters;
  const buttonRef = React__namespace.useRef();
  const [active, setActive] = React__namespace.useState(false);
  const {
    isFocusVisibleRef,
    onFocus: handleFocusVisible,
    onBlur: handleBlurVisible,
    ref: focusVisibleRef
  } = useIsFocusVisible();
  const [focusVisible, setFocusVisible] = React__namespace.useState(false);

  if (disabled && !focusableWhenDisabled && focusVisible) {
    setFocusVisible(false);
  }

  React__namespace.useEffect(() => {
    isFocusVisibleRef.current = focusVisible;
  }, [focusVisible, isFocusVisibleRef]);
  const [hostElementName, setHostElementName] = React__namespace.useState('');

  const createHandleMouseLeave = otherHandlers => event => {
    var _otherHandlers$onMous;

    if (focusVisible) {
      event.preventDefault();
    }

    (_otherHandlers$onMous = otherHandlers.onMouseLeave) == null ? void 0 : _otherHandlers$onMous.call(otherHandlers, event);
  };

  const createHandleBlur = otherHandlers => event => {
    var _otherHandlers$onBlur;

    handleBlurVisible(event);

    if (isFocusVisibleRef.current === false) {
      setFocusVisible(false);
    }

    (_otherHandlers$onBlur = otherHandlers.onBlur) == null ? void 0 : _otherHandlers$onBlur.call(otherHandlers, event);
  };

  const createHandleFocus = otherHandlers => event => {
    var _otherHandlers$onFocu2;

    // Fix for https://github.com/facebook/react/issues/7769
    if (!buttonRef.current) {
      buttonRef.current = event.currentTarget;
    }

    handleFocusVisible(event);

    if (isFocusVisibleRef.current === true) {
      var _otherHandlers$onFocu;

      setFocusVisible(true);
      (_otherHandlers$onFocu = otherHandlers.onFocusVisible) == null ? void 0 : _otherHandlers$onFocu.call(otherHandlers, event);
    }

    (_otherHandlers$onFocu2 = otherHandlers.onFocus) == null ? void 0 : _otherHandlers$onFocu2.call(otherHandlers, event);
  };

  const isNativeButton = () => {
    const button = buttonRef.current;
    return hostElementName === 'BUTTON' || hostElementName === 'INPUT' && ['button', 'submit', 'reset'].includes(button == null ? void 0 : button.type) || hostElementName === 'A' && (button == null ? void 0 : button.href);
  };

  const createHandleClick = otherHandlers => event => {
    if (!disabled) {
      var _otherHandlers$onClic;

      (_otherHandlers$onClic = otherHandlers.onClick) == null ? void 0 : _otherHandlers$onClic.call(otherHandlers, event);
    }
  };

  const createHandleMouseDown = otherHandlers => event => {
    var _otherHandlers$onMous2;

    if (event.target === event.currentTarget && !disabled) {
      setActive(true);
    }

    (_otherHandlers$onMous2 = otherHandlers.onMouseDown) == null ? void 0 : _otherHandlers$onMous2.call(otherHandlers, event);
  };

  const createHandleMouseUp = otherHandlers => event => {
    var _otherHandlers$onMous3;

    if (event.target === event.currentTarget) {
      setActive(false);
    }

    (_otherHandlers$onMous3 = otherHandlers.onMouseUp) == null ? void 0 : _otherHandlers$onMous3.call(otherHandlers, event);
  };

  const createHandleKeyDown = otherHandlers => event => {
    var _otherHandlers$onKeyD;

    (_otherHandlers$onKeyD = otherHandlers.onKeyDown) == null ? void 0 : _otherHandlers$onKeyD.call(otherHandlers, event);

    if (event.defaultPrevented) {
      return;
    }

    if (event.target === event.currentTarget && !isNativeButton() && event.key === ' ') {
      event.preventDefault();
    }

    if (event.target === event.currentTarget && event.key === ' ' && !disabled) {
      setActive(true);
    } // Keyboard accessibility for non interactive elements


    if (event.target === event.currentTarget && !isNativeButton() && event.key === 'Enter' && !disabled) {
      var _otherHandlers$onClic2;

      (_otherHandlers$onClic2 = otherHandlers.onClick) == null ? void 0 : _otherHandlers$onClic2.call(otherHandlers, event);
      event.preventDefault();
    }
  };

  const createHandleKeyUp = otherHandlers => event => {
    var _otherHandlers$onKeyU;

    // calling preventDefault in keyUp on a <button> will not dispatch a click event if Space is pressed
    // https://codesandbox.io/s/button-keyup-preventdefault-dn7f0
    if (event.target === event.currentTarget) {
      setActive(false);
    }

    (_otherHandlers$onKeyU = otherHandlers.onKeyUp) == null ? void 0 : _otherHandlers$onKeyU.call(otherHandlers, event); // Keyboard accessibility for non interactive elements

    if (event.target === event.currentTarget && !isNativeButton() && !disabled && event.key === ' ' && !event.defaultPrevented) {
      var _otherHandlers$onClic3;

      (_otherHandlers$onClic3 = otherHandlers.onClick) == null ? void 0 : _otherHandlers$onClic3.call(otherHandlers, event);
    }
  };

  const handleOwnRef = useForkRef(focusVisibleRef, buttonRef);
  const handleRef = useForkRef(ref, handleOwnRef);

  const updateRef = instance => {
    var _instance$tagName;

    setHostElementName((_instance$tagName = instance == null ? void 0 : instance.tagName) != null ? _instance$tagName : '');
    setRef(handleRef, instance);
  };

  const buttonProps = {};

  if (hostElementName === 'BUTTON') {
    buttonProps.type = type != null ? type : 'button';

    if (focusableWhenDisabled) {
      buttonProps['aria-disabled'] = disabled;
    } else {
      buttonProps.disabled = disabled;
    }
  } else if (hostElementName !== '') {
    if (!href && !to) {
      buttonProps.role = 'button';
      buttonProps.tabIndex = tabIndex != null ? tabIndex : 0;
    }

    if (disabled) {
      buttonProps['aria-disabled'] = disabled;
      buttonProps.tabIndex = focusableWhenDisabled ? tabIndex != null ? tabIndex : 0 : -1;
    }
  }

  const getRootProps = (otherHandlers = {}) => {
    const propsEventHandlers = extractEventHandlers(parameters);

    const externalEventHandlers = _extends({}, propsEventHandlers, otherHandlers); // onFocusVisible can be present on the props, but since it's not a valid React event handler,
    // it must not be forwarded to the inner component.


    delete externalEventHandlers.onFocusVisible;
    return _extends({
      type
    }, externalEventHandlers, buttonProps, {
      onBlur: createHandleBlur(externalEventHandlers),
      onClick: createHandleClick(externalEventHandlers),
      onFocus: createHandleFocus(externalEventHandlers),
      onKeyDown: createHandleKeyDown(externalEventHandlers),
      onKeyUp: createHandleKeyUp(externalEventHandlers),
      onMouseDown: createHandleMouseDown(externalEventHandlers),
      onMouseLeave: createHandleMouseLeave(externalEventHandlers),
      onMouseUp: createHandleMouseUp(externalEventHandlers),
      ref: updateRef
    });
  };

  return {
    getRootProps,
    focusVisible,
    setFocusVisible,
    disabled,
    active
  };
}

/**
 * If `componentProps` is a function, calls it with the provided `ownerState`.
 * Otherwise, just returns `componentProps`.
 */
function resolveComponentProps(componentProps, ownerState) {
  if (typeof componentProps === 'function') {
    return componentProps(ownerState);
  }

  return componentProps;
}

const _excluded$y = ["action", "children", "className", "component", "components", "componentsProps", "disabled", "focusableWhenDisabled", "onBlur", "onClick", "onFocus", "onFocusVisible", "onKeyDown", "onKeyUp", "onMouseLeave"];

const useUtilityClasses$d = ownerState => {
  const {
    active,
    disabled,
    focusVisible
  } = ownerState;
  const slots = {
    root: ['root', disabled && 'disabled', focusVisible && 'focusVisible', active && 'active']
  };
  return composeClasses(slots, getButtonUnstyledUtilityClass, {});
};
/**
 * The foundation for building custom-styled buttons.
 *
 * Demos:
 *
 * - [Button](https://mui.com/base/react-button/)
 *
 * API:
 *
 * - [ButtonUnstyled API](https://mui.com/base/api/button-unstyled/)
 */


const ButtonUnstyled = /*#__PURE__*/React__namespace.forwardRef(function ButtonUnstyled(props, forwardedRef) {
  var _ref;

  const {
    action,
    children,
    className,
    component,
    components = {},
    componentsProps = {},
    focusableWhenDisabled = false
  } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$y);

  const buttonRef = React__namespace.useRef();
  const handleRef = useForkRef(buttonRef, forwardedRef);
  const {
    active,
    focusVisible,
    setFocusVisible,
    getRootProps
  } = useButton(_extends({}, props, {
    focusableWhenDisabled,
    ref: handleRef
  }));
  React__namespace.useImperativeHandle(action, () => ({
    focusVisible: () => {
      setFocusVisible(true);
      buttonRef.current.focus();
    }
  }), [setFocusVisible]);

  const ownerState = _extends({}, props, {
    active,
    focusableWhenDisabled,
    focusVisible
  });

  const classes = useUtilityClasses$d(ownerState);
  const ButtonRoot = (_ref = component != null ? component : components.Root) != null ? _ref : 'button';
  const rootComponentsProps = resolveComponentProps(componentsProps.root, ownerState);
  const buttonRootProps = appendOwnerState(ButtonRoot, _extends({}, getRootProps(), other, rootComponentsProps, {
    className: clsx(classes.root, className, rootComponentsProps == null ? void 0 : rootComponentsProps.className)
  }), ownerState);
  return /*#__PURE__*/jsxRuntime.exports.jsx(ButtonRoot, _extends({}, buttonRootProps, {
    children: children
  }));
});
process.env.NODE_ENV !== "production" ? ButtonUnstyled.propTypes
/* remove-proptypes */
= {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------

  /**
   * A ref for imperative actions. It currently only supports `focusVisible()` action.
   */
  action: propTypes.exports.oneOfType([propTypes.exports.func, propTypes.exports.shape({
    current: propTypes.exports.shape({
      focusVisible: propTypes.exports.func.isRequired
    })
  })]),

  /**
   * @ignore
   */
  children: propTypes.exports.node,

  /**
   * @ignore
   */
  className: propTypes.exports.string,

  /**
   * The component used for the Root slot.
   * Either a string to use a HTML element or a component.
   * This is equivalent to `components.Root`. If both are provided, the `component` is used.
   */
  component: propTypes.exports
  /* @typescript-to-proptypes-ignore */
  .elementType,

  /**
   * The components used for each slot inside the Button.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  components: propTypes.exports.shape({
    Root: propTypes.exports.elementType
  }),

  /**
   * The props used for each slot inside the Button.
   * @default {}
   */
  componentsProps: propTypes.exports.shape({
    root: propTypes.exports.oneOfType([propTypes.exports.func, propTypes.exports.object])
  }),

  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: propTypes.exports.bool,

  /**
   * If `true`, allows a disabled button to receive focus.
   * @default false
   */
  focusableWhenDisabled: propTypes.exports.bool,

  /**
   * @ignore
   */
  onFocusVisible: propTypes.exports.func
} : void 0;

function mapEventPropToEvent(eventProp) {
  return eventProp.substring(2).toLowerCase();
}

function clickedRootScrollbar(event, doc) {
  return doc.documentElement.clientWidth < event.clientX || doc.documentElement.clientHeight < event.clientY;
}

/**
 * Listen for click events that occur somewhere in the document, outside of the element itself.
 * For instance, if you need to hide a menu when people click anywhere else on your page.
 *
 * Demos:
 *
 * - [Click away listener](https://mui.com/base/react-click-away-listener/)
 *
 * API:
 *
 * - [ClickAwayListener API](https://mui.com/base/api/click-away-listener/)
 */
function ClickAwayListener(props) {
  const {
    children,
    disableReactTree = false,
    mouseEvent = 'onClick',
    onClickAway,
    touchEvent = 'onTouchEnd'
  } = props;
  const movedRef = React__namespace.useRef(false);
  const nodeRef = React__namespace.useRef(null);
  const activatedRef = React__namespace.useRef(false);
  const syntheticEventRef = React__namespace.useRef(false);
  React__namespace.useEffect(() => {
    // Ensure that this component is not "activated" synchronously.
    // https://github.com/facebook/react/issues/20074
    setTimeout(() => {
      activatedRef.current = true;
    }, 0);
    return () => {
      activatedRef.current = false;
    };
  }, []);
  const handleRef = useForkRef( // @ts-expect-error TODO upstream fix
  children.ref, nodeRef); // The handler doesn't take event.defaultPrevented into account:
  //
  // event.preventDefault() is meant to stop default behaviors like
  // clicking a checkbox to check it, hitting a button to submit a form,
  // and hitting left arrow to move the cursor in a text input etc.
  // Only special HTML elements have these default behaviors.

  const handleClickAway = useEventCallback(event => {
    // Given developers can stop the propagation of the synthetic event,
    // we can only be confident with a positive value.
    const insideReactTree = syntheticEventRef.current;
    syntheticEventRef.current = false;
    const doc = ownerDocument(nodeRef.current); // 1. IE11 support, which trigger the handleClickAway even after the unbind
    // 2. The child might render null.
    // 3. Behave like a blur listener.

    if (!activatedRef.current || !nodeRef.current || 'clientX' in event && clickedRootScrollbar(event, doc)) {
      return;
    } // Do not act if user performed touchmove


    if (movedRef.current) {
      movedRef.current = false;
      return;
    }

    let insideDOM; // If not enough, can use https://github.com/DieterHolvoet/event-propagation-path/blob/master/propagationPath.js

    if (event.composedPath) {
      insideDOM = event.composedPath().indexOf(nodeRef.current) > -1;
    } else {
      insideDOM = !doc.documentElement.contains( // @ts-expect-error returns `false` as intended when not dispatched from a Node
      event.target) || nodeRef.current.contains( // @ts-expect-error returns `false` as intended when not dispatched from a Node
      event.target);
    }

    if (!insideDOM && (disableReactTree || !insideReactTree)) {
      onClickAway(event);
    }
  }); // Keep track of mouse/touch events that bubbled up through the portal.

  const createHandleSynthetic = handlerName => event => {
    syntheticEventRef.current = true;
    const childrenPropsHandler = children.props[handlerName];

    if (childrenPropsHandler) {
      childrenPropsHandler(event);
    }
  };

  const childrenProps = {
    ref: handleRef
  };

  if (touchEvent !== false) {
    childrenProps[touchEvent] = createHandleSynthetic(touchEvent);
  }

  React__namespace.useEffect(() => {
    if (touchEvent !== false) {
      const mappedTouchEvent = mapEventPropToEvent(touchEvent);
      const doc = ownerDocument(nodeRef.current);

      const handleTouchMove = () => {
        movedRef.current = true;
      };

      doc.addEventListener(mappedTouchEvent, handleClickAway);
      doc.addEventListener('touchmove', handleTouchMove);
      return () => {
        doc.removeEventListener(mappedTouchEvent, handleClickAway);
        doc.removeEventListener('touchmove', handleTouchMove);
      };
    }

    return undefined;
  }, [handleClickAway, touchEvent]);

  if (mouseEvent !== false) {
    childrenProps[mouseEvent] = createHandleSynthetic(mouseEvent);
  }

  React__namespace.useEffect(() => {
    if (mouseEvent !== false) {
      const mappedMouseEvent = mapEventPropToEvent(mouseEvent);
      const doc = ownerDocument(nodeRef.current);
      doc.addEventListener(mappedMouseEvent, handleClickAway);
      return () => {
        doc.removeEventListener(mappedMouseEvent, handleClickAway);
      };
    }

    return undefined;
  }, [handleClickAway, mouseEvent]);
  return /*#__PURE__*/jsxRuntime.exports.jsx(React__namespace.Fragment, {
    children: /*#__PURE__*/React__namespace.cloneElement(children, childrenProps)
  });
}

process.env.NODE_ENV !== "production" ? ClickAwayListener.propTypes
/* remove-proptypes */
= {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------

  /**
   * The wrapped element.
   */
  children: elementAcceptingRef.isRequired,

  /**
   * If `true`, the React tree is ignored and only the DOM tree is considered.
   * This prop changes how portaled elements are handled.
   * @default false
   */
  disableReactTree: propTypes.exports.bool,

  /**
   * The mouse event to listen to. You can disable the listener by providing `false`.
   * @default 'onClick'
   */
  mouseEvent: propTypes.exports.oneOf(['onClick', 'onMouseDown', 'onMouseUp', 'onPointerDown', 'onPointerUp', false]),

  /**
   * Callback fired when a "click away" event is detected.
   */
  onClickAway: propTypes.exports.func.isRequired,

  /**
   * The touch event to listen to. You can disable the listener by providing `false`.
   * @default 'onTouchEnd'
   */
  touchEvent: propTypes.exports.oneOf(['onTouchEnd', 'onTouchStart', false])
} : void 0;

if (process.env.NODE_ENV !== 'production') {
  // eslint-disable-next-line
  ClickAwayListener['propTypes' + ''] = exactProp(ClickAwayListener.propTypes);
}

/**
 * @ignore - internal component.
 */
const FormControlUnstyledContext = /*#__PURE__*/React__namespace.createContext(undefined);

if (process.env.NODE_ENV !== 'production') {
  FormControlUnstyledContext.displayName = 'FormControlUnstyledContext';
}

const formControlUnstyledClasses = generateUtilityClasses('BaseFormControl', ['root', 'disabled', 'error', 'filled', 'focused', 'required']);

const _excluded$x = ["defaultValue", "children", "className", "component", "components", "componentsProps", "disabled", "error", "onChange", "required", "value"];

function hasValue(value) {
  return value != null && !(Array.isArray(value) && value.length === 0) && value !== '';
}
/**
 * Provides context such as filled/focused/error/required for form inputs.
 * Relying on the context provides high flexibility and ensures that the state always stays
 * consistent across the children of the `FormControl`.
 * This context is used by the following components:
 *
 * *   FormLabel
 * *   FormHelperText
 * *   Input
 * *   InputLabel
 *
 * You can find one composition example below and more going to [the demos](https://mui.com/material-ui/react-text-field/#components).
 *
 * ```jsx
 * <FormControl>
 *   <InputLabel htmlFor="my-input">Email address</InputLabel>
 *   <Input id="my-input" aria-describedby="my-helper-text" />
 *   <FormHelperText id="my-helper-text">We'll never share your email.</FormHelperText>
 * </FormControl>
 * ```
 *
 * ⚠️ Only one `Input` can be used within a FormControl because it create visual inconsistencies.
 * For instance, only one input can be focused at the same time, the state shouldn't be shared.
 *
 * Demos:
 *
 * - [Form control](https://mui.com/base/react-form-control/)
 *
 * API:
 *
 * - [FormControlUnstyled API](https://mui.com/base/api/form-control-unstyled/)
 */


const FormControlUnstyled = /*#__PURE__*/React__namespace.forwardRef(function FormControlUnstyled(props, ref) {
  var _ref;

  const {
    defaultValue,
    children,
    className,
    component,
    components = {},
    componentsProps = {},
    disabled = false,
    error = false,
    onChange,
    required = false,
    value: incomingValue
  } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$x);

  const [value, setValue] = useControlled({
    controlled: incomingValue,
    default: defaultValue,
    name: 'FormControl',
    state: 'value'
  });
  const filled = hasValue(value);
  const [focused, setFocused] = React__namespace.useState(false);

  if (disabled && focused) {
    setFocused(false);
  }

  const ownerState = _extends({}, props, {
    disabled,
    error,
    filled,
    focused,
    required
  });

  const handleChange = event => {
    setValue(event.target.value);
    onChange == null ? void 0 : onChange(event);
  };

  const childContext = {
    disabled,
    error,
    filled,
    focused,
    onBlur: () => {
      setFocused(false);
    },
    onChange: handleChange,
    onFocus: () => {
      setFocused(true);
    },
    required,
    value: value != null ? value : ''
  };
  const Root = (_ref = component != null ? component : components.Root) != null ? _ref : 'div';
  const rootProps = appendOwnerState(Root, _extends({}, other, componentsProps.root), ownerState);

  const renderChildren = () => {
    if (typeof children === 'function') {
      return children(childContext);
    }

    return children;
  };

  return /*#__PURE__*/jsxRuntime.exports.jsx(FormControlUnstyledContext.Provider, {
    value: childContext,
    children: /*#__PURE__*/jsxRuntime.exports.jsx(Root, _extends({
      ref: ref
    }, rootProps, {
      className: clsx(formControlUnstyledClasses.root, className, rootProps == null ? void 0 : rootProps.className, disabled && formControlUnstyledClasses.disabled, error && formControlUnstyledClasses.error, filled && formControlUnstyledClasses.filled, focused && formControlUnstyledClasses.focused, required && formControlUnstyledClasses.required),
      children: renderChildren()
    }))
  });
});
process.env.NODE_ENV !== "production" ? FormControlUnstyled.propTypes
/* remove-proptypes */
= {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------

  /**
   * The content of the component.
   */
  children: propTypes.exports
  /* @typescript-to-proptypes-ignore */
  .oneOfType([propTypes.exports.node, propTypes.exports.func]),

  /**
   * Class name applied to the root element.
   */
  className: propTypes.exports.string,

  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: propTypes.exports.elementType,

  /**
   * The components used for each slot inside the FormControl.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  components: propTypes.exports.shape({
    Root: propTypes.exports.elementType
  }),

  /**
   * @ignore
   */
  componentsProps: propTypes.exports.shape({
    root: propTypes.exports.object
  }),

  /**
   * @ignore
   */
  defaultValue: propTypes.exports.any,

  /**
   * If `true`, the label, input and helper text should be displayed in a disabled state.
   * @default false
   */
  disabled: propTypes.exports.bool,

  /**
   * If `true`, the label is displayed in an error state.
   * @default false
   */
  error: propTypes.exports.bool,

  /**
   * @ignore
   */
  onChange: propTypes.exports.func,

  /**
   * If `true`, the label will indicate that the `input` is required.
   * @default false
   */
  required: propTypes.exports.bool,

  /**
   * @ignore
   */
  value: propTypes.exports.any
} : void 0;

function useFormControlUnstyledContext() {
  return React__namespace.useContext(FormControlUnstyledContext);
}

const inputBaseClasses = generateUtilityClasses('MuiInput', ['root', 'formControl', 'focused', 'disabled', 'error', 'multiline', 'input', 'inputMultiline', 'inputTypeSearch', 'adornedStart', 'adornedEnd']);

function useInput(parameters) {
  const {
    defaultValue: defaultValueProp,
    disabled: disabledProp = false,
    error: errorProp = false,
    onBlur,
    onChange,
    onFocus,
    required: requiredProp = false,
    value: valueProp
  } = parameters;
  const formControlContext = useFormControlUnstyledContext();
  let defaultValue;
  let disabled;
  let error;
  let required;
  let value;

  if (formControlContext) {
    var _formControlContext$d, _formControlContext$e, _formControlContext$r;

    defaultValue = undefined;
    disabled = (_formControlContext$d = formControlContext.disabled) != null ? _formControlContext$d : false;
    error = (_formControlContext$e = formControlContext.error) != null ? _formControlContext$e : false;
    required = (_formControlContext$r = formControlContext.required) != null ? _formControlContext$r : false;
    value = formControlContext.value;

    if (process.env.NODE_ENV !== 'production') {
      const definedLocalProps = ['defaultValue', 'disabled', 'error', 'required', 'value'].filter(prop => parameters[prop] !== undefined);

      if (definedLocalProps.length > 0) {
        console.warn(['MUI: You have set props on an input that is inside a FormControlUnstyled.', 'Set these props on a FormControlUnstyled instead. Otherwise they will be ignored.', `Ignored props: ${definedLocalProps.join(', ')}`].join('\n'));
      }
    }
  } else {
    defaultValue = defaultValueProp;
    disabled = disabledProp;
    error = errorProp;
    required = requiredProp;
    value = valueProp;
  }

  const {
    current: isControlled
  } = React__namespace.useRef(value != null);
  const handleInputRefWarning = React__namespace.useCallback(instance => {
    if (process.env.NODE_ENV !== 'production') {
      if (instance && instance.nodeName !== 'INPUT' && !instance.focus) {
        console.error(['MUI: You have provided a `components.Input` to the input component', 'that does not correctly handle the `ref` prop.', 'Make sure the `ref` prop is called with a HTMLInputElement.'].join('\n'));
      }
    }
  }, []);
  const inputRef = React__namespace.useRef(null);
  const handleInputRef = useForkRef(inputRef, handleInputRefWarning);
  const [focused, setFocused] = React__namespace.useState(false); // The blur won't fire when the disabled state is set on a focused input.
  // We need to book keep the focused state manually.

  React__namespace.useEffect(() => {
    if (!formControlContext && disabled && focused) {
      setFocused(false); // @ts-ignore

      onBlur == null ? void 0 : onBlur();
    }
  }, [formControlContext, disabled, focused, onBlur]);

  const handleFocus = otherHandlers => event => {
    var _otherHandlers$onFocu;

    // Fix a bug with IE11 where the focus/blur events are triggered
    // while the component is disabled.
    if (formControlContext != null && formControlContext.disabled) {
      event.stopPropagation();
      return;
    }

    (_otherHandlers$onFocu = otherHandlers.onFocus) == null ? void 0 : _otherHandlers$onFocu.call(otherHandlers, event);

    if (formControlContext && formControlContext.onFocus) {
      var _formControlContext$o;

      formControlContext == null ? void 0 : (_formControlContext$o = formControlContext.onFocus) == null ? void 0 : _formControlContext$o.call(formControlContext);
    } else {
      setFocused(true);
    }
  };

  const handleBlur = otherHandlers => event => {
    var _otherHandlers$onBlur;

    (_otherHandlers$onBlur = otherHandlers.onBlur) == null ? void 0 : _otherHandlers$onBlur.call(otherHandlers, event);

    if (formControlContext && formControlContext.onBlur) {
      formControlContext.onBlur();
    } else {
      setFocused(false);
    }
  };

  const handleChange = otherHandlers => (event, ...args) => {
    var _formControlContext$o2, _otherHandlers$onChan;

    if (!isControlled) {
      const element = event.target || inputRef.current;

      if (element == null) {
        throw new Error(process.env.NODE_ENV !== "production" ? `MUI: Expected valid input target. Did you use a custom \`components.Input\` and forget to forward refs? See https://mui.com/r/input-component-ref-interface for more info.` : formatMuiErrorMessage(17));
      }
    }

    formControlContext == null ? void 0 : (_formControlContext$o2 = formControlContext.onChange) == null ? void 0 : _formControlContext$o2.call(formControlContext, event); // @ts-ignore

    (_otherHandlers$onChan = otherHandlers.onChange) == null ? void 0 : _otherHandlers$onChan.call(otherHandlers, event, ...args);
  };

  const handleClick = otherHandlers => event => {
    var _otherHandlers$onClic;

    if (inputRef.current && event.currentTarget === event.target) {
      inputRef.current.focus();
    }

    (_otherHandlers$onClic = otherHandlers.onClick) == null ? void 0 : _otherHandlers$onClic.call(otherHandlers, event);
  };

  const getRootProps = (externalProps = {}) => {
    // onBlur, onChange and onFocus are forwarded to the input slot.
    const propsEventHandlers = extractEventHandlers(parameters, ['onBlur', 'onChange', 'onFocus']);

    const externalEventHandlers = _extends({}, propsEventHandlers, extractEventHandlers(externalProps));

    return _extends({}, externalProps, externalEventHandlers, {
      onClick: handleClick(externalEventHandlers)
    });
  };

  const getInputProps = (externalProps = {}) => {
    const propsEventHandlers = {
      onBlur,
      onChange,
      onFocus
    };

    const externalEventHandlers = _extends({}, propsEventHandlers, extractEventHandlers(externalProps));

    const mergedEventHandlers = _extends({}, externalProps, externalEventHandlers, {
      onBlur: handleBlur(externalEventHandlers),
      onChange: handleChange(externalEventHandlers),
      onFocus: handleFocus(externalEventHandlers)
    });

    return _extends({}, mergedEventHandlers, {
      'aria-invalid': error || undefined,
      defaultValue: defaultValue,
      ref: handleInputRef,
      value: value,
      required,
      disabled
    });
  };

  return {
    disabled,
    error,
    focused,
    formControlContext,
    getInputProps,
    getRootProps,
    required,
    value
  };
}

const _excluded$w = ["aria-describedby", "aria-label", "aria-labelledby", "autoComplete", "autoFocus", "className", "component", "components", "componentsProps", "defaultValue", "disabled", "endAdornment", "error", "id", "maxRows", "minRows", "multiline", "name", "onClick", "onChange", "onKeyDown", "onKeyUp", "onFocus", "onBlur", "placeholder", "readOnly", "required", "rows", "type", "startAdornment", "value"],
      _excluded2$3 = ["ownerState"];

/**
 *
 * Demos:
 *
 * - [Input](https://mui.com/base/react-input/)
 *
 * API:
 *
 * - [InputUnstyled API](https://mui.com/base/api/input-unstyled/)
 */
const InputUnstyled = /*#__PURE__*/React__namespace.forwardRef(function InputUnstyled(props, forwardedRef) {
  var _ref, _components$Input;

  const {
    'aria-describedby': ariaDescribedby,
    'aria-label': ariaLabel,
    'aria-labelledby': ariaLabelledby,
    autoComplete,
    autoFocus,
    className,
    component,
    components = {},
    componentsProps = {},
    defaultValue,
    disabled,
    endAdornment,
    error,
    id,
    maxRows,
    minRows,
    multiline = false,
    name,
    onClick,
    onChange,
    onKeyDown,
    onKeyUp,
    onFocus,
    onBlur,
    placeholder,
    readOnly,
    required,
    rows,
    type = 'text',
    startAdornment,
    value
  } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$w);

  const {
    getRootProps,
    getInputProps,
    focused,
    formControlContext,
    error: errorState,
    disabled: disabledState
  } = useInput({
    disabled,
    defaultValue,
    error,
    onBlur,
    onClick,
    onChange,
    onFocus,
    required,
    value
  });

  const ownerState = _extends({}, props, {
    disabled: disabledState,
    error: errorState,
    focused,
    formControlContext,
    multiline,
    type
  });

  const rootStateClasses = clsx(disabledState && inputBaseClasses.disabled, errorState && inputBaseClasses.error, focused && inputBaseClasses.focused, Boolean(formControlContext) && inputBaseClasses.formControl, multiline && inputBaseClasses.multiline, Boolean(startAdornment) && inputBaseClasses.adornedStart, Boolean(endAdornment) && inputBaseClasses.adornedEnd);
  const inputStateClasses = clsx(disabledState && inputBaseClasses.disabled, multiline && inputBaseClasses.multiline);
  const propsToForward = {
    'aria-describedby': ariaDescribedby,
    'aria-label': ariaLabel,
    'aria-labelledby': ariaLabelledby,
    autoComplete,
    autoFocus,
    id,
    onKeyDown,
    onKeyUp,
    name,
    placeholder,
    readOnly,
    type
  };
  const Root = (_ref = component != null ? component : components.Root) != null ? _ref : 'div';
  const rootComponentsProps = resolveComponentProps(componentsProps.root, ownerState);
  const rootProps = appendOwnerState(Root, _extends({}, getRootProps(_extends({}, other, rootComponentsProps)), {
    className: clsx(inputBaseClasses.root, rootStateClasses, className, rootComponentsProps == null ? void 0 : rootComponentsProps.className)
  }), ownerState);
  rootProps.ref = useForkRef(rootProps.ref, useForkRef(rootComponentsProps == null ? void 0 : rootComponentsProps.ref, forwardedRef));
  let Input = (_components$Input = components.Input) != null ? _components$Input : 'input';
  const inputComponentsProps = resolveComponentProps(componentsProps.input, ownerState);
  let inputProps = appendOwnerState(Input, _extends({}, getInputProps(_extends({}, inputComponentsProps, propsToForward)), {
    className: clsx(inputBaseClasses.input, inputStateClasses, inputComponentsProps == null ? void 0 : inputComponentsProps.className)
  }), ownerState);
  inputProps.ref = useForkRef(inputProps.ref, inputComponentsProps == null ? void 0 : inputComponentsProps.ref);

  if (multiline) {
    var _components$Textarea, _components$Textarea2;

    const hasHostTextarea = isHostComponent((_components$Textarea = components.Textarea) != null ? _components$Textarea : 'textarea');

    const inputPropsWithoutOwnerState = _objectWithoutPropertiesLoose(inputProps, _excluded2$3);

    if (rows) {
      if (process.env.NODE_ENV !== 'production') {
        if (minRows || maxRows) {
          console.warn('MUI: You can not use the `minRows` or `maxRows` props when the input `rows` prop is set.');
        }
      }
    }

    inputProps = _extends({}, !hasHostTextarea && {
      minRows: rows || minRows,
      maxRows: rows || maxRows
    }, hasHostTextarea ? inputPropsWithoutOwnerState : inputProps, {
      type: undefined
    });
    Input = (_components$Textarea2 = components.Textarea) != null ? _components$Textarea2 : 'textarea';
  }

  return /*#__PURE__*/jsxRuntime.exports.jsxs(Root, _extends({}, rootProps, {
    children: [startAdornment, /*#__PURE__*/jsxRuntime.exports.jsx(Input, _extends({}, inputProps)), endAdornment]
  }));
});
process.env.NODE_ENV !== "production" ? InputUnstyled.propTypes
/* remove-proptypes */
= {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------

  /**
   * @ignore
   */
  'aria-describedby': propTypes.exports.string,

  /**
   * @ignore
   */
  'aria-label': propTypes.exports.string,

  /**
   * @ignore
   */
  'aria-labelledby': propTypes.exports.string,

  /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */
  autoComplete: propTypes.exports.string,

  /**
   * If `true`, the `input` element is focused during the first mount.
   */
  autoFocus: propTypes.exports.bool,

  /**
   * @ignore
   */
  children: propTypes.exports.node,

  /**
   * Class name applied to the root element.
   */
  className: propTypes.exports.string,

  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: propTypes.exports.elementType,

  /**
   * The components used for each slot inside the InputBase.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  components: propTypes.exports.shape({
    Input: propTypes.exports.elementType,
    Root: propTypes.exports.elementType,
    Textarea: propTypes.exports.elementType
  }),

  /**
   * The props used for each slot inside the Input.
   * @default {}
   */
  componentsProps: propTypes.exports.shape({
    input: propTypes.exports.oneOfType([propTypes.exports.func, propTypes.exports.object]),
    root: propTypes.exports.oneOfType([propTypes.exports.func, propTypes.exports.object])
  }),

  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: propTypes.exports.any,

  /**
   * If `true`, the component is disabled.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  disabled: propTypes.exports.bool,

  /**
   * Trailing adornment for this input.
   */
  endAdornment: propTypes.exports.node,

  /**
   * If `true`, the `input` will indicate an error.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  error: propTypes.exports.bool,

  /**
   * The id of the `input` element.
   */
  id: propTypes.exports.string,

  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  maxRows: propTypes.exports.number,

  /**
   * Minimum number of rows to display when multiline option is set to true.
   */
  minRows: propTypes.exports.number,

  /**
   * If `true`, a `textarea` element is rendered.
   * @default false
   */
  multiline: propTypes.exports.bool,

  /**
   * Name attribute of the `input` element.
   */
  name: propTypes.exports.string,

  /**
   * @ignore
   */
  onBlur: propTypes.exports.func,

  /**
   * @ignore
   */
  onChange: propTypes.exports.func,

  /**
   * @ignore
   */
  onClick: propTypes.exports.func,

  /**
   * @ignore
   */
  onFocus: propTypes.exports.func,

  /**
   * @ignore
   */
  onKeyDown: propTypes.exports.func,

  /**
   * @ignore
   */
  onKeyUp: propTypes.exports.func,

  /**
   * The short hint displayed in the `input` before the user enters a value.
   */
  placeholder: propTypes.exports.string,

  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */
  readOnly: propTypes.exports.bool,

  /**
   * If `true`, the `input` element is required.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  required: propTypes.exports.bool,

  /**
   * Number of rows to display when multiline option is set to true.
   */
  rows: propTypes.exports.number,

  /**
   * Leading adornment for this input.
   */
  startAdornment: propTypes.exports.node,

  /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
   * @default 'text'
   */
  type: propTypes.exports
  /* @typescript-to-proptypes-ignore */
  .oneOf(['button', 'checkbox', 'color', 'date', 'datetime-local', 'email', 'file', 'hidden', 'image', 'month', 'number', 'password', 'radio', 'range', 'reset', 'search', 'submit', 'tel', 'text', 'time', 'url', 'week']),

  /**
   * The value of the `input` element, required for a controlled component.
   */
  value: propTypes.exports.any
} : void 0;

var ActionTypes; // split declaration and export due to https://github.com/codesandbox/codesandbox-client/issues/6435

(function (ActionTypes) {
  ActionTypes["blur"] = "blur";
  ActionTypes["focus"] = "focus";
  ActionTypes["keyDown"] = "keyDown";
  ActionTypes["optionClick"] = "optionClick";
  ActionTypes["optionHover"] = "optionHover";
  ActionTypes["optionsChange"] = "optionsChange";
  ActionTypes["setValue"] = "setValue";
  ActionTypes["setHighlight"] = "setHighlight";
  ActionTypes["textNavigation"] = "textNagivation";
})(ActionTypes || (ActionTypes = {}));

const pageSize = 5;

function findValidOptionToHighlight(index, lookupDirection, options, focusDisabled, isOptionDisabled, wrapAround) {
  if (options.length === 0 || options.every((o, i) => isOptionDisabled(o, i))) {
    return -1;
  }

  let nextFocus = index;

  for (;;) {
    // No valid options found
    if (!wrapAround && lookupDirection === 'next' && nextFocus === options.length || !wrapAround && lookupDirection === 'previous' && nextFocus === -1) {
      return -1;
    }

    const nextFocusDisabled = focusDisabled ? false : isOptionDisabled(options[nextFocus], nextFocus);

    if (nextFocusDisabled) {
      nextFocus += lookupDirection === 'next' ? 1 : -1;

      if (wrapAround) {
        nextFocus = (nextFocus + options.length) % options.length;
      }
    } else {
      return nextFocus;
    }
  }
}

function getNewHighlightedOption(options, previouslyHighlightedOption, diff, lookupDirection, highlightDisabled, isOptionDisabled, wrapAround, optionComparer) {
  var _options$nextIndex;

  const maxIndex = options.length - 1;
  const defaultHighlightedIndex = -1;
  let nextIndexCandidate;
  const previouslyHighlightedIndex = previouslyHighlightedOption == null ? -1 : options.findIndex(option => optionComparer(option, previouslyHighlightedOption));

  if (diff === 'reset') {
    var _options$defaultHighl;

    return defaultHighlightedIndex === -1 ? null : (_options$defaultHighl = options[defaultHighlightedIndex]) != null ? _options$defaultHighl : null;
  }

  if (diff === 'start') {
    nextIndexCandidate = 0;
  } else if (diff === 'end') {
    nextIndexCandidate = maxIndex;
  } else {
    const newIndex = previouslyHighlightedIndex + diff;

    if (newIndex < 0) {
      if (!wrapAround && previouslyHighlightedIndex !== -1 || Math.abs(diff) > 1) {
        nextIndexCandidate = 0;
      } else {
        nextIndexCandidate = maxIndex;
      }
    } else if (newIndex > maxIndex) {
      if (!wrapAround || Math.abs(diff) > 1) {
        nextIndexCandidate = maxIndex;
      } else {
        nextIndexCandidate = 0;
      }
    } else {
      nextIndexCandidate = newIndex;
    }
  }

  const nextIndex = findValidOptionToHighlight(nextIndexCandidate, lookupDirection, options, highlightDisabled, isOptionDisabled, wrapAround);
  return (_options$nextIndex = options[nextIndex]) != null ? _options$nextIndex : null;
}

function handleOptionSelection(option, state, props) {
  const {
    multiple,
    optionComparer = (o, v) => o === v,
    isOptionDisabled = () => false
  } = props;
  const {
    selectedValue
  } = state;
  const optionIndex = props.options.indexOf(option);

  if (isOptionDisabled(option, optionIndex)) {
    return state;
  }

  if (multiple) {
    var _ref, _ref2;

    const selectedValues = (_ref = selectedValue) != null ? _ref : []; // if the option is already selected, remove it from the selection, otherwise add it

    const newSelectedValues = selectedValues.some(sv => optionComparer(sv, option)) ? selectedValue.filter(v => !optionComparer(v, option)) : [...((_ref2 = selectedValue) != null ? _ref2 : []), option];
    return {
      selectedValue: newSelectedValues,
      highlightedValue: option
    };
  }

  if (selectedValue != null && optionComparer(option, selectedValue)) {
    return state;
  }

  return {
    selectedValue: option,
    highlightedValue: option
  };
}

function handleKeyDown(event, state, props) {
  const {
    options,
    isOptionDisabled,
    disableListWrap,
    disabledItemsFocusable,
    optionComparer
  } = props;

  const moveHighlight = (diff, direction, wrapAround) => {
    return getNewHighlightedOption(options, state.highlightedValue, diff, direction, disabledItemsFocusable != null ? disabledItemsFocusable : false, isOptionDisabled != null ? isOptionDisabled : () => false, wrapAround, optionComparer);
  };

  switch (event.key) {
    case 'Home':
      return _extends({}, state, {
        highlightedValue: moveHighlight('start', 'next', false)
      });

    case 'End':
      return _extends({}, state, {
        highlightedValue: moveHighlight('end', 'previous', false)
      });

    case 'PageUp':
      return _extends({}, state, {
        highlightedValue: moveHighlight(-pageSize, 'previous', false)
      });

    case 'PageDown':
      return _extends({}, state, {
        highlightedValue: moveHighlight(pageSize, 'next', false)
      });

    case 'ArrowUp':
      // TODO: extend current selection with Shift modifier
      return _extends({}, state, {
        highlightedValue: moveHighlight(-1, 'previous', !(disableListWrap != null ? disableListWrap : false))
      });

    case 'ArrowDown':
      // TODO: extend current selection with Shift modifier
      return _extends({}, state, {
        highlightedValue: moveHighlight(1, 'next', !(disableListWrap != null ? disableListWrap : false))
      });

    case 'Enter':
    case ' ':
      if (state.highlightedValue === null) {
        return state;
      }

      return handleOptionSelection(state.highlightedValue, state, props);
  }

  return state;
}

function handleBlur(state) {
  return _extends({}, state, {
    highlightedValue: null
  });
}

const textCriteriaMatches = (nextFocus, searchString, stringifyOption) => {
  var _stringifyOption;

  const text = (_stringifyOption = stringifyOption(nextFocus)) == null ? void 0 : _stringifyOption.trim().toLowerCase();

  if (!text || text.length === 0) {
    // Make option not navigable if stringification fails or results in empty string.
    return false;
  }

  return text.indexOf(searchString) === 0;
};

function handleTextNavigation(state, searchString, props) {
  const {
    options,
    isOptionDisabled,
    disableListWrap,
    disabledItemsFocusable,
    optionComparer,
    optionStringifier
  } = props;

  const moveHighlight = previouslyHighlightedOption => {
    return getNewHighlightedOption(options, previouslyHighlightedOption, 1, 'next', disabledItemsFocusable != null ? disabledItemsFocusable : false, isOptionDisabled != null ? isOptionDisabled : () => false, !(disableListWrap != null ? disableListWrap : false), optionComparer);
  };

  const startWithCurrentOption = searchString.length > 1;
  let nextOption = startWithCurrentOption ? state.highlightedValue : moveHighlight(state.highlightedValue); // use `for` instead of `while` prevent infinite loop

  for (let index = 0; index < options.length; index += 1) {
    // Return un-mutated state if looped back to the currently highlighted value
    if (!nextOption || !startWithCurrentOption && state.highlightedValue === nextOption) {
      return state;
    }

    if (textCriteriaMatches(nextOption, searchString, optionStringifier) && (!isOptionDisabled(nextOption, options.indexOf(nextOption)) || disabledItemsFocusable)) {
      // The nextOption is the element to be highlighted
      return _extends({}, state, {
        highlightedValue: nextOption
      });
    } // Move to the next element.


    nextOption = moveHighlight(nextOption);
  } // No option match text search criteria


  return state;
}

function handleOptionsChange(options, previousOptions, state, props) {
  var _options$find, _options$find2;

  const {
    multiple,
    optionComparer
  } = props;
  const newHighlightedOption = state.highlightedValue == null ? null : (_options$find = options.find(option => optionComparer(option, state.highlightedValue))) != null ? _options$find : null;

  if (multiple) {
    var _ref3;

    // exclude selected values that are no longer in the options
    const selectedValues = (_ref3 = state.selectedValue) != null ? _ref3 : [];
    const newSelectedValues = selectedValues.filter(selectedValue => options.some(option => optionComparer(option, selectedValue)));
    return {
      highlightedValue: newHighlightedOption,
      selectedValue: newSelectedValues
    };
  }

  const newSelectedValue = (_options$find2 = options.find(option => optionComparer(option, state.selectedValue))) != null ? _options$find2 : null;
  return {
    highlightedValue: newHighlightedOption,
    selectedValue: newSelectedValue
  };
}

function defaultListboxReducer(state, action) {
  const {
    type
  } = action;

  switch (type) {
    case ActionTypes.keyDown:
      return handleKeyDown(action.event, state, action.props);

    case ActionTypes.optionClick:
      return handleOptionSelection(action.option, state, action.props);

    case ActionTypes.blur:
      return handleBlur(state);

    case ActionTypes.setValue:
      return _extends({}, state, {
        selectedValue: action.value
      });

    case ActionTypes.setHighlight:
      return _extends({}, state, {
        highlightedValue: action.highlight
      });

    case ActionTypes.textNavigation:
      return handleTextNavigation(state, action.searchString, action.props);

    case ActionTypes.optionsChange:
      return handleOptionsChange(action.options, action.previousOptions, state, action.props);

    default:
      return state;
  }
}

/**
 * Triggers change event handlers when reducer returns changed state.
 */

function useReducerReturnValueHandler(state, value, options, optionComparer, setValueState, onValueChange, onHighlightChange) {
  const valueRef = React__namespace.useRef(value);
  valueRef.current = value;
  const onValueChangeRef = React__namespace.useRef(onValueChange);
  React__namespace.useEffect(() => {
    onValueChangeRef.current = onValueChange;
  }, [onValueChange]);
  const onHighlightChangeRef = React__namespace.useRef(onHighlightChange);
  React__namespace.useEffect(() => {
    onHighlightChangeRef.current = onHighlightChange;
  }, [onHighlightChange]);
  React__namespace.useEffect(() => {
    if (Array.isArray(state.selectedValue)) {
      if (areArraysEqual(state.selectedValue, valueRef.current)) {
        return;
      }
    } else if (state.selectedValue == null && valueRef.current == null || state.selectedValue != null && valueRef.current != null && optionComparer.current(state.selectedValue, valueRef.current)) {
      return;
    }

    setValueState(state.selectedValue);

    if (state.selectedValue != null) {
      var _onValueChangeRef$cur;

      // @ts-ignore We know that selectedValue has the correct type depending on `selectMultiple` prop.
      (_onValueChangeRef$cur = onValueChangeRef.current) == null ? void 0 : _onValueChangeRef$cur.call(onValueChangeRef, state.selectedValue);
    }
  }, [state.selectedValue, setValueState, optionComparer]);
  React__namespace.useEffect(() => {
    var _onHighlightChangeRef;

    // Fire the highlightChange event when reducer returns changed `highlightedIndex`.
    (_onHighlightChangeRef = onHighlightChangeRef.current) == null ? void 0 : _onHighlightChangeRef.call(onHighlightChangeRef, state.highlightedValue);
  }, [state.highlightedValue]);
}

function useControllableReducer(internalReducer, externalReducer, props) {
  const {
    value: controlledValue,
    defaultValue,
    onChange: onValueChange,
    onHighlightChange,
    options,
    optionComparer
  } = props;
  const propsRef = React__namespace.useRef(props);
  propsRef.current = props;
  const [value, setValueState] = useControlled({
    controlled: controlledValue,
    default: defaultValue,
    name: 'useListbox'
  });
  const previousValueRef = React__namespace.useRef(null);
  const [state, dispatch] = React__namespace.useReducer(externalReducer != null ? externalReducer : internalReducer, {
    highlightedValue: null,
    selectedValue: value
  });
  const optionComparerRef = React__namespace.useRef(optionComparer);
  optionComparerRef.current = optionComparer;
  React__namespace.useEffect(() => {
    // Detect external changes to the controlled `value` prop and update the state.
    if (controlledValue === undefined) {
      return;
    }

    if (Array.isArray(controlledValue) && Array.isArray(previousValueRef.current) && areArraysEqual(previousValueRef.current, controlledValue, optionComparerRef.current)) {
      // `value` is an array and it did not change.
      return;
    }

    if (!Array.isArray(controlledValue) && controlledValue != null && previousValueRef.current != null && optionComparerRef.current(controlledValue, previousValueRef.current)) {
      // `value` is a single option and it did not change.
      return;
    }

    previousValueRef.current = controlledValue;
    dispatch({
      type: ActionTypes.setValue,
      value: controlledValue
    });
  }, [controlledValue]);
  useReducerReturnValueHandler(state, value, options, optionComparerRef, setValueState, onValueChange, onHighlightChange);
  return [state, dispatch];
}

const TEXT_NAVIGATION_RESET_TIMEOUT = 500; // milliseconds

const defaultOptionComparer = (optionA, optionB) => optionA === optionB;

const defaultIsOptionDisabled = () => false;

const defaultOptionStringifier$1 = option => typeof option === 'string' ? option : String(option);

function useListbox(props) {
  var _props$optionIdGenera, _options$highlightedI;

  const {
    disabledItemsFocusable = false,
    disableListWrap = false,
    focusManagement = 'activeDescendant',
    id: idProp,
    isOptionDisabled = defaultIsOptionDisabled,
    listboxRef: externalListboxRef,
    multiple = false,
    optionComparer = defaultOptionComparer,
    optionStringifier = defaultOptionStringifier$1,
    options,
    stateReducer: externalReducer
  } = props;
  const id = useId(idProp);

  function defaultIdGenerator(_, index) {
    return `${id}-option-${index}`;
  }

  const optionIdGenerator = (_props$optionIdGenera = props.optionIdGenerator) != null ? _props$optionIdGenera : defaultIdGenerator;

  const propsWithDefaults = _extends({}, props, {
    disabledItemsFocusable,
    disableListWrap,
    focusManagement,
    isOptionDisabled,
    multiple,
    optionComparer,
    optionStringifier
  });

  const listboxRef = React__namespace.useRef(null);
  const handleRef = useForkRef(externalListboxRef, listboxRef);
  const textCriteriaRef = React__namespace.useRef({
    searchString: '',
    lastTime: null
  });
  const [{
    highlightedValue,
    selectedValue
  }, dispatch] = useControllableReducer(defaultListboxReducer, externalReducer, propsWithDefaults);
  const highlightedIndex = React__namespace.useMemo(() => {
    return highlightedValue == null ? -1 : options.findIndex(option => optionComparer(option, highlightedValue));
  }, [highlightedValue, options, optionComparer]);
  const previousOptions = React__namespace.useRef([]);
  React__namespace.useEffect(() => {
    if (areArraysEqual(previousOptions.current, options, optionComparer)) {
      return;
    }

    dispatch({
      type: ActionTypes.optionsChange,
      options,
      previousOptions: previousOptions.current,
      props: propsWithDefaults
    });
    previousOptions.current = options; // No need to re-run this effect if props change
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [options, optionComparer, dispatch]);
  const setSelectedValue = React__namespace.useCallback(option => {
    dispatch({
      type: ActionTypes.setValue,
      value: option
    });
  }, [dispatch]);
  const setHighlightedValue = React__namespace.useCallback(option => {
    dispatch({
      type: ActionTypes.setHighlight,
      highlight: option
    });
  }, [dispatch]);

  const createHandleOptionClick = (option, other) => event => {
    var _other$onClick;

    (_other$onClick = other.onClick) == null ? void 0 : _other$onClick.call(other, event);

    if (event.defaultPrevented) {
      return;
    }

    event.preventDefault();
    dispatch({
      type: ActionTypes.optionClick,
      option,
      event,
      props: propsWithDefaults
    });
  };

  const createHandleOptionMouseOver = (option, other) => event => {
    var _other$onMouseOver;

    (_other$onMouseOver = other.onMouseOver) == null ? void 0 : _other$onMouseOver.call(other, event);

    if (event.defaultPrevented) {
      return;
    }

    dispatch({
      type: ActionTypes.optionHover,
      option,
      event,
      props: propsWithDefaults
    });
  };

  const createHandleKeyDown = other => event => {
    var _other$onKeyDown;

    (_other$onKeyDown = other.onKeyDown) == null ? void 0 : _other$onKeyDown.call(other, event);

    if (event.defaultPrevented) {
      return;
    }

    const keysToPreventDefault = [' ', 'Enter', 'ArrowUp', 'ArrowDown', 'Home', 'End', 'PageUp', 'PageDown'];

    if (keysToPreventDefault.includes(event.key)) {
      event.preventDefault();
    }

    dispatch({
      type: ActionTypes.keyDown,
      event,
      props: propsWithDefaults
    }); // Handle text navigation

    if (event.key.length === 1) {
      const textCriteria = textCriteriaRef.current;
      const lowerKey = event.key.toLowerCase();
      const currentTime = performance.now();

      if (textCriteria.searchString.length > 0 && textCriteria.lastTime && currentTime - textCriteria.lastTime > TEXT_NAVIGATION_RESET_TIMEOUT) {
        textCriteria.searchString = lowerKey;
      } else if (textCriteria.searchString.length !== 1 || lowerKey !== textCriteria.searchString) {
        // If there is just one character in the buffer and the key is the same, do not append
        textCriteria.searchString += lowerKey;
      }

      textCriteria.lastTime = currentTime;
      dispatch({
        type: ActionTypes.textNavigation,
        searchString: textCriteria.searchString,
        props: propsWithDefaults
      });
    }
  };

  const createHandleBlur = other => event => {
    var _other$onBlur, _listboxRef$current;

    (_other$onBlur = other.onBlur) == null ? void 0 : _other$onBlur.call(other, event);

    if (event.defaultPrevented) {
      return;
    }

    if ((_listboxRef$current = listboxRef.current) != null && _listboxRef$current.contains(document.activeElement)) {
      // focus is within the listbox
      return;
    }

    dispatch({
      type: ActionTypes.blur,
      event,
      props: propsWithDefaults
    });
  };

  const getRootProps = (otherHandlers = {}) => {
    return _extends({}, otherHandlers, {
      'aria-activedescendant': focusManagement === 'activeDescendant' && highlightedValue != null ? optionIdGenerator(highlightedValue, highlightedIndex) : undefined,
      id,
      onBlur: createHandleBlur(otherHandlers),
      onKeyDown: createHandleKeyDown(otherHandlers),
      role: 'listbox',
      tabIndex: focusManagement === 'DOM' ? -1 : 0,
      ref: handleRef
    });
  };

  const getOptionState = option => {
    let selected;
    const index = options.findIndex(opt => optionComparer(opt, option));

    if (multiple) {
      var _ref;

      selected = ((_ref = selectedValue) != null ? _ref : []).some(value => value != null && optionComparer(option, value));
    } else {
      selected = optionComparer(option, selectedValue);
    }

    const disabled = isOptionDisabled(option, index);
    return {
      selected,
      disabled,
      highlighted: highlightedIndex === index
    };
  };

  const getOptionTabIndex = optionState => {
    if (focusManagement === 'activeDescendant') {
      return undefined;
    }

    if (!optionState.highlighted) {
      return -1;
    }

    if (optionState.disabled && !disabledItemsFocusable) {
      return -1;
    }

    return 0;
  };

  const getOptionProps = (option, otherHandlers = {}) => {
    const optionState = getOptionState(option);
    const index = options.findIndex(opt => optionComparer(opt, option));
    return _extends({}, otherHandlers, {
      'aria-disabled': optionState.disabled || undefined,
      'aria-selected': optionState.selected,
      tabIndex: getOptionTabIndex(optionState),
      id: optionIdGenerator(option, index),
      onClick: createHandleOptionClick(option, otherHandlers),
      onMouseOver: createHandleOptionMouseOver(option, otherHandlers),
      role: 'option'
    });
  };

  React__namespace.useDebugValue({
    highlightedOption: options[highlightedIndex],
    selectedOption: selectedValue
  });
  return {
    getRootProps,
    getOptionProps,
    getOptionState,
    highlightedOption: (_options$highlightedI = options[highlightedIndex]) != null ? _options$highlightedI : null,
    selectedOption: selectedValue,
    setSelectedValue,
    setHighlightedValue
  };
}

const MenuUnstyledContext = /*#__PURE__*/React__namespace.createContext(null);
MenuUnstyledContext.displayName = 'MenuUnstyledContext';

function getMenuUnstyledUtilityClass(slot) {
  return generateUtilityClass('MuiMenuUnstyled', slot);
}
generateUtilityClasses('MuiMenuUnstyled', ['root', 'listbox', 'expanded']);

function stateReducer(state, action) {
  if (action.type === ActionTypes.blur || action.type === ActionTypes.optionHover || action.type === ActionTypes.setValue) {
    return state;
  }

  const newState = defaultListboxReducer(state, action);

  if (action.type !== ActionTypes.setHighlight && newState.highlightedValue === null && action.props.options.length > 0) {
    return _extends({}, newState, {
      highlightedValue: action.props.options[0]
    });
  }

  return newState;
}

function useMenu(parameters) {
  const {
    listboxRef: listboxRefProp,
    open = false,
    onClose,
    listboxId
  } = parameters;
  const [menuItems, setMenuItems] = React__namespace.useState({});
  const listboxRef = React__namespace.useRef(null);
  const handleRef = useForkRef(listboxRef, listboxRefProp);
  const registerItem = React__namespace.useCallback((id, metadata) => {
    setMenuItems(previousState => {
      const newState = _extends({}, previousState);

      newState[id] = metadata;
      return newState;
    });
  }, []);
  const unregisterItem = React__namespace.useCallback(id => {
    setMenuItems(previousState => {
      const newState = _extends({}, previousState);

      delete newState[id];
      return newState;
    });
  }, []);
  const {
    getOptionState,
    getOptionProps,
    getRootProps,
    highlightedOption,
    setHighlightedValue: setListboxHighlight
  } = useListbox({
    options: Object.keys(menuItems),
    optionStringifier: id => {
      var _menuItems$id$ref$cur;

      return menuItems[id].label || ((_menuItems$id$ref$cur = menuItems[id].ref.current) == null ? void 0 : _menuItems$id$ref$cur.innerText);
    },
    isOptionDisabled: id => {
      var _menuItems$id;

      return (menuItems == null ? void 0 : (_menuItems$id = menuItems[id]) == null ? void 0 : _menuItems$id.disabled) || false;
    },
    listboxRef: handleRef,
    focusManagement: 'DOM',
    id: listboxId,
    stateReducer,
    disabledItemsFocusable: true
  });
  const highlightFirstItem = React__namespace.useCallback(() => {
    if (Object.keys(menuItems).length > 0) {
      setListboxHighlight(menuItems[Object.keys(menuItems)[0]].id);
    }
  }, [menuItems, setListboxHighlight]);
  const highlightLastItem = React__namespace.useCallback(() => {
    if (Object.keys(menuItems).length > 0) {
      setListboxHighlight(menuItems[Object.keys(menuItems)[Object.keys(menuItems).length - 1]].id);
    }
  }, [menuItems, setListboxHighlight]);
  React__namespace.useEffect(() => {
    if (!open) {
      highlightFirstItem();
    }
  }, [open, highlightFirstItem]);

  const createHandleKeyDown = otherHandlers => e => {
    var _otherHandlers$onKeyD;

    otherHandlers == null ? void 0 : (_otherHandlers$onKeyD = otherHandlers.onKeyDown) == null ? void 0 : _otherHandlers$onKeyD.call(otherHandlers, e);

    if (e.defaultPrevented) {
      return;
    }

    if (e.key === 'Escape' && open) {
      onClose == null ? void 0 : onClose();
    }
  };

  const createHandleBlur = otherHandlers => e => {
    var _listboxRef$current;

    otherHandlers == null ? void 0 : otherHandlers.onBlur(e);

    if (!((_listboxRef$current = listboxRef.current) != null && _listboxRef$current.contains(e.relatedTarget))) {
      onClose == null ? void 0 : onClose();
    }
  };

  React__namespace.useEffect(() => {
    var _listboxRef$current2;

    // set focus to the highlighted item (but prevent stealing focus from other elements on the page)
    if ((_listboxRef$current2 = listboxRef.current) != null && _listboxRef$current2.contains(document.activeElement) && highlightedOption !== null) {
      var _menuItems$highlighte, _menuItems$highlighte2;

      menuItems == null ? void 0 : (_menuItems$highlighte = menuItems[highlightedOption]) == null ? void 0 : (_menuItems$highlighte2 = _menuItems$highlighte.ref.current) == null ? void 0 : _menuItems$highlighte2.focus();
    }
  }, [highlightedOption, menuItems]);

  const getListboxProps = otherHandlers => _extends({}, otherHandlers, getRootProps(_extends({}, otherHandlers, {
    onBlur: createHandleBlur(otherHandlers),
    onKeyDown: createHandleKeyDown(otherHandlers)
  })), {
    role: 'menu'
  });

  const getItemState = id => {
    const {
      disabled,
      highlighted
    } = getOptionState(id);
    return {
      disabled,
      highlighted
    };
  };

  React__namespace.useDebugValue({
    menuItems,
    highlightedOption
  });
  return {
    registerItem,
    unregisterItem,
    menuItems,
    getListboxProps,
    getItemState,
    getItemProps: getOptionProps,
    highlightedOption,
    highlightFirstItem,
    highlightLastItem
  };
}

var top$1 = 'top';
var bottom$1 = 'bottom';
var right$1 = 'right';
var left$1 = 'left';
var auto = 'auto';
var basePlacements = [top$1, bottom$1, right$1, left$1];
var start = 'start';
var end = 'end';
var clippingParents = 'clippingParents';
var viewport = 'viewport';
var popper = 'popper';
var reference = 'reference';
var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []); // modifiers that need to read the DOM

var beforeRead = 'beforeRead';
var read = 'read';
var afterRead = 'afterRead'; // pure-logic modifiers

var beforeMain = 'beforeMain';
var main = 'main';
var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

var beforeWrite = 'beforeWrite';
var write = 'write';
var afterWrite = 'afterWrite';
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

function getNodeName(element) {
  return element ? (element.nodeName || '').toLowerCase() : null;
}

function getWindow(node) {
  if (node == null) {
    return window;
  }

  if (node.toString() !== '[object Window]') {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }

  return node;
}

function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}

function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}

function isShadowRoot(node) {
  // IE 11 has no ShadowRoot
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }

  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// and applies them to the HTMLElements such as popper and arrow

function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function (name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name]; // arrow is optional + virtual elements

    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    } // Flow doesn't support to extend this property, but it's the most
    // effective way to apply styles to an HTMLElement
    // $FlowFixMe[cannot-write]


    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function (name) {
      var value = attributes[name];

      if (value === false) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value === true ? '' : value);
      }
    });
  });
}

function effect$2(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: '0',
      top: '0',
      margin: '0'
    },
    arrow: {
      position: 'absolute'
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;

  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }

  return function () {
    Object.keys(state.elements).forEach(function (name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

      var style = styleProperties.reduce(function (style, property) {
        style[property] = '';
        return style;
      }, {}); // arrow is optional + virtual elements

      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }

      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
} // eslint-disable-next-line import/no-unused-modules


var applyStyles$1 = {
  name: 'applyStyles',
  enabled: true,
  phase: 'write',
  fn: applyStyles,
  effect: effect$2,
  requires: ['computeStyles']
};

function getBasePlacement(placement) {
  return placement.split('-')[0];
}

var max = Math.max;
var min = Math.min;
var round$2 = Math.round;

function getBoundingClientRect(element, includeScale) {
  if (includeScale === void 0) {
    includeScale = false;
  }

  var rect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;

  if (isHTMLElement(element) && includeScale) {
    var offsetHeight = element.offsetHeight;
    var offsetWidth = element.offsetWidth; // Do not attempt to divide by 0, otherwise we get `Infinity` as scale
    // Fallback to 1 in case both values are `0`

    if (offsetWidth > 0) {
      scaleX = round$2(rect.width) / offsetWidth || 1;
    }

    if (offsetHeight > 0) {
      scaleY = round$2(rect.height) / offsetHeight || 1;
    }
  }

  return {
    width: rect.width / scaleX,
    height: rect.height / scaleY,
    top: rect.top / scaleY,
    right: rect.right / scaleX,
    bottom: rect.bottom / scaleY,
    left: rect.left / scaleX,
    x: rect.left / scaleX,
    y: rect.top / scaleY
  };
}

// means it doesn't take into account transforms.

function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
  // Fixes https://github.com/popperjs/popper-core/issues/1223

  var width = element.offsetWidth;
  var height = element.offsetHeight;

  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }

  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }

  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width,
    height: height
  };
}

function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

  if (parent.contains(child)) {
    return true;
  } // then fallback to custom implementation with Shadow DOM support
  else if (rootNode && isShadowRoot(rootNode)) {
      var next = child;

      do {
        if (next && parent.isSameNode(next)) {
          return true;
        } // $FlowFixMe[prop-missing]: need a better way to handle this...


        next = next.parentNode || next.host;
      } while (next);
    } // Give up, the result is false


  return false;
}

function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}

function isTableElement(element) {
  return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
}

function getDocumentElement(element) {
  // $FlowFixMe[incompatible-return]: assume body is always available
  return ((isElement(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
  element.document) || window.document).documentElement;
}

function getParentNode(element) {
  if (getNodeName(element) === 'html') {
    return element;
  }

  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || ( // DOM Element detected
    isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element) // fallback

  );
}

function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle(element).position === 'fixed') {
    return null;
  }

  return element.offsetParent;
} // `.offsetParent` reports `null` for fixed elements, while absolute elements
// return the containing block


function getContainingBlock(element) {
  var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') !== -1;
  var isIE = navigator.userAgent.indexOf('Trident') !== -1;

  if (isIE && isHTMLElement(element)) {
    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
    var elementCss = getComputedStyle(element);

    if (elementCss.position === 'fixed') {
      return null;
    }
  }

  var currentNode = getParentNode(element);

  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }

  while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that
    // create a containing block.
    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }

  return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.


function getOffsetParent(element) {
  var window = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);

  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent);
  }

  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static')) {
    return window;
  }

  return offsetParent || getContainingBlock(element) || window;
}

function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
}

function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}
function withinMaxClamp(min, value, max) {
  var v = within(min, value, max);
  return v > max ? max : v;
}

function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

function expandToHashMap(value, keys) {
  return keys.reduce(function (hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

var toPaddingObject = function toPaddingObject(padding, state) {
  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
};

function arrow(_ref) {
  var _state$modifiersData$;

  var state = _ref.state,
      name = _ref.name,
      options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left$1, right$1].indexOf(basePlacement) >= 0;
  var len = isVertical ? 'height' : 'width';

  if (!arrowElement || !popperOffsets) {
    return;
  }

  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === 'y' ? top$1 : left$1;
  var maxProp = axis === 'y' ? bottom$1 : right$1;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
  var startDiff = popperOffsets[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
  // outside of the popper bounds

  var min = paddingObject[minProp];
  var max = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset = within(min, center, max); // Prevents breaking syntax highlighting...

  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}

function effect$1(_ref2) {
  var state = _ref2.state,
      options = _ref2.options;
  var _options$element = options.element,
      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

  if (arrowElement == null) {
    return;
  } // CSS selector


  if (typeof arrowElement === 'string') {
    arrowElement = state.elements.popper.querySelector(arrowElement);

    if (!arrowElement) {
      return;
    }
  }

  if (process.env.NODE_ENV !== "production") {
    if (!isHTMLElement(arrowElement)) {
      console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', 'To use an SVG arrow, wrap it in an HTMLElement that will be used as', 'the arrow.'].join(' '));
    }
  }

  if (!contains(state.elements.popper, arrowElement)) {
    if (process.env.NODE_ENV !== "production") {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', 'element.'].join(' '));
    }

    return;
  }

  state.elements.arrow = arrowElement;
} // eslint-disable-next-line import/no-unused-modules


var arrow$1 = {
  name: 'arrow',
  enabled: true,
  phase: 'main',
  fn: arrow,
  effect: effect$1,
  requires: ['popperOffsets'],
  requiresIfExists: ['preventOverflow']
};

function getVariation(placement) {
  return placement.split('-')[1];
}

var unsetSides = {
  top: 'auto',
  right: 'auto',
  bottom: 'auto',
  left: 'auto'
}; // Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.

function roundOffsetsByDPR(_ref) {
  var x = _ref.x,
      y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round$2(x * dpr) / dpr || 0,
    y: round$2(y * dpr) / dpr || 0
  };
}

function mapToStyles(_ref2) {
  var _Object$assign2;

  var popper = _ref2.popper,
      popperRect = _ref2.popperRect,
      placement = _ref2.placement,
      variation = _ref2.variation,
      offsets = _ref2.offsets,
      position = _ref2.position,
      gpuAcceleration = _ref2.gpuAcceleration,
      adaptive = _ref2.adaptive,
      roundOffsets = _ref2.roundOffsets,
      isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x,
      x = _offsets$x === void 0 ? 0 : _offsets$x,
      _offsets$y = offsets.y,
      y = _offsets$y === void 0 ? 0 : _offsets$y;

  var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
    x: x,
    y: y
  }) : {
    x: x,
    y: y
  };

  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty('x');
  var hasY = offsets.hasOwnProperty('y');
  var sideX = left$1;
  var sideY = top$1;
  var win = window;

  if (adaptive) {
    var offsetParent = getOffsetParent(popper);
    var heightProp = 'clientHeight';
    var widthProp = 'clientWidth';

    if (offsetParent === getWindow(popper)) {
      offsetParent = getDocumentElement(popper);

      if (getComputedStyle(offsetParent).position !== 'static' && position === 'absolute') {
        heightProp = 'scrollHeight';
        widthProp = 'scrollWidth';
      }
    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


    offsetParent = offsetParent;

    if (placement === top$1 || (placement === left$1 || placement === right$1) && variation === end) {
      sideY = bottom$1;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]
      offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }

    if (placement === left$1 || (placement === top$1 || placement === bottom$1) && variation === end) {
      sideX = right$1;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]
      offsetParent[widthProp];
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }

  var commonStyles = Object.assign({
    position: position
  }, adaptive && unsetSides);

  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x,
    y: y
  }) : {
    x: x,
    y: y
  };

  x = _ref4.x;
  y = _ref4.y;

  if (gpuAcceleration) {
    var _Object$assign;

    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }

  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
}

function computeStyles(_ref5) {
  var state = _ref5.state,
      options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration,
      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
      _options$adaptive = options.adaptive,
      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
      _options$roundOffsets = options.roundOffsets,
      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;

  if (process.env.NODE_ENV !== "production") {
    var transitionProperty = getComputedStyle(state.elements.popper).transitionProperty || '';

    if (adaptive && ['transform', 'top', 'right', 'bottom', 'left'].some(function (property) {
      return transitionProperty.indexOf(property) >= 0;
    })) {
      console.warn(['Popper: Detected CSS transitions on at least one of the following', 'CSS properties: "transform", "top", "right", "bottom", "left".', '\n\n', 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', 'for smooth transitions, or remove these properties from the CSS', 'transition declaration on the popper element if only transitioning', 'opacity or background-color for example.', '\n\n', 'We recommend using the popper element as a wrapper around an inner', 'element that can have any CSS property transitioned for animations.'].join(' '));
    }
  }

  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration: gpuAcceleration,
    isFixed: state.options.strategy === 'fixed'
  };

  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive: adaptive,
      roundOffsets: roundOffsets
    })));
  }

  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: 'absolute',
      adaptive: false,
      roundOffsets: roundOffsets
    })));
  }

  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-placement': state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


var computeStyles$1 = {
  name: 'computeStyles',
  enabled: true,
  phase: 'beforeWrite',
  fn: computeStyles,
  data: {}
};

var passive = {
  passive: true
};

function effect(_ref) {
  var state = _ref.state,
      instance = _ref.instance,
      options = _ref.options;
  var _options$scroll = options.scroll,
      scroll = _options$scroll === void 0 ? true : _options$scroll,
      _options$resize = options.resize,
      resize = _options$resize === void 0 ? true : _options$resize;
  var window = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

  if (scroll) {
    scrollParents.forEach(function (scrollParent) {
      scrollParent.addEventListener('scroll', instance.update, passive);
    });
  }

  if (resize) {
    window.addEventListener('resize', instance.update, passive);
  }

  return function () {
    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.removeEventListener('scroll', instance.update, passive);
      });
    }

    if (resize) {
      window.removeEventListener('resize', instance.update, passive);
    }
  };
} // eslint-disable-next-line import/no-unused-modules


var eventListeners = {
  name: 'eventListeners',
  enabled: true,
  phase: 'write',
  fn: function fn() {},
  effect: effect,
  data: {}
};

var hash$2 = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash$2[matched];
  });
}

var hash$1 = {
  start: 'end',
  end: 'start'
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function (matched) {
    return hash$1[matched];
  });
}

function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft: scrollLeft,
    scrollTop: scrollTop
  };
}

function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  // Popper 1 is broken in this case and never had a bug report so let's assume
  // it's not an issue. I don't think anyone ever specifies width on <html>
  // anyway.
  // Browsers where the left scrollbar doesn't cause an issue report `0` for
  // this (e.g. Edge 2019, IE11, Safari)
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

function getViewportRect(element) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper
  // can be obscured underneath it.
  // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even
  // if it isn't open, so if this isn't available, the popper will be detected
  // to overflow the bottom of the screen too early.

  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)
    // In Chrome, it returns a value very close to 0 (+/-) but contains rounding
    // errors due to floating point numbers, so we need to check precision.
    // Safari returns a number <= 0, usually < -1 when pinch-zoomed
    // Feature detection fails in mobile emulation mode in Chrome.
    // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <
    // 0.001
    // Fallback here: "Not Safari" userAgent

    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }

  return {
    width: width,
    height: height,
    x: x + getWindowScrollBarX(element),
    y: y
  };
}

// of the `<html>` and `<body>` rect bounds if horizontally scrollable

function getDocumentRect(element) {
  var _element$ownerDocumen;

  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;

  if (getComputedStyle(body || html).direction === 'rtl') {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }

  return {
    width: width,
    height: height,
    x: x,
    y: y
  };
}

function isScrollParent(element) {
  // Firefox wants us to check `-x` and `-y` variations as well
  var _getComputedStyle = getComputedStyle(element),
      overflow = _getComputedStyle.overflow,
      overflowX = _getComputedStyle.overflowX,
      overflowY = _getComputedStyle.overflowY;

  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

function getScrollParent(node) {
  if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return node.ownerDocument.body;
  }

  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }

  return getScrollParent(getParentNode(node));
}

/*
given a DOM element, return the list of all scroll parents, up the list of ancesors
until we get to the top window object. This list is what we attach scroll listeners
to, because if any of these parent elements scroll, we'll need to re-calculate the
reference element's position.
*/

function listScrollParents(element, list) {
  var _element$ownerDocumen;

  if (list === void 0) {
    list = [];
  }

  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
  updatedList.concat(listScrollParents(getParentNode(target)));
}

function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

function getInnerBoundingClientRect(element) {
  var rect = getBoundingClientRect(element);
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}

function getClientRectFromMixedType(element, clippingParent) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
} // A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`


function getClippingParents(element) {
  var clippingParents = listScrollParents(getParentNode(element));
  var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;

  if (!isElement(clipperElement)) {
    return [];
  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


  return clippingParents.filter(function (clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
  });
} // Gets the maximum area that the element is visible in due to any number of
// clipping parents


function getClippingRect(element, boundary, rootBoundary) {
  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents[0];
  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

function computeOffsets(_ref) {
  var reference = _ref.reference,
      element = _ref.element,
      placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference.x + reference.width / 2 - element.width / 2;
  var commonY = reference.y + reference.height / 2 - element.height / 2;
  var offsets;

  switch (basePlacement) {
    case top$1:
      offsets = {
        x: commonX,
        y: reference.y - element.height
      };
      break;

    case bottom$1:
      offsets = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;

    case right$1:
      offsets = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;

    case left$1:
      offsets = {
        x: reference.x - element.width,
        y: commonY
      };
      break;

    default:
      offsets = {
        x: reference.x,
        y: reference.y
      };
  }

  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;

  if (mainAxis != null) {
    var len = mainAxis === 'y' ? 'height' : 'width';

    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
        break;

      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
        break;
    }
  }

  return offsets;
}

function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$placement = _options.placement,
      placement = _options$placement === void 0 ? state.placement : _options$placement,
      _options$boundary = _options.boundary,
      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
      _options$rootBoundary = _options.rootBoundary,
      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
      _options$elementConte = _options.elementContext,
      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
      _options$altBoundary = _options.altBoundary,
      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
      _options$padding = _options.padding,
      padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: 'absolute',
    placement: placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
  // 0 or negative = within the clipping rect

  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

  if (elementContext === popper && offsetData) {
    var offset = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function (key) {
      var multiply = [right$1, bottom$1].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top$1, bottom$1].indexOf(key) >= 0 ? 'y' : 'x';
      overflowOffsets[key] += offset[axis] * multiply;
    });
  }

  return overflowOffsets;
}

function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      placement = _options.placement,
      boundary = _options.boundary,
      rootBoundary = _options.rootBoundary,
      padding = _options.padding,
      flipVariations = _options.flipVariations,
      _options$allowedAutoP = _options.allowedAutoPlacements,
      allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
    return getVariation(placement) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function (placement) {
    return allowedAutoPlacements.indexOf(placement) >= 0;
  });

  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;

    if (process.env.NODE_ENV !== "production") {
      console.error(['Popper: The `allowedAutoPlacements` option did not allow any', 'placements. Ensure the `placement` option matches the variation', 'of the allowed placements.', 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(' '));
    }
  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


  var overflows = allowedPlacements.reduce(function (acc, placement) {
    acc[placement] = detectOverflow(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding
    })[getBasePlacement(placement)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function (a, b) {
    return overflows[a] - overflows[b];
  });
}

function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }

  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}

function flip(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;

  if (state.modifiersData[name]._skip) {
    return;
  }

  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
      specifiedFallbackPlacements = options.fallbackPlacements,
      padding = options.padding,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      _options$flipVariatio = options.flipVariations,
      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
      allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
    return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      flipVariations: flipVariations,
      allowedAutoPlacements: allowedAutoPlacements
    }) : placement);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements[0];

  for (var i = 0; i < placements.length; i++) {
    var placement = placements[i];

    var _basePlacement = getBasePlacement(placement);

    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top$1, bottom$1].indexOf(_basePlacement) >= 0;
    var len = isVertical ? 'width' : 'height';
    var overflow = detectOverflow(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      altBoundary: altBoundary,
      padding: padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right$1 : left$1 : isStartVariation ? bottom$1 : top$1;

    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }

    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];

    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }

    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }

    if (checks.every(function (check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }

    checksMap.set(placement, checks);
  }

  if (makeFallbackChecks) {
    // `2` may be desired in some cases – research later
    var numberOfChecks = flipVariations ? 3 : 1;

    var _loop = function _loop(_i) {
      var fittingPlacement = placements.find(function (placement) {
        var checks = checksMap.get(placement);

        if (checks) {
          return checks.slice(0, _i).every(function (check) {
            return check;
          });
        }
      });

      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };

    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);

      if (_ret === "break") break;
    }
  }

  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
} // eslint-disable-next-line import/no-unused-modules


var flip$1 = {
  name: 'flip',
  enabled: true,
  phase: 'main',
  fn: flip,
  requiresIfExists: ['offset'],
  data: {
    _skip: false
  }
};

function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }

  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}

function isAnySideFullyClipped(overflow) {
  return [top$1, right$1, bottom$1, left$1].some(function (side) {
    return overflow[side] >= 0;
  });
}

function hide(_ref) {
  var state = _ref.state,
      name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: 'reference'
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets: referenceClippingOffsets,
    popperEscapeOffsets: popperEscapeOffsets,
    isReferenceHidden: isReferenceHidden,
    hasPopperEscaped: hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-reference-hidden': isReferenceHidden,
    'data-popper-escaped': hasPopperEscaped
  });
} // eslint-disable-next-line import/no-unused-modules


var hide$1 = {
  name: 'hide',
  enabled: true,
  phase: 'main',
  requiresIfExists: ['preventOverflow'],
  fn: hide
};

function distanceAndSkiddingToXY(placement, rects, offset) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left$1, top$1].indexOf(basePlacement) >= 0 ? -1 : 1;

  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
    placement: placement
  })) : offset,
      skidding = _ref[0],
      distance = _ref[1];

  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left$1, right$1].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}

function offset(_ref2) {
  var state = _ref2.state,
      options = _ref2.options,
      name = _ref2.name;
  var _options$offset = options.offset,
      offset = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function (acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement],
      x = _data$state$placement.x,
      y = _data$state$placement.y;

  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


var offset$1 = {
  name: 'offset',
  enabled: true,
  phase: 'main',
  requires: ['popperOffsets'],
  fn: offset
};

function popperOffsets(_ref) {
  var state = _ref.state,
      name = _ref.name;
  // Offsets are the actual position the popper needs to have to be
  // properly positioned near its reference element
  // This is the most basic placement, and will be adjusted by
  // the modifiers in the next step
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: 'absolute',
    placement: state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


var popperOffsets$1 = {
  name: 'popperOffsets',
  enabled: true,
  phase: 'read',
  fn: popperOffsets,
  data: {}
};

function getAltAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}

function preventOverflow(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;
  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      padding = options.padding,
      _options$tether = options.tether,
      tether = _options$tether === void 0 ? true : _options$tether,
      _options$tetherOffset = options.tetherOffset,
      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary: boundary,
    rootBoundary: rootBoundary,
    padding: padding,
    altBoundary: altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };

  if (!popperOffsets) {
    return;
  }

  if (checkMainAxis) {
    var _offsetModifierState$;

    var mainSide = mainAxis === 'y' ? top$1 : left$1;
    var altSide = mainAxis === 'y' ? bottom$1 : right$1;
    var len = mainAxis === 'y' ? 'height' : 'width';
    var offset = popperOffsets[mainAxis];
    var min$1 = offset + overflow[mainSide];
    var max$1 = offset - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
    // outside the reference bounds

    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
    // to include its full size in the calculation. If the reference is small
    // and near the edge of a boundary, the popper can overflow even if the
    // reference is not overflowing as well (e.g. virtual elements with no
    // width or height)

    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);
    popperOffsets[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset;
  }

  if (checkAltAxis) {
    var _offsetModifierState$2;

    var _mainSide = mainAxis === 'x' ? top$1 : left$1;

    var _altSide = mainAxis === 'x' ? bottom$1 : right$1;

    var _offset = popperOffsets[altAxis];

    var _len = altAxis === 'y' ? 'height' : 'width';

    var _min = _offset + overflow[_mainSide];

    var _max = _offset - overflow[_altSide];

    var isOriginSide = [top$1, left$1].indexOf(basePlacement) !== -1;

    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;

    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;

    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;

    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);

    popperOffsets[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


var preventOverflow$1 = {
  name: 'preventOverflow',
  enabled: true,
  phase: 'main',
  fn: preventOverflow,
  requiresIfExists: ['offset']
};

function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round$2(rect.width) / element.offsetWidth || 1;
  var scaleY = round$2(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
} // Returns the composite rect of an element relative to its offsetParent.
// Composite means it takes into account transforms as well as layout.


function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }

  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };

  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }

    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }

  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

function order$1(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function (modifier) {
    map.set(modifier.name, modifier);
  }); // On visiting object, check for its dependencies and visit them recursively

  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function (dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);

        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }

  modifiers.forEach(function (modifier) {
    if (!visited.has(modifier.name)) {
      // check for visited object
      sort(modifier);
    }
  });
  return result;
}

function orderModifiers(modifiers) {
  // order based on dependencies
  var orderedModifiers = order$1(modifiers); // order based on phase

  return modifierPhases.reduce(function (acc, phase) {
    return acc.concat(orderedModifiers.filter(function (modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

function debounce(fn) {
  var pending;
  return function () {
    if (!pending) {
      pending = new Promise(function (resolve) {
        Promise.resolve().then(function () {
          pending = undefined;
          resolve(fn());
        });
      });
    }

    return pending;
  };
}

function format(str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return [].concat(args).reduce(function (p, c) {
    return p.replace(/%s/, c);
  }, str);
}

var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ['name', 'enabled', 'phase', 'fn', 'effect', 'requires', 'options'];
function validateModifiers(modifiers) {
  modifiers.forEach(function (modifier) {
    [].concat(Object.keys(modifier), VALID_PROPERTIES) // IE11-compatible replacement for `new Set(iterable)`
    .filter(function (value, index, self) {
      return self.indexOf(value) === index;
    }).forEach(function (key) {
      switch (key) {
        case 'name':
          if (typeof modifier.name !== 'string') {
            console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', "\"" + String(modifier.name) + "\""));
          }

          break;

        case 'enabled':
          if (typeof modifier.enabled !== 'boolean') {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', "\"" + String(modifier.enabled) + "\""));
          }

          break;

        case 'phase':
          if (modifierPhases.indexOf(modifier.phase) < 0) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(', '), "\"" + String(modifier.phase) + "\""));
          }

          break;

        case 'fn':
          if (typeof modifier.fn !== 'function') {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', "\"" + String(modifier.fn) + "\""));
          }

          break;

        case 'effect':
          if (modifier.effect != null && typeof modifier.effect !== 'function') {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', "\"" + String(modifier.fn) + "\""));
          }

          break;

        case 'requires':
          if (modifier.requires != null && !Array.isArray(modifier.requires)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', "\"" + String(modifier.requires) + "\""));
          }

          break;

        case 'requiresIfExists':
          if (!Array.isArray(modifier.requiresIfExists)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', "\"" + String(modifier.requiresIfExists) + "\""));
          }

          break;

        case 'options':
        case 'data':
          break;

        default:
          console.error("PopperJS: an invalid property has been provided to the \"" + modifier.name + "\" modifier, valid properties are " + VALID_PROPERTIES.map(function (s) {
            return "\"" + s + "\"";
          }).join(', ') + "; but \"" + key + "\" was provided.");
      }

      modifier.requires && modifier.requires.forEach(function (requirement) {
        if (modifiers.find(function (mod) {
          return mod.name === requirement;
        }) == null) {
          console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
}

function uniqueBy(arr, fn) {
  var identifiers = new Set();
  return arr.filter(function (item) {
    var identifier = fn(item);

    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}

function mergeByName(modifiers) {
  var merged = modifiers.reduce(function (merged, current) {
    var existing = merged[current.name];
    merged[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged;
  }, {}); // IE11 does not support Object.values

  return Object.keys(merged).map(function (key) {
    return merged[key];
  });
}

var INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';
var INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';
var DEFAULT_OPTIONS = {
  placement: 'bottom',
  modifiers: [],
  strategy: 'absolute'
};

function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return !args.some(function (element) {
    return !(element && typeof element.getBoundingClientRect === 'function');
  });
}

function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }

  var _generatorOptions = generatorOptions,
      _generatorOptions$def = _generatorOptions.defaultModifiers,
      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
      _generatorOptions$def2 = _generatorOptions.defaultOptions,
      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper(reference, popper, options) {
    if (options === void 0) {
      options = defaultOptions;
    }

    var state = {
      placement: 'bottom',
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference,
        popper: popper
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state,
      setOptions: function setOptions(setOptionsAction) {
        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options);
        state.scrollParents = {
          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
          popper: listScrollParents(popper)
        }; // Orders the modifiers based on their dependencies and `phase`
        // properties

        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

        state.orderedModifiers = orderedModifiers.filter(function (m) {
          return m.enabled;
        }); // Validate the provided modifiers so that the consumer will get warned
        // if one of the modifiers is invalid for any reason

        if (process.env.NODE_ENV !== "production") {
          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function (_ref) {
            var name = _ref.name;
            return name;
          });
          validateModifiers(modifiers);

          if (getBasePlacement(state.options.placement) === auto) {
            var flipModifier = state.orderedModifiers.find(function (_ref2) {
              var name = _ref2.name;
              return name === 'flip';
            });

            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', 'present and enabled to work.'].join(' '));
            }
          }

          var _getComputedStyle = getComputedStyle(popper),
              marginTop = _getComputedStyle.marginTop,
              marginRight = _getComputedStyle.marginRight,
              marginBottom = _getComputedStyle.marginBottom,
              marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can
          // cause bugs with positioning, so we'll warn the consumer


          if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {
            return parseFloat(margin);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));
          }
        }

        runModifierEffects();
        return instance.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }

        var _state$elements = state.elements,
            reference = _state$elements.reference,
            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
        // anymore

        if (!areValidElements(reference, popper)) {
          if (process.env.NODE_ENV !== "production") {
            console.error(INVALID_ELEMENT_ERROR);
          }

          return;
        } // Store the reference and popper rects to be read by modifiers


        state.rects = {
          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
          popper: getLayoutRect(popper)
        }; // Modifiers have the ability to reset the current update cycle. The
        // most common use case for this is the `flip` modifier changing the
        // placement, which then needs to re-run all the modifiers, because the
        // logic was previously ran for the previous placement and is therefore
        // stale/incorrect

        state.reset = false;
        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
        // is filled with the initial data specified by the modifier. This means
        // it doesn't persist and is fresh on each update.
        // To ensure persistent data, use `${name}#persistent`

        state.orderedModifiers.forEach(function (modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;

        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (process.env.NODE_ENV !== "production") {
            __debug_loops__ += 1;

            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }

          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }

          var _state$orderedModifie = state.orderedModifiers[index],
              fn = _state$orderedModifie.fn,
              _state$orderedModifie2 = _state$orderedModifie.options,
              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
              name = _state$orderedModifie.name;

          if (typeof fn === 'function') {
            state = fn({
              state: state,
              options: _options,
              name: name,
              instance: instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function () {
        return new Promise(function (resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };

    if (!areValidElements(reference, popper)) {
      if (process.env.NODE_ENV !== "production") {
        console.error(INVALID_ELEMENT_ERROR);
      }

      return instance;
    }

    instance.setOptions(options).then(function (state) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state);
      }
    }); // Modifiers have the ability to execute arbitrary code before the first
    // update cycle runs. They will be executed in the same order as the update
    // cycle. This is useful when a modifier adds some persistent data that
    // other modifiers need to use, but the modifier is run after the dependent
    // one.

    function runModifierEffects() {
      state.orderedModifiers.forEach(function (_ref3) {
        var name = _ref3.name,
            _ref3$options = _ref3.options,
            options = _ref3$options === void 0 ? {} : _ref3$options,
            effect = _ref3.effect;

        if (typeof effect === 'function') {
          var cleanupFn = effect({
            state: state,
            name: name,
            instance: instance,
            options: options
          });

          var noopFn = function noopFn() {};

          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }

    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function (fn) {
        return fn();
      });
      effectCleanupFns = [];
    }

    return instance;
  };
}

var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper = /*#__PURE__*/popperGenerator({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules

function getContainer$1(container) {
  return typeof container === 'function' ? container() : container;
}
/**
 * Portals provide a first-class way to render children into a DOM node
 * that exists outside the DOM hierarchy of the parent component.
 */


const Portal = /*#__PURE__*/React__namespace.forwardRef(function Portal(props, ref) {
  const {
    children,
    container,
    disablePortal = false
  } = props;
  const [mountNode, setMountNode] = React__namespace.useState(null);
  const handleRef = useForkRef( /*#__PURE__*/React__namespace.isValidElement(children) ? children.ref : null, ref);
  useEnhancedEffect(() => {
    if (!disablePortal) {
      setMountNode(getContainer$1(container) || document.body);
    }
  }, [container, disablePortal]);
  useEnhancedEffect(() => {
    if (mountNode && !disablePortal) {
      setRef(ref, mountNode);
      return () => {
        setRef(ref, null);
      };
    }

    return undefined;
  }, [ref, mountNode, disablePortal]);

  if (disablePortal) {
    if ( /*#__PURE__*/React__namespace.isValidElement(children)) {
      return /*#__PURE__*/React__namespace.cloneElement(children, {
        ref: handleRef
      });
    }

    return children;
  }

  return mountNode ? /*#__PURE__*/ReactDOM__namespace.createPortal(children, mountNode) : mountNode;
});
process.env.NODE_ENV !== "production" ? Portal.propTypes
/* remove-proptypes */
= {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------

  /**
   * The children to render into the `container`.
   */
  children: propTypes.exports.node,

  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: propTypes.exports
  /* @typescript-to-proptypes-ignore */
  .oneOfType([HTMLElementType, propTypes.exports.func]),

  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: propTypes.exports.bool
} : void 0;

if (process.env.NODE_ENV !== 'production') {
  // eslint-disable-next-line
  Portal['propTypes' + ''] = exactProp(Portal.propTypes);
}

const _excluded$v = ["anchorEl", "children", "direction", "disablePortal", "modifiers", "open", "ownerState", "placement", "popperOptions", "popperRef", "TransitionProps"],
      _excluded2$2 = ["anchorEl", "children", "container", "direction", "disablePortal", "keepMounted", "modifiers", "open", "placement", "popperOptions", "popperRef", "style", "transition"];

function flipPlacement(placement, direction) {
  if (direction === 'ltr') {
    return placement;
  }

  switch (placement) {
    case 'bottom-end':
      return 'bottom-start';

    case 'bottom-start':
      return 'bottom-end';

    case 'top-end':
      return 'top-start';

    case 'top-start':
      return 'top-end';

    default:
      return placement;
  }
}

function resolveAnchorEl(anchorEl) {
  return typeof anchorEl === 'function' ? anchorEl() : anchorEl;
}

const defaultPopperOptions = {};
/* eslint-disable react/prop-types */

const PopperTooltip = /*#__PURE__*/React__namespace.forwardRef(function PopperTooltip(props, ref) {
  const {
    anchorEl,
    children,
    direction,
    disablePortal,
    modifiers,
    open,
    placement: initialPlacement,
    popperOptions,
    popperRef: popperRefProp,
    TransitionProps
  } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$v);

  const tooltipRef = React__namespace.useRef(null);
  const ownRef = useForkRef(tooltipRef, ref);
  const popperRef = React__namespace.useRef(null);
  const handlePopperRef = useForkRef(popperRef, popperRefProp);
  const handlePopperRefRef = React__namespace.useRef(handlePopperRef);
  useEnhancedEffect(() => {
    handlePopperRefRef.current = handlePopperRef;
  }, [handlePopperRef]);
  React__namespace.useImperativeHandle(popperRefProp, () => popperRef.current, []);
  const rtlPlacement = flipPlacement(initialPlacement, direction);
  /**
   * placement initialized from prop but can change during lifetime if modifiers.flip.
   * modifiers.flip is essentially a flip for controlled/uncontrolled behavior
   */

  const [placement, setPlacement] = React__namespace.useState(rtlPlacement);
  React__namespace.useEffect(() => {
    if (popperRef.current) {
      popperRef.current.forceUpdate();
    }
  });
  useEnhancedEffect(() => {
    if (!anchorEl || !open) {
      return undefined;
    }

    const handlePopperUpdate = data => {
      setPlacement(data.placement);
    };

    const resolvedAnchorEl = resolveAnchorEl(anchorEl);

    if (process.env.NODE_ENV !== 'production') {
      if (resolvedAnchorEl && resolvedAnchorEl.nodeType === 1) {
        const box = resolvedAnchorEl.getBoundingClientRect();

        if (process.env.NODE_ENV !== 'test' && box.top === 0 && box.left === 0 && box.right === 0 && box.bottom === 0) {
          console.warn(['MUI: The `anchorEl` prop provided to the component is invalid.', 'The anchor element should be part of the document layout.', "Make sure the element is present in the document or that it's not display none."].join('\n'));
        }
      }
    }

    let popperModifiers = [{
      name: 'preventOverflow',
      options: {
        altBoundary: disablePortal
      }
    }, {
      name: 'flip',
      options: {
        altBoundary: disablePortal
      }
    }, {
      name: 'onUpdate',
      enabled: true,
      phase: 'afterWrite',
      fn: ({
        state
      }) => {
        handlePopperUpdate(state);
      }
    }];

    if (modifiers != null) {
      popperModifiers = popperModifiers.concat(modifiers);
    }

    if (popperOptions && popperOptions.modifiers != null) {
      popperModifiers = popperModifiers.concat(popperOptions.modifiers);
    }

    const popper = createPopper(resolveAnchorEl(anchorEl), tooltipRef.current, _extends({
      placement: rtlPlacement
    }, popperOptions, {
      modifiers: popperModifiers
    }));
    handlePopperRefRef.current(popper);
    return () => {
      popper.destroy();
      handlePopperRefRef.current(null);
    };
  }, [anchorEl, disablePortal, modifiers, open, popperOptions, rtlPlacement]);
  const childProps = {
    placement
  };

  if (TransitionProps !== null) {
    childProps.TransitionProps = TransitionProps;
  }

  return /*#__PURE__*/jsxRuntime.exports.jsx("div", _extends({
    ref: ownRef,
    role: "tooltip"
  }, other, {
    children: typeof children === 'function' ? children(childProps) : children
  }));
});
/* eslint-enable react/prop-types */

/**
 * Poppers rely on the 3rd party library [Popper.js](https://popper.js.org/docs/v2/) for positioning.
 */

const PopperUnstyled = /*#__PURE__*/React__namespace.forwardRef(function PopperUnstyled(props, ref) {
  const {
    anchorEl,
    children,
    container: containerProp,
    direction = 'ltr',
    disablePortal = false,
    keepMounted = false,
    modifiers,
    open,
    placement = 'bottom',
    popperOptions = defaultPopperOptions,
    popperRef,
    style,
    transition = false
  } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded2$2);

  const [exited, setExited] = React__namespace.useState(true);

  const handleEnter = () => {
    setExited(false);
  };

  const handleExited = () => {
    setExited(true);
  };

  if (!keepMounted && !open && (!transition || exited)) {
    return null;
  } // If the container prop is provided, use that
  // If the anchorEl prop is provided, use its parent body element as the container
  // If neither are provided let the Modal take care of choosing the container


  const container = containerProp || (anchorEl ? ownerDocument(resolveAnchorEl(anchorEl)).body : undefined);
  return /*#__PURE__*/jsxRuntime.exports.jsx(Portal, {
    disablePortal: disablePortal,
    container: container,
    children: /*#__PURE__*/jsxRuntime.exports.jsx(PopperTooltip, _extends({
      anchorEl: anchorEl,
      direction: direction,
      disablePortal: disablePortal,
      modifiers: modifiers,
      ref: ref,
      open: transition ? !exited : open,
      placement: placement,
      popperOptions: popperOptions,
      popperRef: popperRef
    }, other, {
      style: _extends({
        // Prevents scroll issue, waiting for Popper.js to add this style once initiated.
        position: 'fixed',
        // Fix Popper.js display issue
        top: 0,
        left: 0,
        display: !open && keepMounted && (!transition || exited) ? 'none' : null
      }, style),
      TransitionProps: transition ? {
        in: open,
        onEnter: handleEnter,
        onExited: handleExited
      } : null,
      children: children
    }))
  });
});
process.env.NODE_ENV !== "production" ? PopperUnstyled.propTypes
/* remove-proptypes */
= {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------

  /**
   * An HTML element, [virtualElement](https://popper.js.org/docs/v2/virtual-elements/),
   * or a function that returns either.
   * It's used to set the position of the popper.
   * The return value will passed as the reference object of the Popper instance.
   */
  anchorEl: chainPropTypes(propTypes.exports.oneOfType([HTMLElementType, propTypes.exports.object, propTypes.exports.func]), props => {
    if (props.open) {
      const resolvedAnchorEl = resolveAnchorEl(props.anchorEl);

      if (resolvedAnchorEl && resolvedAnchorEl.nodeType === 1) {
        const box = resolvedAnchorEl.getBoundingClientRect();

        if (process.env.NODE_ENV !== 'test' && box.top === 0 && box.left === 0 && box.right === 0 && box.bottom === 0) {
          return new Error(['MUI: The `anchorEl` prop provided to the component is invalid.', 'The anchor element should be part of the document layout.', "Make sure the element is present in the document or that it's not display none."].join('\n'));
        }
      } else if (!resolvedAnchorEl || typeof resolvedAnchorEl.getBoundingClientRect !== 'function' || resolvedAnchorEl.contextElement != null && resolvedAnchorEl.contextElement.nodeType !== 1) {
        return new Error(['MUI: The `anchorEl` prop provided to the component is invalid.', 'It should be an HTML element instance or a virtualElement ', '(https://popper.js.org/docs/v2/virtual-elements/).'].join('\n'));
      }
    }

    return null;
  }),

  /**
   * Popper render function or node.
   */
  children: propTypes.exports
  /* @typescript-to-proptypes-ignore */
  .oneOfType([propTypes.exports.node, propTypes.exports.func]),

  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: propTypes.exports
  /* @typescript-to-proptypes-ignore */
  .oneOfType([HTMLElementType, propTypes.exports.func]),

  /**
   * Direction of the text.
   * @default 'ltr'
   */
  direction: propTypes.exports.oneOf(['ltr', 'rtl']),

  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: propTypes.exports.bool,

  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Popper.
   * @default false
   */
  keepMounted: propTypes.exports.bool,

  /**
   * Popper.js is based on a "plugin-like" architecture,
   * most of its features are fully encapsulated "modifiers".
   *
   * A modifier is a function that is called each time Popper.js needs to
   * compute the position of the popper.
   * For this reason, modifiers should be very performant to avoid bottlenecks.
   * To learn how to create a modifier, [read the modifiers documentation](https://popper.js.org/docs/v2/modifiers/).
   */
  modifiers: propTypes.exports.arrayOf(propTypes.exports.shape({
    data: propTypes.exports.object,
    effect: propTypes.exports.func,
    enabled: propTypes.exports.bool,
    fn: propTypes.exports.func,
    name: propTypes.exports.any,
    options: propTypes.exports.object,
    phase: propTypes.exports.oneOf(['afterMain', 'afterRead', 'afterWrite', 'beforeMain', 'beforeRead', 'beforeWrite', 'main', 'read', 'write']),
    requires: propTypes.exports.arrayOf(propTypes.exports.string),
    requiresIfExists: propTypes.exports.arrayOf(propTypes.exports.string)
  })),

  /**
   * If `true`, the component is shown.
   */
  open: propTypes.exports.bool.isRequired,

  /**
   * Popper placement.
   * @default 'bottom'
   */
  placement: propTypes.exports.oneOf(['auto-end', 'auto-start', 'auto', 'bottom-end', 'bottom-start', 'bottom', 'left-end', 'left-start', 'left', 'right-end', 'right-start', 'right', 'top-end', 'top-start', 'top']),

  /**
   * Options provided to the [`Popper.js`](https://popper.js.org/docs/v2/constructors/#options) instance.
   * @default {}
   */
  popperOptions: propTypes.exports.shape({
    modifiers: propTypes.exports.array,
    onFirstUpdate: propTypes.exports.func,
    placement: propTypes.exports.oneOf(['auto-end', 'auto-start', 'auto', 'bottom-end', 'bottom-start', 'bottom', 'left-end', 'left-start', 'left', 'right-end', 'right-start', 'right', 'top-end', 'top-start', 'top']),
    strategy: propTypes.exports.oneOf(['absolute', 'fixed'])
  }),

  /**
   * A ref that points to the used popper instance.
   */
  popperRef: refType,

  /**
   * @ignore
   */
  style: propTypes.exports.object,

  /**
   * Help supporting a react-transition-group/Transition component.
   * @default false
   */
  transition: propTypes.exports.bool
} : void 0;

const _excluded$u = ["actions", "anchorEl", "children", "className", "component", "components", "componentsProps", "keepMounted", "onClose", "open"];

function getUtilityClasses$1(ownerState) {
  const {
    open
  } = ownerState;
  const slots = {
    root: ['root', open && 'expanded'],
    listbox: ['listbox', open && 'expanded']
  };
  return composeClasses(slots, getMenuUnstyledUtilityClass, {});
}
/**
 *
 * Demos:
 *
 * - [Menu](https://mui.com/base/react-menu/)
 *
 * API:
 *
 * - [MenuUnstyled API](https://mui.com/base/api/menu-unstyled/)
 */


const MenuUnstyled = /*#__PURE__*/React__namespace.forwardRef(function MenuUnstyled(props, forwardedRef) {
  var _componentsProps$list, _componentsProps$list2, _ref, _componentsProps$root, _components$Listbox, _componentsProps$list3;

  const {
    actions,
    anchorEl,
    children,
    className,
    component,
    components = {},
    componentsProps = {},
    keepMounted = false,
    onClose,
    open = false
  } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$u);

  const {
    registerItem,
    unregisterItem,
    getListboxProps,
    getItemProps,
    getItemState,
    highlightFirstItem,
    highlightLastItem
  } = useMenu({
    open,
    onClose,
    listboxRef: (_componentsProps$list = componentsProps.listbox) == null ? void 0 : _componentsProps$list.ref,
    listboxId: (_componentsProps$list2 = componentsProps.listbox) == null ? void 0 : _componentsProps$list2.id
  });
  React__namespace.useImperativeHandle(actions, () => ({
    highlightFirstItem,
    highlightLastItem
  }), [highlightFirstItem, highlightLastItem]);

  const ownerState = _extends({}, props, {
    open
  });

  const classes = getUtilityClasses$1(ownerState);
  const Popper = (_ref = component != null ? component : components.Root) != null ? _ref : PopperUnstyled;
  const popperProps = appendOwnerState(Popper, _extends({}, other, {
    anchorEl,
    open,
    keepMounted,
    role: undefined
  }, componentsProps.root, {
    className: clsx(classes.root, className, (_componentsProps$root = componentsProps.root) == null ? void 0 : _componentsProps$root.className)
  }), ownerState);
  const Listbox = (_components$Listbox = components.Listbox) != null ? _components$Listbox : 'ul';
  const listboxProps = appendOwnerState(Listbox, _extends({}, componentsProps.listbox, getListboxProps(), {
    className: clsx(classes.listbox, (_componentsProps$list3 = componentsProps.listbox) == null ? void 0 : _componentsProps$list3.className)
  }), ownerState);
  const contextValue = {
    registerItem,
    unregisterItem,
    getItemState,
    getItemProps,
    open
  };
  return /*#__PURE__*/jsxRuntime.exports.jsx(Popper, _extends({}, popperProps, {
    ref: forwardedRef,
    children: /*#__PURE__*/jsxRuntime.exports.jsx(Listbox, _extends({}, listboxProps, {
      children: /*#__PURE__*/jsxRuntime.exports.jsx(MenuUnstyledContext.Provider, {
        value: contextValue,
        children: children
      })
    }))
  }));
});
process.env.NODE_ENV !== "production" ? MenuUnstyled.propTypes
/* remove-proptypes */
= {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------

  /**
   * A ref with imperative actions.
   * It allows to select the first or last menu item.
   */
  actions: refType,

  /**
   * An HTML element, [virtualElement](https://popper.js.org/docs/v2/virtual-elements/),
   * or a function that returns either.
   * It's used to set the position of the popper.
   */
  anchorEl: propTypes.exports
  /* @typescript-to-proptypes-ignore */
  .oneOfType([HTMLElementType, propTypes.exports.object, propTypes.exports.func]),

  /**
   * @ignore
   */
  children: propTypes.exports.node,

  /**
   * @ignore
   */
  className: propTypes.exports.string,

  /**
   * @ignore
   */
  component: propTypes.exports.elementType,

  /**
   * @ignore
   */
  components: propTypes.exports.shape({
    Listbox: propTypes.exports.elementType,
    Root: propTypes.exports.elementType
  }),

  /**
   * @ignore
   */
  componentsProps: propTypes.exports.shape({
    listbox: propTypes.exports.object,
    root: propTypes.exports.object
  }),

  /**
   * Always keep the menu in the DOM.
   * This prop can be useful in SEO situation or when you want to maximize the responsiveness of the Menu.
   *
   * @default false
   */
  keepMounted: propTypes.exports.bool,

  /**
   * Triggered when focus leaves the menu and the menu should close.
   */
  onClose: propTypes.exports.func,

  /**
   * Controls whether the menu is displayed.
   * @default false
   */
  open: propTypes.exports.bool
} : void 0;

function getMenuItemUnstyledUtilityClass(slot) {
  return generateUtilityClass('MuiMenuItemUnstyled', slot);
}
generateUtilityClasses('MuiMenuItemUnstyled', ['root', 'disabled', 'focusVisible']);

function useMenuItem(props) {
  var _itemState$disabled;

  const {
    disabled = false,
    ref,
    label
  } = props;
  const id = useId();
  const menuContext = React__namespace.useContext(MenuUnstyledContext);
  const itemRef = React__namespace.useRef(null);
  const handleRef = useForkRef(itemRef, ref);

  if (menuContext === null) {
    throw new Error('MenuItemUnstyled must be used within a MenuUnstyled');
  }

  const {
    registerItem,
    unregisterItem,
    open
  } = menuContext;
  React__namespace.useEffect(() => {
    if (id === undefined) {
      return undefined;
    }

    registerItem(id, {
      disabled,
      id,
      ref: itemRef,
      label
    });
    return () => unregisterItem(id);
  }, [id, registerItem, unregisterItem, disabled, ref, label]);
  const {
    getRootProps: getButtonProps,
    focusVisible
  } = useButton({
    disabled,
    focusableWhenDisabled: true,
    ref: handleRef
  }); // Ensure the menu item is focused when highlighted

  const [focusRequested, requestFocus] = React__namespace.useState(false);
  const focusIfRequested = React__namespace.useCallback(() => {
    if (focusRequested && itemRef.current != null) {
      itemRef.current.focus();
      requestFocus(false);
    }
  }, [focusRequested]);
  React__namespace.useEffect(() => {
    focusIfRequested();
  });
  React__namespace.useDebugValue({
    id,
    disabled,
    label
  });
  const itemState = menuContext.getItemState(id != null ? id : '');
  const {
    highlighted
  } = itemState != null ? itemState : {
    highlighted: false
  };
  React__namespace.useEffect(() => {
    requestFocus(highlighted && open);
  }, [highlighted, open]);

  if (id === undefined) {
    return {
      getRootProps: other => _extends({}, other, getButtonProps(other), {
        role: 'menuitem'
      }),
      disabled: false,
      focusVisible
    };
  }

  return {
    getRootProps: other => {
      const optionProps = menuContext.getItemProps(id, other);
      return _extends({}, other, getButtonProps(other), {
        tabIndex: optionProps.tabIndex,
        id: optionProps.id,
        role: 'menuitem'
      });
    },
    disabled: (_itemState$disabled = itemState == null ? void 0 : itemState.disabled) != null ? _itemState$disabled : false,
    focusVisible
  };
}

const _excluded$t = ["children", "className", "disabled", "component", "components", "componentsProps", "label"];

function getUtilityClasses(ownerState) {
  const {
    disabled,
    focusVisible
  } = ownerState;
  const slots = {
    root: ['root', disabled && 'disabled', focusVisible && 'focusVisible']
  };
  return composeClasses(slots, getMenuItemUnstyledUtilityClass, {});
}
/**
 *
 * Demos:
 *
 * - [Menu](https://mui.com/base/react-menu/)
 *
 * API:
 *
 * - [MenuItemUnstyled API](https://mui.com/base/api/menu-item-unstyled/)
 */


const MenuItemUnstyled = /*#__PURE__*/React__namespace.forwardRef(function MenuItemUnstyled(props, ref) {
  var _ref, _componentsProps$root;

  const {
    children,
    className,
    disabled: disabledProp = false,
    component,
    components = {},
    componentsProps = {},
    label
  } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$t);

  const Root = (_ref = component != null ? component : components.Root) != null ? _ref : 'li';
  const {
    getRootProps,
    disabled,
    focusVisible
  } = useMenuItem({
    disabled: disabledProp,
    ref,
    label
  });

  const ownerState = _extends({}, props, {
    disabled,
    focusVisible
  });

  const classes = getUtilityClasses(ownerState);
  const rootProps = appendOwnerState(Root, _extends({}, other, componentsProps.root, getRootProps(other), {
    className: clsx(classes.root, className, (_componentsProps$root = componentsProps.root) == null ? void 0 : _componentsProps$root.className)
  }), ownerState);
  return /*#__PURE__*/jsxRuntime.exports.jsx(Root, _extends({}, rootProps, {
    children: children
  }));
});
process.env.NODE_ENV !== "production" ? MenuItemUnstyled.propTypes
/* remove-proptypes */
= {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------

  /**
   * @ignore
   */
  children: propTypes.exports.node,

  /**
   * @ignore
   */
  className: propTypes.exports.string,

  /**
   * @ignore
   */
  component: propTypes.exports.elementType,

  /**
   * @ignore
   */
  components: propTypes.exports.shape({
    Root: propTypes.exports.elementType
  }),

  /**
   * @ignore
   */
  componentsProps: propTypes.exports.shape({
    root: propTypes.exports.object
  }),

  /**
   * If `true`, the menu item will be disabled.
   * @default false
   */
  disabled: propTypes.exports.bool,

  /**
   * A text representation of the menu item's content.
   * Used for keyboard text navigation matching.
   */
  label: propTypes.exports.string
} : void 0;

// Is a vertical scrollbar displayed?
function isOverflowing(container) {
  const doc = ownerDocument(container);

  if (doc.body === container) {
    return ownerWindow(container).innerWidth > doc.documentElement.clientWidth;
  }

  return container.scrollHeight > container.clientHeight;
}

function ariaHidden(element, show) {
  if (show) {
    element.setAttribute('aria-hidden', 'true');
  } else {
    element.removeAttribute('aria-hidden');
  }
}

function getPaddingRight(element) {
  return parseInt(ownerWindow(element).getComputedStyle(element).paddingRight, 10) || 0;
}

function ariaHiddenSiblings(container, mountElement, currentElement, elementsToExclude = [], show) {
  const blacklist = [mountElement, currentElement, ...elementsToExclude];
  const blacklistTagNames = ['TEMPLATE', 'SCRIPT', 'STYLE'];
  [].forEach.call(container.children, element => {
    if (blacklist.indexOf(element) === -1 && blacklistTagNames.indexOf(element.tagName) === -1) {
      ariaHidden(element, show);
    }
  });
}

function findIndexOf(items, callback) {
  let idx = -1;
  items.some((item, index) => {
    if (callback(item)) {
      idx = index;
      return true;
    }

    return false;
  });
  return idx;
}

function handleContainer(containerInfo, props) {
  const restoreStyle = [];
  const container = containerInfo.container;

  if (!props.disableScrollLock) {
    if (isOverflowing(container)) {
      // Compute the size before applying overflow hidden to avoid any scroll jumps.
      const scrollbarSize = getScrollbarSize(ownerDocument(container));
      restoreStyle.push({
        value: container.style.paddingRight,
        property: 'padding-right',
        el: container
      }); // Use computed style, here to get the real padding to add our scrollbar width.

      container.style.paddingRight = `${getPaddingRight(container) + scrollbarSize}px`; // .mui-fixed is a global helper.

      const fixedElements = ownerDocument(container).querySelectorAll('.mui-fixed');
      [].forEach.call(fixedElements, element => {
        restoreStyle.push({
          value: element.style.paddingRight,
          property: 'padding-right',
          el: element
        });
        element.style.paddingRight = `${getPaddingRight(element) + scrollbarSize}px`;
      });
    } // Improve Gatsby support
    // https://css-tricks.com/snippets/css/force-vertical-scrollbar/


    const parent = container.parentElement;
    const containerWindow = ownerWindow(container);
    const scrollContainer = (parent == null ? void 0 : parent.nodeName) === 'HTML' && containerWindow.getComputedStyle(parent).overflowY === 'scroll' ? parent : container; // Block the scroll even if no scrollbar is visible to account for mobile keyboard
    // screensize shrink.

    restoreStyle.push({
      value: scrollContainer.style.overflow,
      property: 'overflow',
      el: scrollContainer
    }, {
      value: scrollContainer.style.overflowX,
      property: 'overflow-x',
      el: scrollContainer
    }, {
      value: scrollContainer.style.overflowY,
      property: 'overflow-y',
      el: scrollContainer
    });
    scrollContainer.style.overflow = 'hidden';
  }

  const restore = () => {
    restoreStyle.forEach(({
      value,
      el,
      property
    }) => {
      if (value) {
        el.style.setProperty(property, value);
      } else {
        el.style.removeProperty(property);
      }
    });
  };

  return restore;
}

function getHiddenSiblings(container) {
  const hiddenSiblings = [];
  [].forEach.call(container.children, element => {
    if (element.getAttribute('aria-hidden') === 'true') {
      hiddenSiblings.push(element);
    }
  });
  return hiddenSiblings;
}

/**
 * @ignore - do not document.
 *
 * Proper state management for containers and the modals in those containers.
 * Simplified, but inspired by react-overlay's ModalManager class.
 * Used by the Modal to ensure proper styling of containers.
 */
class ModalManager {
  constructor() {
    this.containers = void 0;
    this.modals = void 0;
    this.modals = [];
    this.containers = [];
  }

  add(modal, container) {
    let modalIndex = this.modals.indexOf(modal);

    if (modalIndex !== -1) {
      return modalIndex;
    }

    modalIndex = this.modals.length;
    this.modals.push(modal); // If the modal we are adding is already in the DOM.

    if (modal.modalRef) {
      ariaHidden(modal.modalRef, false);
    }

    const hiddenSiblings = getHiddenSiblings(container);
    ariaHiddenSiblings(container, modal.mount, modal.modalRef, hiddenSiblings, true);
    const containerIndex = findIndexOf(this.containers, item => item.container === container);

    if (containerIndex !== -1) {
      this.containers[containerIndex].modals.push(modal);
      return modalIndex;
    }

    this.containers.push({
      modals: [modal],
      container,
      restore: null,
      hiddenSiblings
    });
    return modalIndex;
  }

  mount(modal, props) {
    const containerIndex = findIndexOf(this.containers, item => item.modals.indexOf(modal) !== -1);
    const containerInfo = this.containers[containerIndex];

    if (!containerInfo.restore) {
      containerInfo.restore = handleContainer(containerInfo, props);
    }
  }

  remove(modal) {
    const modalIndex = this.modals.indexOf(modal);

    if (modalIndex === -1) {
      return modalIndex;
    }

    const containerIndex = findIndexOf(this.containers, item => item.modals.indexOf(modal) !== -1);
    const containerInfo = this.containers[containerIndex];
    containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);
    this.modals.splice(modalIndex, 1); // If that was the last modal in a container, clean up the container.

    if (containerInfo.modals.length === 0) {
      // The modal might be closed before it had the chance to be mounted in the DOM.
      if (containerInfo.restore) {
        containerInfo.restore();
      }

      if (modal.modalRef) {
        // In case the modal wasn't in the DOM yet.
        ariaHidden(modal.modalRef, true);
      }

      ariaHiddenSiblings(containerInfo.container, modal.mount, modal.modalRef, containerInfo.hiddenSiblings, false);
      this.containers.splice(containerIndex, 1);
    } else {
      // Otherwise make sure the next top modal is visible to a screen reader.
      const nextTop = containerInfo.modals[containerInfo.modals.length - 1]; // as soon as a modal is adding its modalRef is undefined. it can't set
      // aria-hidden because the dom element doesn't exist either
      // when modal was unmounted before modalRef gets null

      if (nextTop.modalRef) {
        ariaHidden(nextTop.modalRef, false);
      }
    }

    return modalIndex;
  }

  isTopModal(modal) {
    return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;
  }

}

/* eslint-disable consistent-return, jsx-a11y/no-noninteractive-tabindex */
const candidatesSelector = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable="false"])'].join(',');

function getTabIndex(node) {
  const tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);

  if (!Number.isNaN(tabindexAttr)) {
    return tabindexAttr;
  } // Browsers do not return `tabIndex` correctly for contentEditable nodes;
  // https://bugs.chromium.org/p/chromium/issues/detail?id=661108&q=contenteditable%20tabindex&can=2
  // so if they don't have a tabindex attribute specifically set, assume it's 0.
  // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default
  //  `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,
  //  yet they are still part of the regular tab order; in FF, they get a default
  //  `tabIndex` of 0; since Chrome still puts those elements in the regular tab
  //  order, consider their tab index to be 0.


  if (node.contentEditable === 'true' || (node.nodeName === 'AUDIO' || node.nodeName === 'VIDEO' || node.nodeName === 'DETAILS') && node.getAttribute('tabindex') === null) {
    return 0;
  }

  return node.tabIndex;
}

function isNonTabbableRadio(node) {
  if (node.tagName !== 'INPUT' || node.type !== 'radio') {
    return false;
  }

  if (!node.name) {
    return false;
  }

  const getRadio = selector => node.ownerDocument.querySelector(`input[type="radio"]${selector}`);

  let roving = getRadio(`[name="${node.name}"]:checked`);

  if (!roving) {
    roving = getRadio(`[name="${node.name}"]`);
  }

  return roving !== node;
}

function isNodeMatchingSelectorFocusable(node) {
  if (node.disabled || node.tagName === 'INPUT' && node.type === 'hidden' || isNonTabbableRadio(node)) {
    return false;
  }

  return true;
}

function defaultGetTabbable(root) {
  const regularTabNodes = [];
  const orderedTabNodes = [];
  Array.from(root.querySelectorAll(candidatesSelector)).forEach((node, i) => {
    const nodeTabIndex = getTabIndex(node);

    if (nodeTabIndex === -1 || !isNodeMatchingSelectorFocusable(node)) {
      return;
    }

    if (nodeTabIndex === 0) {
      regularTabNodes.push(node);
    } else {
      orderedTabNodes.push({
        documentOrder: i,
        tabIndex: nodeTabIndex,
        node
      });
    }
  });
  return orderedTabNodes.sort((a, b) => a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex).map(a => a.node).concat(regularTabNodes);
}

function defaultIsEnabled() {
  return true;
}
/**
 * Utility component that locks focus inside the component.
 */


function TrapFocus(props) {
  const {
    children,
    disableAutoFocus = false,
    disableEnforceFocus = false,
    disableRestoreFocus = false,
    getTabbable = defaultGetTabbable,
    isEnabled = defaultIsEnabled,
    open
  } = props;
  const ignoreNextEnforceFocus = React__namespace.useRef();
  const sentinelStart = React__namespace.useRef(null);
  const sentinelEnd = React__namespace.useRef(null);
  const nodeToRestore = React__namespace.useRef(null);
  const reactFocusEventTarget = React__namespace.useRef(null); // This variable is useful when disableAutoFocus is true.
  // It waits for the active element to move into the component to activate.

  const activated = React__namespace.useRef(false);
  const rootRef = React__namespace.useRef(null);
  const handleRef = useForkRef(children.ref, rootRef);
  const lastKeydown = React__namespace.useRef(null);
  React__namespace.useEffect(() => {
    // We might render an empty child.
    if (!open || !rootRef.current) {
      return;
    }

    activated.current = !disableAutoFocus;
  }, [disableAutoFocus, open]);
  React__namespace.useEffect(() => {
    // We might render an empty child.
    if (!open || !rootRef.current) {
      return;
    }

    const doc = ownerDocument(rootRef.current);

    if (!rootRef.current.contains(doc.activeElement)) {
      if (!rootRef.current.hasAttribute('tabIndex')) {
        if (process.env.NODE_ENV !== 'production') {
          console.error(['MUI: The modal content node does not accept focus.', 'For the benefit of assistive technologies, ' + 'the tabIndex of the node is being set to "-1".'].join('\n'));
        }

        rootRef.current.setAttribute('tabIndex', -1);
      }

      if (activated.current) {
        rootRef.current.focus();
      }
    }

    return () => {
      // restoreLastFocus()
      if (!disableRestoreFocus) {
        // In IE11 it is possible for document.activeElement to be null resulting
        // in nodeToRestore.current being null.
        // Not all elements in IE11 have a focus method.
        // Once IE11 support is dropped the focus() call can be unconditional.
        if (nodeToRestore.current && nodeToRestore.current.focus) {
          ignoreNextEnforceFocus.current = true;
          nodeToRestore.current.focus();
        }

        nodeToRestore.current = null;
      }
    }; // Missing `disableRestoreFocus` which is fine.
    // We don't support changing that prop on an open TrapFocus
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [open]);
  React__namespace.useEffect(() => {
    // We might render an empty child.
    if (!open || !rootRef.current) {
      return;
    }

    const doc = ownerDocument(rootRef.current);

    const contain = nativeEvent => {
      const {
        current: rootElement
      } = rootRef; // Cleanup functions are executed lazily in React 17.
      // Contain can be called between the component being unmounted and its cleanup function being run.

      if (rootElement === null) {
        return;
      }

      if (!doc.hasFocus() || disableEnforceFocus || !isEnabled() || ignoreNextEnforceFocus.current) {
        ignoreNextEnforceFocus.current = false;
        return;
      }

      if (!rootElement.contains(doc.activeElement)) {
        // if the focus event is not coming from inside the children's react tree, reset the refs
        if (nativeEvent && reactFocusEventTarget.current !== nativeEvent.target || doc.activeElement !== reactFocusEventTarget.current) {
          reactFocusEventTarget.current = null;
        } else if (reactFocusEventTarget.current !== null) {
          return;
        }

        if (!activated.current) {
          return;
        }

        let tabbable = [];

        if (doc.activeElement === sentinelStart.current || doc.activeElement === sentinelEnd.current) {
          tabbable = getTabbable(rootRef.current);
        }

        if (tabbable.length > 0) {
          var _lastKeydown$current, _lastKeydown$current2;

          const isShiftTab = Boolean(((_lastKeydown$current = lastKeydown.current) == null ? void 0 : _lastKeydown$current.shiftKey) && ((_lastKeydown$current2 = lastKeydown.current) == null ? void 0 : _lastKeydown$current2.key) === 'Tab');
          const focusNext = tabbable[0];
          const focusPrevious = tabbable[tabbable.length - 1];

          if (isShiftTab) {
            focusPrevious.focus();
          } else {
            focusNext.focus();
          }
        } else {
          rootElement.focus();
        }
      }
    };

    const loopFocus = nativeEvent => {
      lastKeydown.current = nativeEvent;

      if (disableEnforceFocus || !isEnabled() || nativeEvent.key !== 'Tab') {
        return;
      } // Make sure the next tab starts from the right place.
      // doc.activeElement referes to the origin.


      if (doc.activeElement === rootRef.current && nativeEvent.shiftKey) {
        // We need to ignore the next contain as
        // it will try to move the focus back to the rootRef element.
        ignoreNextEnforceFocus.current = true;
        sentinelEnd.current.focus();
      }
    };

    doc.addEventListener('focusin', contain);
    doc.addEventListener('keydown', loopFocus, true); // With Edge, Safari and Firefox, no focus related events are fired when the focused area stops being a focused area.
    // e.g. https://bugzilla.mozilla.org/show_bug.cgi?id=559561.
    // Instead, we can look if the active element was restored on the BODY element.
    //
    // The whatwg spec defines how the browser should behave but does not explicitly mention any events:
    // https://html.spec.whatwg.org/multipage/interaction.html#focus-fixup-rule.

    const interval = setInterval(() => {
      if (doc.activeElement.tagName === 'BODY') {
        contain();
      }
    }, 50);
    return () => {
      clearInterval(interval);
      doc.removeEventListener('focusin', contain);
      doc.removeEventListener('keydown', loopFocus, true);
    };
  }, [disableAutoFocus, disableEnforceFocus, disableRestoreFocus, isEnabled, open, getTabbable]);

  const onFocus = event => {
    if (nodeToRestore.current === null) {
      nodeToRestore.current = event.relatedTarget;
    }

    activated.current = true;
    reactFocusEventTarget.current = event.target;
    const childrenPropsHandler = children.props.onFocus;

    if (childrenPropsHandler) {
      childrenPropsHandler(event);
    }
  };

  const handleFocusSentinel = event => {
    if (nodeToRestore.current === null) {
      nodeToRestore.current = event.relatedTarget;
    }

    activated.current = true;
  };

  return /*#__PURE__*/jsxRuntime.exports.jsxs(React__namespace.Fragment, {
    children: [/*#__PURE__*/jsxRuntime.exports.jsx("div", {
      tabIndex: 0,
      onFocus: handleFocusSentinel,
      ref: sentinelStart,
      "data-test": "sentinelStart"
    }), /*#__PURE__*/React__namespace.cloneElement(children, {
      ref: handleRef,
      onFocus
    }), /*#__PURE__*/jsxRuntime.exports.jsx("div", {
      tabIndex: 0,
      onFocus: handleFocusSentinel,
      ref: sentinelEnd,
      "data-test": "sentinelEnd"
    })]
  });
}

process.env.NODE_ENV !== "production" ? TrapFocus.propTypes
/* remove-proptypes */
= {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------

  /**
   * A single child content element.
   */
  children: elementAcceptingRef,

  /**
   * If `true`, the trap focus will not automatically shift focus to itself when it opens, and
   * replace it to the last focused element when it closes.
   * This also works correctly with any trap focus children that have the `disableAutoFocus` prop.
   *
   * Generally this should never be set to `true` as it makes the trap focus less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableAutoFocus: propTypes.exports.bool,

  /**
   * If `true`, the trap focus will not prevent focus from leaving the trap focus while open.
   *
   * Generally this should never be set to `true` as it makes the trap focus less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableEnforceFocus: propTypes.exports.bool,

  /**
   * If `true`, the trap focus will not restore focus to previously focused element once
   * trap focus is hidden or unmounted.
   * @default false
   */
  disableRestoreFocus: propTypes.exports.bool,

  /**
   * Returns an array of ordered tabbable nodes (i.e. in tab order) within the root.
   * For instance, you can provide the "tabbable" npm dependency.
   * @param {HTMLElement} root
   */
  getTabbable: propTypes.exports.func,

  /**
   * This prop extends the `open` prop.
   * It allows to toggle the open state without having to wait for a rerender when changing the `open` prop.
   * This prop should be memoized.
   * It can be used to support multiple trap focus mounted at the same time.
   * @default function defaultIsEnabled() {
   *   return true;
   * }
   */
  isEnabled: propTypes.exports.func,

  /**
   * If `true`, focus is locked.
   */
  open: propTypes.exports.bool.isRequired
} : void 0;

if (process.env.NODE_ENV !== 'production') {
  // eslint-disable-next-line
  TrapFocus['propTypes' + ''] = exactProp(TrapFocus.propTypes);
}

function getModalUtilityClass(slot) {
  return generateUtilityClass('MuiModal', slot);
}
generateUtilityClasses('MuiModal', ['root', 'hidden']);

const _excluded$s = ["BackdropComponent", "BackdropProps", "children", "classes", "className", "closeAfterTransition", "component", "components", "componentsProps", "container", "disableAutoFocus", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "manager", "onBackdropClick", "onClose", "onKeyDown", "open", "theme", "onTransitionEnter", "onTransitionExited"];

const useUtilityClasses$c = ownerState => {
  const {
    open,
    exited,
    classes
  } = ownerState;
  const slots = {
    root: ['root', !open && exited && 'hidden']
  };
  return composeClasses(slots, getModalUtilityClass, classes);
};

function getContainer(container) {
  return typeof container === 'function' ? container() : container;
}

function getHasTransition(props) {
  return props.children ? props.children.props.hasOwnProperty('in') : false;
} // A modal manager used to track and manage the state of open Modals.
// Modals don't open on the server so this won't conflict with concurrent requests.


const defaultManager = new ModalManager();
/**
 * Modal is a lower-level construct that is leveraged by the following components:
 *
 * - [Dialog](/material-ui/api/dialog/)
 * - [Drawer](/material-ui/api/drawer/)
 * - [Menu](/material-ui/api/menu/)
 * - [Popover](/material-ui/api/popover/)
 *
 * If you are creating a modal dialog, you probably want to use the [Dialog](/material-ui/api/dialog/) component
 * rather than directly using Modal.
 *
 * This component shares many concepts with [react-overlays](https://react-bootstrap.github.io/react-overlays/#modals).
 */

const ModalUnstyled = /*#__PURE__*/React__namespace.forwardRef(function ModalUnstyled(props, ref) {
  const {
    BackdropComponent,
    BackdropProps,
    children,
    classes: classesProp,
    className,
    closeAfterTransition = false,
    component = 'div',
    components = {},
    componentsProps = {},
    container,
    disableAutoFocus = false,
    disableEnforceFocus = false,
    disableEscapeKeyDown = false,
    disablePortal = false,
    disableRestoreFocus = false,
    disableScrollLock = false,
    hideBackdrop = false,
    keepMounted = false,
    // private
    // eslint-disable-next-line react/prop-types
    manager = defaultManager,
    onBackdropClick,
    onClose,
    onKeyDown,
    open,

    /* eslint-disable react/prop-types */
    theme,
    onTransitionEnter,
    onTransitionExited
  } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$s);

  const [exited, setExited] = React__namespace.useState(true);
  const modal = React__namespace.useRef({});
  const mountNodeRef = React__namespace.useRef(null);
  const modalRef = React__namespace.useRef(null);
  const handleRef = useForkRef(modalRef, ref);
  const hasTransition = getHasTransition(props);

  const getDoc = () => ownerDocument(mountNodeRef.current);

  const getModal = () => {
    modal.current.modalRef = modalRef.current;
    modal.current.mountNode = mountNodeRef.current;
    return modal.current;
  };

  const handleMounted = () => {
    manager.mount(getModal(), {
      disableScrollLock
    }); // Fix a bug on Chrome where the scroll isn't initially 0.

    modalRef.current.scrollTop = 0;
  };

  const handleOpen = useEventCallback(() => {
    const resolvedContainer = getContainer(container) || getDoc().body;
    manager.add(getModal(), resolvedContainer); // The element was already mounted.

    if (modalRef.current) {
      handleMounted();
    }
  });
  const isTopModal = React__namespace.useCallback(() => manager.isTopModal(getModal()), [manager]);
  const handlePortalRef = useEventCallback(node => {
    mountNodeRef.current = node;

    if (!node) {
      return;
    }

    if (open && isTopModal()) {
      handleMounted();
    } else {
      ariaHidden(modalRef.current, true);
    }
  });
  const handleClose = React__namespace.useCallback(() => {
    manager.remove(getModal());
  }, [manager]);
  React__namespace.useEffect(() => {
    return () => {
      handleClose();
    };
  }, [handleClose]);
  React__namespace.useEffect(() => {
    if (open) {
      handleOpen();
    } else if (!hasTransition || !closeAfterTransition) {
      handleClose();
    }
  }, [open, handleClose, hasTransition, closeAfterTransition, handleOpen]);

  const ownerState = _extends({}, props, {
    classes: classesProp,
    closeAfterTransition,
    disableAutoFocus,
    disableEnforceFocus,
    disableEscapeKeyDown,
    disablePortal,
    disableRestoreFocus,
    disableScrollLock,
    exited,
    hideBackdrop,
    keepMounted
  });

  const classes = useUtilityClasses$c(ownerState);

  if (!keepMounted && !open && (!hasTransition || exited)) {
    return null;
  }

  const handleEnter = () => {
    setExited(false);

    if (onTransitionEnter) {
      onTransitionEnter();
    }
  };

  const handleExited = () => {
    setExited(true);

    if (onTransitionExited) {
      onTransitionExited();
    }

    if (closeAfterTransition) {
      handleClose();
    }
  };

  const handleBackdropClick = event => {
    if (event.target !== event.currentTarget) {
      return;
    }

    if (onBackdropClick) {
      onBackdropClick(event);
    }

    if (onClose) {
      onClose(event, 'backdropClick');
    }
  };

  const handleKeyDown = event => {
    if (onKeyDown) {
      onKeyDown(event);
    } // The handler doesn't take event.defaultPrevented into account:
    //
    // event.preventDefault() is meant to stop default behaviors like
    // clicking a checkbox to check it, hitting a button to submit a form,
    // and hitting left arrow to move the cursor in a text input etc.
    // Only special HTML elements have these default behaviors.


    if (event.key !== 'Escape' || !isTopModal()) {
      return;
    }

    if (!disableEscapeKeyDown) {
      // Swallow the event, in case someone is listening for the escape key on the body.
      event.stopPropagation();

      if (onClose) {
        onClose(event, 'escapeKeyDown');
      }
    }
  };

  const childProps = {};

  if (children.props.tabIndex === undefined) {
    childProps.tabIndex = '-1';
  } // It's a Transition like component


  if (hasTransition) {
    childProps.onEnter = createChainedFunction(handleEnter, children.props.onEnter);
    childProps.onExited = createChainedFunction(handleExited, children.props.onExited);
  }

  const Root = components.Root || component;
  const rootProps = componentsProps.root || {};
  return /*#__PURE__*/jsxRuntime.exports.jsx(Portal, {
    ref: handlePortalRef,
    container: container,
    disablePortal: disablePortal,
    children: /*#__PURE__*/jsxRuntime.exports.jsxs(Root, _extends({
      role: "presentation"
    }, rootProps, !isHostComponent(Root) && {
      as: component,
      ownerState: _extends({}, ownerState, rootProps.ownerState),
      theme
    }, other, {
      ref: handleRef,
      onKeyDown: handleKeyDown,
      className: clsx(classes.root, rootProps.className, className),
      children: [!hideBackdrop && BackdropComponent ? /*#__PURE__*/jsxRuntime.exports.jsx(BackdropComponent, _extends({
        "aria-hidden": true,
        open: open,
        onClick: handleBackdropClick
      }, BackdropProps)) : null, /*#__PURE__*/jsxRuntime.exports.jsx(TrapFocus, {
        disableEnforceFocus: disableEnforceFocus,
        disableAutoFocus: disableAutoFocus,
        disableRestoreFocus: disableRestoreFocus,
        isEnabled: isTopModal,
        open: open,
        children: /*#__PURE__*/React__namespace.cloneElement(children, childProps)
      })]
    }))
  });
});
process.env.NODE_ENV !== "production" ? ModalUnstyled.propTypes
/* remove-proptypes */
= {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------

  /**
   * A backdrop component. This prop enables custom backdrop rendering.
   */
  BackdropComponent: propTypes.exports.elementType,

  /**
   * Props applied to the backdrop element.
   */
  BackdropProps: propTypes.exports.object,

  /**
   * A single child content element.
   */
  children: elementAcceptingRef.isRequired,

  /**
   * Override or extend the styles applied to the component.
   */
  classes: propTypes.exports.object,

  /**
   * @ignore
   */
  className: propTypes.exports.string,

  /**
   * When set to true the Modal waits until a nested Transition is completed before closing.
   * @default false
   */
  closeAfterTransition: propTypes.exports.bool,

  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: propTypes.exports.elementType,

  /**
   * The components used for each slot inside the Modal.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  components: propTypes.exports.shape({
    Root: propTypes.exports.elementType
  }),

  /**
   * The props used for each slot inside the Modal.
   * @default {}
   */
  componentsProps: propTypes.exports.shape({
    root: propTypes.exports.object
  }),

  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: propTypes.exports
  /* @typescript-to-proptypes-ignore */
  .oneOfType([HTMLElementType, propTypes.exports.func]),

  /**
   * If `true`, the modal will not automatically shift focus to itself when it opens, and
   * replace it to the last focused element when it closes.
   * This also works correctly with any modal children that have the `disableAutoFocus` prop.
   *
   * Generally this should never be set to `true` as it makes the modal less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableAutoFocus: propTypes.exports.bool,

  /**
   * If `true`, the modal will not prevent focus from leaving the modal while open.
   *
   * Generally this should never be set to `true` as it makes the modal less
   * accessible to assistive technologies, like screen readers.
   * @default false
   */
  disableEnforceFocus: propTypes.exports.bool,

  /**
   * If `true`, hitting escape will not fire the `onClose` callback.
   * @default false
   */
  disableEscapeKeyDown: propTypes.exports.bool,

  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: propTypes.exports.bool,

  /**
   * If `true`, the modal will not restore focus to previously focused element once
   * modal is hidden or unmounted.
   * @default false
   */
  disableRestoreFocus: propTypes.exports.bool,

  /**
   * Disable the scroll lock behavior.
   * @default false
   */
  disableScrollLock: propTypes.exports.bool,

  /**
   * If `true`, the backdrop is not rendered.
   * @default false
   */
  hideBackdrop: propTypes.exports.bool,

  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Modal.
   * @default false
   */
  keepMounted: propTypes.exports.bool,

  /**
   * Callback fired when the backdrop is clicked.
   * @deprecated Use the `onClose` prop with the `reason` argument to handle the `backdropClick` events.
   */
  onBackdropClick: propTypes.exports.func,

  /**
   * Callback fired when the component requests to be closed.
   * The `reason` parameter can optionally be used to control the response to `onClose`.
   *
   * @param {object} event The event source of the callback.
   * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`.
   */
  onClose: propTypes.exports.func,

  /**
   * @ignore
   */
  onKeyDown: propTypes.exports.func,

  /**
   * If `true`, the component is shown.
   */
  open: propTypes.exports.bool.isRequired
} : void 0;

function isOptionGroup(child) {
  return !!child.options;
}

function getOptionsFromChildren(children) {
  if (children == null) {
    return [];
  }

  const selectChildren = [];
  React__default["default"].Children.forEach(children, node => {
    var _props, _props2, _element$props$disabl2;

    const nodeChildren = node == null ? void 0 : (_props = node.props) == null ? void 0 : _props.children;

    if ((node == null ? void 0 : (_props2 = node.props) == null ? void 0 : _props2.value) === undefined) {
      if (nodeChildren != null) {
        var _element$props$disabl;

        const element = node;
        const group = {
          options: getOptionsFromChildren(nodeChildren),
          label: element.props.label,
          disabled: (_element$props$disabl = element.props.disabled) != null ? _element$props$disabl : false
        };
        selectChildren.push(group);
      }

      return;
    }

    const element = node;
    const option = {
      value: element.props.value,
      label: element.props.label || element.props.children,
      disabled: (_element$props$disabl2 = element.props.disabled) != null ? _element$props$disabl2 : false
    };
    selectChildren.push(option);
  });
  return selectChildren != null ? selectChildren : [];
}
function flattenOptionGroups(groupedOptions, isGroupDisabled = false) {
  let flatOptions = [];
  groupedOptions.forEach(optionOrGroup => {
    if (isOptionGroup(optionOrGroup)) {
      flatOptions = flatOptions.concat(flattenOptionGroups(optionOrGroup.options, optionOrGroup.disabled));
    } else {
      flatOptions.push(_extends({}, optionOrGroup, {
        disabled: isGroupDisabled || optionOrGroup.disabled
      }));
    }
  });
  return flatOptions;
}

const defaultOptionStringifier = option => {
  const {
    label,
    value
  } = option;

  if (typeof label === 'string') {
    return label;
  }

  if (typeof value === 'string') {
    return value;
  } // Fall back string representation


  return String(option);
};

function useSelect(props) {
  const {
    buttonRef: buttonRefProp,
    defaultValue,
    disabled = false,
    listboxId,
    listboxRef: listboxRefProp,
    multiple = false,
    onChange,
    onOpenChange,
    open = false,
    options,
    optionStringifier = defaultOptionStringifier,
    value: valueProp
  } = props;
  const buttonRef = React__namespace.useRef(null);
  const handleButtonRef = useForkRef(buttonRefProp, buttonRef);
  const listboxRef = React__namespace.useRef(null);
  const intermediaryListboxRef = useForkRef(listboxRefProp, listboxRef);
  const [value, setValue] = useControlled({
    controlled: valueProp,
    default: defaultValue,
    name: 'SelectUnstyled',
    state: 'value'
  }); // prevents closing the listbox on keyUp right after opening it

  const ignoreEnterKeyUp = React__namespace.useRef(false); // prevents reopening the listbox when button is clicked
  // (listbox closes on lost focus, then immediately reopens on click)

  const ignoreClick = React__namespace.useRef(false); // Ensure the listbox is focused after opening

  const [listboxFocusRequested, requestListboxFocus] = React__namespace.useState(false);
  const focusListboxIfRequested = React__namespace.useCallback(() => {
    if (listboxFocusRequested && listboxRef.current != null) {
      listboxRef.current.focus();
      requestListboxFocus(false);
    }
  }, [listboxFocusRequested]);

  const updateListboxRef = listboxElement => {
    listboxRef.current = listboxElement;
    focusListboxIfRequested();
  };

  const handleListboxRef = useForkRef(intermediaryListboxRef, updateListboxRef);
  React__namespace.useEffect(() => {
    focusListboxIfRequested();
  }, [focusListboxIfRequested]);
  React__namespace.useEffect(() => {
    requestListboxFocus(open);
  }, [open]);

  const createHandleMouseDown = otherHandlers => event => {
    var _otherHandlers$onMous;

    otherHandlers == null ? void 0 : (_otherHandlers$onMous = otherHandlers.onMouseDown) == null ? void 0 : _otherHandlers$onMous.call(otherHandlers, event);

    if (!event.defaultPrevented && open) {
      ignoreClick.current = true;
    }
  };

  const createHandleButtonClick = otherHandlers => event => {
    var _otherHandlers$onClic;

    otherHandlers == null ? void 0 : (_otherHandlers$onClic = otherHandlers.onClick) == null ? void 0 : _otherHandlers$onClic.call(otherHandlers, event);

    if (!event.defaultPrevented && !ignoreClick.current) {
      onOpenChange == null ? void 0 : onOpenChange(!open);
    }

    ignoreClick.current = false;
  };

  const createHandleButtonKeyDown = otherHandlers => event => {
    var _otherHandlers$onKeyD;

    otherHandlers == null ? void 0 : (_otherHandlers$onKeyD = otherHandlers.onKeyDown) == null ? void 0 : _otherHandlers$onKeyD.call(otherHandlers, event);

    if (event.defaultPrevented) {
      return;
    }

    if (event.key === 'Enter') {
      ignoreEnterKeyUp.current = true;
    }

    if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {
      event.preventDefault();
      onOpenChange == null ? void 0 : onOpenChange(true);
    }
  };

  const createHandleListboxKeyUp = otherHandlers => event => {
    var _otherHandlers$onKeyU;

    otherHandlers == null ? void 0 : (_otherHandlers$onKeyU = otherHandlers.onKeyUp) == null ? void 0 : _otherHandlers$onKeyU.call(otherHandlers, event);

    if (event.defaultPrevented) {
      return;
    }

    const closingKeys = multiple ? ['Escape'] : ['Escape', 'Enter', ' '];

    if (open && !ignoreEnterKeyUp.current && closingKeys.includes(event.key)) {
      var _buttonRef$current;

      buttonRef == null ? void 0 : (_buttonRef$current = buttonRef.current) == null ? void 0 : _buttonRef$current.focus();
    }

    ignoreEnterKeyUp.current = false;
  };

  const createHandleListboxItemClick = otherHandlers => event => {
    var _otherHandlers$onClic2;

    otherHandlers == null ? void 0 : (_otherHandlers$onClic2 = otherHandlers.onClick) == null ? void 0 : _otherHandlers$onClic2.call(otherHandlers, event);

    if (event.defaultPrevented) {
      return;
    }

    if (!multiple) {
      onOpenChange == null ? void 0 : onOpenChange(false);
    }
  };

  const createHandleListboxBlur = otherHandlers => event => {
    var _otherHandlers$blur;

    otherHandlers == null ? void 0 : (_otherHandlers$blur = otherHandlers.blur) == null ? void 0 : _otherHandlers$blur.call(otherHandlers, event);

    if (!event.defaultPrevented) {
      onOpenChange == null ? void 0 : onOpenChange(false);
    }
  };

  const listboxReducer = (state, action) => {
    const newState = defaultListboxReducer(state, action); // change selection when listbox is closed

    if (action.type === ActionTypes.keyDown && !open && (action.event.key === 'ArrowUp' || action.event.key === 'ArrowDown')) {
      return _extends({}, newState, {
        selectedValue: newState.highlightedValue
      });
    }

    if (action.type === ActionTypes.blur || action.type === ActionTypes.setValue || action.type === ActionTypes.optionsChange) {
      return _extends({}, newState, {
        highlightedValue: newState.selectedValue
      });
    }

    return newState;
  };

  const {
    getRootProps: getButtonRootProps,
    active: buttonActive,
    focusVisible: buttonFocusVisible
  } = useButton({
    disabled,
    ref: handleButtonRef
  });
  const selectedOption = React__namespace.useMemo(() => {
    var _props$options$find;

    return props.multiple ? props.options.filter(o => value.includes(o.value)) : (_props$options$find = props.options.find(o => o.value === value)) != null ? _props$options$find : null;
  }, [props.multiple, props.options, value]);
  let useListboxParameters;

  if (props.multiple) {
    useListboxParameters = {
      id: listboxId,
      isOptionDisabled: o => {
        var _o$disabled;

        return (_o$disabled = o == null ? void 0 : o.disabled) != null ? _o$disabled : false;
      },
      optionComparer: (o, v) => (o == null ? void 0 : o.value) === (v == null ? void 0 : v.value),
      listboxRef: handleListboxRef,
      multiple: true,
      onChange: newOptions => {
        setValue(newOptions.map(o => o.value));
        onChange == null ? void 0 : onChange(newOptions.map(o => o.value));
      },
      options,
      optionStringifier,
      value: selectedOption
    };
  } else {
    useListboxParameters = {
      id: listboxId,
      isOptionDisabled: o => {
        var _o$disabled2;

        return (_o$disabled2 = o == null ? void 0 : o.disabled) != null ? _o$disabled2 : false;
      },
      optionComparer: (o, v) => (o == null ? void 0 : o.value) === (v == null ? void 0 : v.value),
      listboxRef: handleListboxRef,
      multiple: false,
      onChange: option => {
        var _option$value, _option$value2;

        setValue((_option$value = option == null ? void 0 : option.value) != null ? _option$value : null);
        onChange == null ? void 0 : onChange((_option$value2 = option == null ? void 0 : option.value) != null ? _option$value2 : null);
      },
      options,
      optionStringifier,
      stateReducer: listboxReducer,
      value: selectedOption
    };
  }

  const {
    getRootProps: getListboxRootProps,
    getOptionProps: getListboxOptionProps,
    getOptionState,
    highlightedOption,
    selectedOption: listboxSelectedOption
  } = useListbox(useListboxParameters);

  const getButtonProps = (otherHandlers = {}) => {
    return _extends({}, getButtonRootProps(_extends({}, otherHandlers, {
      onClick: createHandleButtonClick(otherHandlers),
      onMouseDown: createHandleMouseDown(otherHandlers),
      onKeyDown: createHandleButtonKeyDown(otherHandlers)
    })), {
      'aria-expanded': open,
      'aria-haspopup': 'listbox'
    });
  };

  const getListboxProps = (otherHandlers = {}) => getListboxRootProps(_extends({}, otherHandlers, {
    onBlur: createHandleListboxBlur(otherHandlers),
    onKeyUp: createHandleListboxKeyUp(otherHandlers)
  }));

  const getOptionProps = (option, otherHandlers = {}) => {
    return getListboxOptionProps(option, _extends({}, otherHandlers, {
      onClick: createHandleListboxItemClick(otherHandlers)
    }));
  };

  React__namespace.useDebugValue({
    selectedOption: listboxSelectedOption,
    open,
    highlightedOption
  });
  return {
    buttonActive,
    buttonFocusVisible,
    disabled,
    getButtonProps,
    getListboxProps,
    getOptionProps,
    getOptionState,
    open,
    value
  };
}

const SelectUnstyledContext = /*#__PURE__*/React__namespace.createContext(undefined);

function getSelectUnstyledUtilityClass(slot) {
  return generateUtilityClass('MuiSelectUnstyled', slot);
}
generateUtilityClasses('MuiSelectUnstyled', ['root', 'button', 'listbox', 'popper', 'active', 'expanded', 'disabled', 'focusVisible']);

const _excluded$r = ["autoFocus", "children", "className", "component", "components", "componentsProps", "defaultListboxOpen", "defaultValue", "disabled", "listboxOpen", "onChange", "onListboxOpenChange", "value"];

function defaultRenderMultipleValues(selectedOptions) {
  return /*#__PURE__*/jsxRuntime.exports.jsx(React__namespace.Fragment, {
    children: selectedOptions.map(o => o.label).join(', ')
  });
}

function useUtilityClasses$b(ownerState) {
  const {
    active,
    disabled,
    open,
    focusVisible
  } = ownerState;
  const slots = {
    root: ['root', disabled && 'disabled', focusVisible && 'focusVisible', active && 'active', open && 'expanded'],
    listbox: ['listbox', disabled && 'disabled'],
    popper: ['popper']
  };
  return composeClasses(slots, getSelectUnstyledUtilityClass, {});
}
/**
 * The foundation for building custom-styled multi-selection select components.
 */


const MultiSelectUnstyled = /*#__PURE__*/React__namespace.forwardRef(function MultiSelectUnstyled(props, ref) {
  var _props$renderValue, _ref, _components$Listbox, _components$Popper, _componentsProps$list, _componentsProps$list2, _componentsProps$root, _componentsProps$list3, _componentsProps$popp;

  const {
    autoFocus,
    children,
    className,
    component,
    components = {},
    componentsProps = {},
    defaultListboxOpen = false,
    defaultValue = [],
    disabled: disabledProp,
    listboxOpen: listboxOpenProp,
    onChange,
    onListboxOpenChange,
    value: valueProp
  } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$r);

  const renderValue = (_props$renderValue = props.renderValue) != null ? _props$renderValue : defaultRenderMultipleValues;
  const [groupedOptions, setGroupedOptions] = React__namespace.useState([]);
  const options = React__namespace.useMemo(() => flattenOptionGroups(groupedOptions), [groupedOptions]);
  const [listboxOpen, setListboxOpen] = useControlled({
    controlled: listboxOpenProp,
    default: defaultListboxOpen,
    name: 'MultiSelectUnstyled',
    state: 'listboxOpen'
  });
  React__namespace.useEffect(() => {
    setGroupedOptions(getOptionsFromChildren(children));
  }, [children]);
  const [buttonDefined, setButtonDefined] = React__namespace.useState(false);
  const buttonRef = React__namespace.useRef(null);
  const listboxRef = React__namespace.useRef(null);
  const Button = (_ref = component != null ? component : components.Root) != null ? _ref : 'button';
  const ListboxRoot = (_components$Listbox = components.Listbox) != null ? _components$Listbox : 'ul';
  const Popper = (_components$Popper = components.Popper) != null ? _components$Popper : PopperUnstyled;

  const handleButtonRefChange = element => {
    buttonRef.current = element;

    if (element != null) {
      setButtonDefined(true);
    }
  };

  const handleButtonRef = useForkRef(ref, handleButtonRefChange);
  const handleListboxRef = useForkRef(listboxRef, (_componentsProps$list = componentsProps.listbox) == null ? void 0 : _componentsProps$list.ref);
  React__namespace.useEffect(() => {
    if (autoFocus) {
      buttonRef.current.focus();
    }
  }, [autoFocus]);

  const handleOpenChange = isOpen => {
    setListboxOpen(isOpen);
    onListboxOpenChange == null ? void 0 : onListboxOpenChange(isOpen);
  };

  const {
    buttonActive,
    buttonFocusVisible,
    disabled,
    getButtonProps,
    getListboxProps,
    getOptionProps,
    getOptionState,
    value
  } = useSelect({
    buttonRef: handleButtonRef,
    defaultValue,
    disabled: disabledProp,
    listboxId: (_componentsProps$list2 = componentsProps.listbox) == null ? void 0 : _componentsProps$list2.id,
    listboxRef: handleListboxRef,
    multiple: true,
    onChange,
    onOpenChange: handleOpenChange,
    open: listboxOpen,
    options,
    value: valueProp
  });

  const ownerState = _extends({}, props, {
    active: buttonActive,
    defaultListboxOpen,
    disabled,
    focusVisible: buttonFocusVisible,
    open: listboxOpen,
    renderValue,
    value
  });

  const classes = useUtilityClasses$b(ownerState);
  const selectedOptions = React__namespace.useMemo(() => {
    if (value == null) {
      return [];
    }

    return options.filter(o => value.includes(o.value));
  }, [options, value]);
  const buttonProps = appendOwnerState(Button, _extends({}, getButtonProps(), other, componentsProps.root, {
    className: clsx(className, (_componentsProps$root = componentsProps.root) == null ? void 0 : _componentsProps$root.className, classes.root)
  }), ownerState);
  const listboxProps = appendOwnerState(ListboxRoot, _extends({}, getListboxProps(), componentsProps.listbox, {
    className: clsx((_componentsProps$list3 = componentsProps.listbox) == null ? void 0 : _componentsProps$list3.className, classes.listbox)
  }), ownerState); // Popper must be a (non-host) component, therefore ownerState will be present within the props

  const popperProps = appendOwnerState(Popper, _extends({
    open: listboxOpen,
    anchorEl: buttonRef.current,
    placement: 'bottom-start',
    disablePortal: true,
    role: undefined
  }, componentsProps.popper, {
    className: clsx((_componentsProps$popp = componentsProps.popper) == null ? void 0 : _componentsProps$popp.className, classes.popper)
  }), ownerState);
  const context = {
    getOptionProps,
    getOptionState,
    listboxRef
  };
  return /*#__PURE__*/jsxRuntime.exports.jsxs(React__namespace.Fragment, {
    children: [/*#__PURE__*/jsxRuntime.exports.jsx(Button, _extends({}, buttonProps, {
      children: renderValue(selectedOptions)
    })), buttonDefined && /*#__PURE__*/jsxRuntime.exports.jsx(Popper, _extends({}, popperProps, {
      children: /*#__PURE__*/jsxRuntime.exports.jsx(ListboxRoot, _extends({}, listboxProps, {
        children: /*#__PURE__*/jsxRuntime.exports.jsx(SelectUnstyledContext.Provider, {
          value: context,
          children: children
        })
      }))
    }))]
  });
});
process.env.NODE_ENV !== "production" ? MultiSelectUnstyled.propTypes
/* remove-proptypes */
= {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------

  /**
   * If `true`, the select element is focused during the first mount
   * @default false
   */
  autoFocus: propTypes.exports.bool,

  /**
   * @ignore
   */
  children: propTypes.exports.node,

  /**
   * @ignore
   */
  className: propTypes.exports.string,

  /**
   * @ignore
   */
  component: propTypes.exports.elementType,

  /**
   * The components used for each slot inside the Select.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  components: propTypes.exports
  /* @typescript-to-proptypes-ignore */
  .shape({
    Listbox: propTypes.exports.elementType,
    Popper: propTypes.exports.elementType,
    Root: propTypes.exports.elementType
  }),

  /**
   * The props used for each slot inside the Input.
   * @default {}
   */
  componentsProps: propTypes.exports.shape({
    listbox: propTypes.exports.object,
    popper: propTypes.exports.object,
    root: propTypes.exports.object
  }),

  /**
   * If `true`, the select will be initially open.
   * @default false
   */
  defaultListboxOpen: propTypes.exports.bool,

  /**
   * The default selected values. Use when the component is not controlled.
   * @default []
   */
  defaultValue: propTypes.exports.array,

  /**
   * If `true`, the select is disabled.
   * @default false
   */
  disabled: propTypes.exports.bool,

  /**
   * Controls the open state of the select's listbox.
   * @default undefined
   */
  listboxOpen: propTypes.exports.bool,

  /**
   * Callback fired when an option is selected.
   */
  onChange: propTypes.exports.func,

  /**
   * Callback fired when the component requests to be opened.
   * Use in controlled mode (see listboxOpen).
   */
  onListboxOpenChange: propTypes.exports.func,

  /**
   * Function that customizes the rendering of the selected values.
   */
  renderValue: propTypes.exports.func,

  /**
   * The selected values.
   * Set to an empty array to deselect all options.
   */
  value: propTypes.exports.array
} : void 0;

function NoSsr(props) {
  const {
    children,
    defer = false,
    fallback = null
  } = props;
  const [mountedState, setMountedState] = React__namespace.useState(false);
  useEnhancedEffect(() => {
    if (!defer) {
      setMountedState(true);
    }
  }, [defer]);
  React__namespace.useEffect(() => {
    if (defer) {
      setMountedState(true);
    }
  }, [defer]); // We need the Fragment here to force react-docgen to recognise NoSsr as a component.

  return /*#__PURE__*/jsxRuntime.exports.jsx(React__namespace.Fragment, {
    children: mountedState ? children : fallback
  });
}

process.env.NODE_ENV !== "production" ? NoSsr.propTypes
/* remove-proptypes */
= {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------

  /**
   * You can wrap a node.
   */
  children: propTypes.exports.node,

  /**
   * If `true`, the component will not only prevent server-side rendering.
   * It will also defer the rendering of the children into a different screen frame.
   * @default false
   */
  defer: propTypes.exports.bool,

  /**
   * The fallback content to display.
   * @default null
   */
  fallback: propTypes.exports.node
} : void 0;

if (process.env.NODE_ENV !== 'production') {
  // eslint-disable-next-line
  NoSsr['propTypes' + ''] = exactProp(NoSsr.propTypes);
}

function getOptionGroupUnstyledUtilityClass(slot) {
  return generateUtilityClass('MuiOptionGroupUnstyled', slot);
}
generateUtilityClasses('MuiOptionGroupUnstyled', ['root', 'label', 'list']);

const _excluded$q = ["className", "component", "components", "disabled", "componentsProps"];

function useUtilityClasses$a(disabled) {
  const slots = {
    root: ['root', disabled && 'disabled'],
    label: ['label'],
    list: ['list']
  };
  return composeClasses(slots, getOptionGroupUnstyledUtilityClass, {});
}
/**
 * An unstyled option group to be used within a SelectUnstyled.
 *
 * Demos:
 *
 * - [Select](https://mui.com/base/react-select/)
 *
 * API:
 *
 * - [OptionGroupUnstyled API](https://mui.com/base/api/option-group-unstyled/)
 */


const OptionGroupUnstyled = /*#__PURE__*/React__default["default"].forwardRef(function OptionGroupUnstyled(props, ref) {
  var _componentsProps$root, _componentsProps$labe, _componentsProps$list;

  const {
    className,
    component,
    components = {},
    disabled = false,
    componentsProps = {}
  } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$q);

  const Root = component || (components == null ? void 0 : components.Root) || 'li';
  const Label = (components == null ? void 0 : components.Label) || 'span';
  const List = (components == null ? void 0 : components.List) || 'ul';
  const classes = useUtilityClasses$a(disabled);

  const rootProps = _extends({}, other, {
    ref
  }, componentsProps.root, {
    className: clsx(classes.root, className, (_componentsProps$root = componentsProps.root) == null ? void 0 : _componentsProps$root.className)
  });

  const labelProps = _extends({}, componentsProps.label, {
    className: clsx(classes.label, (_componentsProps$labe = componentsProps.label) == null ? void 0 : _componentsProps$labe.className)
  });

  const listProps = _extends({}, componentsProps.list, {
    className: clsx(classes.list, (_componentsProps$list = componentsProps.list) == null ? void 0 : _componentsProps$list.className)
  });

  return /*#__PURE__*/jsxRuntime.exports.jsxs(Root, _extends({}, rootProps, {
    children: [/*#__PURE__*/jsxRuntime.exports.jsx(Label, _extends({}, labelProps, {
      children: props.label
    })), /*#__PURE__*/jsxRuntime.exports.jsx(List, _extends({}, listProps, {
      children: props.children
    }))]
  }));
});
process.env.NODE_ENV !== "production" ? OptionGroupUnstyled.propTypes
/* remove-proptypes */
= {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------

  /**
   * @ignore
   */
  children: propTypes.exports.node,

  /**
   * @ignore
   */
  className: propTypes.exports.string,

  /**
   * The component used for the Root slot.
   * Either a string to use a HTML element or a component.
   * This is equivalent to components.Root.
   * If both are provided, the component is used.
   */
  component: propTypes.exports.elementType,

  /**
   * The components used for each slot inside the OptionGroupUnstyled.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  components: propTypes.exports.shape({
    Label: propTypes.exports.elementType,
    List: propTypes.exports.elementType,
    Root: propTypes.exports.elementType
  }),

  /**
   * The props used for each slot inside the Input.
   * @default {}
   */
  componentsProps: propTypes.exports.shape({
    label: propTypes.exports.object,
    list: propTypes.exports.object,
    root: propTypes.exports.object
  }),

  /**
   * If `true` all the options in the group will be disabled.
   * @default false
   */
  disabled: propTypes.exports.bool,

  /**
   * The human-readable description of the group.
   */
  label: propTypes.exports.node
} : void 0;

function getOptionUnstyledUtilityClass(slot) {
  return generateUtilityClass('MuiOptionUnstyled', slot);
}
generateUtilityClasses('MuiOptionUnstyled', ['root', 'disabled', 'selected', 'highlighted']);

const _excluded$p = ["children", "className", "component", "components", "componentsProps", "disabled", "value", "label"];

function useUtilityClasses$9(ownerState) {
  const {
    disabled,
    highlighted,
    selected
  } = ownerState;
  const slots = {
    root: ['root', disabled && 'disabled', highlighted && 'highlighted', selected && 'selected']
  };
  return composeClasses(slots, getOptionUnstyledUtilityClass, {});
}
/**
 * An unstyled option to be used within a SelectUnstyled.
 */


const OptionUnstyled = /*#__PURE__*/React__default["default"].forwardRef(function OptionUnstyled(props, ref) {
  var _componentsProps$root;

  const {
    children,
    className,
    component,
    components = {},
    componentsProps = {},
    disabled,
    value,
    label
  } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$p);

  const selectContext = React__default["default"].useContext(SelectUnstyledContext);

  if (!selectContext) {
    throw new Error('OptionUnstyled must be used within a SelectUnstyled');
  }

  const Root = component || components.Root || 'li';
  const selectOption = {
    value,
    label: label || children,
    disabled
  };
  const optionState = selectContext.getOptionState(selectOption);
  const optionProps = selectContext.getOptionProps(selectOption);
  const listboxRef = selectContext.listboxRef;

  const ownerState = _extends({}, props, optionState);

  const optionRef = React__default["default"].useRef(null);
  const handleRef = useForkRef(ref, optionRef);
  React__default["default"].useEffect(() => {
    // Scroll to the currently highlighted option
    if (optionState.highlighted) {
      if (!listboxRef.current || !optionRef.current) {
        return;
      }

      const listboxClientRect = listboxRef.current.getBoundingClientRect();
      const optionClientRect = optionRef.current.getBoundingClientRect();

      if (optionClientRect.top < listboxClientRect.top) {
        listboxRef.current.scrollTop -= listboxClientRect.top - optionClientRect.top;
      } else if (optionClientRect.bottom > listboxClientRect.bottom) {
        listboxRef.current.scrollTop += optionClientRect.bottom - listboxClientRect.bottom;
      }
    }
  }, [optionState.highlighted, listboxRef]);
  const classes = useUtilityClasses$9(ownerState);
  const rootProps = appendOwnerState(Root, _extends({}, other, optionProps, componentsProps.root, {
    ref: handleRef,
    className: clsx(classes.root, className, (_componentsProps$root = componentsProps.root) == null ? void 0 : _componentsProps$root.className)
  }), ownerState);
  return /*#__PURE__*/jsxRuntime.exports.jsx(Root, _extends({}, rootProps, {
    children: children
  }));
});
process.env.NODE_ENV !== "production" ? OptionUnstyled.propTypes
/* remove-proptypes */
= {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------

  /**
   * @ignore
   */
  children: propTypes.exports.node,

  /**
   * @ignore
   */
  className: propTypes.exports.string,

  /**
   * The component used for the Root slot.
   * Either a string to use a HTML element or a component.
   * This is equivalent to components.Root.
   * If both are provided, the component is used.
   */
  component: propTypes.exports.elementType,

  /**
   * The components used for each slot inside the OptionUnstyled.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  components: propTypes.exports.shape({
    Root: propTypes.exports.elementType
  }),

  /**
   * The props used for each slot inside the Input.
   * @default {}
   */
  componentsProps: propTypes.exports.shape({
    root: propTypes.exports.object
  }),

  /**
   * If `true`, the option will be disabled.
   * @default false
   */
  disabled: propTypes.exports.bool,

  /**
   * A text representation of the option's content.
   * Used for keyboard text navigation matching.
   */
  label: propTypes.exports.string,

  /**
   * The value of the option.
   */
  value: propTypes.exports.any.isRequired
} : void 0;

const _excluded$o = ["autoFocus", "children", "className", "component", "components", "componentsProps", "defaultValue", "defaultListboxOpen", "disabled", "listboxOpen", "onChange", "onListboxOpenChange", "renderValue", "value"];

function defaultRenderSingleValue(selectedOption) {
  var _selectedOption$label;

  return (_selectedOption$label = selectedOption == null ? void 0 : selectedOption.label) != null ? _selectedOption$label : '';
}

function useUtilityClasses$8(ownerState) {
  const {
    active,
    disabled,
    open,
    focusVisible
  } = ownerState;
  const slots = {
    root: ['root', disabled && 'disabled', focusVisible && 'focusVisible', active && 'active', open && 'expanded'],
    listbox: ['listbox', disabled && 'disabled'],
    popper: ['popper']
  };
  return composeClasses(slots, getSelectUnstyledUtilityClass, {});
}
/**
 * The foundation for building custom-styled select components.
 */


const SelectUnstyled = /*#__PURE__*/React__namespace.forwardRef(function SelectUnstyled(props, ref) {
  var _ref, _components$Listbox, _components$Popper, _componentsProps$list, _componentsProps$list2, _componentsProps$root, _componentsProps$list3, _componentsProps$popp;

  const {
    autoFocus,
    children,
    className,
    component,
    components = {},
    componentsProps = {},
    defaultValue,
    defaultListboxOpen = false,
    disabled: disabledProp,
    listboxOpen: listboxOpenProp,
    onChange,
    onListboxOpenChange,
    renderValue: renderValueProp,
    value: valueProp
  } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$o);

  const renderValue = renderValueProp != null ? renderValueProp : defaultRenderSingleValue;
  const [groupedOptions, setGroupedOptions] = React__namespace.useState([]);
  const options = React__namespace.useMemo(() => flattenOptionGroups(groupedOptions), [groupedOptions]);
  const [listboxOpen, setListboxOpen] = useControlled({
    controlled: listboxOpenProp,
    default: defaultListboxOpen,
    name: 'SelectUnstyled',
    state: 'listboxOpen'
  });
  React__namespace.useEffect(() => {
    setGroupedOptions(getOptionsFromChildren(children));
  }, [children]);
  const [buttonDefined, setButtonDefined] = React__namespace.useState(false);
  const buttonRef = React__namespace.useRef(null);
  const listboxRef = React__namespace.useRef(null);
  const Button = (_ref = component != null ? component : components.Root) != null ? _ref : 'button';
  const ListboxRoot = (_components$Listbox = components.Listbox) != null ? _components$Listbox : 'ul';
  const Popper = (_components$Popper = components.Popper) != null ? _components$Popper : PopperUnstyled;

  const handleButtonRefChange = element => {
    buttonRef.current = element;

    if (element != null) {
      setButtonDefined(true);
    }
  };

  const handleButtonRef = useForkRef(ref, handleButtonRefChange);
  const handleListboxRef = useForkRef(listboxRef, (_componentsProps$list = componentsProps.listbox) == null ? void 0 : _componentsProps$list.ref);
  React__namespace.useEffect(() => {
    if (autoFocus) {
      buttonRef.current.focus();
    }
  }, [autoFocus]);

  const handleOpenChange = isOpen => {
    setListboxOpen(isOpen);
    onListboxOpenChange == null ? void 0 : onListboxOpenChange(isOpen);
  };

  const {
    buttonActive,
    buttonFocusVisible,
    disabled,
    getButtonProps,
    getListboxProps,
    getOptionProps,
    getOptionState,
    value
  } = useSelect({
    buttonRef: handleButtonRef,
    defaultValue,
    disabled: disabledProp,
    listboxId: (_componentsProps$list2 = componentsProps.listbox) == null ? void 0 : _componentsProps$list2.id,
    listboxRef: handleListboxRef,
    multiple: false,
    onChange,
    onOpenChange: handleOpenChange,
    open: listboxOpen,
    options,
    value: valueProp
  });

  const ownerState = _extends({}, props, {
    active: buttonActive,
    defaultListboxOpen,
    disabled,
    focusVisible: buttonFocusVisible,
    open: listboxOpen,
    renderValue,
    value
  });

  const classes = useUtilityClasses$8(ownerState);
  const selectedOptions = React__namespace.useMemo(() => {
    return options.find(o => value === o.value);
  }, [options, value]);
  const buttonProps = appendOwnerState(Button, _extends({}, getButtonProps(), other, componentsProps.root, {
    className: clsx(className, (_componentsProps$root = componentsProps.root) == null ? void 0 : _componentsProps$root.className, classes.root)
  }), ownerState);
  const listboxProps = appendOwnerState(ListboxRoot, _extends({}, getListboxProps(), componentsProps.listbox, {
    className: clsx((_componentsProps$list3 = componentsProps.listbox) == null ? void 0 : _componentsProps$list3.className, classes.listbox)
  }), ownerState); // Popper must be a (non-host) component, therefore ownerState will be present within the props

  const popperProps = appendOwnerState(Popper, _extends({
    open: listboxOpen,
    anchorEl: buttonRef.current,
    placement: 'bottom-start',
    disablePortal: true,
    role: undefined
  }, componentsProps.popper, {
    className: clsx((_componentsProps$popp = componentsProps.popper) == null ? void 0 : _componentsProps$popp.className, classes.popper)
  }), ownerState);
  const context = {
    getOptionProps,
    getOptionState,
    listboxRef
  };
  return /*#__PURE__*/jsxRuntime.exports.jsxs(React__namespace.Fragment, {
    children: [/*#__PURE__*/jsxRuntime.exports.jsx(Button, _extends({}, buttonProps, {
      children: renderValue(selectedOptions)
    })), buttonDefined && /*#__PURE__*/jsxRuntime.exports.jsx(Popper, _extends({}, popperProps, {
      children: /*#__PURE__*/jsxRuntime.exports.jsx(ListboxRoot, _extends({}, listboxProps, {
        children: /*#__PURE__*/jsxRuntime.exports.jsx(SelectUnstyledContext.Provider, {
          value: context,
          children: children
        })
      }))
    }))]
  });
});
process.env.NODE_ENV !== "production" ? SelectUnstyled.propTypes
/* remove-proptypes */
= {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------

  /**
   * If `true`, the select element is focused during the first mount
   * @default false
   */
  autoFocus: propTypes.exports.bool,

  /**
   * @ignore
   */
  children: propTypes.exports.node,

  /**
   * @ignore
   */
  className: propTypes.exports.string,

  /**
   * @ignore
   */
  component: propTypes.exports.elementType,

  /**
   * The components used for each slot inside the Select.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  components: propTypes.exports
  /* @typescript-to-proptypes-ignore */
  .shape({
    Listbox: propTypes.exports.elementType,
    Popper: propTypes.exports.elementType,
    Root: propTypes.exports.elementType
  }),

  /**
   * The props used for each slot inside the Input.
   * @default {}
   */
  componentsProps: propTypes.exports.shape({
    listbox: propTypes.exports.object,
    popper: propTypes.exports.object,
    root: propTypes.exports.object
  }),

  /**
   * If `true`, the select will be initially open.
   * @default false
   */
  defaultListboxOpen: propTypes.exports.bool,

  /**
   * The default selected value. Use when the component is not controlled.
   */
  defaultValue: propTypes.exports
  /* @typescript-to-proptypes-ignore */
  .any,

  /**
   * If `true`, the select is disabled.
   * @default false
   */
  disabled: propTypes.exports.bool,

  /**
   * Controls the open state of the select's listbox.
   * @default undefined
   */
  listboxOpen: propTypes.exports.bool,

  /**
   * Callback fired when an option is selected.
   */
  onChange: propTypes.exports.func,

  /**
   * Callback fired when the component requests to be opened.
   * Use in controlled mode (see listboxOpen).
   */
  onListboxOpenChange: propTypes.exports.func,

  /**
   * Function that customizes the rendering of the selected value.
   */
  renderValue: propTypes.exports.func,

  /**
   * The selected value.
   * Set to `null` to deselect all options.
   */
  value: propTypes.exports
  /* @typescript-to-proptypes-ignore */
  .any
} : void 0;

function getSliderUtilityClass(slot) {
  return generateUtilityClass('MuiSlider', slot);
}
const sliderUnstyledClasses = generateUtilityClasses('MuiSlider', ['root', 'active', 'focusVisible', 'disabled', 'dragging', 'marked', 'vertical', 'trackInverted', 'trackFalse', 'rail', 'track', 'mark', 'markActive', 'markLabel', 'markLabelActive', 'thumb', 'valueLabel', 'valueLabelOpen', 'valueLabelCircle', 'valueLabelLabel']);

const useValueLabelClasses = props => {
  const {
    open
  } = props;
  const utilityClasses = {
    offset: clsx(open && sliderUnstyledClasses.valueLabelOpen),
    circle: sliderUnstyledClasses.valueLabelCircle,
    label: sliderUnstyledClasses.valueLabelLabel
  };
  return utilityClasses;
};
/**
 * @ignore - internal component.
 */


function SliderValueLabelUnstyled(props) {
  const {
    children,
    className,
    value,
    theme
  } = props;
  const classes = useValueLabelClasses(props);
  return /*#__PURE__*/React__namespace.cloneElement(children, {
    className: clsx(children.props.className)
  }, /*#__PURE__*/jsxRuntime.exports.jsxs(React__namespace.Fragment, {
    children: [children.props.children, /*#__PURE__*/jsxRuntime.exports.jsx("span", {
      className: clsx(classes.offset, className),
      theme: theme,
      "aria-hidden": true,
      children: /*#__PURE__*/jsxRuntime.exports.jsx("span", {
        className: classes.circle,
        children: /*#__PURE__*/jsxRuntime.exports.jsx("span", {
          className: classes.label,
          children: value
        })
      })
    })]
  }));
}

process.env.NODE_ENV !== "production" ? SliderValueLabelUnstyled.propTypes = {
  children: propTypes.exports.element.isRequired,
  className: propTypes.exports.string,
  theme: propTypes.exports.any,
  value: propTypes.exports.node
} : void 0;

const INTENTIONAL_DRAG_COUNT_THRESHOLD = 2;

function asc(a, b) {
  return a - b;
}

function clamp$1(value, min, max) {
  if (value == null) {
    return min;
  }

  return Math.min(Math.max(min, value), max);
}

function findClosest(values, currentValue) {
  var _values$reduce;

  const {
    index: closestIndex
  } = (_values$reduce = values.reduce((acc, value, index) => {
    const distance = Math.abs(currentValue - value);

    if (acc === null || distance < acc.distance || distance === acc.distance) {
      return {
        distance,
        index
      };
    }

    return acc;
  }, null)) != null ? _values$reduce : {};
  return closestIndex;
}

function trackFinger(event, touchId) {
  // The event is TouchEvent
  if (touchId.current !== undefined && event.changedTouches) {
    const touchEvent = event;

    for (let i = 0; i < touchEvent.changedTouches.length; i += 1) {
      const touch = touchEvent.changedTouches[i];

      if (touch.identifier === touchId.current) {
        return {
          x: touch.clientX,
          y: touch.clientY
        };
      }
    }

    return false;
  } // The event is MouseEvent


  return {
    x: event.clientX,
    y: event.clientY
  };
}

function valueToPercent(value, min, max) {
  return (value - min) * 100 / (max - min);
}

function percentToValue(percent, min, max) {
  return (max - min) * percent + min;
}

function getDecimalPrecision(num) {
  // This handles the case when num is very small (0.00000001), js will turn this into 1e-8.
  // When num is bigger than 1 or less than -1 it won't get converted to this notation so it's fine.
  if (Math.abs(num) < 1) {
    const parts = num.toExponential().split('e-');
    const matissaDecimalPart = parts[0].split('.')[1];
    return (matissaDecimalPart ? matissaDecimalPart.length : 0) + parseInt(parts[1], 10);
  }

  const decimalPart = num.toString().split('.')[1];
  return decimalPart ? decimalPart.length : 0;
}

function roundValueToStep(value, step, min) {
  const nearest = Math.round((value - min) / step) * step + min;
  return Number(nearest.toFixed(getDecimalPrecision(step)));
}

function setValueIndex({
  values,
  newValue,
  index
}) {
  const output = values.slice();
  output[index] = newValue;
  return output.sort(asc);
}

function focusThumb({
  sliderRef,
  activeIndex,
  setActive
}) {
  var _sliderRef$current, _doc$activeElement;

  const doc = ownerDocument(sliderRef.current);

  if (!((_sliderRef$current = sliderRef.current) != null && _sliderRef$current.contains(doc.activeElement)) || Number(doc == null ? void 0 : (_doc$activeElement = doc.activeElement) == null ? void 0 : _doc$activeElement.getAttribute('data-index')) !== activeIndex) {
    var _sliderRef$current2;

    (_sliderRef$current2 = sliderRef.current) == null ? void 0 : _sliderRef$current2.querySelector(`[type="range"][data-index="${activeIndex}"]`).focus();
  }

  if (setActive) {
    setActive(activeIndex);
  }
}

const axisProps = {
  horizontal: {
    offset: percent => ({
      left: `${percent}%`
    }),
    leap: percent => ({
      width: `${percent}%`
    })
  },
  'horizontal-reverse': {
    offset: percent => ({
      right: `${percent}%`
    }),
    leap: percent => ({
      width: `${percent}%`
    })
  },
  vertical: {
    offset: percent => ({
      bottom: `${percent}%`
    }),
    leap: percent => ({
      height: `${percent}%`
    })
  }
};
const Identity$1 = x => x; // TODO: remove support for Safari < 13.
// https://caniuse.com/#search=touch-action
//
// Safari, on iOS, supports touch action since v13.
// Over 80% of the iOS phones are compatible
// in August 2020.
// Utilizing the CSS.supports method to check if touch-action is supported.
// Since CSS.supports is supported on all but Edge@12 and IE and touch-action
// is supported on both Edge@12 and IE if CSS.supports is not available that means that
// touch-action will be supported

let cachedSupportsTouchActionNone;

function doesSupportTouchActionNone() {
  if (cachedSupportsTouchActionNone === undefined) {
    if (typeof CSS !== 'undefined' && typeof CSS.supports === 'function') {
      cachedSupportsTouchActionNone = CSS.supports('touch-action', 'none');
    } else {
      cachedSupportsTouchActionNone = true;
    }
  }

  return cachedSupportsTouchActionNone;
}

function useSlider(parameters) {
  const {
    'aria-labelledby': ariaLabelledby,
    defaultValue,
    disabled = false,
    disableSwap = false,
    isRtl = false,
    marks: marksProp = false,
    max = 100,
    min = 0,
    name,
    onChange,
    onChangeCommitted,
    orientation = 'horizontal',
    ref,
    scale = Identity$1,
    step = 1,
    tabIndex,
    value: valueProp
  } = parameters;
  const touchId = React__namespace.useRef(); // We can't use the :active browser pseudo-classes.
  // - The active state isn't triggered when clicking on the rail.
  // - The active state isn't transferred when inversing a range slider.

  const [active, setActive] = React__namespace.useState(-1);
  const [open, setOpen] = React__namespace.useState(-1);
  const [dragging, setDragging] = React__namespace.useState(false);
  const moveCount = React__namespace.useRef(0);
  const [valueDerived, setValueState] = useControlled({
    controlled: valueProp,
    default: defaultValue != null ? defaultValue : min,
    name: 'Slider'
  });

  const handleChange = onChange && ((event, value, thumbIndex) => {
    // Redefine target to allow name and value to be read.
    // This allows seamless integration with the most popular form libraries.
    // https://github.com/mui/material-ui/issues/13485#issuecomment-676048492
    // Clone the event to not override `target` of the original event.
    const nativeEvent = event.nativeEvent || event; // @ts-ignore The nativeEvent is function, not object

    const clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
    Object.defineProperty(clonedEvent, 'target', {
      writable: true,
      value: {
        value,
        name
      }
    });
    onChange(clonedEvent, value, thumbIndex);
  });

  const range = Array.isArray(valueDerived);
  let values = range ? valueDerived.slice().sort(asc) : [valueDerived];
  values = values.map(value => clamp$1(value, min, max));
  const marks = marksProp === true && step !== null ? [...Array(Math.floor((max - min) / step) + 1)].map((_, index) => ({
    value: min + step * index
  })) : marksProp || [];
  const marksValues = marks.map(mark => mark.value);
  const {
    isFocusVisibleRef,
    onBlur: handleBlurVisible,
    onFocus: handleFocusVisible,
    ref: focusVisibleRef
  } = useIsFocusVisible();
  const [focusVisible, setFocusVisible] = React__namespace.useState(-1);
  const sliderRef = React__namespace.useRef();
  const handleFocusRef = useForkRef(focusVisibleRef, sliderRef);
  const handleRef = useForkRef(ref, handleFocusRef);

  const createHandleHiddenInputFocus = otherHandlers => event => {
    var _otherHandlers$onFocu;

    const index = Number(event.currentTarget.getAttribute('data-index'));
    handleFocusVisible(event);

    if (isFocusVisibleRef.current === true) {
      setFocusVisible(index);
    }

    setOpen(index);
    otherHandlers == null ? void 0 : (_otherHandlers$onFocu = otherHandlers.onFocus) == null ? void 0 : _otherHandlers$onFocu.call(otherHandlers, event);
  };

  const createHandleHiddenInputBlur = otherHandlers => event => {
    var _otherHandlers$onBlur;

    handleBlurVisible(event);

    if (isFocusVisibleRef.current === false) {
      setFocusVisible(-1);
    }

    setOpen(-1);
    otherHandlers == null ? void 0 : (_otherHandlers$onBlur = otherHandlers.onBlur) == null ? void 0 : _otherHandlers$onBlur.call(otherHandlers, event);
  };

  useEnhancedEffect(() => {
    if (disabled && sliderRef.current.contains(document.activeElement)) {
      var _document$activeEleme;

      // This is necessary because Firefox and Safari will keep focus
      // on a disabled element:
      // https://codesandbox.io/s/mui-pr-22247-forked-h151h?file=/src/App.js
      // @ts-ignore
      (_document$activeEleme = document.activeElement) == null ? void 0 : _document$activeEleme.blur();
    }
  }, [disabled]);

  if (disabled && active !== -1) {
    setActive(-1);
  }

  if (disabled && focusVisible !== -1) {
    setFocusVisible(-1);
  }

  const createHandleHiddenInputChange = otherHandlers => event => {
    var _otherHandlers$onChan;

    (_otherHandlers$onChan = otherHandlers.onChange) == null ? void 0 : _otherHandlers$onChan.call(otherHandlers, event);
    const index = Number(event.currentTarget.getAttribute('data-index'));
    const value = values[index];
    const marksIndex = marksValues.indexOf(value); // @ts-ignore

    let newValue = event.target.valueAsNumber;

    if (marks && step == null) {
      newValue = newValue < value ? marksValues[marksIndex - 1] : marksValues[marksIndex + 1];
    }

    newValue = clamp$1(newValue, min, max);

    if (marks && step == null) {
      const currentMarkIndex = marksValues.indexOf(values[index]);
      newValue = newValue < values[index] ? marksValues[currentMarkIndex - 1] : marksValues[currentMarkIndex + 1];
    }

    if (range) {
      // Bound the new value to the thumb's neighbours.
      if (disableSwap) {
        newValue = clamp$1(newValue, values[index - 1] || -Infinity, values[index + 1] || Infinity);
      }

      const previousValue = newValue;
      newValue = setValueIndex({
        values,
        newValue,
        index
      });
      let activeIndex = index; // Potentially swap the index if needed.

      if (!disableSwap) {
        activeIndex = newValue.indexOf(previousValue);
      }

      focusThumb({
        sliderRef,
        activeIndex
      });
    }

    setValueState(newValue);
    setFocusVisible(index);

    if (handleChange) {
      handleChange(event, newValue, index);
    }

    if (onChangeCommitted) {
      onChangeCommitted(event, newValue);
    }
  };

  const previousIndex = React__namespace.useRef();
  let axis = orientation;

  if (isRtl && orientation === 'horizontal') {
    axis += '-reverse';
  }

  const getFingerNewValue = ({
    finger,
    move = false,
    values: values2
  }) => {
    const {
      current: slider
    } = sliderRef;
    const {
      width,
      height,
      bottom,
      left
    } = slider.getBoundingClientRect();
    let percent;

    if (axis.indexOf('vertical') === 0) {
      percent = (bottom - finger.y) / height;
    } else {
      percent = (finger.x - left) / width;
    }

    if (axis.indexOf('-reverse') !== -1) {
      percent = 1 - percent;
    }

    let newValue;
    newValue = percentToValue(percent, min, max);

    if (step) {
      newValue = roundValueToStep(newValue, step, min);
    } else {
      const closestIndex = findClosest(marksValues, newValue);
      newValue = marksValues[closestIndex];
    }

    newValue = clamp$1(newValue, min, max);
    let activeIndex = 0;

    if (range) {
      if (!move) {
        activeIndex = findClosest(values2, newValue);
      } else {
        activeIndex = previousIndex.current;
      } // Bound the new value to the thumb's neighbours.


      if (disableSwap) {
        newValue = clamp$1(newValue, values2[activeIndex - 1] || -Infinity, values2[activeIndex + 1] || Infinity);
      }

      const previousValue = newValue;
      newValue = setValueIndex({
        values: values2,
        newValue,
        index: activeIndex
      }); // Potentially swap the index if needed.

      if (!(disableSwap && move)) {
        activeIndex = newValue.indexOf(previousValue);
        previousIndex.current = activeIndex;
      }
    }

    return {
      newValue,
      activeIndex
    };
  };

  const handleTouchMove = useEventCallback(nativeEvent => {
    const finger = trackFinger(nativeEvent, touchId);

    if (!finger) {
      return;
    }

    moveCount.current += 1; // Cancel move in case some other element consumed a mouseup event and it was not fired.
    // @ts-ignore buttons doesn't not exists on touch event

    if (nativeEvent.type === 'mousemove' && nativeEvent.buttons === 0) {
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      handleTouchEnd(nativeEvent);
      return;
    }

    const {
      newValue,
      activeIndex
    } = getFingerNewValue({
      finger,
      move: true,
      values
    });
    focusThumb({
      sliderRef,
      activeIndex,
      setActive
    });
    setValueState(newValue);

    if (!dragging && moveCount.current > INTENTIONAL_DRAG_COUNT_THRESHOLD) {
      setDragging(true);
    }

    if (handleChange) {
      handleChange(nativeEvent, newValue, activeIndex);
    }
  });
  const handleTouchEnd = useEventCallback(nativeEvent => {
    const finger = trackFinger(nativeEvent, touchId);
    setDragging(false);

    if (!finger) {
      return;
    }

    const {
      newValue
    } = getFingerNewValue({
      finger,
      move: true,
      values
    });
    setActive(-1);

    if (nativeEvent.type === 'touchend') {
      setOpen(-1);
    }

    if (onChangeCommitted) {
      onChangeCommitted(nativeEvent, newValue);
    }

    touchId.current = undefined; // eslint-disable-next-line @typescript-eslint/no-use-before-define

    stopListening();
  });
  const handleTouchStart = useEventCallback(nativeEvent => {
    if (disabled) {
      return;
    } // If touch-action: none; is not supported we need to prevent the scroll manually.


    if (!doesSupportTouchActionNone()) {
      nativeEvent.preventDefault();
    }

    const touch = nativeEvent.changedTouches[0];

    if (touch != null) {
      // A number that uniquely identifies the current finger in the touch session.
      touchId.current = touch.identifier;
    }

    const finger = trackFinger(nativeEvent, touchId);

    if (finger !== false) {
      const {
        newValue,
        activeIndex
      } = getFingerNewValue({
        finger,
        values
      });
      focusThumb({
        sliderRef,
        activeIndex,
        setActive
      });
      setValueState(newValue);

      if (handleChange) {
        handleChange(nativeEvent, newValue, activeIndex);
      }
    }

    moveCount.current = 0;
    const doc = ownerDocument(sliderRef.current);
    doc.addEventListener('touchmove', handleTouchMove);
    doc.addEventListener('touchend', handleTouchEnd);
  });
  const stopListening = React__namespace.useCallback(() => {
    const doc = ownerDocument(sliderRef.current);
    doc.removeEventListener('mousemove', handleTouchMove);
    doc.removeEventListener('mouseup', handleTouchEnd);
    doc.removeEventListener('touchmove', handleTouchMove);
    doc.removeEventListener('touchend', handleTouchEnd);
  }, [handleTouchEnd, handleTouchMove]);
  React__namespace.useEffect(() => {
    const {
      current: slider
    } = sliderRef;
    slider.addEventListener('touchstart', handleTouchStart, {
      passive: doesSupportTouchActionNone()
    });
    return () => {
      // @ts-ignore
      slider.removeEventListener('touchstart', handleTouchStart, {
        passive: doesSupportTouchActionNone()
      });
      stopListening();
    };
  }, [stopListening, handleTouchStart]);
  React__namespace.useEffect(() => {
    if (disabled) {
      stopListening();
    }
  }, [disabled, stopListening]);

  const createHandleMouseDown = otherHandlers => event => {
    var _otherHandlers$onMous;

    (_otherHandlers$onMous = otherHandlers.onMouseDown) == null ? void 0 : _otherHandlers$onMous.call(otherHandlers, event);

    if (disabled) {
      return;
    }

    if (event.defaultPrevented) {
      return;
    } // Only handle left clicks


    if (event.button !== 0) {
      return;
    } // Avoid text selection


    event.preventDefault();
    const finger = trackFinger(event, touchId);

    if (finger !== false) {
      const {
        newValue,
        activeIndex
      } = getFingerNewValue({
        finger,
        values
      });
      focusThumb({
        sliderRef,
        activeIndex,
        setActive
      });
      setValueState(newValue);

      if (handleChange) {
        handleChange(event, newValue, activeIndex);
      }
    }

    moveCount.current = 0;
    const doc = ownerDocument(sliderRef.current);
    doc.addEventListener('mousemove', handleTouchMove);
    doc.addEventListener('mouseup', handleTouchEnd);
  };

  const trackOffset = valueToPercent(range ? values[0] : min, min, max);
  const trackLeap = valueToPercent(values[values.length - 1], min, max) - trackOffset;

  const getRootProps = (otherHandlers = {}) => {
    const ownEventHandlers = {
      onMouseDown: createHandleMouseDown(otherHandlers || {})
    };

    const mergedEventHandlers = _extends({}, otherHandlers, ownEventHandlers);

    return _extends({
      ref: handleRef
    }, mergedEventHandlers);
  };

  const createHandleMouseOver = otherHandlers => event => {
    var _otherHandlers$onMous2;

    (_otherHandlers$onMous2 = otherHandlers.onMouseOver) == null ? void 0 : _otherHandlers$onMous2.call(otherHandlers, event);
    const index = Number(event.currentTarget.getAttribute('data-index'));
    setOpen(index);
  };

  const createHandleMouseLeave = otherHandlers => event => {
    var _otherHandlers$onMous3;

    (_otherHandlers$onMous3 = otherHandlers.onMouseLeave) == null ? void 0 : _otherHandlers$onMous3.call(otherHandlers, event);
    setOpen(-1);
  };

  const getThumbProps = (otherHandlers = {}) => {
    const ownEventHandlers = {
      onMouseOver: createHandleMouseOver(otherHandlers || {}),
      onMouseLeave: createHandleMouseLeave(otherHandlers || {})
    };

    const mergedEventHandlers = _extends({}, otherHandlers, ownEventHandlers);

    return _extends({}, mergedEventHandlers);
  };

  const getHiddenInputProps = (otherHandlers = {}) => {
    const ownEventHandlers = {
      onChange: createHandleHiddenInputChange(otherHandlers || {}),
      onFocus: createHandleHiddenInputFocus(otherHandlers || {}),
      onBlur: createHandleHiddenInputBlur(otherHandlers || {})
    };

    const mergedEventHandlers = _extends({}, otherHandlers, ownEventHandlers);

    return _extends({
      tabIndex,
      'aria-labelledby': ariaLabelledby,
      'aria-orientation': orientation,
      'aria-valuemax': scale(max),
      'aria-valuemin': scale(min),
      name,
      type: 'range',
      min: parameters.min,
      max: parameters.max,
      step: parameters.step,
      disabled
    }, mergedEventHandlers, {
      style: _extends({}, visuallyHidden, {
        direction: isRtl ? 'rtl' : 'ltr',
        // So that VoiceOver's focus indicator matches the thumb's dimensions
        width: '100%',
        height: '100%'
      })
    });
  };

  return {
    active,
    axis,
    axisProps,
    dragging,
    focusVisible,
    getHiddenInputProps,
    getRootProps,
    getThumbProps,
    marks,
    open,
    range,
    trackLeap,
    trackOffset,
    values
  };
}

const _excluded$n = ["aria-label", "aria-valuetext", "className", "component", "classes", "disableSwap", "disabled", "getAriaLabel", "getAriaValueText", "marks", "max", "min", "name", "onChange", "onChangeCommitted", "onMouseDown", "orientation", "scale", "step", "tabIndex", "track", "value", "valueLabelDisplay", "valueLabelFormat", "isRtl", "components", "componentsProps"];

const Identity = x => x;

const useUtilityClasses$7 = ownerState => {
  const {
    disabled,
    dragging,
    marked,
    orientation,
    track,
    classes
  } = ownerState;
  const slots = {
    root: ['root', disabled && 'disabled', dragging && 'dragging', marked && 'marked', orientation === 'vertical' && 'vertical', track === 'inverted' && 'trackInverted', track === false && 'trackFalse'],
    rail: ['rail'],
    track: ['track'],
    mark: ['mark'],
    markActive: ['markActive'],
    markLabel: ['markLabel'],
    markLabelActive: ['markLabelActive'],
    valueLabel: ['valueLabel'],
    thumb: ['thumb', disabled && 'disabled'],
    active: ['active'],
    disabled: ['disabled'],
    focusVisible: ['focusVisible']
  };
  return composeClasses(slots, getSliderUtilityClass, classes);
};

const Forward = ({
  children
}) => children;

const SliderUnstyled = /*#__PURE__*/React__namespace.forwardRef(function SliderUnstyled(props, ref) {
  var _ref, _components$Rail, _components$Track, _components$Thumb, _components$ValueLabe, _components$Mark, _components$MarkLabel;

  const {
    'aria-label': ariaLabel,
    'aria-valuetext': ariaValuetext,
    className,
    component,
    classes: classesProp,
    disableSwap = false,
    disabled = false,
    getAriaLabel,
    getAriaValueText,
    marks: marksProp = false,
    max = 100,
    min = 0,
    onMouseDown,
    orientation = 'horizontal',
    scale = Identity,
    step = 1,
    track = 'normal',
    valueLabelDisplay = 'off',
    valueLabelFormat = Identity,
    isRtl = false,
    components = {},
    componentsProps = {}
  } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$n); // all props with defaults
  // consider extracting to hook an reusing the lint rule for the varints


  const ownerState = _extends({}, props, {
    marks: marksProp,
    classes: classesProp,
    disabled,
    isRtl,
    max,
    min,
    orientation,
    scale,
    step,
    track,
    valueLabelDisplay,
    valueLabelFormat
  });

  const {
    axisProps,
    getRootProps,
    getHiddenInputProps,
    getThumbProps,
    open,
    active,
    axis,
    range,
    focusVisible,
    dragging,
    marks,
    values,
    trackOffset,
    trackLeap
  } = useSlider(_extends({}, ownerState, {
    ref
  }));
  ownerState.marked = marks.length > 0 && marks.some(mark => mark.label);
  ownerState.dragging = dragging;
  const Root = (_ref = component != null ? component : components.Root) != null ? _ref : 'span';
  const rootProps = appendOwnerState(Root, _extends({}, other, componentsProps.root), ownerState);
  const Rail = (_components$Rail = components.Rail) != null ? _components$Rail : 'span';
  const railProps = appendOwnerState(Rail, componentsProps.rail, ownerState);
  const Track = (_components$Track = components.Track) != null ? _components$Track : 'span';
  const trackProps = appendOwnerState(Track, componentsProps.track, ownerState);

  const trackStyle = _extends({}, axisProps[axis].offset(trackOffset), axisProps[axis].leap(trackLeap));

  const Thumb = (_components$Thumb = components.Thumb) != null ? _components$Thumb : 'span';
  const thumbProps = appendOwnerState(Thumb, componentsProps.thumb, ownerState);
  const ValueLabel = (_components$ValueLabe = components.ValueLabel) != null ? _components$ValueLabe : SliderValueLabelUnstyled;
  const valueLabelProps = appendOwnerState(ValueLabel, componentsProps.valueLabel, ownerState);
  const Mark = (_components$Mark = components.Mark) != null ? _components$Mark : 'span';
  const markProps = appendOwnerState(Mark, componentsProps.mark, ownerState);
  const MarkLabel = (_components$MarkLabel = components.MarkLabel) != null ? _components$MarkLabel : 'span';
  const markLabelProps = appendOwnerState(MarkLabel, componentsProps.markLabel, ownerState);
  const Input = components.Input || 'input';
  const inputProps = appendOwnerState(Input, componentsProps.input, ownerState);
  const hiddenInputProps = getHiddenInputProps();
  const classes = useUtilityClasses$7(ownerState);
  return /*#__PURE__*/jsxRuntime.exports.jsxs(Root, _extends({}, rootProps, getRootProps({
    onMouseDown
  }), {
    className: clsx(classes.root, rootProps.className, className),
    children: [/*#__PURE__*/jsxRuntime.exports.jsx(Rail, _extends({}, railProps, {
      className: clsx(classes.rail, railProps.className)
    })), /*#__PURE__*/jsxRuntime.exports.jsx(Track, _extends({}, trackProps, {
      className: clsx(classes.track, trackProps.className),
      style: _extends({}, trackStyle, trackProps.style)
    })), marks.filter(mark => mark.value >= min && mark.value <= max).map((mark, index) => {
      const percent = valueToPercent(mark.value, min, max);
      const style = axisProps[axis].offset(percent);
      let markActive;

      if (track === false) {
        markActive = values.indexOf(mark.value) !== -1;
      } else {
        markActive = track === 'normal' && (range ? mark.value >= values[0] && mark.value <= values[values.length - 1] : mark.value <= values[0]) || track === 'inverted' && (range ? mark.value <= values[0] || mark.value >= values[values.length - 1] : mark.value >= values[0]);
      }

      return /*#__PURE__*/jsxRuntime.exports.jsxs(React__namespace.Fragment, {
        children: [/*#__PURE__*/jsxRuntime.exports.jsx(Mark, _extends({
          "data-index": index
        }, markProps, !isHostComponent(Mark) && {
          markActive
        }, {
          style: _extends({}, style, markProps.style),
          className: clsx(classes.mark, markProps.className, markActive && classes.markActive)
        })), mark.label != null ? /*#__PURE__*/jsxRuntime.exports.jsx(MarkLabel, _extends({
          "aria-hidden": true,
          "data-index": index
        }, markLabelProps, !isHostComponent(MarkLabel) && {
          markLabelActive: markActive
        }, {
          style: _extends({}, style, markLabelProps.style),
          className: clsx(classes.markLabel, markLabelProps.className, markActive && classes.markLabelActive),
          children: mark.label
        })) : null]
      }, mark.value);
    }), values.map((value, index) => {
      const percent = valueToPercent(value, min, max);
      const style = axisProps[axis].offset(percent);
      const ValueLabelComponent = valueLabelDisplay === 'off' ? Forward : ValueLabel;
      return /*#__PURE__*/jsxRuntime.exports.jsx(React__namespace.Fragment, {
        children: /*#__PURE__*/jsxRuntime.exports.jsx(ValueLabelComponent, _extends({}, !isHostComponent(ValueLabelComponent) && {
          valueLabelFormat,
          valueLabelDisplay,
          value: typeof valueLabelFormat === 'function' ? valueLabelFormat(scale(value), index) : valueLabelFormat,
          index,
          open: open === index || active === index || valueLabelDisplay === 'on',
          disabled
        }, valueLabelProps, {
          className: clsx(classes.valueLabel, valueLabelProps.className),
          children: /*#__PURE__*/jsxRuntime.exports.jsx(Thumb, _extends({
            "data-index": index
          }, thumbProps, getThumbProps(), {
            className: clsx(classes.thumb, thumbProps.className, active === index && classes.active, focusVisible === index && classes.focusVisible),
            style: _extends({}, style, {
              pointerEvents: disableSwap && active !== index ? 'none' : undefined
            }, thumbProps.style),
            children: /*#__PURE__*/jsxRuntime.exports.jsx(Input, _extends({}, hiddenInputProps, {
              "data-index": index,
              "aria-label": getAriaLabel ? getAriaLabel(index) : ariaLabel,
              "aria-valuenow": scale(value),
              "aria-valuetext": getAriaValueText ? getAriaValueText(scale(value), index) : ariaValuetext,
              value: values[index]
            }, !isHostComponent(Input) && {
              ownerState: _extends({}, ownerState, inputProps.ownerState)
            }, inputProps, {
              style: _extends({}, hiddenInputProps.style, inputProps.style)
            }))
          }))
        }))
      }, index);
    })]
  }));
});
process.env.NODE_ENV !== "production" ? SliderUnstyled.propTypes
/* remove-proptypes */
= {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------

  /**
   * The label of the slider.
   */
  'aria-label': chainPropTypes(propTypes.exports.string, props => {
    const range = Array.isArray(props.value || props.defaultValue);

    if (range && props['aria-label'] != null) {
      return new Error('MUI: You need to use the `getAriaLabel` prop instead of `aria-label` when using a range slider.');
    }

    return null;
  }),

  /**
   * The id of the element containing a label for the slider.
   */
  'aria-labelledby': propTypes.exports.string,

  /**
   * A string value that provides a user-friendly name for the current value of the slider.
   */
  'aria-valuetext': chainPropTypes(propTypes.exports.string, props => {
    const range = Array.isArray(props.value || props.defaultValue);

    if (range && props['aria-valuetext'] != null) {
      return new Error('MUI: You need to use the `getAriaValueText` prop instead of `aria-valuetext` when using a range slider.');
    }

    return null;
  }),

  /**
   * @ignore
   */
  children: propTypes.exports.node,

  /**
   * Override or extend the styles applied to the component.
   */
  classes: propTypes.exports.object,

  /**
   * @ignore
   */
  className: propTypes.exports.string,

  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: propTypes.exports.elementType,

  /**
   * The components used for each slot inside the Slider.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  components: propTypes.exports.shape({
    Input: propTypes.exports.elementType,
    Mark: propTypes.exports.elementType,
    MarkLabel: propTypes.exports.elementType,
    Rail: propTypes.exports.elementType,
    Root: propTypes.exports.elementType,
    Thumb: propTypes.exports.elementType,
    Track: propTypes.exports.elementType,
    ValueLabel: propTypes.exports.elementType
  }),

  /**
   * The props used for each slot inside the Slider.
   * @default {}
   */
  componentsProps: propTypes.exports.shape({
    input: propTypes.exports.object,
    mark: propTypes.exports.object,
    markLabel: propTypes.exports.object,
    rail: propTypes.exports.object,
    root: propTypes.exports.object,
    thumb: propTypes.exports.object,
    track: propTypes.exports.object,
    valueLabel: propTypes.exports.shape({
      className: propTypes.exports.string,
      components: propTypes.exports.shape({
        Root: propTypes.exports.elementType
      }),
      style: propTypes.exports.object,
      value: propTypes.exports.oneOfType([propTypes.exports.arrayOf(propTypes.exports.number), propTypes.exports.number]),
      valueLabelDisplay: propTypes.exports.oneOf(['auto', 'off', 'on'])
    })
  }),

  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: propTypes.exports.oneOfType([propTypes.exports.arrayOf(propTypes.exports.number), propTypes.exports.number]),

  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: propTypes.exports.bool,

  /**
   * If `true`, the active thumb doesn't swap when moving pointer over a thumb while dragging another thumb.
   * @default false
   */
  disableSwap: propTypes.exports.bool,

  /**
   * Accepts a function which returns a string value that provides a user-friendly name for the thumb labels of the slider.
   * This is important for screen reader users.
   * @param {number} index The thumb label's index to format.
   * @returns {string}
   */
  getAriaLabel: propTypes.exports.func,

  /**
   * Accepts a function which returns a string value that provides a user-friendly name for the current value of the slider.
   * This is important for screen reader users.
   * @param {number} value The thumb label's value to format.
   * @param {number} index The thumb label's index to format.
   * @returns {string}
   */
  getAriaValueText: propTypes.exports.func,

  /**
   * Indicates whether the theme context has rtl direction. It is set automatically.
   * @default false
   */
  isRtl: propTypes.exports.bool,

  /**
   * Marks indicate predetermined values to which the user can move the slider.
   * If `true` the marks are spaced according the value of the `step` prop.
   * If an array, it should contain objects with `value` and an optional `label` keys.
   * @default false
   */
  marks: propTypes.exports.oneOfType([propTypes.exports.arrayOf(propTypes.exports.shape({
    label: propTypes.exports.node,
    value: propTypes.exports.number.isRequired
  })), propTypes.exports.bool]),

  /**
   * The maximum allowed value of the slider.
   * Should not be equal to min.
   * @default 100
   */
  max: propTypes.exports.number,

  /**
   * The minimum allowed value of the slider.
   * Should not be equal to max.
   * @default 0
   */
  min: propTypes.exports.number,

  /**
   * Name attribute of the hidden `input` element.
   */
  name: propTypes.exports.string,

  /**
   * Callback function that is fired when the slider's value changed.
   *
   * @param {Event} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (any).
   * **Warning**: This is a generic event not a change event.
   * @param {number | number[]} value The new value.
   * @param {number} activeThumb Index of the currently moved thumb.
   */
  onChange: propTypes.exports.func,

  /**
   * Callback function that is fired when the `mouseup` is triggered.
   *
   * @param {React.SyntheticEvent | Event} event The event source of the callback. **Warning**: This is a generic event not a change event.
   * @param {number | number[]} value The new value.
   */
  onChangeCommitted: propTypes.exports.func,

  /**
   * @ignore
   */
  onMouseDown: propTypes.exports.func,

  /**
   * The component orientation.
   * @default 'horizontal'
   */
  orientation: propTypes.exports.oneOf(['horizontal', 'vertical']),

  /**
   * A transformation function, to change the scale of the slider.
   * @default (x) => x
   */
  scale: propTypes.exports.func,

  /**
   * The granularity with which the slider can step through values. (A "discrete" slider.)
   * The `min` prop serves as the origin for the valid values.
   * We recommend (max - min) to be evenly divisible by the step.
   *
   * When step is `null`, the thumb can only be slid onto marks provided with the `marks` prop.
   * @default 1
   */
  step: propTypes.exports.number,

  /**
   * Tab index attribute of the hidden `input` element.
   */
  tabIndex: propTypes.exports.number,

  /**
   * The track presentation:
   *
   * - `normal` the track will render a bar representing the slider value.
   * - `inverted` the track will render a bar representing the remaining slider value.
   * - `false` the track will render without a bar.
   * @default 'normal'
   */
  track: propTypes.exports.oneOf(['inverted', 'normal', false]),

  /**
   * The value of the slider.
   * For ranged sliders, provide an array with two values.
   */
  value: propTypes.exports.oneOfType([propTypes.exports.arrayOf(propTypes.exports.number), propTypes.exports.number]),

  /**
   * Controls when the value label is displayed:
   *
   * - `auto` the value label will display when the thumb is hovered or focused.
   * - `on` will display persistently.
   * - `off` will never display.
   * @default 'off'
   */
  valueLabelDisplay: propTypes.exports.oneOf(['auto', 'off', 'on']),

  /**
   * The format function the value label's value.
   *
   * When a function is provided, it should have the following signature:
   *
   * - {number} value The value label's value to format
   * - {number} index The value label's index to format
   * @default (x) => x
   */
  valueLabelFormat: propTypes.exports.oneOfType([propTypes.exports.func, propTypes.exports.string])
} : void 0;

/**
 * The basic building block for creating custom switches.
 *
 * Demos:
 *
 * - [Switches](https://mui.com/components/switches/)
 */
function useSwitch(props) {
  const {
    checked: checkedProp,
    defaultChecked,
    disabled,
    onBlur,
    onChange,
    onFocus,
    onFocusVisible,
    readOnly,
    required
  } = props;
  const [checked, setCheckedState] = useControlled({
    controlled: checkedProp,
    default: Boolean(defaultChecked),
    name: 'Switch',
    state: 'checked'
  });

  const createHandleInputChange = otherProps => event => {
    var _otherProps$onChange;

    // Workaround for https://github.com/facebook/react/issues/9023
    if (event.nativeEvent.defaultPrevented) {
      return;
    }

    setCheckedState(event.target.checked);
    onChange == null ? void 0 : onChange(event);
    (_otherProps$onChange = otherProps.onChange) == null ? void 0 : _otherProps$onChange.call(otherProps, event);
  };

  const {
    isFocusVisibleRef,
    onBlur: handleBlurVisible,
    onFocus: handleFocusVisible,
    ref: focusVisibleRef
  } = useIsFocusVisible();
  const [focusVisible, setFocusVisible] = React__namespace.useState(false);

  if (disabled && focusVisible) {
    setFocusVisible(false);
  }

  React__namespace.useEffect(() => {
    isFocusVisibleRef.current = focusVisible;
  }, [focusVisible, isFocusVisibleRef]);
  const inputRef = React__namespace.useRef(null);

  const createHandleFocus = otherProps => event => {
    var _otherProps$onFocus;

    // Fix for https://github.com/facebook/react/issues/7769
    if (!inputRef.current) {
      inputRef.current = event.currentTarget;
    }

    handleFocusVisible(event);

    if (isFocusVisibleRef.current === true) {
      setFocusVisible(true);
      onFocusVisible == null ? void 0 : onFocusVisible(event);
    }

    onFocus == null ? void 0 : onFocus(event);
    (_otherProps$onFocus = otherProps.onFocus) == null ? void 0 : _otherProps$onFocus.call(otherProps, event);
  };

  const createHandleBlur = otherProps => event => {
    var _otherProps$onBlur;

    handleBlurVisible(event);

    if (isFocusVisibleRef.current === false) {
      setFocusVisible(false);
    }

    onBlur == null ? void 0 : onBlur(event);
    (_otherProps$onBlur = otherProps.onBlur) == null ? void 0 : _otherProps$onBlur.call(otherProps, event);
  };

  const handleRefChange = useForkRef(focusVisibleRef, inputRef);

  const getInputProps = (otherProps = {}) => _extends({
    checked: checkedProp,
    defaultChecked,
    disabled,
    readOnly,
    ref: handleRefChange,
    required,
    type: 'checkbox'
  }, otherProps, {
    onChange: createHandleInputChange(otherProps),
    onFocus: createHandleFocus(otherProps),
    onBlur: createHandleBlur(otherProps)
  });

  return {
    checked,
    disabled: Boolean(disabled),
    focusVisible,
    getInputProps,
    readOnly: Boolean(readOnly)
  };
}

const switchUnstyledClasses = generateUtilityClasses('MuiSwitch', ['root', 'input', 'track', 'thumb', 'checked', 'disabled', 'focusVisible', 'readOnly']);

const _excluded$m = ["checked", "className", "component", "components", "componentsProps", "defaultChecked", "disabled", "onBlur", "onChange", "onFocus", "onFocusVisible", "readOnly", "required"];
const SwitchUnstyled = /*#__PURE__*/React__namespace.forwardRef(function SwitchUnstyled(props, ref) {
  var _ref, _components$Thumb, _components$Input, _components$Track;

  const {
    checked: checkedProp,
    className,
    component,
    components = {},
    componentsProps = {},
    defaultChecked,
    disabled: disabledProp,
    onBlur,
    onChange,
    onFocus,
    onFocusVisible,
    readOnly: readOnlyProp
  } = props,
        otherProps = _objectWithoutPropertiesLoose(props, _excluded$m);

  const useSwitchProps = {
    checked: checkedProp,
    defaultChecked,
    disabled: disabledProp,
    onBlur,
    onChange,
    onFocus,
    onFocusVisible,
    readOnly: readOnlyProp
  };
  const {
    getInputProps,
    checked,
    disabled,
    focusVisible,
    readOnly
  } = useSwitch(useSwitchProps);

  const ownerState = _extends({}, props, {
    checked,
    disabled,
    focusVisible,
    readOnly
  });

  const stateClasses = clsx(checked && switchUnstyledClasses.checked, disabled && switchUnstyledClasses.disabled, focusVisible && switchUnstyledClasses.focusVisible, readOnly && switchUnstyledClasses.readOnly);
  const Root = (_ref = component != null ? component : components.Root) != null ? _ref : 'span';
  const rootComponentProps = resolveComponentProps(componentsProps.root, ownerState);
  const rootProps = appendOwnerState(Root, _extends({}, otherProps, rootComponentProps, {
    className: clsx(switchUnstyledClasses.root, stateClasses, className, rootComponentProps == null ? void 0 : rootComponentProps.className)
  }), ownerState);
  const Thumb = (_components$Thumb = components.Thumb) != null ? _components$Thumb : 'span';
  const thumbComponentProps = resolveComponentProps(componentsProps.thumb, ownerState);
  const thumbProps = appendOwnerState(Thumb, _extends({}, thumbComponentProps, {
    className: clsx(switchUnstyledClasses.thumb, thumbComponentProps == null ? void 0 : thumbComponentProps.className)
  }), ownerState);
  const Input = (_components$Input = components.Input) != null ? _components$Input : 'input';
  const inputComponentProps = resolveComponentProps(componentsProps.input, ownerState);
  const inputProps = appendOwnerState(Input, _extends({}, getInputProps(), inputComponentProps, {
    className: clsx(switchUnstyledClasses.input, inputComponentProps == null ? void 0 : inputComponentProps.className)
  }), ownerState);
  const Track = components.Track === null ? () => null : (_components$Track = components.Track) != null ? _components$Track : 'span';
  const trackComponentProps = resolveComponentProps(componentsProps.track, ownerState);
  const trackProps = appendOwnerState(Track, _extends({}, trackComponentProps, {
    className: clsx(switchUnstyledClasses.track, trackComponentProps == null ? void 0 : trackComponentProps.className)
  }), ownerState);
  return /*#__PURE__*/jsxRuntime.exports.jsxs(Root, _extends({
    ref: ref
  }, rootProps, {
    children: [/*#__PURE__*/jsxRuntime.exports.jsx(Track, _extends({}, trackProps)), /*#__PURE__*/jsxRuntime.exports.jsx(Thumb, _extends({}, thumbProps)), /*#__PURE__*/jsxRuntime.exports.jsx(Input, _extends({}, inputProps))]
  }));
});
process.env.NODE_ENV !== "production" ? SwitchUnstyled.propTypes
/* remove-proptypes */
= {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------

  /**
   * If `true`, the component is checked.
   */
  checked: propTypes.exports.bool,

  /**
   * Class name applied to the root element.
   */
  className: propTypes.exports.string,

  /**
   * The component used for the Root slot.
   * Either a string to use a HTML element or a component.
   * This is equivalent to `components.Root`. If both are provided, the `component` is used.
   */
  component: propTypes.exports.elementType,

  /**
   * The components used for each slot inside the Switch.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  components: propTypes.exports
  /* @typescript-to-proptypes-ignore */
  .shape({
    Input: propTypes.exports.elementType,
    Root: propTypes.exports.elementType,
    Thumb: propTypes.exports.elementType,
    Track: propTypes.exports.oneOfType([propTypes.exports.elementType, propTypes.exports.oneOf([null])])
  }),

  /**
   * The props used for each slot inside the Switch.
   * @default {}
   */
  componentsProps: propTypes.exports.shape({
    input: propTypes.exports.oneOfType([propTypes.exports.func, propTypes.exports.object]),
    root: propTypes.exports.oneOfType([propTypes.exports.func, propTypes.exports.object]),
    thumb: propTypes.exports.oneOfType([propTypes.exports.func, propTypes.exports.object]),
    track: propTypes.exports.oneOfType([propTypes.exports.func, propTypes.exports.object])
  }),

  /**
   * The default checked state. Use when the component is not controlled.
   */
  defaultChecked: propTypes.exports.bool,

  /**
   * If `true`, the component is disabled.
   */
  disabled: propTypes.exports.bool,

  /**
   * @ignore
   */
  onBlur: propTypes.exports.func,

  /**
   * Callback fired when the state is changed.
   *
   * @param {React.ChangeEvent<HTMLInputElement>} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   * You can pull out the new checked state by accessing `event.target.checked` (boolean).
   */
  onChange: propTypes.exports.func,

  /**
   * @ignore
   */
  onFocus: propTypes.exports.func,

  /**
   * @ignore
   */
  onFocusVisible: propTypes.exports.func,

  /**
   * If `true`, the component is read only.
   */
  readOnly: propTypes.exports.bool,

  /**
   * If `true`, the `input` element is required.
   */
  required: propTypes.exports.bool
} : void 0;

function getTabPanelUnstyledUtilityClass(slot) {
  return generateUtilityClass('TabPanelUnstyled', slot);
}
generateUtilityClasses('TabPanelUnstyled', ['root', 'hidden']);

function getTabsUnstyledUtilityClass(slot) {
  return generateUtilityClass('TabsUnstyled', slot);
}
generateUtilityClasses('TabsUnstyled', ['root', 'horizontal', 'vertical']);

const useTabs = parameters => {
  const {
    value: valueProp,
    defaultValue,
    onChange,
    orientation,
    direction,
    selectionFollowsFocus
  } = parameters;
  const [value, setValue] = useControlled({
    controlled: valueProp,
    default: defaultValue,
    name: 'Tabs',
    state: 'value'
  });
  const idPrefix = useId();
  const onSelected = React__namespace.useCallback((e, newValue) => {
    setValue(newValue);

    if (onChange) {
      onChange(e, newValue);
    }
  }, [onChange, setValue]);
  const tabsContextValue = React__namespace.useMemo(() => {
    return {
      idPrefix,
      value,
      onSelected,
      orientation,
      direction,
      selectionFollowsFocus
    };
  }, [idPrefix, value, onSelected, orientation, direction, selectionFollowsFocus]);
  return {
    tabsContextValue
  };
};

/**
 * @ignore - internal component.
 */
const Context = /*#__PURE__*/React__namespace.createContext(null);

if (process.env.NODE_ENV !== 'production') {
  Context.displayName = 'TabsContext';
}
/**
 * @returns {unknown}
 */


function useTabContext() {
  return React__namespace.useContext(Context);
}
function getPanelId(context, value) {
  const {
    idPrefix
  } = context;

  if (idPrefix === null) {
    return null;
  }

  return `${context.idPrefix}-P-${value}`;
}
function getTabId(context, value) {
  const {
    idPrefix
  } = context;

  if (idPrefix === null) {
    return null;
  }

  return `${context.idPrefix}-T-${value}`;
}

const _excluded$l = ["children", "className", "value", "defaultValue", "orientation", "direction", "component", "components", "componentsProps", "onChange", "selectionFollowsFocus"];

const useUtilityClasses$6 = ownerState => {
  const {
    orientation
  } = ownerState;
  const slots = {
    root: ['root', orientation]
  };
  return composeClasses(slots, getTabsUnstyledUtilityClass, {});
};
/**
 *
 * Demos:
 *
 * - [Tabs](https://mui.com/base/react-tabs/)
 *
 * API:
 *
 * - [TabsUnstyled API](https://mui.com/base/api/tabs-unstyled/)
 */


const TabsUnstyled = /*#__PURE__*/React__namespace.forwardRef((props, ref) => {
  var _ref, _componentsProps$root;

  const {
    children,
    className,
    orientation = 'horizontal',
    direction = 'ltr',
    component,
    components = {},
    componentsProps = {}
  } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$l);

  const {
    tabsContextValue
  } = useTabs(props);

  const ownerState = _extends({}, props, {
    orientation,
    direction
  });

  const classes = useUtilityClasses$6(ownerState);
  const TabsRoot = (_ref = component != null ? component : components.Root) != null ? _ref : 'div';
  const tabsRootProps = appendOwnerState(TabsRoot, _extends({}, other, componentsProps.root, {
    ref,
    className: clsx(classes.root, (_componentsProps$root = componentsProps.root) == null ? void 0 : _componentsProps$root.className, className)
  }), ownerState);
  return /*#__PURE__*/jsxRuntime.exports.jsx(TabsRoot, _extends({}, tabsRootProps, {
    children: /*#__PURE__*/jsxRuntime.exports.jsx(Context.Provider, {
      value: tabsContextValue,
      children: children
    })
  }));
});
process.env.NODE_ENV !== "production" ? TabsUnstyled.propTypes
/* remove-proptypes */
= {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------

  /**
   * The content of the component.
   */
  children: propTypes.exports.node,

  /**
   * @ignore
   */
  className: propTypes.exports.string,

  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: propTypes.exports.elementType,

  /**
   * The components used for each slot inside the Tabs.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  components: propTypes.exports.shape({
    Root: propTypes.exports.elementType
  }),

  /**
   * The props used for each slot inside the Tabs.
   * @default {}
   */
  componentsProps: propTypes.exports.shape({
    root: propTypes.exports.object
  }),

  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: propTypes.exports.oneOfType([propTypes.exports.oneOf([false]), propTypes.exports.number, propTypes.exports.string]),

  /**
   * The direction of the text.
   * @default 'ltr'
   */
  direction: propTypes.exports.oneOf(['ltr', 'rtl']),

  /**
   * Callback invoked when new value is being set.
   */
  onChange: propTypes.exports.func,

  /**
   * The component orientation (layout flow direction).
   * @default 'horizontal'
   */
  orientation: propTypes.exports.oneOf(['horizontal', 'vertical']),

  /**
   * If `true` the selected tab changes on focus. Otherwise it only
   * changes on activation.
   */
  selectionFollowsFocus: propTypes.exports.bool,

  /**
   * The value of the currently selected `Tab`.
   * If you don't want any selected `Tab`, you can set this prop to `false`.
   */
  value: propTypes.exports.oneOfType([propTypes.exports.oneOf([false]), propTypes.exports.number, propTypes.exports.string])
} : void 0;

const useTabPanel = parameters => {
  const {
    value
  } = parameters;
  const context = useTabContext();

  if (context === null) {
    throw new Error('No TabContext provided');
  }

  const hidden = value !== context.value;
  const id = getPanelId(context, value);
  const tabId = getTabId(context, value);

  const getRootProps = () => {
    return {
      'aria-labelledby': tabId != null ? tabId : undefined,
      hidden,
      id: id != null ? id : undefined
    };
  };

  return {
    hidden,
    getRootProps
  };
};

const _excluded$k = ["children", "className", "value", "components", "componentsProps", "component"];

const useUtilityClasses$5 = ownerState => {
  const {
    hidden
  } = ownerState;
  const slots = {
    root: ['root', hidden && 'hidden']
  };
  return composeClasses(slots, getTabPanelUnstyledUtilityClass, {});
};
/**
 *
 * Demos:
 *
 * - [Tabs](https://mui.com/base/react-tabs/)
 *
 * API:
 *
 * - [TabPanelUnstyled API](https://mui.com/base/api/tab-panel-unstyled/)
 */


const TabPanelUnstyled = /*#__PURE__*/React__namespace.forwardRef(function TabPanelUnstyled(props, ref) {
  var _ref, _componentsProps$root;

  const {
    children,
    className,
    components = {},
    componentsProps = {},
    component
  } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$k);

  const {
    hidden,
    getRootProps
  } = useTabPanel(props);

  const ownerState = _extends({}, props, {
    hidden
  });

  const classes = useUtilityClasses$5(ownerState);
  const TabPanelRoot = (_ref = component != null ? component : components.Root) != null ? _ref : 'div';
  const tabPanelRootProps = appendOwnerState(TabPanelRoot, _extends({}, getRootProps(), {
    role: 'tabpanel'
  }, other, componentsProps.root, {
    ref,
    className: clsx(classes.root, (_componentsProps$root = componentsProps.root) == null ? void 0 : _componentsProps$root.className, className)
  }), ownerState);
  return /*#__PURE__*/jsxRuntime.exports.jsx(TabPanelRoot, _extends({}, tabPanelRootProps, {
    children: !hidden && children
  }));
});
process.env.NODE_ENV !== "production" ? TabPanelUnstyled.propTypes
/* remove-proptypes */
= {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------

  /**
   * The content of the component.
   */
  children: propTypes.exports.node,

  /**
   * @ignore
   */
  className: propTypes.exports.string,

  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: propTypes.exports.elementType,

  /**
   * The components used for each slot inside the TabPanel.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  components: propTypes.exports.shape({
    Root: propTypes.exports.elementType
  }),

  /**
   * The props used for each slot inside the TabPanel.
   * @default {}
   */
  componentsProps: propTypes.exports.shape({
    root: propTypes.exports.object
  }),

  /**
   * The value of the TabPanel. It will be shown when the Tab with the corresponding value is selected.
   */
  value: propTypes.exports.oneOfType([propTypes.exports.number, propTypes.exports.string]).isRequired
} : void 0;

function getTabsListUnstyledUtilityClass(slot) {
  return generateUtilityClass('TabsListUnstyled', slot);
}
generateUtilityClasses('TabsListUnstyled', ['root', 'horizontal', 'vertical']);

const nextItem = (list, item) => {
  if (!list) {
    return null;
  }

  if (list === item) {
    return list.firstChild;
  }

  if (item && item.nextElementSibling) {
    return item.nextElementSibling;
  }

  return list.firstChild;
};

const previousItem = (list, item) => {
  if (!list) {
    return null;
  }

  if (list === item) {
    return list.lastChild;
  }

  if (item && item.previousElementSibling) {
    return item.previousElementSibling;
  }

  return list.lastChild;
};

const moveFocus = (list, currentFocus, traversalFunction) => {
  let wrappedOnce = false;
  let nextFocus = traversalFunction(list, currentFocus);

  while (list && nextFocus) {
    // Prevent infinite loop.
    if (nextFocus === list.firstChild) {
      if (wrappedOnce) {
        return;
      }

      wrappedOnce = true;
    } // Same logic as useAutocomplete.js


    const nextFocusDisabled = nextFocus.disabled || nextFocus.getAttribute('aria-disabled') === 'true';

    if (!nextFocus.hasAttribute('tabindex') || nextFocusDisabled) {
      // Move to the next element.
      nextFocus = traversalFunction(list, nextFocus);
    } else {
      nextFocus.focus();
      return;
    }
  }
};

const useTabsList = parameters => {
  const {
    'aria-label': ariaLabel,
    'aria-labelledby': ariaLabelledBy,
    children,
    ref
  } = parameters;
  const tabsListRef = /*#__PURE__*/React__namespace.createRef();
  const handleRef = useForkRef(tabsListRef, ref);
  const context = useTabContext();

  if (context === null) {
    throw new Error('No TabContext provided');
  }

  const {
    value,
    orientation = 'horizontal',
    direction = 'ltr'
  } = context;
  const isRtl = direction === 'rtl';

  const handleKeyDown = event => {
    const list = tabsListRef.current;
    const currentFocus = ownerDocument(list).activeElement; // Keyboard navigation assumes that [role="tab"] are siblings
    // though we might warn in the future about nested, interactive elements
    // as a a11y violation

    const role = currentFocus == null ? void 0 : currentFocus.getAttribute('role');

    if (role !== 'tab') {
      return;
    }

    let previousItemKey = orientation === 'horizontal' ? 'ArrowLeft' : 'ArrowUp';
    let nextItemKey = orientation === 'horizontal' ? 'ArrowRight' : 'ArrowDown';

    if (orientation === 'horizontal' && isRtl) {
      // swap previousItemKey with nextItemKey
      previousItemKey = 'ArrowRight';
      nextItemKey = 'ArrowLeft';
    }

    switch (event.key) {
      case previousItemKey:
        event.preventDefault();
        moveFocus(list, currentFocus, previousItem);
        break;

      case nextItemKey:
        event.preventDefault();
        moveFocus(list, currentFocus, nextItem);
        break;

      case 'Home':
        event.preventDefault();
        moveFocus(list, null, nextItem);
        break;

      case 'End':
        event.preventDefault();
        moveFocus(list, null, previousItem);
        break;
    }
  };

  const createHandleKeyDown = otherHandlers => event => {
    var _otherHandlers$onKeyD;

    handleKeyDown(event);
    (_otherHandlers$onKeyD = otherHandlers.onKeyDown) == null ? void 0 : _otherHandlers$onKeyD.call(otherHandlers, event);
  };

  const getRootProps = (otherHandlers = {}) => {
    const propsEventHandlers = extractEventHandlers(parameters);

    const externalEventHandlers = _extends({}, propsEventHandlers, otherHandlers);

    const ownEventHandlers = {
      onKeyDown: createHandleKeyDown(externalEventHandlers)
    };

    const mergedEventHandlers = _extends({}, externalEventHandlers, ownEventHandlers);

    return _extends({
      'aria-label': ariaLabel,
      'aria-labelledby': ariaLabelledBy,
      'aria-orientation': orientation === 'vertical' ? 'vertical' : undefined,
      role: 'tablist',
      ref: handleRef
    }, mergedEventHandlers);
  };

  const processChildren = React__namespace.useCallback(() => {
    const valueToIndex = new Map();
    let childIndex = 0;
    const processedChildren = React__namespace.Children.map(children, child => {
      if (! /*#__PURE__*/React__namespace.isValidElement(child)) {
        return null;
      }

      if (process.env.NODE_ENV !== 'production') {
        if (reactIs.exports.isFragment(child)) {
          console.error(["MUI: The Tabs component doesn't accept a Fragment as a child.", 'Consider providing an array instead.'].join('\n'));
        }
      }

      const childValue = child.props.value === undefined ? childIndex : child.props.value;
      valueToIndex.set(childValue, childIndex);
      childIndex += 1;
      return /*#__PURE__*/React__namespace.cloneElement(child, _extends({
        value: childValue
      }, childIndex === 1 && value === false && !child.props.tabIndex || value === childValue ? {
        tabIndex: 0
      } : {
        tabIndex: -1
      }));
    });
    return processedChildren;
  }, [children, value]);
  return {
    isRtl,
    orientation,
    value,
    processChildren,
    getRootProps
  };
};

const _excluded$j = ["className", "children", "component", "components", "componentsProps"];

const useUtilityClasses$4 = ownerState => {
  const {
    orientation
  } = ownerState;
  const slots = {
    root: ['root', orientation]
  };
  return composeClasses(slots, getTabsListUnstyledUtilityClass, {});
};
/**
 *
 * Demos:
 *
 * - [Tabs](https://mui.com/base/react-tabs/)
 *
 * API:
 *
 * - [TabsListUnstyled API](https://mui.com/base/api/tabs-list-unstyled/)
 */


const TabsListUnstyled = /*#__PURE__*/React__namespace.forwardRef((props, ref) => {
  var _ref, _componentsProps$root;

  const {
    className,
    component,
    components = {},
    componentsProps = {}
  } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$j);

  const {
    isRtl,
    orientation,
    getRootProps,
    processChildren
  } = useTabsList(_extends({}, props, {
    ref
  }));

  const ownerState = _extends({}, props, {
    isRtl,
    orientation
  });

  const classes = useUtilityClasses$4(ownerState);
  const TabsListRoot = (_ref = component != null ? component : components.Root) != null ? _ref : 'div';
  const tabsListRootProps = appendOwnerState(TabsListRoot, _extends({}, getRootProps(), other, componentsProps.root, {
    className: clsx(className, (_componentsProps$root = componentsProps.root) == null ? void 0 : _componentsProps$root.className, classes.root)
  }), ownerState);
  const processedChildren = processChildren();
  return /*#__PURE__*/jsxRuntime.exports.jsx(TabsListRoot, _extends({}, tabsListRootProps, {
    children: processedChildren
  }));
});
process.env.NODE_ENV !== "production" ? TabsListUnstyled.propTypes
/* remove-proptypes */
= {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------

  /**
   * The content of the component.
   */
  children: propTypes.exports.node,

  /**
   * @ignore
   */
  className: propTypes.exports.string,

  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: propTypes.exports.elementType,

  /**
   * The components used for each slot inside the TabsList.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  components: propTypes.exports.shape({
    Root: propTypes.exports.elementType
  }),

  /**
   * The props used for each slot inside the TabsList.
   * @default {}
   */
  componentsProps: propTypes.exports.shape({
    root: propTypes.exports.object
  })
} : void 0;

function getTabUnstyledUtilityClass(slot) {
  return generateUtilityClass('TabUnstyled', slot);
}
generateUtilityClasses('TabUnstyled', ['root', 'selected', 'disabled']);

const _excluded$i = ["getRootProps"];

const useTab = parameters => {
  var _getPanelId, _getTabId;

  const {
    value: valueProp,
    onChange,
    onClick,
    onFocus
  } = parameters;

  const _useButton = useButton(parameters),
        {
    getRootProps: getRootPropsButton
  } = _useButton,
        otherButtonProps = _objectWithoutPropertiesLoose(_useButton, _excluded$i);

  const context = useTabContext();

  if (context === null) {
    throw new Error('No TabContext provided');
  }

  const value = valueProp != null ? valueProp : 0;
  const selected = context.value === value;
  const selectionFollowsFocus = context.selectionFollowsFocus;
  const a11yAttributes = {
    role: 'tab',
    'aria-controls': (_getPanelId = getPanelId(context, value)) != null ? _getPanelId : undefined,
    id: (_getTabId = getTabId(context, value)) != null ? _getTabId : undefined,
    'aria-selected': selected,
    disabled: otherButtonProps.disabled
  };

  const createHandleFocus = otherHandlers => event => {
    var _otherHandlers$onFocu;

    (_otherHandlers$onFocu = otherHandlers.onFocus) == null ? void 0 : _otherHandlers$onFocu.call(otherHandlers, event);

    if (event.defaultPrevented) {
      return;
    }

    if (selectionFollowsFocus && !selected) {
      if (onChange) {
        onChange(event, value);
      }

      context.onSelected(event, value);
    }

    if (onFocus) {
      onFocus(event);
    }
  };

  const createHandleClick = otherHandlers => event => {
    var _otherHandlers$onClic;

    (_otherHandlers$onClic = otherHandlers.onClick) == null ? void 0 : _otherHandlers$onClic.call(otherHandlers, event);

    if (event.defaultPrevented) {
      return;
    }

    if (!selected) {
      if (onChange) {
        onChange(event, value);
      }

      context.onSelected(event, value);
    }

    if (onClick) {
      onClick(event);
    }
  };

  const getRootProps = (otherHandlers = {}) => {
    const buttonResolvedProps = getRootPropsButton(_extends({}, otherHandlers, {
      onClick: createHandleClick(otherHandlers),
      onFocus: createHandleFocus(otherHandlers)
    }));
    return _extends({}, buttonResolvedProps, a11yAttributes);
  };

  return _extends({
    getRootProps
  }, otherButtonProps, {
    selected
  });
};

const _excluded$h = ["action", "children", "value", "className", "disabled", "onChange", "onClick", "onFocus", "component", "components", "componentsProps"];

const useUtilityClasses$3 = ownerState => {
  const {
    selected,
    disabled
  } = ownerState;
  const slots = {
    root: ['root', selected && 'selected', disabled && 'disabled']
  };
  return composeClasses(slots, getTabUnstyledUtilityClass, {});
};
/**
 *
 * Demos:
 *
 * - [Tabs](https://mui.com/base/react-tabs/)
 *
 * API:
 *
 * - [TabUnstyled API](https://mui.com/base/api/tab-unstyled/)
 */


const TabUnstyled = /*#__PURE__*/React__namespace.forwardRef(function TabUnstyled(props, ref) {
  var _ref, _componentsProps$root;

  const {
    action,
    children,
    className,
    disabled = false,
    component,
    components = {},
    componentsProps = {}
  } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$h);

  const tabRef = React__namespace.useRef();
  const handleRef = useForkRef(tabRef, ref);
  const {
    active,
    focusVisible,
    setFocusVisible,
    selected,
    getRootProps
  } = useTab(_extends({}, props, {
    ref: handleRef
  }));
  React__namespace.useImperativeHandle(action, () => ({
    focusVisible: () => {
      setFocusVisible(true);
      tabRef.current.focus();
    }
  }), [setFocusVisible]);

  const ownerState = _extends({}, props, {
    active,
    focusVisible,
    disabled,
    selected
  });

  const classes = useUtilityClasses$3(ownerState);
  const TabRoot = (_ref = component != null ? component : components.Root) != null ? _ref : 'button';
  const tabRootProps = appendOwnerState(TabRoot, _extends({}, getRootProps(), other, componentsProps.root, {
    className: clsx(classes.root, (_componentsProps$root = componentsProps.root) == null ? void 0 : _componentsProps$root.className, className),
    ref
  }), ownerState);
  return /*#__PURE__*/jsxRuntime.exports.jsx(TabRoot, _extends({}, tabRootProps, {
    children: children
  }));
});
process.env.NODE_ENV !== "production" ? TabUnstyled.propTypes
/* remove-proptypes */
= {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------

  /**
   * A ref for imperative actions. It currently only supports `focusVisible()` action.
   */
  action: propTypes.exports.oneOfType([propTypes.exports.func, propTypes.exports.shape({
    current: propTypes.exports.shape({
      focusVisible: propTypes.exports.func.isRequired
    })
  })]),

  /**
   * @ignore
   */
  children: propTypes.exports.node,

  /**
   * @ignore
   */
  className: propTypes.exports.string,

  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: propTypes.exports.elementType,

  /**
   * The components used for each slot inside the Tab.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  components: propTypes.exports.shape({
    Root: propTypes.exports.elementType
  }),

  /**
   * The props used for each slot inside the Tab.
   * @default {}
   */
  componentsProps: propTypes.exports.shape({
    root: propTypes.exports.object
  }),

  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: propTypes.exports.bool,

  /**
   * Callback invoked when new value is being set.
   */
  onChange: propTypes.exports.func,

  /**
   * @ignore
   */
  onClick: propTypes.exports.func,

  /**
   * @ignore
   */
  onFocus: propTypes.exports.func,

  /**
   * You can provide your own value. Otherwise, we fall back to the child position index.
   */
  value: propTypes.exports.oneOfType([propTypes.exports.number, propTypes.exports.string])
} : void 0;

const _excluded$g = ["onChange", "maxRows", "minRows", "style", "value"];

function getStyleValue(computedStyle, property) {
  return parseInt(computedStyle[property], 10) || 0;
}

const styles$1 = {
  shadow: {
    // Visibility needed to hide the extra text area on iPads
    visibility: 'hidden',
    // Remove from the content flow
    position: 'absolute',
    // Ignore the scrollbar width
    overflow: 'hidden',
    height: 0,
    top: 0,
    left: 0,
    // Create a new layer, increase the isolation of the computed values
    transform: 'translateZ(0)'
  }
};
const TextareaAutosize = /*#__PURE__*/React__namespace.forwardRef(function TextareaAutosize(props, ref) {
  const {
    onChange,
    maxRows,
    minRows = 1,
    style,
    value
  } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$g);

  const {
    current: isControlled
  } = React__namespace.useRef(value != null);
  const inputRef = React__namespace.useRef(null);
  const handleRef = useForkRef(ref, inputRef);
  const shadowRef = React__namespace.useRef(null);
  const renders = React__namespace.useRef(0);
  const [state, setState] = React__namespace.useState({});
  const syncHeight = React__namespace.useCallback(() => {
    const input = inputRef.current;
    const containerWindow = ownerWindow(input);
    const computedStyle = containerWindow.getComputedStyle(input); // If input's width is shrunk and it's not visible, don't sync height.

    if (computedStyle.width === '0px') {
      return;
    }

    const inputShallow = shadowRef.current;
    inputShallow.style.width = computedStyle.width;
    inputShallow.value = input.value || props.placeholder || 'x';

    if (inputShallow.value.slice(-1) === '\n') {
      // Certain fonts which overflow the line height will cause the textarea
      // to report a different scrollHeight depending on whether the last line
      // is empty. Make it non-empty to avoid this issue.
      inputShallow.value += ' ';
    }

    const boxSizing = computedStyle['box-sizing'];
    const padding = getStyleValue(computedStyle, 'padding-bottom') + getStyleValue(computedStyle, 'padding-top');
    const border = getStyleValue(computedStyle, 'border-bottom-width') + getStyleValue(computedStyle, 'border-top-width'); // The height of the inner content

    const innerHeight = inputShallow.scrollHeight; // Measure height of a textarea with a single row

    inputShallow.value = 'x';
    const singleRowHeight = inputShallow.scrollHeight; // The height of the outer content

    let outerHeight = innerHeight;

    if (minRows) {
      outerHeight = Math.max(Number(minRows) * singleRowHeight, outerHeight);
    }

    if (maxRows) {
      outerHeight = Math.min(Number(maxRows) * singleRowHeight, outerHeight);
    }

    outerHeight = Math.max(outerHeight, singleRowHeight); // Take the box sizing into account for applying this value as a style.

    const outerHeightStyle = outerHeight + (boxSizing === 'border-box' ? padding + border : 0);
    const overflow = Math.abs(outerHeight - innerHeight) <= 1;
    setState(prevState => {
      // Need a large enough difference to update the height.
      // This prevents infinite rendering loop.
      if (renders.current < 20 && (outerHeightStyle > 0 && Math.abs((prevState.outerHeightStyle || 0) - outerHeightStyle) > 1 || prevState.overflow !== overflow)) {
        renders.current += 1;
        return {
          overflow,
          outerHeightStyle
        };
      }

      if (process.env.NODE_ENV !== 'production') {
        if (renders.current === 20) {
          console.error(['MUI: Too many re-renders. The layout is unstable.', 'TextareaAutosize limits the number of renders to prevent an infinite loop.'].join('\n'));
        }
      }

      return prevState;
    });
  }, [maxRows, minRows, props.placeholder]);
  React__namespace.useEffect(() => {
    const handleResize = debounce$1(() => {
      renders.current = 0;
      syncHeight();
    });
    const containerWindow = ownerWindow(inputRef.current);
    containerWindow.addEventListener('resize', handleResize);
    let resizeObserver;

    if (typeof ResizeObserver !== 'undefined') {
      resizeObserver = new ResizeObserver(handleResize);
      resizeObserver.observe(inputRef.current);
    }

    return () => {
      handleResize.clear();
      containerWindow.removeEventListener('resize', handleResize);

      if (resizeObserver) {
        resizeObserver.disconnect();
      }
    };
  }, [syncHeight]);
  useEnhancedEffect(() => {
    syncHeight();
  });
  React__namespace.useEffect(() => {
    renders.current = 0;
  }, [value]);

  const handleChange = event => {
    renders.current = 0;

    if (!isControlled) {
      syncHeight();
    }

    if (onChange) {
      onChange(event);
    }
  };

  return /*#__PURE__*/jsxRuntime.exports.jsxs(React__namespace.Fragment, {
    children: [/*#__PURE__*/jsxRuntime.exports.jsx("textarea", _extends({
      value: value,
      onChange: handleChange,
      ref: handleRef // Apply the rows prop to get a "correct" first SSR paint
      ,
      rows: minRows,
      style: _extends({
        height: state.outerHeightStyle,
        // Need a large enough difference to allow scrolling.
        // This prevents infinite rendering loop.
        overflow: state.overflow ? 'hidden' : null
      }, style)
    }, other)), /*#__PURE__*/jsxRuntime.exports.jsx("textarea", {
      "aria-hidden": true,
      className: props.className,
      readOnly: true,
      ref: shadowRef,
      tabIndex: -1,
      style: _extends({}, styles$1.shadow, style, {
        padding: 0
      })
    })]
  });
});
process.env.NODE_ENV !== "production" ? TextareaAutosize.propTypes
/* remove-proptypes */
= {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------

  /**
   * @ignore
   */
  className: propTypes.exports.string,

  /**
   * Maximum number of rows to display.
   */
  maxRows: propTypes.exports.oneOfType([propTypes.exports.number, propTypes.exports.string]),

  /**
   * Minimum number of rows to display.
   * @default 1
   */
  minRows: propTypes.exports.oneOfType([propTypes.exports.number, propTypes.exports.string]),

  /**
   * @ignore
   */
  onChange: propTypes.exports.func,

  /**
   * @ignore
   */
  placeholder: propTypes.exports.string,

  /**
   * @ignore
   */
  style: propTypes.exports.object,

  /**
   * @ignore
   */
  value: propTypes.exports.oneOfType([propTypes.exports.arrayOf(propTypes.exports.string), propTypes.exports.number, propTypes.exports.string])
} : void 0;

/*

Based off glamor's StyleSheet, thanks Sunil ❤️

high performance StyleSheet for css-in-js systems

- uses multiple style tags behind the scenes for millions of rules
- uses `insertRule` for appending in production for *much* faster performance

// usage

import { StyleSheet } from '@emotion/sheet'

let styleSheet = new StyleSheet({ key: '', container: document.head })

styleSheet.insert('#box { border: 1px solid red; }')
- appends a css rule into the stylesheet

styleSheet.flush()
- empties the stylesheet of all its contents

*/
// $FlowFixMe
function sheetForTag(tag) {
  if (tag.sheet) {
    // $FlowFixMe
    return tag.sheet;
  } // this weirdness brought to you by firefox

  /* istanbul ignore next */


  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      // $FlowFixMe
      return document.styleSheets[i];
    }
  }
}

function createStyleElement(options) {
  var tag = document.createElement('style');
  tag.setAttribute('data-emotion', options.key);

  if (options.nonce !== undefined) {
    tag.setAttribute('nonce', options.nonce);
  }

  tag.appendChild(document.createTextNode(''));
  tag.setAttribute('data-s', '');
  return tag;
}

var StyleSheet = /*#__PURE__*/function () {
  function StyleSheet(options) {
    var _this = this;

    this._insertTag = function (tag) {
      var before;

      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }

      _this.container.insertBefore(tag, before);

      _this.tags.push(tag);
    };

    this.isSpeedy = options.speedy === undefined ? process.env.NODE_ENV === 'production' : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce; // key is the value of the data-emotion attribute, it's used to identify different sheets

    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }

  var _proto = StyleSheet.prototype;

  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };

  _proto.insert = function insert(rule) {
    // the max length is how many rules we have per style tag, it's 65000 in speedy mode
    // it's 1 in dev because we insert source maps that map a single rule to a location
    // and you can only have one source map per style tag
    if (this.ctr % (this.isSpeedy ? 65000 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }

    var tag = this.tags[this.tags.length - 1];

    if (process.env.NODE_ENV !== 'production') {
      var isImportRule = rule.charCodeAt(0) === 64 && rule.charCodeAt(1) === 105;

      if (isImportRule && this._alreadyInsertedOrderInsensitiveRule) {
        // this would only cause problem in speedy mode
        // but we don't want enabling speedy to affect the observable behavior
        // so we report this error at all times
        console.error("You're attempting to insert the following rule:\n" + rule + '\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules.');
      }
      this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !isImportRule;
    }

    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);

      try {
        // this is the ultrafast version, works across browsers
        // the big drawback is that the css won't be editable in devtools
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e) {
        if (process.env.NODE_ENV !== 'production' && !/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear){/.test(rule)) {
          console.error("There was a problem inserting the following rule: \"" + rule + "\"", e);
        }
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }

    this.ctr++;
  };

  _proto.flush = function flush() {
    // $FlowFixMe
    this.tags.forEach(function (tag) {
      return tag.parentNode && tag.parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;

    if (process.env.NODE_ENV !== 'production') {
      this._alreadyInsertedOrderInsensitiveRule = false;
    }
  };

  return StyleSheet;
}();

var MS = '-ms-';
var MOZ = '-moz-';
var WEBKIT = '-webkit-';

var COMMENT = 'comm';
var RULESET = 'rule';
var DECLARATION = 'decl';
var IMPORT = '@import';
var KEYFRAMES = '@keyframes';

/**
 * @param {number}
 * @return {number}
 */
var abs = Math.abs;

/**
 * @param {number}
 * @return {string}
 */
var from = String.fromCharCode;

/**
 * @param {object}
 * @return {object}
 */
var assign = Object.assign;

/**
 * @param {string} value
 * @param {number} length
 * @return {number}
 */
function hash (value, length) {
	return (((((((length << 2) ^ charat(value, 0)) << 2) ^ charat(value, 1)) << 2) ^ charat(value, 2)) << 2) ^ charat(value, 3)
}

/**
 * @param {string} value
 * @return {string}
 */
function trim (value) {
	return value.trim()
}

/**
 * @param {string} value
 * @param {RegExp} pattern
 * @return {string?}
 */
function match (value, pattern) {
	return (value = pattern.exec(value)) ? value[0] : value
}

/**
 * @param {string} value
 * @param {(string|RegExp)} pattern
 * @param {string} replacement
 * @return {string}
 */
function replace (value, pattern, replacement) {
	return value.replace(pattern, replacement)
}

/**
 * @param {string} value
 * @param {string} search
 * @return {number}
 */
function indexof (value, search) {
	return value.indexOf(search)
}

/**
 * @param {string} value
 * @param {number} index
 * @return {number}
 */
function charat (value, index) {
	return value.charCodeAt(index) | 0
}

/**
 * @param {string} value
 * @param {number} begin
 * @param {number} end
 * @return {string}
 */
function substr (value, begin, end) {
	return value.slice(begin, end)
}

/**
 * @param {string} value
 * @return {number}
 */
function strlen (value) {
	return value.length
}

/**
 * @param {any[]} value
 * @return {number}
 */
function sizeof (value) {
	return value.length
}

/**
 * @param {any} value
 * @param {any[]} array
 * @return {any}
 */
function append (value, array) {
	return array.push(value), value
}

/**
 * @param {string[]} array
 * @param {function} callback
 * @return {string}
 */
function combine (array, callback) {
	return array.map(callback).join('')
}

var line = 1;
var column = 1;
var length = 0;
var position$1 = 0;
var character = 0;
var characters = '';

/**
 * @param {string} value
 * @param {object | null} root
 * @param {object | null} parent
 * @param {string} type
 * @param {string[] | string} props
 * @param {object[] | string} children
 * @param {number} length
 */
function node (value, root, parent, type, props, children, length) {
	return {value: value, root: root, parent: parent, type: type, props: props, children: children, line: line, column: column, length: length, return: ''}
}

/**
 * @param {object} root
 * @param {object} props
 * @return {object}
 */
function copy (root, props) {
	return assign(node('', null, null, '', null, null, 0), root, {length: -root.length}, props)
}

/**
 * @return {number}
 */
function char () {
	return character
}

/**
 * @return {number}
 */
function prev () {
	character = position$1 > 0 ? charat(characters, --position$1) : 0;

	if (column--, character === 10)
		column = 1, line--;

	return character
}

/**
 * @return {number}
 */
function next () {
	character = position$1 < length ? charat(characters, position$1++) : 0;

	if (column++, character === 10)
		column = 1, line++;

	return character
}

/**
 * @return {number}
 */
function peek () {
	return charat(characters, position$1)
}

/**
 * @return {number}
 */
function caret () {
	return position$1
}

/**
 * @param {number} begin
 * @param {number} end
 * @return {string}
 */
function slice (begin, end) {
	return substr(characters, begin, end)
}

/**
 * @param {number} type
 * @return {number}
 */
function token (type) {
	switch (type) {
		// \0 \t \n \r \s whitespace token
		case 0: case 9: case 10: case 13: case 32:
			return 5
		// ! + , / > @ ~ isolate token
		case 33: case 43: case 44: case 47: case 62: case 64: case 126:
		// ; { } breakpoint token
		case 59: case 123: case 125:
			return 4
		// : accompanied token
		case 58:
			return 3
		// " ' ( [ opening delimit token
		case 34: case 39: case 40: case 91:
			return 2
		// ) ] closing delimit token
		case 41: case 93:
			return 1
	}

	return 0
}

/**
 * @param {string} value
 * @return {any[]}
 */
function alloc (value) {
	return line = column = 1, length = strlen(characters = value), position$1 = 0, []
}

/**
 * @param {any} value
 * @return {any}
 */
function dealloc (value) {
	return characters = '', value
}

/**
 * @param {number} type
 * @return {string}
 */
function delimit (type) {
	return trim(slice(position$1 - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)))
}

/**
 * @param {number} type
 * @return {string}
 */
function whitespace (type) {
	while (character = peek())
		if (character < 33)
			next();
		else
			break

	return token(type) > 2 || token(character) > 3 ? '' : ' '
}

/**
 * @param {number} index
 * @param {number} count
 * @return {string}
 */
function escaping (index, count) {
	while (--count && next())
		// not 0-9 A-F a-f
		if (character < 48 || character > 102 || (character > 57 && character < 65) || (character > 70 && character < 97))
			break

	return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32))
}

/**
 * @param {number} type
 * @return {number}
 */
function delimiter (type) {
	while (next())
		switch (character) {
			// ] ) " '
			case type:
				return position$1
			// " '
			case 34: case 39:
				if (type !== 34 && type !== 39)
					delimiter(character);
				break
			// (
			case 40:
				if (type === 41)
					delimiter(type);
				break
			// \
			case 92:
				next();
				break
		}

	return position$1
}

/**
 * @param {number} type
 * @param {number} index
 * @return {number}
 */
function commenter (type, index) {
	while (next())
		// //
		if (type + character === 47 + 10)
			break
		// /*
		else if (type + character === 42 + 42 && peek() === 47)
			break

	return '/*' + slice(index, position$1 - 1) + '*' + from(type === 47 ? type : next())
}

/**
 * @param {number} index
 * @return {string}
 */
function identifier (index) {
	while (!token(peek()))
		next();

	return slice(index, position$1)
}

/**
 * @param {string} value
 * @return {object[]}
 */
function compile (value) {
	return dealloc(parse('', null, null, null, [''], value = alloc(value), 0, [0], value))
}

/**
 * @param {string} value
 * @param {object} root
 * @param {object?} parent
 * @param {string[]} rule
 * @param {string[]} rules
 * @param {string[]} rulesets
 * @param {number[]} pseudo
 * @param {number[]} points
 * @param {string[]} declarations
 * @return {object}
 */
function parse (value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
	var index = 0;
	var offset = 0;
	var length = pseudo;
	var atrule = 0;
	var property = 0;
	var previous = 0;
	var variable = 1;
	var scanning = 1;
	var ampersand = 1;
	var character = 0;
	var type = '';
	var props = rules;
	var children = rulesets;
	var reference = rule;
	var characters = type;

	while (scanning)
		switch (previous = character, character = next()) {
			// (
			case 40:
				if (previous != 108 && characters.charCodeAt(length - 1) == 58) {
					if (indexof(characters += replace(delimit(character), '&', '&\f'), '&\f') != -1)
						ampersand = -1;
					break
				}
			// " ' [
			case 34: case 39: case 91:
				characters += delimit(character);
				break
			// \t \n \r \s
			case 9: case 10: case 13: case 32:
				characters += whitespace(previous);
				break
			// \
			case 92:
				characters += escaping(caret() - 1, 7);
				continue
			// /
			case 47:
				switch (peek()) {
					case 42: case 47:
						append(comment(commenter(next(), caret()), root, parent), declarations);
						break
					default:
						characters += '/';
				}
				break
			// {
			case 123 * variable:
				points[index++] = strlen(characters) * ampersand;
			// } ; \0
			case 125 * variable: case 59: case 0:
				switch (character) {
					// \0 }
					case 0: case 125: scanning = 0;
					// ;
					case 59 + offset:
						if (property > 0 && (strlen(characters) - length))
							append(property > 32 ? declaration(characters + ';', rule, parent, length - 1) : declaration(replace(characters, ' ', '') + ';', rule, parent, length - 2), declarations);
						break
					// @ ;
					case 59: characters += ';';
					// { rule/at-rule
					default:
						append(reference = ruleset(characters, root, parent, index, offset, rules, points, type, props = [], children = [], length), rulesets);

						if (character === 123)
							if (offset === 0)
								parse(characters, root, reference, reference, props, rulesets, length, points, children);
							else
								switch (atrule) {
									// d m s
									case 100: case 109: case 115:
										parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length), children), rules, children, length, points, rule ? props : children);
										break
									default:
										parse(characters, reference, reference, reference, [''], children, 0, points, children);
								}
				}

				index = offset = property = 0, variable = ampersand = 1, type = characters = '', length = pseudo;
				break
			// :
			case 58:
				length = 1 + strlen(characters), property = previous;
			default:
				if (variable < 1)
					if (character == 123)
						--variable;
					else if (character == 125 && variable++ == 0 && prev() == 125)
						continue

				switch (characters += from(character), character * variable) {
					// &
					case 38:
						ampersand = offset > 0 ? 1 : (characters += '\f', -1);
						break
					// ,
					case 44:
						points[index++] = (strlen(characters) - 1) * ampersand, ampersand = 1;
						break
					// @
					case 64:
						// -
						if (peek() === 45)
							characters += delimit(next());

						atrule = peek(), offset = length = strlen(type = characters += identifier(caret())), character++;
						break
					// -
					case 45:
						if (previous === 45 && strlen(characters) == 2)
							variable = 0;
				}
		}

	return rulesets
}

/**
 * @param {string} value
 * @param {object} root
 * @param {object?} parent
 * @param {number} index
 * @param {number} offset
 * @param {string[]} rules
 * @param {number[]} points
 * @param {string} type
 * @param {string[]} props
 * @param {string[]} children
 * @param {number} length
 * @return {object}
 */
function ruleset (value, root, parent, index, offset, rules, points, type, props, children, length) {
	var post = offset - 1;
	var rule = offset === 0 ? rules : [''];
	var size = sizeof(rule);

	for (var i = 0, j = 0, k = 0; i < index; ++i)
		for (var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size; ++x)
			if (z = trim(j > 0 ? rule[x] + ' ' + y : replace(y, /&\f/g, rule[x])))
				props[k++] = z;

	return node(value, root, parent, offset === 0 ? RULESET : type, props, children, length)
}

/**
 * @param {number} value
 * @param {object} root
 * @param {object?} parent
 * @return {object}
 */
function comment (value, root, parent) {
	return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0)
}

/**
 * @param {string} value
 * @param {object} root
 * @param {object?} parent
 * @param {number} length
 * @return {object}
 */
function declaration (value, root, parent, length) {
	return node(value, root, parent, DECLARATION, substr(value, 0, length), substr(value, length + 1, -1), length)
}

/**
 * @param {string} value
 * @param {number} length
 * @return {string}
 */
function prefix (value, length) {
	switch (hash(value, length)) {
		// color-adjust
		case 5103:
			return WEBKIT + 'print-' + value + value
		// animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
		case 5737: case 4201: case 3177: case 3433: case 1641: case 4457: case 2921:
		// text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
		case 5572: case 6356: case 5844: case 3191: case 6645: case 3005:
		// mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
		case 6391: case 5879: case 5623: case 6135: case 4599: case 4855:
		// background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
		case 4215: case 6389: case 5109: case 5365: case 5621: case 3829:
			return WEBKIT + value + value
		// appearance, user-select, transform, hyphens, text-size-adjust
		case 5349: case 4246: case 4810: case 6968: case 2756:
			return WEBKIT + value + MOZ + value + MS + value + value
		// flex, flex-direction
		case 6828: case 4268:
			return WEBKIT + value + MS + value + value
		// order
		case 6165:
			return WEBKIT + value + MS + 'flex-' + value + value
		// align-items
		case 5187:
			return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + 'box-$1$2' + MS + 'flex-$1$2') + value
		// align-self
		case 5443:
			return WEBKIT + value + MS + 'flex-item-' + replace(value, /flex-|-self/, '') + value
		// align-content
		case 4675:
			return WEBKIT + value + MS + 'flex-line-pack' + replace(value, /align-content|flex-|-self/, '') + value
		// flex-shrink
		case 5548:
			return WEBKIT + value + MS + replace(value, 'shrink', 'negative') + value
		// flex-basis
		case 5292:
			return WEBKIT + value + MS + replace(value, 'basis', 'preferred-size') + value
		// flex-grow
		case 6060:
			return WEBKIT + 'box-' + replace(value, '-grow', '') + WEBKIT + value + MS + replace(value, 'grow', 'positive') + value
		// transition
		case 4554:
			return WEBKIT + replace(value, /([^-])(transform)/g, '$1' + WEBKIT + '$2') + value
		// cursor
		case 6187:
			return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + '$1'), /(image-set)/, WEBKIT + '$1'), value, '') + value
		// background, background-image
		case 5495: case 3959:
			return replace(value, /(image-set\([^]*)/, WEBKIT + '$1' + '$`$1')
		// justify-content
		case 4968:
			return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + 'box-pack:$3' + MS + 'flex-pack:$3'), /s.+-b[^;]+/, 'justify') + WEBKIT + value + value
		// (margin|padding)-inline-(start|end)
		case 4095: case 3583: case 4068: case 2532:
			return replace(value, /(.+)-inline(.+)/, WEBKIT + '$1$2') + value
		// (min|max)?(width|height|inline-size|block-size)
		case 8116: case 7059: case 5753: case 5535:
		case 5445: case 5701: case 4933: case 4677:
		case 5533: case 5789: case 5021: case 4765:
			// stretch, max-content, min-content, fill-available
			if (strlen(value) - 1 - length > 6)
				switch (charat(value, length + 1)) {
					// (m)ax-content, (m)in-content
					case 109:
						// -
						if (charat(value, length + 4) !== 45)
							break
					// (f)ill-available, (f)it-content
					case 102:
						return replace(value, /(.+:)(.+)-([^]+)/, '$1' + WEBKIT + '$2-$3' + '$1' + MOZ + (charat(value, length + 3) == 108 ? '$3' : '$2-$3')) + value
					// (s)tretch
					case 115:
						return ~indexof(value, 'stretch') ? prefix(replace(value, 'stretch', 'fill-available'), length) + value : value
				}
			break
		// position: sticky
		case 4949:
			// (s)ticky?
			if (charat(value, length + 1) !== 115)
				break
		// display: (flex|inline-flex)
		case 6444:
			switch (charat(value, strlen(value) - 3 - (~indexof(value, '!important') && 10))) {
				// stic(k)y
				case 107:
					return replace(value, ':', ':' + WEBKIT) + value
				// (inline-)?fl(e)x
				case 101:
					return replace(value, /(.+:)([^;!]+)(;|!.+)?/, '$1' + WEBKIT + (charat(value, 14) === 45 ? 'inline-' : '') + 'box$3' + '$1' + WEBKIT + '$2$3' + '$1' + MS + '$2box$3') + value
			}
			break
		// writing-mode
		case 5936:
			switch (charat(value, length + 11)) {
				// vertical-l(r)
				case 114:
					return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'tb') + value
				// vertical-r(l)
				case 108:
					return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'tb-rl') + value
				// horizontal(-)tb
				case 45:
					return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'lr') + value
			}

			return WEBKIT + value + MS + value + value
	}

	return value
}

/**
 * @param {object[]} children
 * @param {function} callback
 * @return {string}
 */
function serialize (children, callback) {
	var output = '';
	var length = sizeof(children);

	for (var i = 0; i < length; i++)
		output += callback(children[i], i, children, callback) || '';

	return output
}

/**
 * @param {object} element
 * @param {number} index
 * @param {object[]} children
 * @param {function} callback
 * @return {string}
 */
function stringify (element, index, children, callback) {
	switch (element.type) {
		case IMPORT: case DECLARATION: return element.return = element.return || element.value
		case COMMENT: return ''
		case KEYFRAMES: return element.return = element.value + '{' + serialize(element.children, callback) + '}'
		case RULESET: element.value = element.props.join(',');
	}

	return strlen(children = serialize(element.children, callback)) ? element.return = element.value + '{' + children + '}' : ''
}

/**
 * @param {function[]} collection
 * @return {function}
 */
function middleware (collection) {
	var length = sizeof(collection);

	return function (element, index, children, callback) {
		var output = '';

		for (var i = 0; i < length; i++)
			output += collection[i](element, index, children, callback) || '';

		return output
	}
}

/**
 * @param {function} callback
 * @return {function}
 */
function rulesheet (callback) {
	return function (element) {
		if (!element.root)
			if (element = element.return)
				callback(element);
	}
}

/**
 * @param {object} element
 * @param {number} index
 * @param {object[]} children
 * @param {function} callback
 */
function prefixer (element, index, children, callback) {
	if (element.length > -1)
		if (!element.return)
			switch (element.type) {
				case DECLARATION: element.return = prefix(element.value, element.length);
					break
				case KEYFRAMES:
					return serialize([copy(element, {value: replace(element.value, '@', '@' + WEBKIT)})], callback)
				case RULESET:
					if (element.length)
						return combine(element.props, function (value) {
							switch (match(value, /(::plac\w+|:read-\w+)/)) {
								// :read-(only|write)
								case ':read-only': case ':read-write':
									return serialize([copy(element, {props: [replace(value, /:(read-\w+)/, ':' + MOZ + '$1')]})], callback)
								// :placeholder
								case '::placeholder':
									return serialize([
										copy(element, {props: [replace(value, /:(plac\w+)/, ':' + WEBKIT + 'input-$1')]}),
										copy(element, {props: [replace(value, /:(plac\w+)/, ':' + MOZ + '$1')]}),
										copy(element, {props: [replace(value, /:(plac\w+)/, MS + 'input-$1')]})
									], callback)
							}

							return ''
						})
			}
}

var weakMemoize = function weakMemoize(func) {
  // $FlowFixMe flow doesn't include all non-primitive types as allowed for weakmaps
  var cache = new WeakMap();
  return function (arg) {
    if (cache.has(arg)) {
      // $FlowFixMe
      return cache.get(arg);
    }

    var ret = func(arg);
    cache.set(arg, ret);
    return ret;
  };
};

function memoize$1(fn) {
  var cache = Object.create(null);
  return function (arg) {
    if (cache[arg] === undefined) cache[arg] = fn(arg);
    return cache[arg];
  };
}

var last = function last(arr) {
  return arr.length ? arr[arr.length - 1] : null;
}; // based on https://github.com/thysultan/stylis.js/blob/e6843c373ebcbbfade25ebcc23f540ed8508da0a/src/Tokenizer.js#L239-L244


var identifierWithPointTracking = function identifierWithPointTracking(begin, points, index) {
  var previous = 0;
  var character = 0;

  while (true) {
    previous = character;
    character = peek(); // &\f

    if (previous === 38 && character === 12) {
      points[index] = 1;
    }

    if (token(character)) {
      break;
    }

    next();
  }

  return slice(begin, position$1);
};

var toRules = function toRules(parsed, points) {
  // pretend we've started with a comma
  var index = -1;
  var character = 44;

  do {
    switch (token(character)) {
      case 0:
        // &\f
        if (character === 38 && peek() === 12) {
          // this is not 100% correct, we don't account for literal sequences here - like for example quoted strings
          // stylis inserts \f after & to know when & where it should replace this sequence with the context selector
          // and when it should just concatenate the outer and inner selectors
          // it's very unlikely for this sequence to actually appear in a different context, so we just leverage this fact here
          points[index] = 1;
        }

        parsed[index] += identifierWithPointTracking(position$1 - 1, points, index);
        break;

      case 2:
        parsed[index] += delimit(character);
        break;

      case 4:
        // comma
        if (character === 44) {
          // colon
          parsed[++index] = peek() === 58 ? '&\f' : '';
          points[index] = parsed[index].length;
          break;
        }

      // fallthrough

      default:
        parsed[index] += from(character);
    }
  } while (character = next());

  return parsed;
};

var getRules = function getRules(value, points) {
  return dealloc(toRules(alloc(value), points));
}; // WeakSet would be more appropriate, but only WeakMap is supported in IE11


var fixedElements = /* #__PURE__ */new WeakMap();
var compat = function compat(element) {
  if (element.type !== 'rule' || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }

  var value = element.value,
      parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;

  while (parent.type !== 'rule') {
    parent = parent.parent;
    if (!parent) return;
  } // short-circuit for the simplest case


  if (element.props.length === 1 && value.charCodeAt(0) !== 58
  /* colon */
  && !fixedElements.get(parent)) {
    return;
  } // if this is an implicitly inserted rule (the one eagerly inserted at the each new nested level)
  // then the props has already been manipulated beforehand as they that array is shared between it and its "rule parent"


  if (isImplicitRule) {
    return;
  }

  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;

  for (var i = 0, k = 0; i < rules.length; i++) {
    for (var j = 0; j < parentRules.length; j++, k++) {
      element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
    }
  }
};
var removeLabel = function removeLabel(element) {
  if (element.type === 'decl') {
    var value = element.value;

    if ( // charcode for l
    value.charCodeAt(0) === 108 && // charcode for b
    value.charCodeAt(2) === 98) {
      // this ignores label
      element["return"] = '';
      element.value = '';
    }
  }
};
var ignoreFlag = 'emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason';

var isIgnoringComment = function isIgnoringComment(element) {
  return !!element && element.type === 'comm' && element.children.indexOf(ignoreFlag) > -1;
};

var createUnsafeSelectorsAlarm = function createUnsafeSelectorsAlarm(cache) {
  return function (element, index, children) {
    if (element.type !== 'rule') return;
    var unsafePseudoClasses = element.value.match(/(:first|:nth|:nth-last)-child/g);

    if (unsafePseudoClasses && cache.compat !== true) {
      var prevElement = index > 0 ? children[index - 1] : null;

      if (prevElement && isIgnoringComment(last(prevElement.children))) {
        return;
      }

      unsafePseudoClasses.forEach(function (unsafePseudoClass) {
        console.error("The pseudo class \"" + unsafePseudoClass + "\" is potentially unsafe when doing server-side rendering. Try changing it to \"" + unsafePseudoClass.split('-child')[0] + "-of-type\".");
      });
    }
  };
};

var isImportRule = function isImportRule(element) {
  return element.type.charCodeAt(1) === 105 && element.type.charCodeAt(0) === 64;
};

var isPrependedWithRegularRules = function isPrependedWithRegularRules(index, children) {
  for (var i = index - 1; i >= 0; i--) {
    if (!isImportRule(children[i])) {
      return true;
    }
  }

  return false;
}; // use this to remove incorrect elements from further processing
// so they don't get handed to the `sheet` (or anything else)
// as that could potentially lead to additional logs which in turn could be overhelming to the user


var nullifyElement = function nullifyElement(element) {
  element.type = '';
  element.value = '';
  element["return"] = '';
  element.children = '';
  element.props = '';
};

var incorrectImportAlarm = function incorrectImportAlarm(element, index, children) {
  if (!isImportRule(element)) {
    return;
  }

  if (element.parent) {
    console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles.");
    nullifyElement(element);
  } else if (isPrependedWithRegularRules(index, children)) {
    console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules.");
    nullifyElement(element);
  }
};

var isBrowser = typeof document !== 'undefined';
var getServerStylisCache = isBrowser ? undefined : weakMemoize(function () {
  return memoize$1(function () {
    var cache = {};
    return function (name) {
      return cache[name];
    };
  });
});
var defaultStylisPlugins = [prefixer];

var createCache = function createCache(options) {
  var key = options.key;

  if (process.env.NODE_ENV !== 'production' && !key) {
    throw new Error("You have to configure `key` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.\n" + "If multiple caches share the same key they might \"fight\" for each other's style elements.");
  }

  if (isBrowser && key === 'css') {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])"); // get SSRed styles out of the way of React's hydration
    // document.head is a safe place to move them to(though note document.head is not necessarily the last place they will be)
    // note this very very intentionally targets all style elements regardless of the key to ensure
    // that creating a cache works inside of render of a React component

    Array.prototype.forEach.call(ssrStyles, function (node) {
      // we want to only move elements which have a space in the data-emotion attribute value
      // because that indicates that it is an Emotion 11 server-side rendered style elements
      // while we will already ignore Emotion 11 client-side inserted styles because of the :not([data-s]) part in the selector
      // Emotion 10 client-side inserted styles did not have data-s (but importantly did not have a space in their data-emotion attributes)
      // so checking for the space ensures that loading Emotion 11 after Emotion 10 has inserted some styles
      // will not result in the Emotion 10 styles being destroyed
      var dataEmotionAttribute = node.getAttribute('data-emotion');

      if (dataEmotionAttribute.indexOf(' ') === -1) {
        return;
      }
      document.head.appendChild(node);
      node.setAttribute('data-s', '');
    });
  }

  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;

  if (process.env.NODE_ENV !== 'production') {
    // $FlowFixMe
    if (/[^a-z-]/.test(key)) {
      throw new Error("Emotion key must only contain lower case alphabetical characters and - but \"" + key + "\" was passed");
    }
  }

  var inserted = {}; // $FlowFixMe

  var container;
  var nodesToHydrate = [];

  if (isBrowser) {
    container = options.container || document.head;
    Array.prototype.forEach.call( // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll("style[data-emotion^=\"" + key + " \"]"), function (node) {
      var attrib = node.getAttribute("data-emotion").split(' '); // $FlowFixMe

      for (var i = 1; i < attrib.length; i++) {
        inserted[attrib[i]] = true;
      }

      nodesToHydrate.push(node);
    });
  }

  var _insert;

  var omnipresentPlugins = [compat, removeLabel];

  if (process.env.NODE_ENV !== 'production') {
    omnipresentPlugins.push(createUnsafeSelectorsAlarm({
      get compat() {
        return cache.compat;
      }

    }), incorrectImportAlarm);
  }

  if (isBrowser) {
    var currentSheet;
    var finalizingPlugins = [stringify, process.env.NODE_ENV !== 'production' ? function (element) {
      if (!element.root) {
        if (element["return"]) {
          currentSheet.insert(element["return"]);
        } else if (element.value && element.type !== COMMENT) {
          // insert empty rule in non-production environments
          // so @emotion/jest can grab `key` from the (JS)DOM for caches without any rules inserted yet
          currentSheet.insert(element.value + "{}");
        }
      }
    } : rulesheet(function (rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));

    var stylis = function stylis(styles) {
      return serialize(compile(styles), serializer);
    };

    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;

      if (process.env.NODE_ENV !== 'production' && serialized.map !== undefined) {
        currentSheet = {
          insert: function insert(rule) {
            sheet.insert(rule + serialized.map);
          }
        };
      }

      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);

      if (shouldCache) {
        cache.inserted[serialized.name] = true;
      }
    };
  } else {
    var _finalizingPlugins = [stringify];

    var _serializer = middleware(omnipresentPlugins.concat(stylisPlugins, _finalizingPlugins));

    var _stylis = function _stylis(styles) {
      return serialize(compile(styles), _serializer);
    }; // $FlowFixMe


    var serverStylisCache = getServerStylisCache(stylisPlugins)(key);

    var getRules = function getRules(selector, serialized) {
      var name = serialized.name;

      if (serverStylisCache[name] === undefined) {
        serverStylisCache[name] = _stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      }

      return serverStylisCache[name];
    };

    _insert = function _insert(selector, serialized, sheet, shouldCache) {
      var name = serialized.name;
      var rules = getRules(selector, serialized);

      if (cache.compat === undefined) {
        // in regular mode, we don't set the styles on the inserted cache
        // since we don't need to and that would be wasting memory
        // we return them so that they are rendered in a style tag
        if (shouldCache) {
          cache.inserted[name] = true;
        }

        if ( // using === development instead of !== production
        // because if people do ssr in tests, the source maps showing up would be annoying
        process.env.NODE_ENV === 'development' && serialized.map !== undefined) {
          return rules + serialized.map;
        }

        return rules;
      } else {
        // in compat mode, we put the styles on the inserted cache so
        // that emotion-server can pull out the styles
        // except when we don't want to cache it which was in Global but now
        // is nowhere but we don't want to do a major right now
        // and just in case we're going to leave the case here
        // it's also not affecting client side bundle size
        // so it's really not a big deal
        if (shouldCache) {
          cache.inserted[name] = rules;
        } else {
          return rules;
        }
      }
    };
  }

  var cache = {
    key: key,
    sheet: new StyleSheet({
      key: key,
      container: container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted: inserted,
    registered: {},
    insert: _insert
  };
  cache.sheet.hydrate(nodesToHydrate);
  return cache;
};

createCache({
  key: 'css',
  prepend: true
});
process.env.NODE_ENV !== "production" ? {
  /**
   * Your component tree.
   */
  children: propTypes.exports.node,

  /**
   * By default, the styles are injected last in the <head> element of the page.
   * As a result, they gain more specificity than any other style sheet.
   * If you want to override MUI's styles, set this prop.
   */
  injectFirst: propTypes.exports.bool
} : void 0;

function isEmpty$2(obj) {
  return obj === undefined || obj === null || Object.keys(obj).length === 0;
}

function GlobalStyles(props) {
  const {
    styles,
    defaultTheme = {}
  } = props;
  const globalStyles = typeof styles === 'function' ? themeInput => styles(isEmpty$2(themeInput) ? defaultTheme : themeInput) : styles;
  return /*#__PURE__*/jsxRuntime.exports.jsx(react.Global, {
    styles: globalStyles
  });
}
process.env.NODE_ENV !== "production" ? GlobalStyles.propTypes = {
  defaultTheme: propTypes.exports.object,
  styles: propTypes.exports.oneOfType([propTypes.exports.string, propTypes.exports.object, propTypes.exports.func])
} : void 0;

/** @license MUI v5.8.0
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
function styled$2(tag, options) {
  const stylesFactory = emStyled__default["default"](tag, options);

  if (process.env.NODE_ENV !== 'production') {
    return (...styles) => {
      const component = typeof tag === 'string' ? `"${tag}"` : 'component';

      if (styles.length === 0) {
        console.error([`MUI: Seems like you called \`styled(${component})()\` without a \`style\` argument.`, 'You must provide a `styles` argument: `styled("div")(styleYouForgotToPass)`.'].join('\n'));
      } else if (styles.some(style => style === undefined)) {
        console.error(`MUI: the styled(${component})(...args) API requires all its args to be defined.`);
      }

      return stylesFactory(...styles);
    };
  }

  return stylesFactory;
}

const responsivePropType = process.env.NODE_ENV !== 'production' ? propTypes.exports.oneOfType([propTypes.exports.number, propTypes.exports.string, propTypes.exports.object, propTypes.exports.array]) : {};

function merge(acc, item) {
  if (!item) {
    return acc;
  }

  return deepmerge(acc, item, {
    clone: false // No need to clone deep, it's way faster.

  });
}

// For instance with the first breakpoint xs: [xs, sm[.

const values$1 = {
  xs: 0,
  // phone
  sm: 600,
  // tablet
  md: 900,
  // small laptop
  lg: 1200,
  // desktop
  xl: 1536 // large screen

};
const defaultBreakpoints = {
  // Sorted ASC by size. That's important.
  // It can't be configured as it's used statically for propTypes.
  keys: ['xs', 'sm', 'md', 'lg', 'xl'],
  up: key => `@media (min-width:${values$1[key]}px)`
};
function handleBreakpoints(props, propValue, styleFromPropValue) {
  const theme = props.theme || {};

  if (Array.isArray(propValue)) {
    const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
    return propValue.reduce((acc, item, index) => {
      acc[themeBreakpoints.up(themeBreakpoints.keys[index])] = styleFromPropValue(propValue[index]);
      return acc;
    }, {});
  }

  if (typeof propValue === 'object') {
    const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
    return Object.keys(propValue).reduce((acc, breakpoint) => {
      // key is breakpoint
      if (Object.keys(themeBreakpoints.values || values$1).indexOf(breakpoint) !== -1) {
        const mediaKey = themeBreakpoints.up(breakpoint);
        acc[mediaKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
      } else {
        const cssKey = breakpoint;
        acc[cssKey] = propValue[cssKey];
      }

      return acc;
    }, {});
  }

  const output = styleFromPropValue(propValue);
  return output;
}

function createEmptyBreakpointObject(breakpointsInput = {}) {
  var _breakpointsInput$key;

  const breakpointsInOrder = breakpointsInput == null ? void 0 : (_breakpointsInput$key = breakpointsInput.keys) == null ? void 0 : _breakpointsInput$key.reduce((acc, key) => {
    const breakpointStyleKey = breakpointsInput.up(key);
    acc[breakpointStyleKey] = {};
    return acc;
  }, {});
  return breakpointsInOrder || {};
}
function removeUnusedBreakpoints(breakpointKeys, style) {
  return breakpointKeys.reduce((acc, key) => {
    const breakpointOutput = acc[key];
    const isBreakpointUnused = !breakpointOutput || Object.keys(breakpointOutput).length === 0;

    if (isBreakpointUnused) {
      delete acc[key];
    }

    return acc;
  }, style);
}

function getPath(obj, path, checkVars = true) {
  if (!path || typeof path !== 'string') {
    return null;
  } // Check if CSS variables are used


  if (obj && obj.vars && checkVars) {
    const val = `vars.${path}`.split('.').reduce((acc, item) => acc && acc[item] ? acc[item] : null, obj);

    if (val != null) {
      return val;
    }
  }

  return path.split('.').reduce((acc, item) => {
    if (acc && acc[item] != null) {
      return acc[item];
    }

    return null;
  }, obj);
}

function getValue$1(themeMapping, transform, propValueFinal, userValue = propValueFinal) {
  let value;

  if (typeof themeMapping === 'function') {
    value = themeMapping(propValueFinal);
  } else if (Array.isArray(themeMapping)) {
    value = themeMapping[propValueFinal] || userValue;
  } else {
    value = getPath(themeMapping, propValueFinal) || userValue;
  }

  if (transform) {
    value = transform(value);
  }

  return value;
}

function style$1(options) {
  const {
    prop,
    cssProperty = options.prop,
    themeKey,
    transform
  } = options;

  const fn = props => {
    if (props[prop] == null) {
      return null;
    }

    const propValue = props[prop];
    const theme = props.theme;
    const themeMapping = getPath(theme, themeKey) || {};

    const styleFromPropValue = propValueFinal => {
      let value = getValue$1(themeMapping, transform, propValueFinal);

      if (propValueFinal === value && typeof propValueFinal === 'string') {
        // Haven't found value
        value = getValue$1(themeMapping, transform, `${prop}${propValueFinal === 'default' ? '' : capitalize(propValueFinal)}`, propValueFinal);
      }

      if (cssProperty === false) {
        return value;
      }

      return {
        [cssProperty]: value
      };
    };

    return handleBreakpoints(props, propValue, styleFromPropValue);
  };

  fn.propTypes = process.env.NODE_ENV !== 'production' ? {
    [prop]: responsivePropType
  } : {};
  fn.filterProps = [prop];
  return fn;
}

function compose(...styles) {
  const handlers = styles.reduce((acc, style) => {
    style.filterProps.forEach(prop => {
      acc[prop] = style;
    });
    return acc;
  }, {});

  const fn = props => {
    return Object.keys(props).reduce((acc, prop) => {
      if (handlers[prop]) {
        return merge(acc, handlers[prop](props));
      }

      return acc;
    }, {});
  };

  fn.propTypes = process.env.NODE_ENV !== 'production' ? styles.reduce((acc, style) => Object.assign(acc, style.propTypes), {}) : {};
  fn.filterProps = styles.reduce((acc, style) => acc.concat(style.filterProps), []);
  return fn;
}

function memoize(fn) {
  const cache = {};
  return arg => {
    if (cache[arg] === undefined) {
      cache[arg] = fn(arg);
    }

    return cache[arg];
  };
}

const properties = {
  m: 'margin',
  p: 'padding'
};
const directions = {
  t: 'Top',
  r: 'Right',
  b: 'Bottom',
  l: 'Left',
  x: ['Left', 'Right'],
  y: ['Top', 'Bottom']
};
const aliases = {
  marginX: 'mx',
  marginY: 'my',
  paddingX: 'px',
  paddingY: 'py'
}; // memoize() impact:
// From 300,000 ops/sec
// To 350,000 ops/sec

const getCssProperties = memoize(prop => {
  // It's not a shorthand notation.
  if (prop.length > 2) {
    if (aliases[prop]) {
      prop = aliases[prop];
    } else {
      return [prop];
    }
  }

  const [a, b] = prop.split('');
  const property = properties[a];
  const direction = directions[b] || '';
  return Array.isArray(direction) ? direction.map(dir => property + dir) : [property + direction];
});
const marginKeys = ['m', 'mt', 'mr', 'mb', 'ml', 'mx', 'my', 'margin', 'marginTop', 'marginRight', 'marginBottom', 'marginLeft', 'marginX', 'marginY', 'marginInline', 'marginInlineStart', 'marginInlineEnd', 'marginBlock', 'marginBlockStart', 'marginBlockEnd'];
const paddingKeys = ['p', 'pt', 'pr', 'pb', 'pl', 'px', 'py', 'padding', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft', 'paddingX', 'paddingY', 'paddingInline', 'paddingInlineStart', 'paddingInlineEnd', 'paddingBlock', 'paddingBlockStart', 'paddingBlockEnd'];
const spacingKeys = [...marginKeys, ...paddingKeys];
function createUnaryUnit(theme, themeKey, defaultValue, propName) {
  var _getPath;

  const themeSpacing = (_getPath = getPath(theme, themeKey, false)) != null ? _getPath : defaultValue;

  if (typeof themeSpacing === 'number') {
    return abs => {
      if (typeof abs === 'string') {
        return abs;
      }

      if (process.env.NODE_ENV !== 'production') {
        if (typeof abs !== 'number') {
          console.error(`MUI: Expected ${propName} argument to be a number or a string, got ${abs}.`);
        }
      }

      return themeSpacing * abs;
    };
  }

  if (Array.isArray(themeSpacing)) {
    return abs => {
      if (typeof abs === 'string') {
        return abs;
      }

      if (process.env.NODE_ENV !== 'production') {
        if (!Number.isInteger(abs)) {
          console.error([`MUI: The \`theme.${themeKey}\` array type cannot be combined with non integer values.` + `You should either use an integer value that can be used as index, or define the \`theme.${themeKey}\` as a number.`].join('\n'));
        } else if (abs > themeSpacing.length - 1) {
          console.error([`MUI: The value provided (${abs}) overflows.`, `The supported values are: ${JSON.stringify(themeSpacing)}.`, `${abs} > ${themeSpacing.length - 1}, you need to add the missing values.`].join('\n'));
        }
      }

      return themeSpacing[abs];
    };
  }

  if (typeof themeSpacing === 'function') {
    return themeSpacing;
  }

  if (process.env.NODE_ENV !== 'production') {
    console.error([`MUI: The \`theme.${themeKey}\` value (${themeSpacing}) is invalid.`, 'It should be a number, an array or a function.'].join('\n'));
  }

  return () => undefined;
}
function createUnarySpacing(theme) {
  return createUnaryUnit(theme, 'spacing', 8, 'spacing');
}
function getValue(transformer, propValue) {
  if (typeof propValue === 'string' || propValue == null) {
    return propValue;
  }

  const abs = Math.abs(propValue);
  const transformed = transformer(abs);

  if (propValue >= 0) {
    return transformed;
  }

  if (typeof transformed === 'number') {
    return -transformed;
  }

  return `-${transformed}`;
}
function getStyleFromPropValue(cssProperties, transformer) {
  return propValue => cssProperties.reduce((acc, cssProperty) => {
    acc[cssProperty] = getValue(transformer, propValue);
    return acc;
  }, {});
}

function resolveCssProperty(props, keys, prop, transformer) {
  // Using a hash computation over an array iteration could be faster, but with only 28 items,
  // it's doesn't worth the bundle size.
  if (keys.indexOf(prop) === -1) {
    return null;
  }

  const cssProperties = getCssProperties(prop);
  const styleFromPropValue = getStyleFromPropValue(cssProperties, transformer);
  const propValue = props[prop];
  return handleBreakpoints(props, propValue, styleFromPropValue);
}

function style(props, keys) {
  const transformer = createUnarySpacing(props.theme);
  return Object.keys(props).map(prop => resolveCssProperty(props, keys, prop, transformer)).reduce(merge, {});
}
process.env.NODE_ENV !== 'production' ? marginKeys.reduce((obj, key) => {
  obj[key] = responsivePropType;
  return obj;
}, {}) : {};
process.env.NODE_ENV !== 'production' ? paddingKeys.reduce((obj, key) => {
  obj[key] = responsivePropType;
  return obj;
}, {}) : {};

function spacing(props) {
  return style(props, spacingKeys);
}

spacing.propTypes = process.env.NODE_ENV !== 'production' ? spacingKeys.reduce((obj, key) => {
  obj[key] = responsivePropType;
  return obj;
}, {}) : {};
spacing.filterProps = spacingKeys;

function getBorder(value) {
  if (typeof value !== 'number') {
    return value;
  }

  return `${value}px solid`;
}

const border = style$1({
  prop: 'border',
  themeKey: 'borders',
  transform: getBorder
});
const borderTop = style$1({
  prop: 'borderTop',
  themeKey: 'borders',
  transform: getBorder
});
const borderRight = style$1({
  prop: 'borderRight',
  themeKey: 'borders',
  transform: getBorder
});
const borderBottom = style$1({
  prop: 'borderBottom',
  themeKey: 'borders',
  transform: getBorder
});
const borderLeft = style$1({
  prop: 'borderLeft',
  themeKey: 'borders',
  transform: getBorder
});
const borderColor = style$1({
  prop: 'borderColor',
  themeKey: 'palette'
});
const borderTopColor = style$1({
  prop: 'borderTopColor',
  themeKey: 'palette'
});
const borderRightColor = style$1({
  prop: 'borderRightColor',
  themeKey: 'palette'
});
const borderBottomColor = style$1({
  prop: 'borderBottomColor',
  themeKey: 'palette'
});
const borderLeftColor = style$1({
  prop: 'borderLeftColor',
  themeKey: 'palette'
});
const borderRadius = props => {
  if (props.borderRadius !== undefined && props.borderRadius !== null) {
    const transformer = createUnaryUnit(props.theme, 'shape.borderRadius', 4, 'borderRadius');

    const styleFromPropValue = propValue => ({
      borderRadius: getValue(transformer, propValue)
    });

    return handleBreakpoints(props, props.borderRadius, styleFromPropValue);
  }

  return null;
};
borderRadius.propTypes = process.env.NODE_ENV !== 'production' ? {
  borderRadius: responsivePropType
} : {};
borderRadius.filterProps = ['borderRadius'];
const borders = compose(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius);

const displayPrint = style$1({
  prop: 'displayPrint',
  cssProperty: false,
  transform: value => ({
    '@media print': {
      display: value
    }
  })
});
const displayRaw = style$1({
  prop: 'display'
});
const overflow = style$1({
  prop: 'overflow'
});
const textOverflow = style$1({
  prop: 'textOverflow'
});
const visibility = style$1({
  prop: 'visibility'
});
const whiteSpace = style$1({
  prop: 'whiteSpace'
});
var display = compose(displayPrint, displayRaw, overflow, textOverflow, visibility, whiteSpace);

const flexBasis = style$1({
  prop: 'flexBasis'
});
const flexDirection = style$1({
  prop: 'flexDirection'
});
const flexWrap = style$1({
  prop: 'flexWrap'
});
const justifyContent = style$1({
  prop: 'justifyContent'
});
const alignItems = style$1({
  prop: 'alignItems'
});
const alignContent = style$1({
  prop: 'alignContent'
});
const order = style$1({
  prop: 'order'
});
const flex = style$1({
  prop: 'flex'
});
const flexGrow = style$1({
  prop: 'flexGrow'
});
const flexShrink = style$1({
  prop: 'flexShrink'
});
const alignSelf = style$1({
  prop: 'alignSelf'
});
const justifyItems = style$1({
  prop: 'justifyItems'
});
const justifySelf = style$1({
  prop: 'justifySelf'
});
const flexbox = compose(flexBasis, flexDirection, flexWrap, justifyContent, alignItems, alignContent, order, flex, flexGrow, flexShrink, alignSelf, justifyItems, justifySelf);

const gap = props => {
  if (props.gap !== undefined && props.gap !== null) {
    const transformer = createUnaryUnit(props.theme, 'spacing', 8, 'gap');

    const styleFromPropValue = propValue => ({
      gap: getValue(transformer, propValue)
    });

    return handleBreakpoints(props, props.gap, styleFromPropValue);
  }

  return null;
};
gap.propTypes = process.env.NODE_ENV !== 'production' ? {
  gap: responsivePropType
} : {};
gap.filterProps = ['gap'];
const columnGap = props => {
  if (props.columnGap !== undefined && props.columnGap !== null) {
    const transformer = createUnaryUnit(props.theme, 'spacing', 8, 'columnGap');

    const styleFromPropValue = propValue => ({
      columnGap: getValue(transformer, propValue)
    });

    return handleBreakpoints(props, props.columnGap, styleFromPropValue);
  }

  return null;
};
columnGap.propTypes = process.env.NODE_ENV !== 'production' ? {
  columnGap: responsivePropType
} : {};
columnGap.filterProps = ['columnGap'];
const rowGap = props => {
  if (props.rowGap !== undefined && props.rowGap !== null) {
    const transformer = createUnaryUnit(props.theme, 'spacing', 8, 'rowGap');

    const styleFromPropValue = propValue => ({
      rowGap: getValue(transformer, propValue)
    });

    return handleBreakpoints(props, props.rowGap, styleFromPropValue);
  }

  return null;
};
rowGap.propTypes = process.env.NODE_ENV !== 'production' ? {
  rowGap: responsivePropType
} : {};
rowGap.filterProps = ['rowGap'];
const gridColumn = style$1({
  prop: 'gridColumn'
});
const gridRow = style$1({
  prop: 'gridRow'
});
const gridAutoFlow = style$1({
  prop: 'gridAutoFlow'
});
const gridAutoColumns = style$1({
  prop: 'gridAutoColumns'
});
const gridAutoRows = style$1({
  prop: 'gridAutoRows'
});
const gridTemplateColumns = style$1({
  prop: 'gridTemplateColumns'
});
const gridTemplateRows = style$1({
  prop: 'gridTemplateRows'
});
const gridTemplateAreas = style$1({
  prop: 'gridTemplateAreas'
});
const gridArea = style$1({
  prop: 'gridArea'
});
const grid = compose(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);

const color = style$1({
  prop: 'color',
  themeKey: 'palette'
});
const bgcolor = style$1({
  prop: 'bgcolor',
  cssProperty: 'backgroundColor',
  themeKey: 'palette'
});
const backgroundColor = style$1({
  prop: 'backgroundColor',
  themeKey: 'palette'
});
const palette = compose(color, bgcolor, backgroundColor);

const position = style$1({
  prop: 'position'
});
const zIndex$1 = style$1({
  prop: 'zIndex',
  themeKey: 'zIndex'
});
const top = style$1({
  prop: 'top'
});
const right = style$1({
  prop: 'right'
});
const bottom = style$1({
  prop: 'bottom'
});
const left = style$1({
  prop: 'left'
});
var positions = compose(position, zIndex$1, top, right, bottom, left);

const boxShadow = style$1({
  prop: 'boxShadow',
  themeKey: 'shadows'
});

function transform(value) {
  return value <= 1 && value !== 0 ? `${value * 100}%` : value;
}

const width = style$1({
  prop: 'width',
  transform
});
const maxWidth = props => {
  if (props.maxWidth !== undefined && props.maxWidth !== null) {
    const styleFromPropValue = propValue => {
      var _props$theme, _props$theme$breakpoi, _props$theme$breakpoi2;

      const breakpoint = ((_props$theme = props.theme) == null ? void 0 : (_props$theme$breakpoi = _props$theme.breakpoints) == null ? void 0 : (_props$theme$breakpoi2 = _props$theme$breakpoi.values) == null ? void 0 : _props$theme$breakpoi2[propValue]) || values$1[propValue];
      return {
        maxWidth: breakpoint || transform(propValue)
      };
    };

    return handleBreakpoints(props, props.maxWidth, styleFromPropValue);
  }

  return null;
};
maxWidth.filterProps = ['maxWidth'];
const minWidth = style$1({
  prop: 'minWidth',
  transform
});
const height = style$1({
  prop: 'height',
  transform
});
const maxHeight = style$1({
  prop: 'maxHeight',
  transform
});
const minHeight = style$1({
  prop: 'minHeight',
  transform
});
style$1({
  prop: 'size',
  cssProperty: 'width',
  transform
});
style$1({
  prop: 'size',
  cssProperty: 'height',
  transform
});
const boxSizing = style$1({
  prop: 'boxSizing'
});
const sizing = compose(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);

const fontFamily = style$1({
  prop: 'fontFamily',
  themeKey: 'typography'
});
const fontSize = style$1({
  prop: 'fontSize',
  themeKey: 'typography'
});
const fontStyle = style$1({
  prop: 'fontStyle',
  themeKey: 'typography'
});
const fontWeight = style$1({
  prop: 'fontWeight',
  themeKey: 'typography'
});
const letterSpacing = style$1({
  prop: 'letterSpacing'
});
const textTransform = style$1({
  prop: 'textTransform'
});
const lineHeight = style$1({
  prop: 'lineHeight'
});
const textAlign = style$1({
  prop: 'textAlign'
});
const typographyVariant = style$1({
  prop: 'typography',
  cssProperty: false,
  themeKey: 'typography'
});
const typography = compose(typographyVariant, fontFamily, fontSize, fontStyle, fontWeight, letterSpacing, lineHeight, textAlign, textTransform);

const filterPropsMapping = {
  borders: borders.filterProps,
  display: display.filterProps,
  flexbox: flexbox.filterProps,
  grid: grid.filterProps,
  positions: positions.filterProps,
  palette: palette.filterProps,
  shadows: boxShadow.filterProps,
  sizing: sizing.filterProps,
  spacing: spacing.filterProps,
  typography: typography.filterProps
};
const styleFunctionMapping = {
  borders,
  display,
  flexbox,
  grid,
  positions,
  palette,
  shadows: boxShadow,
  sizing,
  spacing,
  typography
};
const propToStyleFunction = Object.keys(filterPropsMapping).reduce((acc, styleFnName) => {
  filterPropsMapping[styleFnName].forEach(propName => {
    acc[propName] = styleFunctionMapping[styleFnName];
  });
  return acc;
}, {});

function objectsHaveSameKeys(...objects) {
  const allKeys = objects.reduce((keys, object) => keys.concat(Object.keys(object)), []);
  const union = new Set(allKeys);
  return objects.every(object => union.size === Object.keys(object).length);
}

function callIfFn(maybeFn, arg) {
  return typeof maybeFn === 'function' ? maybeFn(arg) : maybeFn;
} // eslint-disable-next-line @typescript-eslint/naming-convention


function unstable_createStyleFunctionSx(styleFunctionMapping$1 = styleFunctionMapping) {
  const propToStyleFunction = Object.keys(styleFunctionMapping$1).reduce((acc, styleFnName) => {
    styleFunctionMapping$1[styleFnName].filterProps.forEach(propName => {
      acc[propName] = styleFunctionMapping$1[styleFnName];
    });
    return acc;
  }, {});

  function getThemeValue(prop, value, theme) {
    const inputProps = {
      [prop]: value,
      theme
    };
    const styleFunction = propToStyleFunction[prop];
    return styleFunction ? styleFunction(inputProps) : {
      [prop]: value
    };
  }

  function styleFunctionSx(props) {
    const {
      sx,
      theme = {}
    } = props || {};

    if (!sx) {
      return null; // emotion & styled-components will neglect null
    }
    /*
     * Receive `sxInput` as object or callback
     * and then recursively check keys & values to create media query object styles.
     * (the result will be used in `styled`)
     */


    function traverse(sxInput) {
      let sxObject = sxInput;

      if (typeof sxInput === 'function') {
        sxObject = sxInput(theme);
      } else if (typeof sxInput !== 'object') {
        // value
        return sxInput;
      }

      if (!sxObject) {
        return null;
      }

      const emptyBreakpoints = createEmptyBreakpointObject(theme.breakpoints);
      const breakpointsKeys = Object.keys(emptyBreakpoints);
      let css = emptyBreakpoints;
      Object.keys(sxObject).forEach(styleKey => {
        const value = callIfFn(sxObject[styleKey], theme);

        if (value !== null && value !== undefined) {
          if (typeof value === 'object') {
            if (propToStyleFunction[styleKey]) {
              css = merge(css, getThemeValue(styleKey, value, theme));
            } else {
              const breakpointsValues = handleBreakpoints({
                theme
              }, value, x => ({
                [styleKey]: x
              }));

              if (objectsHaveSameKeys(breakpointsValues, value)) {
                css[styleKey] = styleFunctionSx({
                  sx: value,
                  theme
                });
              } else {
                css = merge(css, breakpointsValues);
              }
            }
          } else {
            css = merge(css, getThemeValue(styleKey, value, theme));
          }
        }
      });
      return removeUnusedBreakpoints(breakpointsKeys, css);
    }

    return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);
  }

  return styleFunctionSx;
}
const styleFunctionSx = unstable_createStyleFunctionSx();
styleFunctionSx.filterProps = ['sx'];

const _excluded$f = ["sx"];

const splitProps = props => {
  const result = {
    systemProps: {},
    otherProps: {}
  };
  Object.keys(props).forEach(prop => {
    if (propToStyleFunction[prop]) {
      result.systemProps[prop] = props[prop];
    } else {
      result.otherProps[prop] = props[prop];
    }
  });
  return result;
};

function extendSxProp(props) {
  const {
    sx: inSx
  } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$f);

  const {
    systemProps,
    otherProps
  } = splitProps(other);
  let finalSx;

  if (Array.isArray(inSx)) {
    finalSx = [systemProps, ...inSx];
  } else if (typeof inSx === 'function') {
    finalSx = (...args) => {
      const result = inSx(...args);

      if (!isPlainObject(result)) {
        return systemProps;
      }

      return _extends({}, systemProps, result);
    };
  } else {
    finalSx = _extends({}, systemProps, inSx);
  }

  return _extends({}, otherProps, {
    sx: finalSx
  });
}

const _excluded$e = ["values", "unit", "step"];

const sortBreakpointsValues = values => {
  const breakpointsAsArray = Object.keys(values).map(key => ({
    key,
    val: values[key]
  })) || []; // Sort in ascending order

  breakpointsAsArray.sort((breakpoint1, breakpoint2) => breakpoint1.val - breakpoint2.val);
  return breakpointsAsArray.reduce((acc, obj) => {
    return _extends({}, acc, {
      [obj.key]: obj.val
    });
  }, {});
}; // Keep in mind that @media is inclusive by the CSS specification.


function createBreakpoints(breakpoints) {
  const {
    // The breakpoint **start** at this value.
    // For instance with the first breakpoint xs: [xs, sm).
    values = {
      xs: 0,
      // phone
      sm: 600,
      // tablet
      md: 900,
      // small laptop
      lg: 1200,
      // desktop
      xl: 1536 // large screen

    },
    unit = 'px',
    step = 5
  } = breakpoints,
        other = _objectWithoutPropertiesLoose(breakpoints, _excluded$e);

  const sortedValues = sortBreakpointsValues(values);
  const keys = Object.keys(sortedValues);

  function up(key) {
    const value = typeof values[key] === 'number' ? values[key] : key;
    return `@media (min-width:${value}${unit})`;
  }

  function down(key) {
    const value = typeof values[key] === 'number' ? values[key] : key;
    return `@media (max-width:${value - step / 100}${unit})`;
  }

  function between(start, end) {
    const endIndex = keys.indexOf(end);
    return `@media (min-width:${typeof values[start] === 'number' ? values[start] : start}${unit}) and ` + `(max-width:${(endIndex !== -1 && typeof values[keys[endIndex]] === 'number' ? values[keys[endIndex]] : end) - step / 100}${unit})`;
  }

  function only(key) {
    if (keys.indexOf(key) + 1 < keys.length) {
      return between(key, keys[keys.indexOf(key) + 1]);
    }

    return up(key);
  }

  function not(key) {
    // handle first and last key separately, for better readability
    const keyIndex = keys.indexOf(key);

    if (keyIndex === 0) {
      return up(keys[1]);
    }

    if (keyIndex === keys.length - 1) {
      return down(keys[keyIndex]);
    }

    return between(key, keys[keys.indexOf(key) + 1]).replace('@media', '@media not all and');
  }

  return _extends({
    keys,
    values: sortedValues,
    up,
    down,
    between,
    only,
    not,
    unit
  }, other);
}

const shape = {
  borderRadius: 4
};

/* tslint:enable:unified-signatures */
function createSpacing(spacingInput = 8) {
  // Already transformed.
  if (spacingInput.mui) {
    return spacingInput;
  } // Material Design layouts are visually balanced. Most measurements align to an 8dp grid, which aligns both spacing and the overall layout.
  // Smaller components, such as icons, can align to a 4dp grid.
  // https://material.io/design/layout/understanding-layout.html#usage


  const transform = createUnarySpacing({
    spacing: spacingInput
  });

  const spacing = (...argsInput) => {
    if (process.env.NODE_ENV !== 'production') {
      if (!(argsInput.length <= 4)) {
        console.error(`MUI: Too many arguments provided, expected between 0 and 4, got ${argsInput.length}`);
      }
    }

    const args = argsInput.length === 0 ? [1] : argsInput;
    return args.map(argument => {
      const output = transform(argument);
      return typeof output === 'number' ? `${output}px` : output;
    }).join(' ');
  };

  spacing.mui = true;
  return spacing;
}

const _excluded$d = ["breakpoints", "palette", "spacing", "shape"];

function createTheme$1(options = {}, ...args) {
  const {
    breakpoints: breakpointsInput = {},
    palette: paletteInput = {},
    spacing: spacingInput,
    shape: shapeInput = {}
  } = options,
        other = _objectWithoutPropertiesLoose(options, _excluded$d);

  const breakpoints = createBreakpoints(breakpointsInput);
  const spacing = createSpacing(spacingInput);
  let muiTheme = deepmerge({
    breakpoints,
    direction: 'ltr',
    components: {},
    // Inject component definitions.
    palette: _extends({
      mode: 'light'
    }, paletteInput),
    spacing,
    shape: _extends({}, shape, shapeInput)
  }, other);
  muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
  return muiTheme;
}

const ThemeContext = /*#__PURE__*/React__namespace.createContext(null);

if (process.env.NODE_ENV !== 'production') {
  ThemeContext.displayName = 'ThemeContext';
}

function useTheme$3() {
  const theme = React__namespace.useContext(ThemeContext);

  if (process.env.NODE_ENV !== 'production') {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    React__namespace.useDebugValue(theme);
  }

  return theme;
}

const hasSymbol = typeof Symbol === 'function' && Symbol.for;
var nested = hasSymbol ? Symbol.for('mui.nested') : '__THEME_NESTED__';

function mergeOuterLocalTheme(outerTheme, localTheme) {
  if (typeof localTheme === 'function') {
    const mergedTheme = localTheme(outerTheme);

    if (process.env.NODE_ENV !== 'production') {
      if (!mergedTheme) {
        console.error(['MUI: You should return an object from your theme function, i.e.', '<ThemeProvider theme={() => ({})} />'].join('\n'));
      }
    }

    return mergedTheme;
  }

  return _extends({}, outerTheme, localTheme);
}
/**
 * This component takes a `theme` prop.
 * It makes the `theme` available down the React tree thanks to React context.
 * This component should preferably be used at **the root of your component tree**.
 */


function ThemeProvider$1(props) {
  const {
    children,
    theme: localTheme
  } = props;
  const outerTheme = useTheme$3();

  if (process.env.NODE_ENV !== 'production') {
    if (outerTheme === null && typeof localTheme === 'function') {
      console.error(['MUI: You are providing a theme function prop to the ThemeProvider component:', '<ThemeProvider theme={outerTheme => outerTheme} />', '', 'However, no outer theme is present.', 'Make sure a theme is already injected higher in the React tree ' + 'or provide a theme object.'].join('\n'));
    }
  }

  const theme = React__namespace.useMemo(() => {
    const output = outerTheme === null ? localTheme : mergeOuterLocalTheme(outerTheme, localTheme);

    if (output != null) {
      output[nested] = outerTheme !== null;
    }

    return output;
  }, [localTheme, outerTheme]);
  return /*#__PURE__*/jsxRuntime.exports.jsx(ThemeContext.Provider, {
    value: theme,
    children: children
  });
}

process.env.NODE_ENV !== "production" ? ThemeProvider$1.propTypes = {
  /**
   * Your component tree.
   */
  children: propTypes.exports.node,

  /**
   * A theme object. You can provide a function to extend the outer theme.
   */
  theme: propTypes.exports.oneOfType([propTypes.exports.object, propTypes.exports.func]).isRequired
} : void 0;

if (process.env.NODE_ENV !== 'production') {
  process.env.NODE_ENV !== "production" ? ThemeProvider$1.propTypes = exactProp(ThemeProvider$1.propTypes) : void 0;
}

function isObjectEmpty(obj) {
  return Object.keys(obj).length === 0;
}

function useTheme$2(defaultTheme = null) {
  const contextTheme = useTheme$3();
  return !contextTheme || isObjectEmpty(contextTheme) ? defaultTheme : contextTheme;
}

const systemDefaultTheme$1 = createTheme$1();

function useTheme$1(defaultTheme = systemDefaultTheme$1) {
  return useTheme$2(defaultTheme);
}

const _excluded$c = ["className", "component"];
function createBox(options = {}) {
  const {
    defaultTheme,
    defaultClassName = 'MuiBox-root',
    generateClassName,
    styleFunctionSx: styleFunctionSx$1 = styleFunctionSx
  } = options;
  const BoxRoot = styled$2('div')(styleFunctionSx$1);
  const Box = /*#__PURE__*/React__namespace.forwardRef(function Box(inProps, ref) {
    const theme = useTheme$1(defaultTheme);

    const _extendSxProp = extendSxProp(inProps),
          {
      className,
      component = 'div'
    } = _extendSxProp,
          other = _objectWithoutPropertiesLoose(_extendSxProp, _excluded$c);

    return /*#__PURE__*/jsxRuntime.exports.jsx(BoxRoot, _extends({
      as: component,
      ref: ref,
      className: clsx(className, generateClassName ? generateClassName(defaultClassName) : defaultClassName),
      theme: theme
    }, other));
  });
  return Box;
}

const Box = createBox();
process.env.NODE_ENV !== "production" ? Box.propTypes
/* remove-proptypes */
= {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------

  /**
   * @ignore
   */
  children: propTypes.exports.node,

  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: propTypes.exports.elementType,

  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: propTypes.exports.oneOfType([propTypes.exports.arrayOf(propTypes.exports.oneOfType([propTypes.exports.func, propTypes.exports.object, propTypes.exports.bool])), propTypes.exports.func, propTypes.exports.object])
} : void 0;

const _excluded$b = ["variant"];

function isEmpty$1(string) {
  return string.length === 0;
}
/**
 * Generates string classKey based on the properties provided. It starts with the
 * variant if defined, and then it appends all other properties in alphabetical order.
 * @param {object} props - the properties for which the classKey should be created.
 */


function propsToClassKey(props) {
  const {
    variant
  } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$b);

  let classKey = variant || '';
  Object.keys(other).sort().forEach(key => {
    if (key === 'color') {
      classKey += isEmpty$1(classKey) ? props[key] : capitalize(props[key]);
    } else {
      classKey += `${isEmpty$1(classKey) ? key : capitalize(key)}${capitalize(props[key].toString())}`;
    }
  });
  return classKey;
}

const _excluded$a = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"],
      _excluded2$1 = ["theme"],
      _excluded3 = ["theme"];

function isEmpty(obj) {
  return Object.keys(obj).length === 0;
}

const getStyleOverrides = (name, theme) => {
  if (theme.components && theme.components[name] && theme.components[name].styleOverrides) {
    return theme.components[name].styleOverrides;
  }

  return null;
};

const getVariantStyles = (name, theme) => {
  let variants = [];

  if (theme && theme.components && theme.components[name] && theme.components[name].variants) {
    variants = theme.components[name].variants;
  }

  const variantsStyles = {};
  variants.forEach(definition => {
    const key = propsToClassKey(definition.props);
    variantsStyles[key] = definition.style;
  });
  return variantsStyles;
};

const variantsResolver = (props, styles, theme, name) => {
  var _theme$components, _theme$components$nam;

  const {
    ownerState = {}
  } = props;
  const variantsStyles = [];
  const themeVariants = theme == null ? void 0 : (_theme$components = theme.components) == null ? void 0 : (_theme$components$nam = _theme$components[name]) == null ? void 0 : _theme$components$nam.variants;

  if (themeVariants) {
    themeVariants.forEach(themeVariant => {
      let isMatch = true;
      Object.keys(themeVariant.props).forEach(key => {
        if (ownerState[key] !== themeVariant.props[key] && props[key] !== themeVariant.props[key]) {
          isMatch = false;
        }
      });

      if (isMatch) {
        variantsStyles.push(styles[propsToClassKey(themeVariant.props)]);
      }
    });
  }

  return variantsStyles;
}; // Update /system/styled/#api in case if this changes


function shouldForwardProp(prop) {
  return prop !== 'ownerState' && prop !== 'theme' && prop !== 'sx' && prop !== 'as';
}
const systemDefaultTheme = createTheme$1();

const lowercaseFirstLetter = string => {
  return string.charAt(0).toLowerCase() + string.slice(1);
};

function createStyled(input = {}) {
  const {
    defaultTheme = systemDefaultTheme,
    rootShouldForwardProp = shouldForwardProp,
    slotShouldForwardProp = shouldForwardProp,
    styleFunctionSx: styleFunctionSx$1 = styleFunctionSx
  } = input;
  return (tag, inputOptions = {}) => {
    const {
      name: componentName,
      slot: componentSlot,
      skipVariantsResolver: inputSkipVariantsResolver,
      skipSx: inputSkipSx,
      overridesResolver
    } = inputOptions,
          options = _objectWithoutPropertiesLoose(inputOptions, _excluded$a); // if skipVariantsResolver option is defined, take the value, otherwise, true for root and false for other slots.


    const skipVariantsResolver = inputSkipVariantsResolver !== undefined ? inputSkipVariantsResolver : componentSlot && componentSlot !== 'Root' || false;
    const skipSx = inputSkipSx || false;
    let label;

    if (process.env.NODE_ENV !== 'production') {
      if (componentName) {
        label = `${componentName}-${lowercaseFirstLetter(componentSlot || 'Root')}`;
      }
    }

    let shouldForwardPropOption = shouldForwardProp;

    if (componentSlot === 'Root') {
      shouldForwardPropOption = rootShouldForwardProp;
    } else if (componentSlot) {
      // any other slot specified
      shouldForwardPropOption = slotShouldForwardProp;
    }

    const defaultStyledResolver = styled$2(tag, _extends({
      shouldForwardProp: shouldForwardPropOption,
      label
    }, options));

    const muiStyledResolver = (styleArg, ...expressions) => {
      const expressionsWithDefaultTheme = expressions ? expressions.map(stylesArg => {
        // On the server emotion doesn't use React.forwardRef for creating components, so the created
        // component stays as a function. This condition makes sure that we do not interpolate functions
        // which are basically components used as a selectors.
        // eslint-disable-next-line no-underscore-dangle
        return typeof stylesArg === 'function' && stylesArg.__emotion_real !== stylesArg ? _ref => {
          let {
            theme: themeInput
          } = _ref,
              other = _objectWithoutPropertiesLoose(_ref, _excluded2$1);

          return stylesArg(_extends({
            theme: isEmpty(themeInput) ? defaultTheme : themeInput
          }, other));
        } : stylesArg;
      }) : [];
      let transformedStyleArg = styleArg;

      if (componentName && overridesResolver) {
        expressionsWithDefaultTheme.push(props => {
          const theme = isEmpty(props.theme) ? defaultTheme : props.theme;
          const styleOverrides = getStyleOverrides(componentName, theme);

          if (styleOverrides) {
            const resolvedStyleOverrides = {};
            Object.entries(styleOverrides).forEach(([slotKey, slotStyle]) => {
              resolvedStyleOverrides[slotKey] = typeof slotStyle === 'function' ? slotStyle(_extends({}, props, {
                theme
              })) : slotStyle;
            });
            return overridesResolver(props, resolvedStyleOverrides);
          }

          return null;
        });
      }

      if (componentName && !skipVariantsResolver) {
        expressionsWithDefaultTheme.push(props => {
          const theme = isEmpty(props.theme) ? defaultTheme : props.theme;
          return variantsResolver(props, getVariantStyles(componentName, theme), theme, componentName);
        });
      }

      if (!skipSx) {
        expressionsWithDefaultTheme.push(props => {
          const theme = isEmpty(props.theme) ? defaultTheme : props.theme;
          return styleFunctionSx$1(_extends({}, props, {
            theme
          }));
        });
      }

      const numOfCustomFnsApplied = expressionsWithDefaultTheme.length - expressions.length;

      if (Array.isArray(styleArg) && numOfCustomFnsApplied > 0) {
        const placeholders = new Array(numOfCustomFnsApplied).fill(''); // If the type is array, than we need to add placeholders in the template for the overrides, variants and the sx styles.

        transformedStyleArg = [...styleArg, ...placeholders];
        transformedStyleArg.raw = [...styleArg.raw, ...placeholders];
      } else if (typeof styleArg === 'function' && // On the server emotion doesn't use React.forwardRef for creating components, so the created
      // component stays as a function. This condition makes sure that we do not interpolate functions
      // which are basically components used as a selectors.
      // eslint-disable-next-line no-underscore-dangle
      styleArg.__emotion_real !== styleArg) {
        // If the type is function, we need to define the default theme.
        transformedStyleArg = _ref2 => {
          let {
            theme: themeInput
          } = _ref2,
              other = _objectWithoutPropertiesLoose(_ref2, _excluded3);

          return styleArg(_extends({
            theme: isEmpty(themeInput) ? defaultTheme : themeInput
          }, other));
        };
      }

      const Component = defaultStyledResolver(transformedStyleArg, ...expressionsWithDefaultTheme);

      if (process.env.NODE_ENV !== 'production') {
        let displayName;

        if (componentName) {
          displayName = `${componentName}${componentSlot || ''}`;
        }

        if (displayName === undefined) {
          displayName = `Styled(${getDisplayName(tag)})`;
        }

        Component.displayName = displayName;
      }

      return Component;
    };

    if (defaultStyledResolver.withConfig) {
      muiStyledResolver.withConfig = defaultStyledResolver.withConfig;
    }

    return muiStyledResolver;
  };
}

const styled$1 = createStyled();

function getThemeProps(params) {
  const {
    theme,
    name,
    props
  } = params;

  if (!theme || !theme.components || !theme.components[name] || !theme.components[name].defaultProps) {
    return props;
  }

  return resolveProps(theme.components[name].defaultProps, props);
}

function useThemeProps$1({
  props,
  name,
  defaultTheme
}) {
  const theme = useTheme$1(defaultTheme);
  const mergedProps = getThemeProps({
    theme,
    name,
    props
  });
  return mergedProps;
}

/**
 * Returns a number whose value is limited to the given range.
 * @param {number} value The value to be clamped
 * @param {number} min The lower boundary of the output range
 * @param {number} max The upper boundary of the output range
 * @returns {number} A number in the range [min, max]
 */
function clamp(value, min = 0, max = 1) {
  if (process.env.NODE_ENV !== 'production') {
    if (value < min || value > max) {
      console.error(`MUI: The value provided ${value} is out of range [${min}, ${max}].`);
    }
  }

  return Math.min(Math.max(min, value), max);
}
/**
 * Converts a color from CSS hex format to CSS rgb format.
 * @param {string} color - Hex color, i.e. #nnn or #nnnnnn
 * @returns {string} A CSS rgb color string
 */


function hexToRgb(color) {
  color = color.slice(1);
  const re = new RegExp(`.{1,${color.length >= 6 ? 2 : 1}}`, 'g');
  let colors = color.match(re);

  if (colors && colors[0].length === 1) {
    colors = colors.map(n => n + n);
  }

  return colors ? `rgb${colors.length === 4 ? 'a' : ''}(${colors.map((n, index) => {
    return index < 3 ? parseInt(n, 16) : Math.round(parseInt(n, 16) / 255 * 1000) / 1000;
  }).join(', ')})` : '';
}
/**
 * Returns an object with the type and values of a color.
 *
 * Note: Does not support rgb % values.
 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
 * @returns {object} - A MUI color object: {type: string, values: number[]}
 */


function decomposeColor(color) {
  // Idempotent
  if (color.type) {
    return color;
  }

  if (color.charAt(0) === '#') {
    return decomposeColor(hexToRgb(color));
  }

  const marker = color.indexOf('(');
  const type = color.substring(0, marker);

  if (['rgb', 'rgba', 'hsl', 'hsla', 'color'].indexOf(type) === -1) {
    throw new Error(process.env.NODE_ENV !== "production" ? `MUI: Unsupported \`${color}\` color.
The following formats are supported: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().` : formatMuiErrorMessage(9, color));
  }

  let values = color.substring(marker + 1, color.length - 1);
  let colorSpace;

  if (type === 'color') {
    values = values.split(' ');
    colorSpace = values.shift();

    if (values.length === 4 && values[3].charAt(0) === '/') {
      values[3] = values[3].slice(1);
    }

    if (['srgb', 'display-p3', 'a98-rgb', 'prophoto-rgb', 'rec-2020'].indexOf(colorSpace) === -1) {
      throw new Error(process.env.NODE_ENV !== "production" ? `MUI: unsupported \`${colorSpace}\` color space.
The following color spaces are supported: srgb, display-p3, a98-rgb, prophoto-rgb, rec-2020.` : formatMuiErrorMessage(10, colorSpace));
    }
  } else {
    values = values.split(',');
  }

  values = values.map(value => parseFloat(value));
  return {
    type,
    values,
    colorSpace
  };
}
/**
 * Returns a channel created from the input color.
 *
 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
 * @returns {string} - The channel for the color, that can be used in rgba or hsla colors
 */

const colorChannel = color => {
  const decomposedColor = decomposeColor(color);
  return decomposedColor.values.slice(0, 3).map((val, idx) => decomposedColor.type.indexOf('hsl') !== -1 && idx !== 0 ? `${val}%` : val).join(' ');
};
/**
 * Converts a color object with type and values to a string.
 * @param {object} color - Decomposed color
 * @param {string} color.type - One of: 'rgb', 'rgba', 'hsl', 'hsla'
 * @param {array} color.values - [n,n,n] or [n,n,n,n]
 * @returns {string} A CSS color string
 */

function recomposeColor(color) {
  const {
    type,
    colorSpace
  } = color;
  let {
    values
  } = color;

  if (type.indexOf('rgb') !== -1) {
    // Only convert the first 3 values to int (i.e. not alpha)
    values = values.map((n, i) => i < 3 ? parseInt(n, 10) : n);
  } else if (type.indexOf('hsl') !== -1) {
    values[1] = `${values[1]}%`;
    values[2] = `${values[2]}%`;
  }

  if (type.indexOf('color') !== -1) {
    values = `${colorSpace} ${values.join(' ')}`;
  } else {
    values = `${values.join(', ')}`;
  }

  return `${type}(${values})`;
}
/**
 * Converts a color from hsl format to rgb format.
 * @param {string} color - HSL color values
 * @returns {string} rgb color values
 */

function hslToRgb(color) {
  color = decomposeColor(color);
  const {
    values
  } = color;
  const h = values[0];
  const s = values[1] / 100;
  const l = values[2] / 100;
  const a = s * Math.min(l, 1 - l);

  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);

  let type = 'rgb';
  const rgb = [Math.round(f(0) * 255), Math.round(f(8) * 255), Math.round(f(4) * 255)];

  if (color.type === 'hsla') {
    type += 'a';
    rgb.push(values[3]);
  }

  return recomposeColor({
    type,
    values: rgb
  });
}
/**
 * The relative brightness of any point in a color space,
 * normalized to 0 for darkest black and 1 for lightest white.
 *
 * Formula: https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests
 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
 * @returns {number} The relative brightness of the color in the range 0 - 1
 */

function getLuminance(color) {
  color = decomposeColor(color);
  let rgb = color.type === 'hsl' ? decomposeColor(hslToRgb(color)).values : color.values;
  rgb = rgb.map(val => {
    if (color.type !== 'color') {
      val /= 255; // normalized
    }

    return val <= 0.03928 ? val / 12.92 : ((val + 0.055) / 1.055) ** 2.4;
  }); // Truncate at 3 digits

  return Number((0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]).toFixed(3));
}
/**
 * Calculates the contrast ratio between two colors.
 *
 * Formula: https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests
 * @param {string} foreground - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
 * @param {string} background - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
 * @returns {number} A contrast ratio value in the range 0 - 21.
 */

function getContrastRatio(foreground, background) {
  const lumA = getLuminance(foreground);
  const lumB = getLuminance(background);
  return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
}
/**
 * Sets the absolute transparency of a color.
 * Any existing alpha values are overwritten.
 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
 * @param {number} value - value to set the alpha channel to in the range 0 - 1
 * @returns {string} A CSS color string. Hex input values are returned as rgb
 */

function alpha(color, value) {
  color = decomposeColor(color);
  value = clamp(value);

  if (color.type === 'rgb' || color.type === 'hsl') {
    color.type += 'a';
  }

  if (color.type === 'color') {
    color.values[3] = `/${value}`;
  } else {
    color.values[3] = value;
  }

  return recomposeColor(color);
}
/**
 * Darkens a color.
 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
 * @param {number} coefficient - multiplier in the range 0 - 1
 * @returns {string} A CSS color string. Hex input values are returned as rgb
 */

function darken(color, coefficient) {
  color = decomposeColor(color);
  coefficient = clamp(coefficient);

  if (color.type.indexOf('hsl') !== -1) {
    color.values[2] *= 1 - coefficient;
  } else if (color.type.indexOf('rgb') !== -1 || color.type.indexOf('color') !== -1) {
    for (let i = 0; i < 3; i += 1) {
      color.values[i] *= 1 - coefficient;
    }
  }

  return recomposeColor(color);
}
/**
 * Lightens a color.
 * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
 * @param {number} coefficient - multiplier in the range 0 - 1
 * @returns {string} A CSS color string. Hex input values are returned as rgb
 */

function lighten(color, coefficient) {
  color = decomposeColor(color);
  coefficient = clamp(coefficient);

  if (color.type.indexOf('hsl') !== -1) {
    color.values[2] += (100 - color.values[2]) * coefficient;
  } else if (color.type.indexOf('rgb') !== -1) {
    for (let i = 0; i < 3; i += 1) {
      color.values[i] += (255 - color.values[i]) * coefficient;
    }
  } else if (color.type.indexOf('color') !== -1) {
    for (let i = 0; i < 3; i += 1) {
      color.values[i] += (1 - color.values[i]) * coefficient;
    }
  }

  return recomposeColor(color);
}

function InnerThemeProvider(props) {
  const theme = useTheme$1();
  return /*#__PURE__*/jsxRuntime.exports.jsx(react.ThemeContext.Provider, {
    value: typeof theme === 'object' ? theme : {},
    children: props.children
  });
}

process.env.NODE_ENV !== "production" ? InnerThemeProvider.propTypes = {
  /**
   * Your component tree.
   */
  children: propTypes.exports.node
} : void 0;
/**
 * This component makes the `theme` available down the React tree.
 * It should preferably be used at **the root of your component tree**.
 */

function ThemeProvider(props) {
  const {
    children,
    theme: localTheme
  } = props;
  return /*#__PURE__*/jsxRuntime.exports.jsx(ThemeProvider$1, {
    theme: localTheme,
    children: /*#__PURE__*/jsxRuntime.exports.jsx(InnerThemeProvider, {
      children: children
    })
  });
}

process.env.NODE_ENV !== "production" ? ThemeProvider.propTypes
/* remove-proptypes */
= {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------

  /**
   * Your component tree.
   */
  children: propTypes.exports.node,

  /**
   * A theme object. You can provide a function to extend the outer theme.
   */
  theme: propTypes.exports.oneOfType([propTypes.exports.func, propTypes.exports.object]).isRequired
} : void 0;

if (process.env.NODE_ENV !== 'production') {
  process.env.NODE_ENV !== "production" ? ThemeProvider.propTypes = exactProp(ThemeProvider.propTypes) : void 0;
}

/**
 * This function create an object from keys, value and then assign to target
 *
 * @param {Object} obj : the target object to be assigned
 * @param {string[]} keys
 * @param {string | number} value
 *
 * @example
 * const source = {}
 * assignNestedKeys(source, ['palette', 'primary'], 'var(--palette-primary)')
 * console.log(source) // { palette: { primary: 'var(--palette-primary)' } }
 *
 * @example
 * const source = { palette: { primary: 'var(--palette-primary)' } }
 * assignNestedKeys(source, ['palette', 'secondary'], 'var(--palette-secondary)')
 * console.log(source) // { palette: { primary: 'var(--palette-primary)', secondary: 'var(--palette-secondary)' } }
 */
const assignNestedKeys = (obj, keys, value, arrayKeys = []) => {
  let temp = obj;
  keys.forEach((k, index) => {
    if (index === keys.length - 1) {
      if (Array.isArray(temp)) {
        temp[Number(k)] = value;
      } else if (temp && typeof temp === 'object') {
        temp[k] = value;
      }
    } else if (temp && typeof temp === 'object') {
      if (!temp[k]) {
        temp[k] = arrayKeys.includes(k) ? [] : {};
      }

      temp = temp[k];
    }
  });
};
/**
 *
 * @param {Object} obj : source object
 * @param {Function} callback : a function that will be called when
 *                   - the deepest key in source object is reached
 *                   - the value of the deepest key is NOT `undefined` | `null`
 *
 * @example
 * walkObjectDeep({ palette: { primary: { main: '#000000' } } }, console.log)
 * // ['palette', 'primary', 'main'] '#000000'
 */

const walkObjectDeep = (obj, callback, shouldSkipPaths) => {
  function recurse(object, parentKeys = [], arrayKeys = []) {
    Object.entries(object).forEach(([key, value]) => {
      if (!shouldSkipPaths || shouldSkipPaths && !shouldSkipPaths([...parentKeys, key])) {
        if (value !== undefined && value !== null) {
          if (typeof value === 'object' && Object.keys(value).length > 0) {
            recurse(value, [...parentKeys, key], Array.isArray(value) ? [...arrayKeys, key] : arrayKeys);
          } else {
            callback([...parentKeys, key], value, arrayKeys);
          }
        }
      }
    });
  }

  recurse(obj);
};

const getCssValue = (keys, value) => {
  if (typeof value === 'number') {
    if (['lineHeight', 'fontWeight', 'opacity', 'zIndex'].some(prop => keys.includes(prop))) {
      // CSS property that are unitless
      return value;
    }

    const lastKey = keys[keys.length - 1];

    if (lastKey.toLowerCase().indexOf('opacity') >= 0) {
      // opacity values are unitless
      return value;
    }

    return `${value}px`;
  }

  return value;
};
/**
 * a function that parse theme and return { css, vars }
 *
 * @param {Object} theme
 * @param {{
 *  prefix?: string,
 *  basePrefix?: string,
 *  shouldSkipGeneratingVar?: (objectPathKeys: Array<string>, value: string | number) => boolean
 * }} options.
 *  `basePrefix`: defined by design system.
 *  `prefix`: defined by application
 *
 *   the CSS variable value will be adjusted based on the provided `basePrefix` & `prefix` which can be found in `parsedTheme`.
 *
 * @returns {{ css: Object, vars: Object, parsedTheme: typeof theme }} `css` is the stylesheet, `vars` is an object to get css variable (same structure as theme), and `parsedTheme` is the cloned version of theme.
 *
 * @example
 * const { css, vars, parsedTheme } = parser({
 *   fontSize: 12,
 *   lineHeight: 1.2,
 *   palette: { primary: { 500: 'var(--color)' } }
 * }, { prefix: 'foo' })
 *
 * console.log(css) // { '--foo-fontSize': '12px', '--foo-lineHeight': 1.2, '--foo-palette-primary-500': 'var(--foo-color)' }
 * console.log(vars) // { fontSize: '--foo-fontSize', lineHeight: '--foo-lineHeight', palette: { primary: { 500: 'var(--foo-palette-primary-500)' } } }
 * console.log(parsedTheme) // { fontSize: 12, lineHeight: 1.2, palette: { primary: { 500: 'var(--foo-color)' } } }
 */


function cssVarsParser(theme, options) {
  const {
    prefix,
    basePrefix = '',
    shouldSkipGeneratingVar
  } = options || {};
  const css = {};
  const vars = {};
  const parsedTheme = {};
  walkObjectDeep(theme, (keys, value, arrayKeys) => {
    if (typeof value === 'string' || typeof value === 'number') {
      if (typeof value === 'string' && value.match(/var\(\s*--/)) {
        // for CSS variable, apply prefix or remove basePrefix from the variable
        if (!basePrefix && prefix) {
          value = value.replace(/var\(\s*--/g, `var(--${prefix}-`);
        } else {
          value = prefix ? value.replace(new RegExp(`var\\(\\s*--${basePrefix}`, 'g'), `var(--${prefix}`) // removing spaces
          : value.replace(new RegExp(`var\\(\\s*--${basePrefix}-`, 'g'), 'var(--');
        }
      }

      if (!shouldSkipGeneratingVar || shouldSkipGeneratingVar && !shouldSkipGeneratingVar(keys, value)) {
        // only create css & var if `shouldSkipGeneratingVar` return false
        const cssVar = `--${prefix ? `${prefix}-` : ''}${keys.join('-')}`;
        Object.assign(css, {
          [cssVar]: getCssValue(keys, value)
        });
        assignNestedKeys(vars, keys, `var(${cssVar})`, arrayKeys);
      }
    }

    assignNestedKeys(parsedTheme, keys, value, arrayKeys);
  }, keys => keys[0] === 'vars' // skip 'vars/*' paths
  );
  return {
    css,
    vars,
    parsedTheme
  };
}

const DEFAULT_MODE_STORAGE_KEY = 'mode';
const DEFAULT_COLOR_SCHEME_STORAGE_KEY = 'color-scheme';
const DEFAULT_ATTRIBUTE = 'data-color-scheme';
function getInitColorSchemeScript(options) {
  const {
    enableSystem = false,
    defaultLightColorScheme = 'light',
    defaultDarkColorScheme = 'dark',
    modeStorageKey = DEFAULT_MODE_STORAGE_KEY,
    colorSchemeStorageKey = DEFAULT_COLOR_SCHEME_STORAGE_KEY,
    attribute = DEFAULT_ATTRIBUTE,
    colorSchemeNode = 'document.documentElement'
  } = options || {};
  return /*#__PURE__*/jsxRuntime.exports.jsx("script", {
    // eslint-disable-next-line react/no-danger
    dangerouslySetInnerHTML: {
      __html: `(function() { try {
        var mode = localStorage.getItem('${modeStorageKey}');
        var colorScheme = '';
        if (mode === 'system' || (!mode && !!${enableSystem})) {
          // handle system mode
          var mql = window.matchMedia('(prefers-color-scheme: dark)');
          if (mql.matches) {
            colorScheme = localStorage.getItem('${colorSchemeStorageKey}-dark') || '${defaultDarkColorScheme}';
          } else {
            colorScheme = localStorage.getItem('${colorSchemeStorageKey}-light') || '${defaultLightColorScheme}';
          }
        }
        if (mode === 'light') {
          colorScheme = localStorage.getItem('${colorSchemeStorageKey}-light') || '${defaultLightColorScheme}';
        }
        if (mode === 'dark') {
          colorScheme = localStorage.getItem('${colorSchemeStorageKey}-dark') || '${defaultDarkColorScheme}';
        }
        if (colorScheme) {
          ${colorSchemeNode}.setAttribute('${attribute}', colorScheme);
        }
      } catch (e) {} })();`
    }
  });
}

function getSystemMode(mode) {
  if (typeof window !== 'undefined' && mode === 'system') {
    const mql = window.matchMedia('(prefers-color-scheme: dark)');

    if (mql.matches) {
      return 'dark';
    }

    return 'light';
  }

  return undefined;
}

function processState(state, callback) {
  if (state.mode === 'light' || state.mode === 'system' && state.systemMode === 'light') {
    return callback('light');
  }

  if (state.mode === 'dark' || state.mode === 'system' && state.systemMode === 'dark') {
    return callback('dark');
  }

  return undefined;
}

function getColorScheme(state) {
  return processState(state, mode => {
    if (mode === 'light') {
      return state.lightColorScheme;
    }

    if (mode === 'dark') {
      return state.darkColorScheme;
    }

    return undefined;
  });
}

function resolveValue(key, defaultValue) {
  if (typeof window === 'undefined') {
    return undefined;
  }

  let value;

  try {
    value = localStorage.getItem(key) || undefined;
  } catch (e) {// Unsupported
  }

  return value || defaultValue;
}

function useCurrentColorScheme(options) {
  const {
    defaultMode = 'light',
    defaultLightColorScheme,
    defaultDarkColorScheme,
    supportedColorSchemes = [],
    modeStorageKey = DEFAULT_MODE_STORAGE_KEY,
    colorSchemeStorageKey = DEFAULT_COLOR_SCHEME_STORAGE_KEY,
    storageWindow = typeof window === 'undefined' ? undefined : window
  } = options;
  const joinedColorSchemes = supportedColorSchemes.join(',');
  const [state, setState] = React__namespace.useState(() => {
    const initialMode = resolveValue(modeStorageKey, defaultMode);
    return {
      mode: initialMode,
      systemMode: getSystemMode(initialMode),
      lightColorScheme: resolveValue(`${colorSchemeStorageKey}-light`) || defaultLightColorScheme,
      darkColorScheme: resolveValue(`${colorSchemeStorageKey}-dark`) || defaultDarkColorScheme
    };
  });
  const colorScheme = getColorScheme(state);
  const setMode = React__namespace.useCallback(mode => {
    setState(currentState => {
      const newMode = !mode ? defaultMode : mode;

      if (mode === currentState.mode) {
        return currentState;
      }

      if (typeof localStorage !== 'undefined') {
        localStorage.setItem(modeStorageKey, newMode);
      }

      return _extends({}, currentState, {
        mode: newMode,
        systemMode: getSystemMode(newMode)
      });
    });
  }, [modeStorageKey, defaultMode]);
  const setColorScheme = React__namespace.useCallback(value => {
    if (!value || typeof value === 'string') {
      if (value && !joinedColorSchemes.includes(value)) {
        console.error(`\`${value}\` does not exist in \`theme.colorSchemes\`.`);
      } else {
        setState(currentState => {
          const newState = _extends({}, currentState);

          if (!value) {
            // reset to default color scheme
            newState.lightColorScheme = defaultLightColorScheme;
            newState.darkColorScheme = defaultDarkColorScheme;
            return newState;
          }

          processState(currentState, mode => {
            localStorage.setItem(`${colorSchemeStorageKey}-${mode}`, value);

            if (mode === 'light') {
              newState.lightColorScheme = value;
            }

            if (mode === 'dark') {
              newState.darkColorScheme = value;
            }
          });
          return newState;
        });
      }
    } else if (value.light && !joinedColorSchemes.includes(value.light) || value.dark && !joinedColorSchemes.includes(value.dark)) {
      console.error(`\`${value}\` does not exist in \`theme.colorSchemes\`.`);
    } else {
      setState(currentState => {
        const newState = _extends({}, currentState);

        if (value.light || value.light === null) {
          newState.lightColorScheme = value.light === null ? defaultLightColorScheme : value.light;
        }

        if (value.dark || value.dark === null) {
          newState.darkColorScheme = value.dark === null ? defaultDarkColorScheme : value.dark;
        }

        return newState;
      });

      if (value.light) {
        localStorage.setItem(`${colorSchemeStorageKey}-light`, value.light);
      }

      if (value.dark) {
        localStorage.setItem(`${colorSchemeStorageKey}-dark`, value.dark);
      }
    }
  }, [joinedColorSchemes, colorSchemeStorageKey, defaultLightColorScheme, defaultDarkColorScheme]);
  const handleMediaQuery = React__namespace.useCallback(e => {
    if (state.mode === 'system') {
      setState(currentState => _extends({}, currentState, {
        systemMode: e.matches ? 'dark' : 'light'
      }));
    }
  }, [state.mode]); // Ref hack to avoid adding handleMediaQuery as a dep

  const mediaListener = React__namespace.useRef(handleMediaQuery);
  mediaListener.current = handleMediaQuery;
  React__namespace.useEffect(() => {
    const handler = (...args) => mediaListener.current(...args); // Always listen to System preference


    const media = window.matchMedia('(prefers-color-scheme: dark)'); // Intentionally use deprecated listener methods to support iOS & old browsers

    media.addListener(handler);
    handler(media);
    return () => media.removeListener(handler);
  }, []); // Save mode, lightColorScheme & darkColorScheme to localStorage

  React__namespace.useEffect(() => {
    if (state.mode) {
      localStorage.setItem(modeStorageKey, state.mode);
    }

    processState(state, mode => {
      if (mode === 'light') {
        localStorage.setItem(`${colorSchemeStorageKey}-light`, state.lightColorScheme);
      }

      if (mode === 'dark') {
        localStorage.setItem(`${colorSchemeStorageKey}-dark`, state.darkColorScheme);
      }
    });
  }, [state, colorSchemeStorageKey, modeStorageKey]); // Handle when localStorage has changed

  React__namespace.useEffect(() => {
    const handleStorage = event => {
      const value = event.newValue;

      if (typeof event.key === 'string' && event.key.startsWith(colorSchemeStorageKey) && (!value || joinedColorSchemes.match(value))) {
        // If the key is deleted, value will be null then reset color scheme to the default one.
        if (event.key.endsWith('light')) {
          setColorScheme({
            light: value
          });
        }

        if (event.key.endsWith('dark')) {
          setColorScheme({
            dark: value
          });
        }
      }

      if (event.key === modeStorageKey && (!value || ['light', 'dark', 'system'].includes(value))) {
        setMode(value || defaultMode);
      }
    };

    if (storageWindow) {
      // For syncing color-scheme changes between iframes
      storageWindow.addEventListener('storage', handleStorage);
      return () => storageWindow.removeEventListener('storage', handleStorage);
    }

    return undefined;
  }, [setColorScheme, setMode, modeStorageKey, colorSchemeStorageKey, joinedColorSchemes, defaultMode, storageWindow]);
  return _extends({}, state, {
    colorScheme,
    setMode,
    setColorScheme
  });
}

/**
 * The benefit of this function is to help developers get CSS var from theme without specifying the whole variable
 * and they does not need to remember the prefix (defined once).
 */
function createGetCssVar(prefix = '') {
  function appendVar(...vars) {
    if (!vars.length) {
      return '';
    }

    const value = vars[0];

    if (typeof value === 'string' && !value.match(/(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))/)) {
      return `, var(--${prefix ? `${prefix}-` : ''}${value}${appendVar(...vars.slice(1))})`;
    }

    return `, ${value}`;
  } // AdditionalVars makes `getCssVar` less strict, so it can be use like this `getCssVar('non-mui-variable')` without type error.


  const getCssVar = (field, ...vars) => {
    return `var(--${prefix ? `${prefix}-` : ''}${field}${appendVar(...vars)})`;
  };

  return getCssVar;
}

const _excluded$9 = ["colorSchemes", "components"];
const DISABLE_CSS_TRANSITION = '*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}';
function createCssVarsProvider(options) {
  const {
    theme: defaultTheme = {},
    attribute: defaultAttribute = DEFAULT_ATTRIBUTE,
    modeStorageKey: defaultModeStorageKey = DEFAULT_MODE_STORAGE_KEY,
    colorSchemeStorageKey: defaultColorSchemeStorageKey = DEFAULT_COLOR_SCHEME_STORAGE_KEY,
    defaultMode: desisgnSystemMode = 'light',
    defaultColorScheme: designSystemColorScheme,
    disableTransitionOnChange: designSystemTransitionOnChange = false,
    enableColorScheme: designSystemEnableColorScheme = true,
    prefix: designSystemPrefix = '',
    shouldSkipGeneratingVar,
    resolveTheme
  } = options;

  if (!defaultTheme.colorSchemes || typeof designSystemColorScheme === 'string' && !defaultTheme.colorSchemes[designSystemColorScheme] || typeof designSystemColorScheme === 'object' && !defaultTheme.colorSchemes[designSystemColorScheme == null ? void 0 : designSystemColorScheme.light] || typeof designSystemColorScheme === 'object' && !defaultTheme.colorSchemes[designSystemColorScheme == null ? void 0 : designSystemColorScheme.dark]) {
    console.error(`MUI: \`${designSystemColorScheme}\` does not exist in \`theme.colorSchemes\`.`);
  }

  const ColorSchemeContext = /*#__PURE__*/React__namespace.createContext(undefined);

  const useColorScheme = () => {
    const value = React__namespace.useContext(ColorSchemeContext);

    if (!value) {
      throw new Error(process.env.NODE_ENV !== "production" ? `MUI: \`useColorScheme\` must be called under <CssVarsProvider />` : formatMuiErrorMessage(19));
    }

    return value;
  };

  function CssVarsProvider({
    children,
    theme: themeProp = defaultTheme,
    prefix = designSystemPrefix,
    modeStorageKey = defaultModeStorageKey,
    colorSchemeStorageKey = defaultColorSchemeStorageKey,
    attribute = defaultAttribute,
    defaultMode = desisgnSystemMode,
    defaultColorScheme = designSystemColorScheme,
    disableTransitionOnChange = designSystemTransitionOnChange,
    enableColorScheme = designSystemEnableColorScheme,
    storageWindow = typeof window === 'undefined' ? undefined : window,
    documentNode = typeof document === 'undefined' ? undefined : document,
    colorSchemeNode = typeof document === 'undefined' ? undefined : document.documentElement,
    colorSchemeSelector = ':root'
  }) {
    const hasMounted = React__namespace.useRef(false);

    const {
      colorSchemes = {},
      components = {}
    } = themeProp,
          restThemeProp = _objectWithoutPropertiesLoose(themeProp, _excluded$9);

    const allColorSchemes = Object.keys(colorSchemes);
    const defaultLightColorScheme = typeof defaultColorScheme === 'string' ? defaultColorScheme : defaultColorScheme.light;
    const defaultDarkColorScheme = typeof defaultColorScheme === 'string' ? defaultColorScheme : defaultColorScheme.dark;
    const {
      mode,
      setMode,
      systemMode,
      lightColorScheme,
      darkColorScheme,
      colorScheme,
      setColorScheme
    } = useCurrentColorScheme({
      supportedColorSchemes: allColorSchemes,
      defaultLightColorScheme,
      defaultDarkColorScheme,
      modeStorageKey,
      colorSchemeStorageKey,
      defaultMode,
      storageWindow
    });

    const resolvedColorScheme = (() => {
      if (!colorScheme) {
        // This scope occurs on the server
        if (defaultMode === 'dark') {
          return defaultDarkColorScheme;
        } // use light color scheme, if default mode is 'light' | 'auto'


        return defaultLightColorScheme;
      }

      return colorScheme;
    })();

    let theme = restThemeProp;
    const {
      css: rootCss,
      vars: rootVars,
      parsedTheme
    } = cssVarsParser(theme, {
      prefix,
      basePrefix: designSystemPrefix,
      shouldSkipGeneratingVar
    });
    theme = _extends({}, parsedTheme, {
      components,
      colorSchemes,
      prefix,
      vars: rootVars,
      getCssVar: createGetCssVar(prefix),
      getColorSchemeSelector: targetColorScheme => `[${attribute}="${targetColorScheme}"] &`
    });
    const defaultColorSchemeStyleSheet = {};
    const otherColorSchemesStyleSheet = {};
    Object.entries(colorSchemes).forEach(([key, scheme]) => {
      const {
        css,
        vars,
        parsedTheme: parsedScheme
      } = cssVarsParser(scheme, {
        prefix,
        basePrefix: designSystemPrefix,
        shouldSkipGeneratingVar
      });
      theme.vars = deepmerge(theme.vars, vars);

      if (key === resolvedColorScheme) {
        theme = _extends({}, theme, parsedScheme);

        if (theme.palette) {
          // assign runtime mode & colorScheme
          theme.palette.mode = mode;
          theme.palette.colorScheme = resolvedColorScheme;
        }
      }

      const resolvedDefaultColorScheme = (() => {
        if (typeof defaultColorScheme === 'string') {
          return defaultColorScheme;
        }

        if (defaultMode === 'dark') {
          return defaultColorScheme.dark;
        }

        return defaultColorScheme.light;
      })();

      if (key === resolvedDefaultColorScheme) {
        defaultColorSchemeStyleSheet[colorSchemeSelector] = css;
      } else {
        otherColorSchemesStyleSheet[`${colorSchemeSelector === ':root' ? '' : colorSchemeSelector}[${attribute}="${key}"]`] = css;
      }
    });
    React__namespace.useEffect(() => {
      if (colorScheme && colorSchemeNode) {
        // attaches attribute to <html> because the css variables are attached to :root (html)
        colorSchemeNode.setAttribute(attribute, colorScheme);
      }
    }, [colorScheme, attribute, colorSchemeNode]);
    useEnhancedEffect(() => {
      if (!mode || !enableColorScheme || !colorSchemeNode) {
        return undefined;
      }

      const priorColorScheme = colorSchemeNode.style.getPropertyValue('color-scheme'); // `color-scheme` tells browser to render built-in elements according to its value: `light` or `dark`

      if (mode === 'system') {
        colorSchemeNode.style.setProperty('color-scheme', systemMode);
      } else {
        colorSchemeNode.style.setProperty('color-scheme', mode);
      }

      return () => {
        colorSchemeNode.style.setProperty('color-scheme', priorColorScheme);
      };
    }, [mode, systemMode, enableColorScheme, colorSchemeNode]);
    React__namespace.useEffect(() => {
      let timer;

      if (disableTransitionOnChange && hasMounted.current && documentNode) {
        // credit: https://github.com/pacocoursey/next-themes/blob/b5c2bad50de2d61ad7b52a9c5cdc801a78507d7a/index.tsx#L313
        const css = documentNode.createElement('style');
        css.appendChild(documentNode.createTextNode(DISABLE_CSS_TRANSITION));
        documentNode.head.appendChild(css); // Force browser repaint

        (() => window.getComputedStyle(documentNode.body))();

        timer = setTimeout(() => {
          documentNode.head.removeChild(css);
        }, 1);
      }

      return () => {
        clearTimeout(timer);
      };
    }, [colorScheme, disableTransitionOnChange, documentNode]);
    React__namespace.useEffect(() => {
      hasMounted.current = true;
      return () => {
        hasMounted.current = false;
      };
    }, []);
    return /*#__PURE__*/jsxRuntime.exports.jsxs(ColorSchemeContext.Provider, {
      value: {
        mode,
        setMode,
        lightColorScheme,
        darkColorScheme,
        colorScheme,
        setColorScheme,
        allColorSchemes
      },
      children: [/*#__PURE__*/jsxRuntime.exports.jsx(GlobalStyles, {
        styles: {
          [colorSchemeSelector]: rootCss
        }
      }), /*#__PURE__*/jsxRuntime.exports.jsx(GlobalStyles, {
        styles: defaultColorSchemeStyleSheet
      }), /*#__PURE__*/jsxRuntime.exports.jsx(GlobalStyles, {
        styles: otherColorSchemesStyleSheet
      }), /*#__PURE__*/jsxRuntime.exports.jsx(ThemeProvider, {
        theme: resolveTheme ? resolveTheme(theme) : theme,
        children: children
      })]
    });
  }

  process.env.NODE_ENV !== "production" ? CssVarsProvider.propTypes = {
    /**
     * The body attribute name to attach colorScheme.
     */
    attribute: propTypes.exports.string,

    /**
     * The component tree.
     */
    children: propTypes.exports.node,

    /**
     * The node used to attach the color-scheme attribute
     */
    colorSchemeNode: propTypes.exports.any,

    /**
     * The CSS selector for attaching the generated custom properties
     */
    colorSchemeSelector: propTypes.exports.string,

    /**
     * localStorage key used to store `colorScheme`
     */
    colorSchemeStorageKey: propTypes.exports.string,

    /**
     * The initial color scheme used.
     */
    defaultColorScheme: propTypes.exports.oneOfType([propTypes.exports.string, propTypes.exports.object]),

    /**
     * The initial mode used.
     */
    defaultMode: propTypes.exports.string,

    /**
     * Disable CSS transitions when switching between modes or color schemes
     */
    disableTransitionOnChange: propTypes.exports.bool,

    /**
     * The document to attach the attribute to
     */
    documentNode: propTypes.exports.any,

    /**
     * Indicate to the browser which color scheme is used (light or dark) for rendering built-in UI
     */
    enableColorScheme: propTypes.exports.bool,

    /**
     * The key in the local storage used to store current color scheme.
     */
    modeStorageKey: propTypes.exports.string,

    /**
     * CSS variable prefix.
     */
    prefix: propTypes.exports.string,

    /**
     * The window that attaches the 'storage' event listener
     * @default window
     */
    storageWindow: propTypes.exports.any,

    /**
     * The calculated theme object that will be passed through context.
     */
    theme: propTypes.exports.object
  } : void 0;

  const getInitColorSchemeScript$1 = params => getInitColorSchemeScript(_extends({
    attribute: defaultAttribute,
    colorSchemeStorageKey: defaultColorSchemeStorageKey,
    modeStorageKey: defaultModeStorageKey
  }, params));

  return {
    CssVarsProvider,
    useColorScheme,
    getInitColorSchemeScript: getInitColorSchemeScript$1
  };
}

const _excluded$8 = ["className", "component", "disableGutters", "fixed", "maxWidth", "classes"];
const defaultTheme$2 = createTheme$1();
const defaultCreateStyledComponent = styled$1('div', {
  name: 'MuiContainer',
  slot: 'Root',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.root, styles[`maxWidth${capitalize(String(ownerState.maxWidth))}`], ownerState.fixed && styles.fixed, ownerState.disableGutters && styles.disableGutters];
  }
});

const useThemePropsDefault = inProps => useThemeProps$1({
  props: inProps,
  name: 'MuiContainer',
  defaultTheme: defaultTheme$2
});

const useUtilityClasses$2 = (ownerState, componentName) => {
  const getContainerUtilityClass = slot => {
    return generateUtilityClass(componentName, slot);
  };

  const {
    classes,
    fixed,
    disableGutters,
    maxWidth
  } = ownerState;
  const slots = {
    root: ['root', maxWidth && `maxWidth${capitalize(String(maxWidth))}`, fixed && 'fixed', disableGutters && 'disableGutters']
  };
  return composeClasses(slots, getContainerUtilityClass, classes);
};

function createContainer(options = {}) {
  const {
    // This will allow adding custom styled fn (for example for custom sx style function)
    createStyledComponent = defaultCreateStyledComponent,
    useThemeProps = useThemePropsDefault,
    componentName = 'MuiContainer'
  } = options;
  const ContainerRoot = createStyledComponent(({
    theme,
    ownerState
  }) => _extends({
    width: '100%',
    marginLeft: 'auto',
    boxSizing: 'border-box',
    marginRight: 'auto',
    display: 'block'
  }, !ownerState.disableGutters && {
    paddingLeft: theme.spacing(2),
    paddingRight: theme.spacing(2),
    // @ts-ignore module augmentation fails if custom breakpoints are used
    [theme.breakpoints.up('sm')]: {
      paddingLeft: theme.spacing(3),
      paddingRight: theme.spacing(3)
    }
  }), ({
    theme,
    ownerState
  }) => ownerState.fixed && Object.keys(theme.breakpoints.values).reduce((acc, breakpointValueKey) => {
    const breakpoint = breakpointValueKey;
    const value = theme.breakpoints.values[breakpoint];

    if (value !== 0) {
      // @ts-ignore
      acc[theme.breakpoints.up(breakpoint)] = {
        maxWidth: `${value}${theme.breakpoints.unit}`
      };
    }

    return acc;
  }, {}), ({
    theme,
    ownerState
  }) => _extends({}, ownerState.maxWidth === 'xs' && {
    // @ts-ignore module augmentation fails if custom breakpoints are used
    [theme.breakpoints.up('xs')]: {
      // @ts-ignore module augmentation fails if custom breakpoints are used
      maxWidth: Math.max(theme.breakpoints.values.xs, 444)
    }
  }, ownerState.maxWidth && // @ts-ignore module augmentation fails if custom breakpoints are used
  ownerState.maxWidth !== 'xs' && {
    // @ts-ignore module augmentation fails if custom breakpoints are used
    [theme.breakpoints.up(ownerState.maxWidth)]: {
      // @ts-ignore module augmentation fails if custom breakpoints are used
      maxWidth: `${theme.breakpoints.values[ownerState.maxWidth]}${theme.breakpoints.unit}`
    }
  }));
  const Container = /*#__PURE__*/React__namespace.forwardRef(function Container(inProps, ref) {
    const props = useThemeProps(inProps);

    const {
      className,
      component = 'div',
      disableGutters = false,
      fixed = false,
      maxWidth = 'lg'
    } = props,
          other = _objectWithoutPropertiesLoose(props, _excluded$8);

    const ownerState = _extends({}, props, {
      component,
      disableGutters,
      fixed,
      maxWidth
    }); // @ts-ignore module augmentation fails if custom breakpoints are used


    const classes = useUtilityClasses$2(ownerState, componentName);
    return (
      /*#__PURE__*/
      // @ts-ignore theme is injected by the styled util
      jsxRuntime.exports.jsx(ContainerRoot, _extends({
        as: component // @ts-ignore module augmentation fails if custom breakpoints are used
        ,
        ownerState: ownerState,
        className: clsx(classes.root, className),
        ref: ref
      }, other))
    );
  });
  process.env.NODE_ENV !== "production" ? Container.propTypes
  /* remove-proptypes */
  = {
    children: propTypes.exports.node,
    classes: propTypes.exports.object,
    className: propTypes.exports.string,
    component: propTypes.exports.elementType,
    disableGutters: propTypes.exports.bool,
    fixed: propTypes.exports.bool,
    maxWidth: propTypes.exports
    /* @typescript-to-proptypes-ignore */
    .oneOfType([propTypes.exports.oneOf(['xs', 'sm', 'md', 'lg', 'xl', false]), propTypes.exports.string]),
    sx: propTypes.exports.oneOfType([propTypes.exports.arrayOf(propTypes.exports.oneOfType([propTypes.exports.func, propTypes.exports.object, propTypes.exports.bool])), propTypes.exports.func, propTypes.exports.object])
  } : void 0;
  return Container;
}

/**
 *
 * Demos:
 *
 * - [Container (Material UI)](https://mui.com/material-ui/react-container/)
 * - [Container (MUI System)](https://mui.com/system/react-container/)
 *
 * API:
 *
 * - [Container API](https://mui.com/system/api/container/)
 */

const Container = createContainer();
process.env.NODE_ENV !== "production" ? Container.propTypes
/* remove-proptypes */
= {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------

  /**
   * @ignore
   */
  children: propTypes.exports.node,

  /**
   * Override or extend the styles applied to the component.
   */
  classes: propTypes.exports.object,

  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: propTypes.exports.elementType,

  /**
   * If `true`, the left and right padding is removed.
   * @default false
   */
  disableGutters: propTypes.exports.bool,

  /**
   * Set the max-width to match the min-width of the current breakpoint.
   * This is useful if you'd prefer to design for a fixed set of sizes
   * instead of trying to accommodate a fully fluid viewport.
   * It's fluid by default.
   * @default false
   */
  fixed: propTypes.exports.bool,

  /**
   * Determine the max-width of the container.
   * The container width grows with the size of the screen.
   * Set to `false` to disable `maxWidth`.
   * @default 'lg'
   */
  maxWidth: propTypes.exports
  /* @typescript-to-proptypes-ignore */
  .oneOfType([propTypes.exports.oneOf(['xs', 'sm', 'md', 'lg', 'xl', false]), propTypes.exports.string]),

  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: propTypes.exports.oneOfType([propTypes.exports.arrayOf(propTypes.exports.oneOfType([propTypes.exports.func, propTypes.exports.object, propTypes.exports.bool])), propTypes.exports.func, propTypes.exports.object])
} : void 0;

generateUtilityClasses('MuiContainer', ['root', 'disableGutters', 'fixed', 'maxWidthXs', 'maxWidthSm', 'maxWidthMd', 'maxWidthLg', 'maxWidthXl']);

function createMixins(breakpoints, mixins) {
  return _extends({
    toolbar: {
      minHeight: 56,
      [breakpoints.up('xs')]: {
        '@media (orientation: landscape)': {
          minHeight: 48
        }
      },
      [breakpoints.up('sm')]: {
        minHeight: 64
      }
    }
  }, mixins);
}

const common = {
  black: '#000',
  white: '#fff'
};

const grey = {
  50: '#fafafa',
  100: '#f5f5f5',
  200: '#eeeeee',
  300: '#e0e0e0',
  400: '#bdbdbd',
  500: '#9e9e9e',
  600: '#757575',
  700: '#616161',
  800: '#424242',
  900: '#212121',
  A100: '#f5f5f5',
  A200: '#eeeeee',
  A400: '#bdbdbd',
  A700: '#616161'
};

const purple = {
  50: '#f3e5f5',
  100: '#e1bee7',
  200: '#ce93d8',
  300: '#ba68c8',
  400: '#ab47bc',
  500: '#9c27b0',
  600: '#8e24aa',
  700: '#7b1fa2',
  800: '#6a1b9a',
  900: '#4a148c',
  A100: '#ea80fc',
  A200: '#e040fb',
  A400: '#d500f9',
  A700: '#aa00ff'
};

const red = {
  50: '#ffebee',
  100: '#ffcdd2',
  200: '#ef9a9a',
  300: '#e57373',
  400: '#ef5350',
  500: '#f44336',
  600: '#e53935',
  700: '#d32f2f',
  800: '#c62828',
  900: '#b71c1c',
  A100: '#ff8a80',
  A200: '#ff5252',
  A400: '#ff1744',
  A700: '#d50000'
};

const orange = {
  50: '#fff3e0',
  100: '#ffe0b2',
  200: '#ffcc80',
  300: '#ffb74d',
  400: '#ffa726',
  500: '#ff9800',
  600: '#fb8c00',
  700: '#f57c00',
  800: '#ef6c00',
  900: '#e65100',
  A100: '#ffd180',
  A200: '#ffab40',
  A400: '#ff9100',
  A700: '#ff6d00'
};

const blue = {
  50: '#e3f2fd',
  100: '#bbdefb',
  200: '#90caf9',
  300: '#64b5f6',
  400: '#42a5f5',
  500: '#2196f3',
  600: '#1e88e5',
  700: '#1976d2',
  800: '#1565c0',
  900: '#0d47a1',
  A100: '#82b1ff',
  A200: '#448aff',
  A400: '#2979ff',
  A700: '#2962ff'
};

const lightBlue = {
  50: '#e1f5fe',
  100: '#b3e5fc',
  200: '#81d4fa',
  300: '#4fc3f7',
  400: '#29b6f6',
  500: '#03a9f4',
  600: '#039be5',
  700: '#0288d1',
  800: '#0277bd',
  900: '#01579b',
  A100: '#80d8ff',
  A200: '#40c4ff',
  A400: '#00b0ff',
  A700: '#0091ea'
};

const green = {
  50: '#e8f5e9',
  100: '#c8e6c9',
  200: '#a5d6a7',
  300: '#81c784',
  400: '#66bb6a',
  500: '#4caf50',
  600: '#43a047',
  700: '#388e3c',
  800: '#2e7d32',
  900: '#1b5e20',
  A100: '#b9f6ca',
  A200: '#69f0ae',
  A400: '#00e676',
  A700: '#00c853'
};

const _excluded$7 = ["mode", "contrastThreshold", "tonalOffset"];
const light = {
  // The colors used to style the text.
  text: {
    // The most important text.
    primary: 'rgba(0, 0, 0, 0.87)',
    // Secondary text.
    secondary: 'rgba(0, 0, 0, 0.6)',
    // Disabled text have even lower visual prominence.
    disabled: 'rgba(0, 0, 0, 0.38)'
  },
  // The color used to divide different elements.
  divider: 'rgba(0, 0, 0, 0.12)',
  // The background colors used to style the surfaces.
  // Consistency between these values is important.
  background: {
    paper: common.white,
    default: common.white
  },
  // The colors used to style the action elements.
  action: {
    // The color of an active action like an icon button.
    active: 'rgba(0, 0, 0, 0.54)',
    // The color of an hovered action.
    hover: 'rgba(0, 0, 0, 0.04)',
    hoverOpacity: 0.04,
    // The color of a selected action.
    selected: 'rgba(0, 0, 0, 0.08)',
    selectedOpacity: 0.08,
    // The color of a disabled action.
    disabled: 'rgba(0, 0, 0, 0.26)',
    // The background color of a disabled action.
    disabledBackground: 'rgba(0, 0, 0, 0.12)',
    disabledOpacity: 0.38,
    focus: 'rgba(0, 0, 0, 0.12)',
    focusOpacity: 0.12,
    activatedOpacity: 0.12
  }
};
const dark = {
  text: {
    primary: common.white,
    secondary: 'rgba(255, 255, 255, 0.7)',
    disabled: 'rgba(255, 255, 255, 0.5)',
    icon: 'rgba(255, 255, 255, 0.5)'
  },
  divider: 'rgba(255, 255, 255, 0.12)',
  background: {
    paper: '#121212',
    default: '#121212'
  },
  action: {
    active: common.white,
    hover: 'rgba(255, 255, 255, 0.08)',
    hoverOpacity: 0.08,
    selected: 'rgba(255, 255, 255, 0.16)',
    selectedOpacity: 0.16,
    disabled: 'rgba(255, 255, 255, 0.3)',
    disabledBackground: 'rgba(255, 255, 255, 0.12)',
    disabledOpacity: 0.38,
    focus: 'rgba(255, 255, 255, 0.12)',
    focusOpacity: 0.12,
    activatedOpacity: 0.24
  }
};

function addLightOrDark(intent, direction, shade, tonalOffset) {
  const tonalOffsetLight = tonalOffset.light || tonalOffset;
  const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;

  if (!intent[direction]) {
    if (intent.hasOwnProperty(shade)) {
      intent[direction] = intent[shade];
    } else if (direction === 'light') {
      intent.light = lighten(intent.main, tonalOffsetLight);
    } else if (direction === 'dark') {
      intent.dark = darken(intent.main, tonalOffsetDark);
    }
  }
}

function getDefaultPrimary(mode = 'light') {
  if (mode === 'dark') {
    return {
      main: blue[200],
      light: blue[50],
      dark: blue[400]
    };
  }

  return {
    main: blue[700],
    light: blue[400],
    dark: blue[800]
  };
}

function getDefaultSecondary(mode = 'light') {
  if (mode === 'dark') {
    return {
      main: purple[200],
      light: purple[50],
      dark: purple[400]
    };
  }

  return {
    main: purple[500],
    light: purple[300],
    dark: purple[700]
  };
}

function getDefaultError(mode = 'light') {
  if (mode === 'dark') {
    return {
      main: red[500],
      light: red[300],
      dark: red[700]
    };
  }

  return {
    main: red[700],
    light: red[400],
    dark: red[800]
  };
}

function getDefaultInfo(mode = 'light') {
  if (mode === 'dark') {
    return {
      main: lightBlue[400],
      light: lightBlue[300],
      dark: lightBlue[700]
    };
  }

  return {
    main: lightBlue[700],
    light: lightBlue[500],
    dark: lightBlue[900]
  };
}

function getDefaultSuccess(mode = 'light') {
  if (mode === 'dark') {
    return {
      main: green[400],
      light: green[300],
      dark: green[700]
    };
  }

  return {
    main: green[800],
    light: green[500],
    dark: green[900]
  };
}

function getDefaultWarning(mode = 'light') {
  if (mode === 'dark') {
    return {
      main: orange[400],
      light: orange[300],
      dark: orange[700]
    };
  }

  return {
    main: '#ed6c02',
    // closest to orange[800] that pass 3:1.
    light: orange[500],
    dark: orange[900]
  };
}

function createPalette(palette) {
  const {
    mode = 'light',
    contrastThreshold = 3,
    tonalOffset = 0.2
  } = palette,
        other = _objectWithoutPropertiesLoose(palette, _excluded$7);

  const primary = palette.primary || getDefaultPrimary(mode);
  const secondary = palette.secondary || getDefaultSecondary(mode);
  const error = palette.error || getDefaultError(mode);
  const info = palette.info || getDefaultInfo(mode);
  const success = palette.success || getDefaultSuccess(mode);
  const warning = palette.warning || getDefaultWarning(mode); // Use the same logic as
  // Bootstrap: https://github.com/twbs/bootstrap/blob/1d6e3710dd447de1a200f29e8fa521f8a0908f70/scss/_functions.scss#L59
  // and material-components-web https://github.com/material-components/material-components-web/blob/ac46b8863c4dab9fc22c4c662dc6bd1b65dd652f/packages/mdc-theme/_functions.scss#L54

  function getContrastText(background) {
    const contrastText = getContrastRatio(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;

    if (process.env.NODE_ENV !== 'production') {
      const contrast = getContrastRatio(background, contrastText);

      if (contrast < 3) {
        console.error([`MUI: The contrast ratio of ${contrast}:1 for ${contrastText} on ${background}`, 'falls below the WCAG recommended absolute minimum contrast ratio of 3:1.', 'https://www.w3.org/TR/2008/REC-WCAG20-20081211/#visual-audio-contrast-contrast'].join('\n'));
      }
    }

    return contrastText;
  }

  const augmentColor = ({
    color,
    name,
    mainShade = 500,
    lightShade = 300,
    darkShade = 700
  }) => {
    color = _extends({}, color);

    if (!color.main && color[mainShade]) {
      color.main = color[mainShade];
    }

    if (!color.hasOwnProperty('main')) {
      throw new Error(process.env.NODE_ENV !== "production" ? `MUI: The color${name ? ` (${name})` : ''} provided to augmentColor(color) is invalid.
The color object needs to have a \`main\` property or a \`${mainShade}\` property.` : formatMuiErrorMessage(11, name ? ` (${name})` : '', mainShade));
    }

    if (typeof color.main !== 'string') {
      throw new Error(process.env.NODE_ENV !== "production" ? `MUI: The color${name ? ` (${name})` : ''} provided to augmentColor(color) is invalid.
\`color.main\` should be a string, but \`${JSON.stringify(color.main)}\` was provided instead.

Did you intend to use one of the following approaches?

import { green } from "@mui/material/colors";

const theme1 = createTheme({ palette: {
  primary: green,
} });

const theme2 = createTheme({ palette: {
  primary: { main: green[500] },
} });` : formatMuiErrorMessage(12, name ? ` (${name})` : '', JSON.stringify(color.main)));
    }

    addLightOrDark(color, 'light', lightShade, tonalOffset);
    addLightOrDark(color, 'dark', darkShade, tonalOffset);

    if (!color.contrastText) {
      color.contrastText = getContrastText(color.main);
    }

    return color;
  };

  const modes = {
    dark,
    light
  };

  if (process.env.NODE_ENV !== 'production') {
    if (!modes[mode]) {
      console.error(`MUI: The palette mode \`${mode}\` is not supported.`);
    }
  }

  const paletteOutput = deepmerge(_extends({
    // A collection of common colors.
    common: _extends({}, common),
    // prevent mutable object.
    // The palette mode, can be light or dark.
    mode,
    // The colors used to represent primary interface elements for a user.
    primary: augmentColor({
      color: primary,
      name: 'primary'
    }),
    // The colors used to represent secondary interface elements for a user.
    secondary: augmentColor({
      color: secondary,
      name: 'secondary',
      mainShade: 'A400',
      lightShade: 'A200',
      darkShade: 'A700'
    }),
    // The colors used to represent interface elements that the user should be made aware of.
    error: augmentColor({
      color: error,
      name: 'error'
    }),
    // The colors used to represent potentially dangerous actions or important messages.
    warning: augmentColor({
      color: warning,
      name: 'warning'
    }),
    // The colors used to present information to the user that is neutral and not necessarily important.
    info: augmentColor({
      color: info,
      name: 'info'
    }),
    // The colors used to indicate the successful completion of an action that user triggered.
    success: augmentColor({
      color: success,
      name: 'success'
    }),
    // The grey colors.
    grey,
    // Used by `getContrastText()` to maximize the contrast between
    // the background and the text.
    contrastThreshold,
    // Takes a background color and returns the text color that maximizes the contrast.
    getContrastText,
    // Generate a rich color object.
    augmentColor,
    // Used by the functions below to shift a color's luminance by approximately
    // two indexes within its tonal palette.
    // E.g., shift from Red 500 to Red 300 or Red 700.
    tonalOffset
  }, modes[mode]), other);
  return paletteOutput;
}

const _excluded$6 = ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"];

function round$1(value) {
  return Math.round(value * 1e5) / 1e5;
}

const caseAllCaps = {
  textTransform: 'uppercase'
};
const defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
/**
 * @see @link{https://material.io/design/typography/the-type-system.html}
 * @see @link{https://material.io/design/typography/understanding-typography.html}
 */

function createTypography(palette, typography) {
  const _ref = typeof typography === 'function' ? typography(palette) : typography,
        {
    fontFamily = defaultFontFamily,
    // The default font size of the Material Specification.
    fontSize = 14,
    // px
    fontWeightLight = 300,
    fontWeightRegular = 400,
    fontWeightMedium = 500,
    fontWeightBold = 700,
    // Tell MUI what's the font-size on the html element.
    // 16px is the default font-size used by browsers.
    htmlFontSize = 16,
    // Apply the CSS properties to all the variants.
    allVariants,
    pxToRem: pxToRem2
  } = _ref,
        other = _objectWithoutPropertiesLoose(_ref, _excluded$6);

  if (process.env.NODE_ENV !== 'production') {
    if (typeof fontSize !== 'number') {
      console.error('MUI: `fontSize` is required to be a number.');
    }

    if (typeof htmlFontSize !== 'number') {
      console.error('MUI: `htmlFontSize` is required to be a number.');
    }
  }

  const coef = fontSize / 14;

  const pxToRem = pxToRem2 || (size => `${size / htmlFontSize * coef}rem`);

  const buildVariant = (fontWeight, size, lineHeight, letterSpacing, casing) => _extends({
    fontFamily,
    fontWeight,
    fontSize: pxToRem(size),
    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
    lineHeight
  }, fontFamily === defaultFontFamily ? {
    letterSpacing: `${round$1(letterSpacing / size)}em`
  } : {}, casing, allVariants);

  const variants = {
    h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
    h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
    h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
    h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
    h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
    h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
    subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
    subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
    body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
    body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
    button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
    caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
    overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps)
  };
  return deepmerge(_extends({
    htmlFontSize,
    pxToRem,
    fontFamily,
    fontSize,
    fontWeightLight,
    fontWeightRegular,
    fontWeightMedium,
    fontWeightBold
  }, variants), other, {
    clone: false // No need to clone deep

  });
}

const shadowKeyUmbraOpacity = 0.2;
const shadowKeyPenumbraOpacity = 0.14;
const shadowAmbientShadowOpacity = 0.12;

function createShadow(...px) {
  return [`${px[0]}px ${px[1]}px ${px[2]}px ${px[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`, `${px[4]}px ${px[5]}px ${px[6]}px ${px[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`, `${px[8]}px ${px[9]}px ${px[10]}px ${px[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`].join(',');
} // Values from https://github.com/material-components/material-components-web/blob/be8747f94574669cb5e7add1a7c54fa41a89cec7/packages/mdc-elevation/_variables.scss


const shadows = ['none', createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)];

const _excluded$5 = ["duration", "easing", "delay"];
// Follow https://material.google.com/motion/duration-easing.html#duration-easing-natural-easing-curves
// to learn the context in which each easing should be used.
const easing = {
  // This is the most common easing curve.
  easeInOut: 'cubic-bezier(0.4, 0, 0.2, 1)',
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: 'cubic-bezier(0.0, 0, 0.2, 1)',
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: 'cubic-bezier(0.4, 0, 1, 1)',
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: 'cubic-bezier(0.4, 0, 0.6, 1)'
}; // Follow https://material.io/guidelines/motion/duration-easing.html#duration-easing-common-durations
// to learn when use what timing

const duration = {
  shortest: 150,
  shorter: 200,
  short: 250,
  // most basic recommended timing
  standard: 300,
  // this is to be used in complex animations
  complex: 375,
  // recommended when something is entering screen
  enteringScreen: 225,
  // recommended when something is leaving screen
  leavingScreen: 195
};

function formatMs(milliseconds) {
  return `${Math.round(milliseconds)}ms`;
}

function getAutoHeightDuration(height) {
  if (!height) {
    return 0;
  }

  const constant = height / 36; // https://www.wolframalpha.com/input/?i=(4+%2B+15+*+(x+%2F+36+)+**+0.25+%2B+(x+%2F+36)+%2F+5)+*+10

  return Math.round((4 + 15 * constant ** 0.25 + constant / 5) * 10);
}

function createTransitions(inputTransitions) {
  const mergedEasing = _extends({}, easing, inputTransitions.easing);

  const mergedDuration = _extends({}, duration, inputTransitions.duration);

  const create = (props = ['all'], options = {}) => {
    const {
      duration: durationOption = mergedDuration.standard,
      easing: easingOption = mergedEasing.easeInOut,
      delay = 0
    } = options,
          other = _objectWithoutPropertiesLoose(options, _excluded$5);

    if (process.env.NODE_ENV !== 'production') {
      const isString = value => typeof value === 'string'; // IE11 support, replace with Number.isNaN
      // eslint-disable-next-line no-restricted-globals


      const isNumber = value => !isNaN(parseFloat(value));

      if (!isString(props) && !Array.isArray(props)) {
        console.error('MUI: Argument "props" must be a string or Array.');
      }

      if (!isNumber(durationOption) && !isString(durationOption)) {
        console.error(`MUI: Argument "duration" must be a number or a string but found ${durationOption}.`);
      }

      if (!isString(easingOption)) {
        console.error('MUI: Argument "easing" must be a string.');
      }

      if (!isNumber(delay) && !isString(delay)) {
        console.error('MUI: Argument "delay" must be a number or a string.');
      }

      if (Object.keys(other).length !== 0) {
        console.error(`MUI: Unrecognized argument(s) [${Object.keys(other).join(',')}].`);
      }
    }

    return (Array.isArray(props) ? props : [props]).map(animatedProp => `${animatedProp} ${typeof durationOption === 'string' ? durationOption : formatMs(durationOption)} ${easingOption} ${typeof delay === 'string' ? delay : formatMs(delay)}`).join(',');
  };

  return _extends({
    getAutoHeightDuration,
    create
  }, inputTransitions, {
    easing: mergedEasing,
    duration: mergedDuration
  });
}

// We need to centralize the zIndex definitions as they work
// like global values in the browser.
const zIndex = {
  mobileStepper: 1000,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
};

const _excluded$4 = ["breakpoints", "mixins", "spacing", "palette", "transitions", "typography", "shape"];

function createTheme(options = {}, ...args) {
  const {
    mixins: mixinsInput = {},
    palette: paletteInput = {},
    transitions: transitionsInput = {},
    typography: typographyInput = {}
  } = options,
        other = _objectWithoutPropertiesLoose(options, _excluded$4);

  const palette = createPalette(paletteInput);
  const systemTheme = createTheme$1(options);
  let muiTheme = deepmerge(systemTheme, {
    mixins: createMixins(systemTheme.breakpoints, mixinsInput),
    palette,
    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
    shadows: shadows.slice(),
    typography: createTypography(palette, typographyInput),
    transitions: createTransitions(transitionsInput),
    zIndex: _extends({}, zIndex)
  });
  muiTheme = deepmerge(muiTheme, other);
  muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);

  if (process.env.NODE_ENV !== 'production') {
    const stateClasses = ['active', 'checked', 'completed', 'disabled', 'error', 'expanded', 'focused', 'focusVisible', 'required', 'selected'];

    const traverse = (node, component) => {
      let key; // eslint-disable-next-line guard-for-in, no-restricted-syntax

      for (key in node) {
        const child = node[key];

        if (stateClasses.indexOf(key) !== -1 && Object.keys(child).length > 0) {
          if (process.env.NODE_ENV !== 'production') {
            const stateClass = generateUtilityClass('', key);
            console.error([`MUI: The \`${component}\` component increases ` + `the CSS specificity of the \`${key}\` internal state.`, 'You can not override it like this: ', JSON.stringify(node, null, 2), '', `Instead, you need to use the '&.${stateClass}' syntax:`, JSON.stringify({
              root: {
                [`&.${stateClass}`]: child
              }
            }, null, 2), '', 'https://mui.com/r/state-classes-guide'].join('\n'));
          } // Remove the style to prevent global conflicts.


          node[key] = {};
        }
      }
    };

    Object.keys(muiTheme.components).forEach(component => {
      const styleOverrides = muiTheme.components[component].styleOverrides;

      if (styleOverrides && component.indexOf('Mui') === 0) {
        traverse(styleOverrides, component);
      }
    });
  }

  return muiTheme;
}

const defaultTheme$1 = createTheme();

const rootShouldForwardProp = prop => shouldForwardProp(prop) && prop !== 'classes';
const styled = createStyled({
  defaultTheme: defaultTheme$1,
  rootShouldForwardProp
});

function useTheme() {
  const theme = useTheme$1(defaultTheme$1);

  if (process.env.NODE_ENV !== 'production') {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    React__namespace.useDebugValue(theme);
  }

  return theme;
}

function useThemeProps({
  props,
  name
}) {
  return useThemeProps$1({
    props,
    name,
    defaultTheme: defaultTheme$1
  });
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}

/**
 * Checks if a given element has a CSS class.
 * 
 * @param element the element
 * @param className the CSS class name
 */
function hasClass(element, className) {
  if (element.classList) return !!className && element.classList.contains(className);
  return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
}

/**
 * Adds a CSS class to a given element.
 * 
 * @param element the element
 * @param className the CSS class name
 */

function addClass(element, className) {
  if (element.classList) element.classList.add(className);else if (!hasClass(element, className)) if (typeof element.className === 'string') element.className = element.className + " " + className;else element.setAttribute('class', (element.className && element.className.baseVal || '') + " " + className);
}

function replaceClassName(origClass, classToRemove) {
  return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", 'g'), '$1').replace(/\s+/g, ' ').replace(/^\s*|\s*$/g, '');
}
/**
 * Removes a CSS class from a given element.
 * 
 * @param element the element
 * @param className the CSS class name
 */


function removeClass$1(element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else if (typeof element.className === 'string') {
    element.className = replaceClassName(element.className, className);
  } else {
    element.setAttribute('class', replaceClassName(element.className && element.className.baseVal || '', className));
  }
}

var config = {
  disabled: false
};

var timeoutsShape = process.env.NODE_ENV !== 'production' ? propTypes.exports.oneOfType([propTypes.exports.number, propTypes.exports.shape({
  enter: propTypes.exports.number,
  exit: propTypes.exports.number,
  appear: propTypes.exports.number
}).isRequired]) : null;
var classNamesShape = process.env.NODE_ENV !== 'production' ? propTypes.exports.oneOfType([propTypes.exports.string, propTypes.exports.shape({
  enter: propTypes.exports.string,
  exit: propTypes.exports.string,
  active: propTypes.exports.string
}), propTypes.exports.shape({
  enter: propTypes.exports.string,
  enterDone: propTypes.exports.string,
  enterActive: propTypes.exports.string,
  exit: propTypes.exports.string,
  exitDone: propTypes.exports.string,
  exitActive: propTypes.exports.string
})]) : null;

var TransitionGroupContext = React__default["default"].createContext(null);

var UNMOUNTED = 'unmounted';
var EXITED = 'exited';
var ENTERING = 'entering';
var ENTERED = 'entered';
var EXITING = 'exiting';
/**
 * The Transition component lets you describe a transition from one component
 * state to another _over time_ with a simple declarative API. Most commonly
 * it's used to animate the mounting and unmounting of a component, but can also
 * be used to describe in-place transition states as well.
 *
 * ---
 *
 * **Note**: `Transition` is a platform-agnostic base component. If you're using
 * transitions in CSS, you'll probably want to use
 * [`CSSTransition`](https://reactcommunity.org/react-transition-group/css-transition)
 * instead. It inherits all the features of `Transition`, but contains
 * additional features necessary to play nice with CSS transitions (hence the
 * name of the component).
 *
 * ---
 *
 * By default the `Transition` component does not alter the behavior of the
 * component it renders, it only tracks "enter" and "exit" states for the
 * components. It's up to you to give meaning and effect to those states. For
 * example we can add styles to a component when it enters or exits:
 *
 * ```jsx
 * import { Transition } from 'react-transition-group';
 *
 * const duration = 300;
 *
 * const defaultStyle = {
 *   transition: `opacity ${duration}ms ease-in-out`,
 *   opacity: 0,
 * }
 *
 * const transitionStyles = {
 *   entering: { opacity: 1 },
 *   entered:  { opacity: 1 },
 *   exiting:  { opacity: 0 },
 *   exited:  { opacity: 0 },
 * };
 *
 * const Fade = ({ in: inProp }) => (
 *   <Transition in={inProp} timeout={duration}>
 *     {state => (
 *       <div style={{
 *         ...defaultStyle,
 *         ...transitionStyles[state]
 *       }}>
 *         I'm a fade Transition!
 *       </div>
 *     )}
 *   </Transition>
 * );
 * ```
 *
 * There are 4 main states a Transition can be in:
 *  - `'entering'`
 *  - `'entered'`
 *  - `'exiting'`
 *  - `'exited'`
 *
 * Transition state is toggled via the `in` prop. When `true` the component
 * begins the "Enter" stage. During this stage, the component will shift from
 * its current transition state, to `'entering'` for the duration of the
 * transition and then to the `'entered'` stage once it's complete. Let's take
 * the following example (we'll use the
 * [useState](https://reactjs.org/docs/hooks-reference.html#usestate) hook):
 *
 * ```jsx
 * function App() {
 *   const [inProp, setInProp] = useState(false);
 *   return (
 *     <div>
 *       <Transition in={inProp} timeout={500}>
 *         {state => (
 *           // ...
 *         )}
 *       </Transition>
 *       <button onClick={() => setInProp(true)}>
 *         Click to Enter
 *       </button>
 *     </div>
 *   );
 * }
 * ```
 *
 * When the button is clicked the component will shift to the `'entering'` state
 * and stay there for 500ms (the value of `timeout`) before it finally switches
 * to `'entered'`.
 *
 * When `in` is `false` the same thing happens except the state moves from
 * `'exiting'` to `'exited'`.
 */

var Transition = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(Transition, _React$Component);

  function Transition(props, context) {
    var _this;

    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context; // In the context of a TransitionGroup all enters are really appears

    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;

    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }

    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }

  Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;

    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }

    return null;
  } // getSnapshotBeforeUpdate(prevProps) {
  //   let nextStatus = null
  //   if (prevProps !== this.props) {
  //     const { status } = this.state
  //     if (this.props.in) {
  //       if (status !== ENTERING && status !== ENTERED) {
  //         nextStatus = ENTERING
  //       }
  //     } else {
  //       if (status === ENTERING || status === ENTERED) {
  //         nextStatus = EXITING
  //       }
  //     }
  //   }
  //   return { nextStatus }
  // }
  ;

  var _proto = Transition.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;

    if (prevProps !== this.props) {
      var status = this.state.status;

      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }

    this.updateStatus(false, nextStatus);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };

  _proto.getTimeouts = function getTimeouts() {
    var timeout = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout;

    if (timeout != null && typeof timeout !== 'number') {
      exit = timeout.exit;
      enter = timeout.enter; // TODO: remove fallback for next major

      appear = timeout.appear !== undefined ? timeout.appear : enter;
    }

    return {
      exit: exit,
      enter: enter,
      appear: appear
    };
  };

  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }

    if (nextStatus !== null) {
      // nextStatus will always be ENTERING or EXITING.
      this.cancelNextCallback();

      if (nextStatus === ENTERING) {
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };

  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;

    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;

    var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM__default["default"].findDOMNode(this), appearing],
        maybeNode = _ref2[0],
        maybeAppearing = _ref2[1];

    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter; // no enter animation skip right to ENTERED
    // if we are mounting and running this it means appear _must_ be set

    if (!mounting && !enter || config.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function () {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }

    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING
    }, function () {
      _this2.props.onEntering(maybeNode, maybeAppearing);

      _this2.onTransitionEnd(enterTimeout, function () {
        _this2.safeSetState({
          status: ENTERED
        }, function () {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  };

  _proto.performExit = function performExit() {
    var _this3 = this;

    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? undefined : ReactDOM__default["default"].findDOMNode(this); // no exit animation skip right to EXITED

    if (!exit || config.disabled) {
      this.safeSetState({
        status: EXITED
      }, function () {
        _this3.props.onExited(maybeNode);
      });
      return;
    }

    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING
    }, function () {
      _this3.props.onExiting(maybeNode);

      _this3.onTransitionEnd(timeouts.exit, function () {
        _this3.safeSetState({
          status: EXITED
        }, function () {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  };

  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };

  _proto.safeSetState = function safeSetState(nextState, callback) {
    // This shouldn't be necessary, but there are weird race conditions with
    // setState callbacks and unmounting in testing, so always make sure that
    // we can cancel any pending setState callbacks after we unmount.
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };

  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;

    var active = true;

    this.nextCallback = function (event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };

    this.nextCallback.cancel = function () {
      active = false;
    };

    return this.nextCallback;
  };

  _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {
    this.setNextCallback(handler);
    var node = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM__default["default"].findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;

    if (!node || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }

    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback],
          maybeNode = _ref3[0],
          maybeNextCallback = _ref3[1];

      this.props.addEndListener(maybeNode, maybeNextCallback);
    }

    if (timeout != null) {
      setTimeout(this.nextCallback, timeout);
    }
  };

  _proto.render = function render() {
    var status = this.state.status;

    if (status === UNMOUNTED) {
      return null;
    }

    var _this$props = this.props,
        children = _this$props.children;
        _this$props.in;
        _this$props.mountOnEnter;
        _this$props.unmountOnExit;
        _this$props.appear;
        _this$props.enter;
        _this$props.exit;
        _this$props.timeout;
        _this$props.addEndListener;
        _this$props.onEnter;
        _this$props.onEntering;
        _this$props.onEntered;
        _this$props.onExit;
        _this$props.onExiting;
        _this$props.onExited;
        _this$props.nodeRef;
        var childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);

    return (
      /*#__PURE__*/
      // allows for nested Transitions
      React__default["default"].createElement(TransitionGroupContext.Provider, {
        value: null
      }, typeof children === 'function' ? children(status, childProps) : React__default["default"].cloneElement(React__default["default"].Children.only(children), childProps))
    );
  };

  return Transition;
}(React__default["default"].Component);

Transition.contextType = TransitionGroupContext;
Transition.propTypes = process.env.NODE_ENV !== "production" ? {
  /**
   * A React reference to DOM element that need to transition:
   * https://stackoverflow.com/a/51127130/4671932
   *
   *   - When `nodeRef` prop is used, `node` is not passed to callback functions
   *      (e.g. `onEnter`) because user already has direct access to the node.
   *   - When changing `key` prop of `Transition` in a `TransitionGroup` a new
   *     `nodeRef` need to be provided to `Transition` with changed `key` prop
   *     (see
   *     [test/CSSTransition-test.js](https://github.com/reactjs/react-transition-group/blob/13435f897b3ab71f6e19d724f145596f5910581c/test/CSSTransition-test.js#L362-L437)).
   */
  nodeRef: propTypes.exports.shape({
    current: typeof Element === 'undefined' ? propTypes.exports.any : function (propValue, key, componentName, location, propFullName, secret) {
      var value = propValue[key];
      return propTypes.exports.instanceOf(value && 'ownerDocument' in value ? value.ownerDocument.defaultView.Element : Element)(propValue, key, componentName, location, propFullName, secret);
    }
  }),

  /**
   * A `function` child can be used instead of a React element. This function is
   * called with the current transition status (`'entering'`, `'entered'`,
   * `'exiting'`, `'exited'`), which can be used to apply context
   * specific props to a component.
   *
   * ```jsx
   * <Transition in={this.state.in} timeout={150}>
   *   {state => (
   *     <MyComponent className={`fade fade-${state}`} />
   *   )}
   * </Transition>
   * ```
   */
  children: propTypes.exports.oneOfType([propTypes.exports.func.isRequired, propTypes.exports.element.isRequired]).isRequired,

  /**
   * Show the component; triggers the enter or exit states
   */
  in: propTypes.exports.bool,

  /**
   * By default the child component is mounted immediately along with
   * the parent `Transition` component. If you want to "lazy mount" the component on the
   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay
   * mounted, even on "exited", unless you also specify `unmountOnExit`.
   */
  mountOnEnter: propTypes.exports.bool,

  /**
   * By default the child component stays mounted after it reaches the `'exited'` state.
   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.
   */
  unmountOnExit: propTypes.exports.bool,

  /**
   * By default the child component does not perform the enter transition when
   * it first mounts, regardless of the value of `in`. If you want this
   * behavior, set both `appear` and `in` to `true`.
   *
   * > **Note**: there are no special appear states like `appearing`/`appeared`, this prop
   * > only adds an additional enter transition. However, in the
   * > `<CSSTransition>` component that first enter transition does result in
   * > additional `.appear-*` classes, that way you can choose to style it
   * > differently.
   */
  appear: propTypes.exports.bool,

  /**
   * Enable or disable enter transitions.
   */
  enter: propTypes.exports.bool,

  /**
   * Enable or disable exit transitions.
   */
  exit: propTypes.exports.bool,

  /**
   * The duration of the transition, in milliseconds.
   * Required unless `addEndListener` is provided.
   *
   * You may specify a single timeout for all transitions:
   *
   * ```jsx
   * timeout={500}
   * ```
   *
   * or individually:
   *
   * ```jsx
   * timeout={{
   *  appear: 500,
   *  enter: 300,
   *  exit: 500,
   * }}
   * ```
   *
   * - `appear` defaults to the value of `enter`
   * - `enter` defaults to `0`
   * - `exit` defaults to `0`
   *
   * @type {number | { enter?: number, exit?: number, appear?: number }}
   */
  timeout: function timeout(props) {
    var pt = timeoutsShape;
    if (!props.addEndListener) pt = pt.isRequired;

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return pt.apply(void 0, [props].concat(args));
  },

  /**
   * Add a custom transition end trigger. Called with the transitioning
   * DOM node and a `done` callback. Allows for more fine grained transition end
   * logic. Timeouts are still used as a fallback if provided.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * ```jsx
   * addEndListener={(node, done) => {
   *   // use the css transitionend event to mark the finish of a transition
   *   node.addEventListener('transitionend', done, false);
   * }}
   * ```
   */
  addEndListener: propTypes.exports.func,

  /**
   * Callback fired before the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEnter: propTypes.exports.func,

  /**
   * Callback fired after the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: propTypes.exports.func,

  /**
   * Callback fired after the "entered" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEntered: propTypes.exports.func,

  /**
   * Callback fired before the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExit: propTypes.exports.func,

  /**
   * Callback fired after the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExiting: propTypes.exports.func,

  /**
   * Callback fired after the "exited" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExited: propTypes.exports.func
} : {}; // Name the function so it is clearer in the documentation

function noop() {}

Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop,
  onEntering: noop,
  onEntered: noop,
  onExit: noop,
  onExiting: noop,
  onExited: noop
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;

var _addClass = function addClass$1(node, classes) {
  return node && classes && classes.split(' ').forEach(function (c) {
    return addClass(node, c);
  });
};

var removeClass = function removeClass(node, classes) {
  return node && classes && classes.split(' ').forEach(function (c) {
    return removeClass$1(node, c);
  });
};
/**
 * A transition component inspired by the excellent
 * [ng-animate](https://docs.angularjs.org/api/ngAnimate) library, you should
 * use it if you're using CSS transitions or animations. It's built upon the
 * [`Transition`](https://reactcommunity.org/react-transition-group/transition)
 * component, so it inherits all of its props.
 *
 * `CSSTransition` applies a pair of class names during the `appear`, `enter`,
 * and `exit` states of the transition. The first class is applied and then a
 * second `*-active` class in order to activate the CSS transition. After the
 * transition, matching `*-done` class names are applied to persist the
 * transition state.
 *
 * ```jsx
 * function App() {
 *   const [inProp, setInProp] = useState(false);
 *   return (
 *     <div>
 *       <CSSTransition in={inProp} timeout={200} classNames="my-node">
 *         <div>
 *           {"I'll receive my-node-* classes"}
 *         </div>
 *       </CSSTransition>
 *       <button type="button" onClick={() => setInProp(true)}>
 *         Click to Enter
 *       </button>
 *     </div>
 *   );
 * }
 * ```
 *
 * When the `in` prop is set to `true`, the child component will first receive
 * the class `example-enter`, then the `example-enter-active` will be added in
 * the next tick. `CSSTransition` [forces a
 * reflow](https://github.com/reactjs/react-transition-group/blob/5007303e729a74be66a21c3e2205e4916821524b/src/CSSTransition.js#L208-L215)
 * between before adding the `example-enter-active`. This is an important trick
 * because it allows us to transition between `example-enter` and
 * `example-enter-active` even though they were added immediately one after
 * another. Most notably, this is what makes it possible for us to animate
 * _appearance_.
 *
 * ```css
 * .my-node-enter {
 *   opacity: 0;
 * }
 * .my-node-enter-active {
 *   opacity: 1;
 *   transition: opacity 200ms;
 * }
 * .my-node-exit {
 *   opacity: 1;
 * }
 * .my-node-exit-active {
 *   opacity: 0;
 *   transition: opacity 200ms;
 * }
 * ```
 *
 * `*-active` classes represent which styles you want to animate **to**, so it's
 * important to add `transition` declaration only to them, otherwise transitions
 * might not behave as intended! This might not be obvious when the transitions
 * are symmetrical, i.e. when `*-enter-active` is the same as `*-exit`, like in
 * the example above (minus `transition`), but it becomes apparent in more
 * complex transitions.
 *
 * **Note**: If you're using the
 * [`appear`](http://reactcommunity.org/react-transition-group/transition#Transition-prop-appear)
 * prop, make sure to define styles for `.appear-*` classes as well.
 */


var CSSTransition = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(CSSTransition, _React$Component);

  function CSSTransition() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.appliedClasses = {
      appear: {},
      enter: {},
      exit: {}
    };

    _this.onEnter = function (maybeNode, maybeAppearing) {
      var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing),
          node = _this$resolveArgument[0],
          appearing = _this$resolveArgument[1];

      _this.removeClasses(node, 'exit');

      _this.addClass(node, appearing ? 'appear' : 'enter', 'base');

      if (_this.props.onEnter) {
        _this.props.onEnter(maybeNode, maybeAppearing);
      }
    };

    _this.onEntering = function (maybeNode, maybeAppearing) {
      var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing),
          node = _this$resolveArgument2[0],
          appearing = _this$resolveArgument2[1];

      var type = appearing ? 'appear' : 'enter';

      _this.addClass(node, type, 'active');

      if (_this.props.onEntering) {
        _this.props.onEntering(maybeNode, maybeAppearing);
      }
    };

    _this.onEntered = function (maybeNode, maybeAppearing) {
      var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing),
          node = _this$resolveArgument3[0],
          appearing = _this$resolveArgument3[1];

      var type = appearing ? 'appear' : 'enter';

      _this.removeClasses(node, type);

      _this.addClass(node, type, 'done');

      if (_this.props.onEntered) {
        _this.props.onEntered(maybeNode, maybeAppearing);
      }
    };

    _this.onExit = function (maybeNode) {
      var _this$resolveArgument4 = _this.resolveArguments(maybeNode),
          node = _this$resolveArgument4[0];

      _this.removeClasses(node, 'appear');

      _this.removeClasses(node, 'enter');

      _this.addClass(node, 'exit', 'base');

      if (_this.props.onExit) {
        _this.props.onExit(maybeNode);
      }
    };

    _this.onExiting = function (maybeNode) {
      var _this$resolveArgument5 = _this.resolveArguments(maybeNode),
          node = _this$resolveArgument5[0];

      _this.addClass(node, 'exit', 'active');

      if (_this.props.onExiting) {
        _this.props.onExiting(maybeNode);
      }
    };

    _this.onExited = function (maybeNode) {
      var _this$resolveArgument6 = _this.resolveArguments(maybeNode),
          node = _this$resolveArgument6[0];

      _this.removeClasses(node, 'exit');

      _this.addClass(node, 'exit', 'done');

      if (_this.props.onExited) {
        _this.props.onExited(maybeNode);
      }
    };

    _this.resolveArguments = function (maybeNode, maybeAppearing) {
      return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] // here `maybeNode` is actually `appearing`
      : [maybeNode, maybeAppearing];
    };

    _this.getClassNames = function (type) {
      var classNames = _this.props.classNames;
      var isStringClassNames = typeof classNames === 'string';
      var prefix = isStringClassNames && classNames ? classNames + "-" : '';
      var baseClassName = isStringClassNames ? "" + prefix + type : classNames[type];
      var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames[type + "Active"];
      var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames[type + "Done"];
      return {
        baseClassName: baseClassName,
        activeClassName: activeClassName,
        doneClassName: doneClassName
      };
    };

    return _this;
  }

  var _proto = CSSTransition.prototype;

  _proto.addClass = function addClass(node, type, phase) {
    var className = this.getClassNames(type)[phase + "ClassName"];

    var _this$getClassNames = this.getClassNames('enter'),
        doneClassName = _this$getClassNames.doneClassName;

    if (type === 'appear' && phase === 'done' && doneClassName) {
      className += " " + doneClassName;
    } // This is to force a repaint,
    // which is necessary in order to transition styles when adding a class name.


    if (phase === 'active') {
      /* eslint-disable no-unused-expressions */
      node && node.scrollTop;
    }

    if (className) {
      this.appliedClasses[type][phase] = className;

      _addClass(node, className);
    }
  };

  _proto.removeClasses = function removeClasses(node, type) {
    var _this$appliedClasses$ = this.appliedClasses[type],
        baseClassName = _this$appliedClasses$.base,
        activeClassName = _this$appliedClasses$.active,
        doneClassName = _this$appliedClasses$.done;
    this.appliedClasses[type] = {};

    if (baseClassName) {
      removeClass(node, baseClassName);
    }

    if (activeClassName) {
      removeClass(node, activeClassName);
    }

    if (doneClassName) {
      removeClass(node, doneClassName);
    }
  };

  _proto.render = function render() {
    var _this$props = this.props;
        _this$props.classNames;
        var props = _objectWithoutPropertiesLoose(_this$props, ["classNames"]);

    return /*#__PURE__*/React__default["default"].createElement(Transition, _extends({}, props, {
      onEnter: this.onEnter,
      onEntered: this.onEntered,
      onEntering: this.onEntering,
      onExit: this.onExit,
      onExiting: this.onExiting,
      onExited: this.onExited
    }));
  };

  return CSSTransition;
}(React__default["default"].Component);

CSSTransition.defaultProps = {
  classNames: ''
};
CSSTransition.propTypes = process.env.NODE_ENV !== "production" ? _extends({}, Transition.propTypes, {
  /**
   * The animation classNames applied to the component as it appears, enters,
   * exits or has finished the transition. A single name can be provided, which
   * will be suffixed for each stage, e.g. `classNames="fade"` applies:
   *
   * - `fade-appear`, `fade-appear-active`, `fade-appear-done`
   * - `fade-enter`, `fade-enter-active`, `fade-enter-done`
   * - `fade-exit`, `fade-exit-active`, `fade-exit-done`
   *
   * A few details to note about how these classes are applied:
   *
   * 1. They are _joined_ with the ones that are already defined on the child
   *    component, so if you want to add some base styles, you can use
   *    `className` without worrying that it will be overridden.
   *
   * 2. If the transition component mounts with `in={false}`, no classes are
   *    applied yet. You might be expecting `*-exit-done`, but if you think
   *    about it, a component cannot finish exiting if it hasn't entered yet.
   *
   * 2. `fade-appear-done` and `fade-enter-done` will _both_ be applied. This
   *    allows you to define different behavior for when appearing is done and
   *    when regular entering is done, using selectors like
   *    `.fade-enter-done:not(.fade-appear-done)`. For example, you could apply
   *    an epic entrance animation when element first appears in the DOM using
   *    [Animate.css](https://daneden.github.io/animate.css/). Otherwise you can
   *    simply use `fade-enter-done` for defining both cases.
   *
   * Each individual classNames can also be specified independently like:
   *
   * ```js
   * classNames={{
   *  appear: 'my-appear',
   *  appearActive: 'my-active-appear',
   *  appearDone: 'my-done-appear',
   *  enter: 'my-enter',
   *  enterActive: 'my-active-enter',
   *  enterDone: 'my-done-enter',
   *  exit: 'my-exit',
   *  exitActive: 'my-active-exit',
   *  exitDone: 'my-done-exit',
   * }}
   * ```
   *
   * If you want to set these classes using CSS Modules:
   *
   * ```js
   * import styles from './styles.css';
   * ```
   *
   * you might want to use camelCase in your CSS file, that way could simply
   * spread them instead of listing them one by one:
   *
   * ```js
   * classNames={{ ...styles }}
   * ```
   *
   * @type {string | {
   *  appear?: string,
   *  appearActive?: string,
   *  appearDone?: string,
   *  enter?: string,
   *  enterActive?: string,
   *  enterDone?: string,
   *  exit?: string,
   *  exitActive?: string,
   *  exitDone?: string,
   * }}
   */
  classNames: classNamesShape,

  /**
   * A `<Transition>` callback fired immediately after the 'enter' or 'appear' class is
   * applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEnter: propTypes.exports.func,

  /**
   * A `<Transition>` callback fired immediately after the 'enter-active' or
   * 'appear-active' class is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: propTypes.exports.func,

  /**
   * A `<Transition>` callback fired immediately after the 'enter' or
   * 'appear' classes are **removed** and the `done` class is added to the DOM node.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntered: propTypes.exports.func,

  /**
   * A `<Transition>` callback fired immediately after the 'exit' class is
   * applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExit: propTypes.exports.func,

  /**
   * A `<Transition>` callback fired immediately after the 'exit-active' is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExiting: propTypes.exports.func,

  /**
   * A `<Transition>` callback fired immediately after the 'exit' classes
   * are **removed** and the `exit-done` class is added to the DOM node.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExited: propTypes.exports.func
}) : {};

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

/**
 * Given `this.props.children`, return an object mapping key to child.
 *
 * @param {*} children `this.props.children`
 * @return {object} Mapping of key to child
 */

function getChildMapping(children, mapFn) {
  var mapper = function mapper(child) {
    return mapFn && React$3.isValidElement(child) ? mapFn(child) : child;
  };

  var result = Object.create(null);
  if (children) React$3.Children.map(children, function (c) {
    return c;
  }).forEach(function (child) {
    // run the map function here instead so that the key is the computed one
    result[child.key] = mapper(child);
  });
  return result;
}
/**
 * When you're adding or removing children some may be added or removed in the
 * same render pass. We want to show *both* since we want to simultaneously
 * animate elements in and out. This function takes a previous set of keys
 * and a new set of keys and merges them with its best guess of the correct
 * ordering. In the future we may expose some of the utilities in
 * ReactMultiChild to make this easy, but for now React itself does not
 * directly have this concept of the union of prevChildren and nextChildren
 * so we implement it here.
 *
 * @param {object} prev prev children as returned from
 * `ReactTransitionChildMapping.getChildMapping()`.
 * @param {object} next next children as returned from
 * `ReactTransitionChildMapping.getChildMapping()`.
 * @return {object} a key set that contains all keys in `prev` and all keys
 * in `next` in a reasonable order.
 */

function mergeChildMappings(prev, next) {
  prev = prev || {};
  next = next || {};

  function getValueForKey(key) {
    return key in next ? next[key] : prev[key];
  } // For each key of `next`, the list of keys to insert before that key in
  // the combined list


  var nextKeysPending = Object.create(null);
  var pendingKeys = [];

  for (var prevKey in prev) {
    if (prevKey in next) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }

  var i;
  var childMapping = {};

  for (var nextKey in next) {
    if (nextKeysPending[nextKey]) {
      for (i = 0; i < nextKeysPending[nextKey].length; i++) {
        var pendingNextKey = nextKeysPending[nextKey][i];
        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
      }
    }

    childMapping[nextKey] = getValueForKey(nextKey);
  } // Finally, add the keys which didn't appear before any key in `next`


  for (i = 0; i < pendingKeys.length; i++) {
    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
  }

  return childMapping;
}

function getProp(child, prop, props) {
  return props[prop] != null ? props[prop] : child.props[prop];
}

function getInitialChildMapping(props, onExited) {
  return getChildMapping(props.children, function (child) {
    return React$3.cloneElement(child, {
      onExited: onExited.bind(null, child),
      in: true,
      appear: getProp(child, 'appear', props),
      enter: getProp(child, 'enter', props),
      exit: getProp(child, 'exit', props)
    });
  });
}
function getNextChildMapping(nextProps, prevChildMapping, onExited) {
  var nextChildMapping = getChildMapping(nextProps.children);
  var children = mergeChildMappings(prevChildMapping, nextChildMapping);
  Object.keys(children).forEach(function (key) {
    var child = children[key];
    if (!React$3.isValidElement(child)) return;
    var hasPrev = (key in prevChildMapping);
    var hasNext = (key in nextChildMapping);
    var prevChild = prevChildMapping[key];
    var isLeaving = React$3.isValidElement(prevChild) && !prevChild.props.in; // item is new (entering)

    if (hasNext && (!hasPrev || isLeaving)) {
      // console.log('entering', key)
      children[key] = React$3.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: true,
        exit: getProp(child, 'exit', nextProps),
        enter: getProp(child, 'enter', nextProps)
      });
    } else if (!hasNext && hasPrev && !isLeaving) {
      // item is old (exiting)
      // console.log('leaving', key)
      children[key] = React$3.cloneElement(child, {
        in: false
      });
    } else if (hasNext && hasPrev && React$3.isValidElement(prevChild)) {
      // item hasn't changed transition states
      // copy over the last transition props;
      // console.log('unchanged', key)
      children[key] = React$3.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: prevChild.props.in,
        exit: getProp(child, 'exit', nextProps),
        enter: getProp(child, 'enter', nextProps)
      });
    }
  });
  return children;
}

var values = Object.values || function (obj) {
  return Object.keys(obj).map(function (k) {
    return obj[k];
  });
};

var defaultProps = {
  component: 'div',
  childFactory: function childFactory(child) {
    return child;
  }
};
/**
 * The `<TransitionGroup>` component manages a set of transition components
 * (`<Transition>` and `<CSSTransition>`) in a list. Like with the transition
 * components, `<TransitionGroup>` is a state machine for managing the mounting
 * and unmounting of components over time.
 *
 * Consider the example below. As items are removed or added to the TodoList the
 * `in` prop is toggled automatically by the `<TransitionGroup>`.
 *
 * Note that `<TransitionGroup>`  does not define any animation behavior!
 * Exactly _how_ a list item animates is up to the individual transition
 * component. This means you can mix and match animations across different list
 * items.
 */

var TransitionGroup = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(TransitionGroup, _React$Component);

  function TransitionGroup(props, context) {
    var _this;

    _this = _React$Component.call(this, props, context) || this;

    var handleExited = _this.handleExited.bind(_assertThisInitialized(_this)); // Initial children should all be entering, dependent on appear


    _this.state = {
      contextValue: {
        isMounting: true
      },
      handleExited: handleExited,
      firstRender: true
    };
    return _this;
  }

  var _proto = TransitionGroup.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.mounted = true;
    this.setState({
      contextValue: {
        isMounting: false
      }
    });
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;
  };

  TransitionGroup.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
    var prevChildMapping = _ref.children,
        handleExited = _ref.handleExited,
        firstRender = _ref.firstRender;
    return {
      children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
      firstRender: false
    };
  } // node is `undefined` when user provided `nodeRef` prop
  ;

  _proto.handleExited = function handleExited(child, node) {
    var currentChildMapping = getChildMapping(this.props.children);
    if (child.key in currentChildMapping) return;

    if (child.props.onExited) {
      child.props.onExited(node);
    }

    if (this.mounted) {
      this.setState(function (state) {
        var children = _extends({}, state.children);

        delete children[child.key];
        return {
          children: children
        };
      });
    }
  };

  _proto.render = function render() {
    var _this$props = this.props,
        Component = _this$props.component,
        childFactory = _this$props.childFactory,
        props = _objectWithoutPropertiesLoose(_this$props, ["component", "childFactory"]);

    var contextValue = this.state.contextValue;
    var children = values(this.state.children).map(childFactory);
    delete props.appear;
    delete props.enter;
    delete props.exit;

    if (Component === null) {
      return /*#__PURE__*/React__default["default"].createElement(TransitionGroupContext.Provider, {
        value: contextValue
      }, children);
    }

    return /*#__PURE__*/React__default["default"].createElement(TransitionGroupContext.Provider, {
      value: contextValue
    }, /*#__PURE__*/React__default["default"].createElement(Component, props, children));
  };

  return TransitionGroup;
}(React__default["default"].Component);

TransitionGroup.propTypes = process.env.NODE_ENV !== "production" ? {
  /**
   * `<TransitionGroup>` renders a `<div>` by default. You can change this
   * behavior by providing a `component` prop.
   * If you use React v16+ and would like to avoid a wrapping `<div>` element
   * you can pass in `component={null}`. This is useful if the wrapping div
   * borks your css styles.
   */
  component: propTypes.exports.any,

  /**
   * A set of `<Transition>` components, that are toggled `in` and out as they
   * leave. the `<TransitionGroup>` will inject specific transition props, so
   * remember to spread them through if you are wrapping the `<Transition>` as
   * with our `<Fade>` example.
   *
   * While this component is meant for multiple `Transition` or `CSSTransition`
   * children, sometimes you may want to have a single transition child with
   * content that you want to be transitioned out and in when you change it
   * (e.g. routes, images etc.) In that case you can change the `key` prop of
   * the transition child as you change its content, this will cause
   * `TransitionGroup` to transition the child out and back in.
   */
  children: propTypes.exports.node,

  /**
   * A convenience prop that enables or disables appear animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  appear: propTypes.exports.bool,

  /**
   * A convenience prop that enables or disables enter animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  enter: propTypes.exports.bool,

  /**
   * A convenience prop that enables or disables exit animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  exit: propTypes.exports.bool,

  /**
   * You may need to apply reactive updates to a child as it is exiting.
   * This is generally done by using `cloneElement` however in the case of an exiting
   * child the element has already been removed and not accessible to the consumer.
   *
   * If you do need to update a child as it leaves you can provide a `childFactory`
   * to wrap every child, even the ones that are leaving.
   *
   * @type Function(child: ReactElement) -> ReactElement
   */
  childFactory: propTypes.exports.func
} : {};
TransitionGroup.defaultProps = defaultProps;

/**
 * The `<ReplaceTransition>` component is a specialized `Transition` component
 * that animates between two children.
 *
 * ```jsx
 * <ReplaceTransition in>
 *   <Fade><div>I appear first</div></Fade>
 *   <Fade><div>I replace the above</div></Fade>
 * </ReplaceTransition>
 * ```
 */

var ReplaceTransition = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(ReplaceTransition, _React$Component);

  function ReplaceTransition() {
    var _this;

    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
      _args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;

    _this.handleEnter = function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return _this.handleLifecycle('onEnter', 0, args);
    };

    _this.handleEntering = function () {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return _this.handleLifecycle('onEntering', 0, args);
    };

    _this.handleEntered = function () {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      return _this.handleLifecycle('onEntered', 0, args);
    };

    _this.handleExit = function () {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }

      return _this.handleLifecycle('onExit', 1, args);
    };

    _this.handleExiting = function () {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }

      return _this.handleLifecycle('onExiting', 1, args);
    };

    _this.handleExited = function () {
      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }

      return _this.handleLifecycle('onExited', 1, args);
    };

    return _this;
  }

  var _proto = ReplaceTransition.prototype;

  _proto.handleLifecycle = function handleLifecycle(handler, idx, originalArgs) {
    var _child$props;

    var children = this.props.children;
    var child = React__default["default"].Children.toArray(children)[idx];
    if (child.props[handler]) (_child$props = child.props)[handler].apply(_child$props, originalArgs);

    if (this.props[handler]) {
      var maybeNode = child.props.nodeRef ? undefined : ReactDOM__default["default"].findDOMNode(this);
      this.props[handler](maybeNode);
    }
  };

  _proto.render = function render() {
    var _this$props = this.props,
        children = _this$props.children,
        inProp = _this$props.in,
        props = _objectWithoutPropertiesLoose(_this$props, ["children", "in"]);

    var _React$Children$toArr = React__default["default"].Children.toArray(children),
        first = _React$Children$toArr[0],
        second = _React$Children$toArr[1];

    delete props.onEnter;
    delete props.onEntering;
    delete props.onEntered;
    delete props.onExit;
    delete props.onExiting;
    delete props.onExited;
    return /*#__PURE__*/React__default["default"].createElement(TransitionGroup, props, inProp ? React__default["default"].cloneElement(first, {
      key: 'first',
      onEnter: this.handleEnter,
      onEntering: this.handleEntering,
      onEntered: this.handleEntered
    }) : React__default["default"].cloneElement(second, {
      key: 'second',
      onEnter: this.handleExit,
      onEntering: this.handleExiting,
      onEntered: this.handleExited
    }));
  };

  return ReplaceTransition;
}(React__default["default"].Component);

ReplaceTransition.propTypes = process.env.NODE_ENV !== "production" ? {
  in: propTypes.exports.bool.isRequired,
  children: function children(props, propName) {
    if (React__default["default"].Children.count(props[propName]) !== 2) return new Error("\"" + propName + "\" must be exactly two transition components.");
    return null;
  }
} : {};

var _leaveRenders, _enterRenders;

function areChildrenDifferent(oldChildren, newChildren) {
  if (oldChildren === newChildren) return false;

  if (React__default["default"].isValidElement(oldChildren) && React__default["default"].isValidElement(newChildren) && oldChildren.key != null && oldChildren.key === newChildren.key) {
    return false;
  }

  return true;
}
/**
 * Enum of modes for SwitchTransition component
 * @enum { string }
 */


var modes = {
  out: 'out-in',
  in: 'in-out'
};

var callHook = function callHook(element, name, cb) {
  return function () {
    var _element$props;

    element.props[name] && (_element$props = element.props)[name].apply(_element$props, arguments);
    cb();
  };
};

var leaveRenders = (_leaveRenders = {}, _leaveRenders[modes.out] = function (_ref) {
  var current = _ref.current,
      changeState = _ref.changeState;
  return React__default["default"].cloneElement(current, {
    in: false,
    onExited: callHook(current, 'onExited', function () {
      changeState(ENTERING, null);
    })
  });
}, _leaveRenders[modes.in] = function (_ref2) {
  var current = _ref2.current,
      changeState = _ref2.changeState,
      children = _ref2.children;
  return [current, React__default["default"].cloneElement(children, {
    in: true,
    onEntered: callHook(children, 'onEntered', function () {
      changeState(ENTERING);
    })
  })];
}, _leaveRenders);
var enterRenders = (_enterRenders = {}, _enterRenders[modes.out] = function (_ref3) {
  var children = _ref3.children,
      changeState = _ref3.changeState;
  return React__default["default"].cloneElement(children, {
    in: true,
    onEntered: callHook(children, 'onEntered', function () {
      changeState(ENTERED, React__default["default"].cloneElement(children, {
        in: true
      }));
    })
  });
}, _enterRenders[modes.in] = function (_ref4) {
  var current = _ref4.current,
      children = _ref4.children,
      changeState = _ref4.changeState;
  return [React__default["default"].cloneElement(current, {
    in: false,
    onExited: callHook(current, 'onExited', function () {
      changeState(ENTERED, React__default["default"].cloneElement(children, {
        in: true
      }));
    })
  }), React__default["default"].cloneElement(children, {
    in: true
  })];
}, _enterRenders);
/**
 * A transition component inspired by the [vue transition modes](https://vuejs.org/v2/guide/transitions.html#Transition-Modes).
 * You can use it when you want to control the render between state transitions.
 * Based on the selected mode and the child's key which is the `Transition` or `CSSTransition` component, the `SwitchTransition` makes a consistent transition between them.
 *
 * If the `out-in` mode is selected, the `SwitchTransition` waits until the old child leaves and then inserts a new child.
 * If the `in-out` mode is selected, the `SwitchTransition` inserts a new child first, waits for the new child to enter and then removes the old child.
 *
 * **Note**: If you want the animation to happen simultaneously
 * (that is, to have the old child removed and a new child inserted **at the same time**),
 * you should use
 * [`TransitionGroup`](https://reactcommunity.org/react-transition-group/transition-group)
 * instead.
 *
 * ```jsx
 * function App() {
 *  const [state, setState] = useState(false);
 *  return (
 *    <SwitchTransition>
 *      <CSSTransition
 *        key={state ? "Goodbye, world!" : "Hello, world!"}
 *        addEndListener={(node, done) => node.addEventListener("transitionend", done, false)}
 *        classNames='fade'
 *      >
 *        <button onClick={() => setState(state => !state)}>
 *          {state ? "Goodbye, world!" : "Hello, world!"}
 *        </button>
 *      </CSSTransition>
 *    </SwitchTransition>
 *  );
 * }
 * ```
 *
 * ```css
 * .fade-enter{
 *    opacity: 0;
 * }
 * .fade-exit{
 *    opacity: 1;
 * }
 * .fade-enter-active{
 *    opacity: 1;
 * }
 * .fade-exit-active{
 *    opacity: 0;
 * }
 * .fade-enter-active,
 * .fade-exit-active{
 *    transition: opacity 500ms;
 * }
 * ```
 */

var SwitchTransition = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(SwitchTransition, _React$Component);

  function SwitchTransition() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.state = {
      status: ENTERED,
      current: null
    };
    _this.appeared = false;

    _this.changeState = function (status, current) {
      if (current === void 0) {
        current = _this.state.current;
      }

      _this.setState({
        status: status,
        current: current
      });
    };

    return _this;
  }

  var _proto = SwitchTransition.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.appeared = true;
  };

  SwitchTransition.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {
    if (props.children == null) {
      return {
        current: null
      };
    }

    if (state.status === ENTERING && props.mode === modes.in) {
      return {
        status: ENTERING
      };
    }

    if (state.current && areChildrenDifferent(state.current, props.children)) {
      return {
        status: EXITING
      };
    }

    return {
      current: React__default["default"].cloneElement(props.children, {
        in: true
      })
    };
  };

  _proto.render = function render() {
    var _this$props = this.props,
        children = _this$props.children,
        mode = _this$props.mode,
        _this$state = this.state,
        status = _this$state.status,
        current = _this$state.current;
    var data = {
      children: children,
      current: current,
      changeState: this.changeState,
      status: status
    };
    var component;

    switch (status) {
      case ENTERING:
        component = enterRenders[mode](data);
        break;

      case EXITING:
        component = leaveRenders[mode](data);
        break;

      case ENTERED:
        component = current;
    }

    return /*#__PURE__*/React__default["default"].createElement(TransitionGroupContext.Provider, {
      value: {
        isMounting: !this.appeared
      }
    }, component);
  };

  return SwitchTransition;
}(React__default["default"].Component);

SwitchTransition.propTypes = process.env.NODE_ENV !== "production" ? {
  /**
   * Transition modes.
   * `out-in`: Current element transitions out first, then when complete, the new element transitions in.
   * `in-out`: New element transitions in first, then when complete, the current element transitions out.
   *
   * @type {'out-in'|'in-out'}
   */
  mode: propTypes.exports.oneOf([modes.in, modes.out]),

  /**
   * Any `Transition` or `CSSTransition` component.
   */
  children: propTypes.exports.oneOfType([propTypes.exports.element.isRequired])
} : {};
SwitchTransition.defaultProps = {
  mode: modes.out
};

const reflow = node => node.scrollTop;
function getTransitionProps(props, options) {
  var _style$transitionDura, _style$transitionTimi;

  const {
    timeout,
    easing,
    style = {}
  } = props;
  return {
    duration: (_style$transitionDura = style.transitionDuration) != null ? _style$transitionDura : typeof timeout === 'number' ? timeout : timeout[options.mode] || 0,
    easing: (_style$transitionTimi = style.transitionTimingFunction) != null ? _style$transitionTimi : typeof easing === 'object' ? easing[options.mode] : easing,
    delay: style.transitionDelay
  };
}

const _excluded$3 = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];

function getScale(value) {
  return `scale(${value}, ${value ** 2})`;
}

const styles = {
  entering: {
    opacity: 1,
    transform: getScale(1)
  },
  entered: {
    opacity: 1,
    transform: 'none'
  }
};
/*
 TODO v6: remove
 Conditionally apply a workaround for the CSS transition bug in Safari 15.4 / WebKit browsers.
 Remove this workaround once the WebKit bug fix is released.
 */

const isWebKit154 = typeof navigator !== 'undefined' && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)[4-9]/i.test(navigator.userAgent);
/**
 * The Grow transition is used by the [Tooltip](/material-ui/react-tooltip/) and
 * [Popover](/material-ui/react-popover/) components.
 * It uses [react-transition-group](https://github.com/reactjs/react-transition-group) internally.
 */

const Grow = /*#__PURE__*/React__namespace.forwardRef(function Grow(props, ref) {
  const {
    addEndListener,
    appear = true,
    children,
    easing,
    in: inProp,
    onEnter,
    onEntered,
    onEntering,
    onExit,
    onExited,
    onExiting,
    style,
    timeout = 'auto',
    // eslint-disable-next-line react/prop-types
    TransitionComponent = Transition
  } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$3);

  const timer = React__namespace.useRef();
  const autoTimeout = React__namespace.useRef();
  const theme = useTheme();
  const nodeRef = React__namespace.useRef(null);
  const foreignRef = useForkRef(children.ref, ref);
  const handleRef = useForkRef(nodeRef, foreignRef);

  const normalizedTransitionCallback = callback => maybeIsAppearing => {
    if (callback) {
      const node = nodeRef.current; // onEnterXxx and onExitXxx callbacks have a different arguments.length value.

      if (maybeIsAppearing === undefined) {
        callback(node);
      } else {
        callback(node, maybeIsAppearing);
      }
    }
  };

  const handleEntering = normalizedTransitionCallback(onEntering);
  const handleEnter = normalizedTransitionCallback((node, isAppearing) => {
    reflow(node); // So the animation always start from the start.

    const {
      duration: transitionDuration,
      delay,
      easing: transitionTimingFunction
    } = getTransitionProps({
      style,
      timeout,
      easing
    }, {
      mode: 'enter'
    });
    let duration;

    if (timeout === 'auto') {
      duration = theme.transitions.getAutoHeightDuration(node.clientHeight);
      autoTimeout.current = duration;
    } else {
      duration = transitionDuration;
    }

    node.style.transition = [theme.transitions.create('opacity', {
      duration,
      delay
    }), theme.transitions.create('transform', {
      duration: isWebKit154 ? duration : duration * 0.666,
      delay,
      easing: transitionTimingFunction
    })].join(',');

    if (onEnter) {
      onEnter(node, isAppearing);
    }
  });
  const handleEntered = normalizedTransitionCallback(onEntered);
  const handleExiting = normalizedTransitionCallback(onExiting);
  const handleExit = normalizedTransitionCallback(node => {
    const {
      duration: transitionDuration,
      delay,
      easing: transitionTimingFunction
    } = getTransitionProps({
      style,
      timeout,
      easing
    }, {
      mode: 'exit'
    });
    let duration;

    if (timeout === 'auto') {
      duration = theme.transitions.getAutoHeightDuration(node.clientHeight);
      autoTimeout.current = duration;
    } else {
      duration = transitionDuration;
    }

    node.style.transition = [theme.transitions.create('opacity', {
      duration,
      delay
    }), theme.transitions.create('transform', {
      duration: isWebKit154 ? duration : duration * 0.666,
      delay: isWebKit154 ? delay : delay || duration * 0.333,
      easing: transitionTimingFunction
    })].join(',');
    node.style.opacity = 0;
    node.style.transform = getScale(0.75);

    if (onExit) {
      onExit(node);
    }
  });
  const handleExited = normalizedTransitionCallback(onExited);

  const handleAddEndListener = next => {
    if (timeout === 'auto') {
      timer.current = setTimeout(next, autoTimeout.current || 0);
    }

    if (addEndListener) {
      // Old call signature before `react-transition-group` implemented `nodeRef`
      addEndListener(nodeRef.current, next);
    }
  };

  React__namespace.useEffect(() => {
    return () => {
      clearTimeout(timer.current);
    };
  }, []);
  return /*#__PURE__*/jsxRuntime.exports.jsx(TransitionComponent, _extends({
    appear: appear,
    in: inProp,
    nodeRef: nodeRef,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    addEndListener: handleAddEndListener,
    timeout: timeout === 'auto' ? null : timeout
  }, other, {
    children: (state, childProps) => {
      return /*#__PURE__*/React__namespace.cloneElement(children, _extends({
        style: _extends({
          opacity: 0,
          transform: getScale(0.75),
          visibility: state === 'exited' && !inProp ? 'hidden' : undefined
        }, styles[state], style, children.props.style),
        ref: handleRef
      }, childProps));
    }
  }));
});
process.env.NODE_ENV !== "production" ? Grow.propTypes
/* remove-proptypes */
= {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------

  /**
   * Add a custom transition end trigger. Called with the transitioning DOM
   * node and a done callback. Allows for more fine grained transition end
   * logic. Note: Timeouts are still used as a fallback if provided.
   */
  addEndListener: propTypes.exports.func,

  /**
   * Perform the enter transition when it first mounts if `in` is also `true`.
   * Set this to `false` to disable this behavior.
   * @default true
   */
  appear: propTypes.exports.bool,

  /**
   * A single child content element.
   */
  children: elementAcceptingRef.isRequired,

  /**
   * The transition timing function.
   * You may specify a single easing or a object containing enter and exit values.
   */
  easing: propTypes.exports.oneOfType([propTypes.exports.shape({
    enter: propTypes.exports.string,
    exit: propTypes.exports.string
  }), propTypes.exports.string]),

  /**
   * If `true`, the component will transition in.
   */
  in: propTypes.exports.bool,

  /**
   * @ignore
   */
  onEnter: propTypes.exports.func,

  /**
   * @ignore
   */
  onEntered: propTypes.exports.func,

  /**
   * @ignore
   */
  onEntering: propTypes.exports.func,

  /**
   * @ignore
   */
  onExit: propTypes.exports.func,

  /**
   * @ignore
   */
  onExited: propTypes.exports.func,

  /**
   * @ignore
   */
  onExiting: propTypes.exports.func,

  /**
   * @ignore
   */
  style: propTypes.exports.object,

  /**
   * The duration for the transition, in milliseconds.
   * You may specify a single timeout for all transitions, or individually with an object.
   *
   * Set to 'auto' to automatically calculate transition time based on height.
   * @default 'auto'
   */
  timeout: propTypes.exports.oneOfType([propTypes.exports.oneOf(['auto']), propTypes.exports.number, propTypes.exports.shape({
    appear: propTypes.exports.number,
    enter: propTypes.exports.number,
    exit: propTypes.exports.number
  })])
} : void 0;
Grow.muiSupportAuto = true;

function getPaperUtilityClass(slot) {
  return generateUtilityClass('MuiPaper', slot);
}
generateUtilityClasses('MuiPaper', ['root', 'rounded', 'outlined', 'elevation', 'elevation0', 'elevation1', 'elevation2', 'elevation3', 'elevation4', 'elevation5', 'elevation6', 'elevation7', 'elevation8', 'elevation9', 'elevation10', 'elevation11', 'elevation12', 'elevation13', 'elevation14', 'elevation15', 'elevation16', 'elevation17', 'elevation18', 'elevation19', 'elevation20', 'elevation21', 'elevation22', 'elevation23', 'elevation24']);

const _excluded$2 = ["className", "component", "elevation", "square", "variant"];
const getOverlayAlpha = elevation => {
  let alphaValue;

  if (elevation < 1) {
    alphaValue = 5.11916 * elevation ** 2;
  } else {
    alphaValue = 4.5 * Math.log(elevation + 1) + 2;
  }

  return (alphaValue / 100).toFixed(2);
};

const useUtilityClasses$1 = ownerState => {
  const {
    square,
    elevation,
    variant,
    classes
  } = ownerState;
  const slots = {
    root: ['root', variant, !square && 'rounded', variant === 'elevation' && `elevation${elevation}`]
  };
  return composeClasses(slots, getPaperUtilityClass, classes);
};

const PaperRoot = styled('div', {
  name: 'MuiPaper',
  slot: 'Root',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.root, styles[ownerState.variant], !ownerState.square && styles.rounded, ownerState.variant === 'elevation' && styles[`elevation${ownerState.elevation}`]];
  }
})(({
  theme,
  ownerState
}) => {
  var _theme$vars$overlays;

  return _extends({
    backgroundColor: (theme.vars || theme).palette.background.paper,
    color: (theme.vars || theme).palette.text.primary,
    transition: theme.transitions.create('box-shadow')
  }, !ownerState.square && {
    borderRadius: theme.shape.borderRadius
  }, ownerState.variant === 'outlined' && {
    border: `1px solid ${(theme.vars || theme).palette.divider}`
  }, ownerState.variant === 'elevation' && _extends({
    boxShadow: (theme.vars || theme).shadows[ownerState.elevation]
  }, !theme.vars && theme.palette.mode === 'dark' && {
    backgroundImage: `linear-gradient(${alpha('#fff', getOverlayAlpha(ownerState.elevation))}, ${alpha('#fff', getOverlayAlpha(ownerState.elevation))})`
  }, theme.vars && {
    backgroundImage: (_theme$vars$overlays = theme.vars.overlays) == null ? void 0 : _theme$vars$overlays[ownerState.elevation]
  }));
});
const Paper = /*#__PURE__*/React__namespace.forwardRef(function Paper(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: 'MuiPaper'
  });

  const {
    className,
    component = 'div',
    elevation = 1,
    square = false,
    variant = 'elevation'
  } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded$2);

  const ownerState = _extends({}, props, {
    component,
    elevation,
    square,
    variant
  });

  const classes = useUtilityClasses$1(ownerState);

  if (process.env.NODE_ENV !== 'production') {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    const theme = useTheme();

    if (theme.shadows[elevation] === undefined) {
      console.error([`MUI: The elevation provided <Paper elevation={${elevation}}> is not available in the theme.`, `Please make sure that \`theme.shadows[${elevation}]\` is defined.`].join('\n'));
    }
  }

  return /*#__PURE__*/jsxRuntime.exports.jsx(PaperRoot, _extends({
    as: component,
    ownerState: ownerState,
    className: clsx(classes.root, className),
    ref: ref
  }, other));
});
process.env.NODE_ENV !== "production" ? Paper.propTypes
/* remove-proptypes */
= {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------

  /**
   * The content of the component.
   */
  children: propTypes.exports.node,

  /**
   * Override or extend the styles applied to the component.
   */
  classes: propTypes.exports.object,

  /**
   * @ignore
   */
  className: propTypes.exports.string,

  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: propTypes.exports.elementType,

  /**
   * Shadow depth, corresponds to `dp` in the spec.
   * It accepts values between 0 and 24 inclusive.
   * @default 1
   */
  elevation: chainPropTypes(integerPropType, props => {
    const {
      elevation,
      variant
    } = props;

    if (elevation > 0 && variant === 'outlined') {
      return new Error(`MUI: Combining \`elevation={${elevation}}\` with \`variant="${variant}"\` has no effect. Either use \`elevation={0}\` or use a different \`variant\`.`);
    }

    return null;
  }),

  /**
   * If `true`, rounded corners are disabled.
   * @default false
   */
  square: propTypes.exports.bool,

  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: propTypes.exports.oneOfType([propTypes.exports.arrayOf(propTypes.exports.oneOfType([propTypes.exports.func, propTypes.exports.object, propTypes.exports.bool])), propTypes.exports.func, propTypes.exports.object]),

  /**
   * The variant to use.
   * @default 'elevation'
   */
  variant: propTypes.exports
  /* @typescript-to-proptypes-ignore */
  .oneOfType([propTypes.exports.oneOf(['elevation', 'outlined']), propTypes.exports.string])
} : void 0;

const _excluded$1 = ["colorSchemes"],
      _excluded2 = ["palette"];
const defaultDarkOverlays = [...Array(25)].map((_, index) => {
  if (index === 0) {
    return undefined;
  }

  const overlay = getOverlayAlpha(index);
  return `linear-gradient(rgba(255 255 255 / ${overlay}), rgba(255 255 255 / ${overlay}))`;
});
function extendTheme(options = {}, ...args) {
  var _colorSchemesInput$li, _colorSchemesInput$da, _colorSchemesInput$li2, _colorSchemesInput$li3, _colorSchemesInput$da2, _colorSchemesInput$da3;

  const {
    colorSchemes: colorSchemesInput = {}
  } = options,
        input = _objectWithoutPropertiesLoose(options, _excluded$1);

  const _createThemeWithoutVa = createTheme(_extends({}, input, colorSchemesInput.light && {
    palette: (_colorSchemesInput$li = colorSchemesInput.light) == null ? void 0 : _colorSchemesInput$li.palette
  })),
        {
    palette: lightPalette
  } = _createThemeWithoutVa,
        muiTheme = _objectWithoutPropertiesLoose(_createThemeWithoutVa, _excluded2);

  const {
    palette: darkPalette
  } = createTheme({
    palette: _extends({
      mode: 'dark'
    }, (_colorSchemesInput$da = colorSchemesInput.dark) == null ? void 0 : _colorSchemesInput$da.palette)
  });

  let theme = _extends({}, muiTheme, {
    colorSchemes: _extends({}, colorSchemesInput, {
      light: _extends({}, colorSchemesInput.light, {
        palette: lightPalette,
        opacity: _extends({
          placeholder: 0.42,
          inputTouchBottomLine: 0.42
        }, (_colorSchemesInput$li2 = colorSchemesInput.light) == null ? void 0 : _colorSchemesInput$li2.opacity),
        overlays: ((_colorSchemesInput$li3 = colorSchemesInput.light) == null ? void 0 : _colorSchemesInput$li3.overlays) || []
      }),
      dark: _extends({}, colorSchemesInput.dark, {
        palette: darkPalette,
        opacity: _extends({
          placeholder: 0.5,
          inputTouchBottomLine: 0.7
        }, (_colorSchemesInput$da2 = colorSchemesInput.dark) == null ? void 0 : _colorSchemesInput$da2.opacity),
        overlays: ((_colorSchemesInput$da3 = colorSchemesInput.dark) == null ? void 0 : _colorSchemesInput$da3.overlays) || defaultDarkOverlays
      })
    })
  });

  Object.keys(theme.colorSchemes).forEach(key => {
    const palette = theme.colorSchemes[key].palette; // attach black & white channels to common node

    if (key === 'dark') {
      palette.common.background = palette.common.background || '#000';
      palette.common.onBackground = palette.common.onBackground || '#fff';
    } else {
      palette.common.background = palette.common.background || '#fff';
      palette.common.onBackground = palette.common.onBackground || '#000';
    }

    palette.common.backgroundChannel = colorChannel(palette.common.background);
    palette.common.onBackgroundChannel = colorChannel(palette.common.onBackground);
    palette.dividerChannel = colorChannel(palette.divider); // special token for Tooltip
    // TODO: consider adding `main`, and `light` to palette.grey to make it consistent.

    if (!palette.grey.dark) {
      palette.grey.dark = palette.grey[700];
    }

    Object.keys(palette).forEach(color => {
      const colors = palette[color]; // Color palettes: primary, secondary, error, info, success, and warning

      if (colors.main) {
        palette[color].mainChannel = colorChannel(colors.main);
      }

      if (colors.light) {
        palette[color].lightChannel = colorChannel(colors.light);
      }

      if (colors.dark) {
        palette[color].darkChannel = colorChannel(colors.dark);
      }

      if (colors.contrastText) {
        palette[color].contrastTextChannel = colorChannel(colors.contrastText);
      } // Text colors: text.primary, text.secondary


      if (colors.primary) {
        palette[color].primaryChannel = colorChannel(colors.primary);
      }

      if (colors.secondary) {
        palette[color].secondaryChannel = colorChannel(colors.secondary);
      } // Action colors: action.activeChannel


      if (colors.active) {
        palette[color].activeChannel = colorChannel(colors.active);
      }
    });
  });
  theme = args.reduce((acc, argument) => deepmerge(acc, argument), theme);
  return theme;
}

const defaultTheme = extendTheme();
createCssVarsProvider({
  theme: defaultTheme,
  attribute: 'data-mui-color-scheme',
  modeStorageKey: 'mui-mode',
  colorSchemeStorageKey: 'mui-color-scheme',
  defaultColorScheme: {
    light: 'light',
    dark: 'dark'
  },
  prefix: 'md',
  resolveTheme: theme => {
    const newTheme = _extends({}, theme, {
      typography: createTypography(theme.palette, theme.typography)
    });

    return newTheme;
  },
  shouldSkipGeneratingVar: keys => !!keys[0].match(/(typography|mixins|breakpoints|direction|transitions)/)
});

const PopperRoot = styled(PopperUnstyled, {
  name: 'MuiPopper',
  slot: 'Root',
  overridesResolver: (props, styles) => styles.root
})({});
/**
 *
 * Demos:
 *
 * - [Autocomplete](https://mui.com/material-ui/react-autocomplete/)
 * - [Menus](https://mui.com/material-ui/react-menu/)
 * - [Popper](https://mui.com/material-ui/react-popper/)
 *
 * API:
 *
 * - [Popper API](https://mui.com/material-ui/api/popper/)
 */

const Popper = /*#__PURE__*/React__namespace.forwardRef(function Popper(inProps, ref) {
  const theme = useTheme$2();
  const props = useThemeProps({
    props: inProps,
    name: 'MuiPopper'
  });
  return /*#__PURE__*/jsxRuntime.exports.jsx(PopperRoot, _extends({
    direction: theme == null ? void 0 : theme.direction
  }, props, {
    ref: ref
  }));
});
process.env.NODE_ENV !== "production" ? Popper.propTypes
/* remove-proptypes */
= {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------

  /**
   * An HTML element, [virtualElement](https://popper.js.org/docs/v2/virtual-elements/),
   * or a function that returns either.
   * It's used to set the position of the popper.
   * The return value will passed as the reference object of the Popper instance.
   */
  anchorEl: propTypes.exports
  /* @typescript-to-proptypes-ignore */
  .oneOfType([HTMLElementType, propTypes.exports.object, propTypes.exports.func]),

  /**
   * Popper render function or node.
   */
  children: propTypes.exports
  /* @typescript-to-proptypes-ignore */
  .oneOfType([propTypes.exports.node, propTypes.exports.func]),

  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: propTypes.exports
  /* @typescript-to-proptypes-ignore */
  .oneOfType([HTMLElementType, propTypes.exports.func]),

  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: propTypes.exports.bool,

  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Popper.
   * @default false
   */
  keepMounted: propTypes.exports.bool,

  /**
   * Popper.js is based on a "plugin-like" architecture,
   * most of its features are fully encapsulated "modifiers".
   *
   * A modifier is a function that is called each time Popper.js needs to
   * compute the position of the popper.
   * For this reason, modifiers should be very performant to avoid bottlenecks.
   * To learn how to create a modifier, [read the modifiers documentation](https://popper.js.org/docs/v2/modifiers/).
   */
  modifiers: propTypes.exports.arrayOf(propTypes.exports.shape({
    data: propTypes.exports.object,
    effect: propTypes.exports.func,
    enabled: propTypes.exports.bool,
    fn: propTypes.exports.func,
    name: propTypes.exports.any,
    options: propTypes.exports.object,
    phase: propTypes.exports.oneOf(['afterMain', 'afterRead', 'afterWrite', 'beforeMain', 'beforeRead', 'beforeWrite', 'main', 'read', 'write']),
    requires: propTypes.exports.arrayOf(propTypes.exports.string),
    requiresIfExists: propTypes.exports.arrayOf(propTypes.exports.string)
  })),

  /**
   * If `true`, the component is shown.
   */
  open: propTypes.exports.bool.isRequired,

  /**
   * Popper placement.
   * @default 'bottom'
   */
  placement: propTypes.exports.oneOf(['auto-end', 'auto-start', 'auto', 'bottom-end', 'bottom-start', 'bottom', 'left-end', 'left-start', 'left', 'right-end', 'right-start', 'right', 'top-end', 'top-start', 'top']),

  /**
   * Options provided to the [`Popper.js`](https://popper.js.org/docs/v2/constructors/#options) instance.
   * @default {}
   */
  popperOptions: propTypes.exports.shape({
    modifiers: propTypes.exports.array,
    onFirstUpdate: propTypes.exports.func,
    placement: propTypes.exports.oneOf(['auto-end', 'auto-start', 'auto', 'bottom-end', 'bottom-start', 'bottom', 'left-end', 'left-start', 'left', 'right-end', 'right-start', 'right', 'top-end', 'top-start', 'top']),
    strategy: propTypes.exports.oneOf(['absolute', 'fixed'])
  }),

  /**
   * A ref that points to the used popper instance.
   */
  popperRef: refType,

  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: propTypes.exports.oneOfType([propTypes.exports.arrayOf(propTypes.exports.oneOfType([propTypes.exports.func, propTypes.exports.object, propTypes.exports.bool])), propTypes.exports.func, propTypes.exports.object]),

  /**
   * Help supporting a react-transition-group/Transition component.
   * @default false
   */
  transition: propTypes.exports.bool
} : void 0;

function getTooltipUtilityClass(slot) {
  return generateUtilityClass('MuiTooltip', slot);
}
const tooltipClasses = generateUtilityClasses('MuiTooltip', ['popper', 'popperInteractive', 'popperArrow', 'popperClose', 'tooltip', 'tooltipArrow', 'touch', 'tooltipPlacementLeft', 'tooltipPlacementRight', 'tooltipPlacementTop', 'tooltipPlacementBottom', 'arrow']);

const _excluded = ["arrow", "children", "classes", "components", "componentsProps", "describeChild", "disableFocusListener", "disableHoverListener", "disableInteractive", "disableTouchListener", "enterDelay", "enterNextDelay", "enterTouchDelay", "followCursor", "id", "leaveDelay", "leaveTouchDelay", "onClose", "onOpen", "open", "placement", "PopperComponent", "PopperProps", "title", "TransitionComponent", "TransitionProps"];

function round(value) {
  return Math.round(value * 1e5) / 1e5;
}

const useUtilityClasses = ownerState => {
  const {
    classes,
    disableInteractive,
    arrow,
    touch,
    placement
  } = ownerState;
  const slots = {
    popper: ['popper', !disableInteractive && 'popperInteractive', arrow && 'popperArrow'],
    tooltip: ['tooltip', arrow && 'tooltipArrow', touch && 'touch', `tooltipPlacement${capitalize(placement.split('-')[0])}`],
    arrow: ['arrow']
  };
  return composeClasses(slots, getTooltipUtilityClass, classes);
};

const TooltipPopper = styled(Popper, {
  name: 'MuiTooltip',
  slot: 'Popper',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.popper, !ownerState.disableInteractive && styles.popperInteractive, ownerState.arrow && styles.popperArrow, !ownerState.open && styles.popperClose];
  }
})(({
  theme,
  ownerState,
  open
}) => _extends({
  zIndex: (theme.vars || theme).zIndex.tooltip,
  pointerEvents: 'none'
}, !ownerState.disableInteractive && {
  pointerEvents: 'auto'
}, !open && {
  pointerEvents: 'none'
}, ownerState.arrow && {
  [`&[data-popper-placement*="bottom"] .${tooltipClasses.arrow}`]: {
    top: 0,
    marginTop: '-0.71em',
    '&::before': {
      transformOrigin: '0 100%'
    }
  },
  [`&[data-popper-placement*="top"] .${tooltipClasses.arrow}`]: {
    bottom: 0,
    marginBottom: '-0.71em',
    '&::before': {
      transformOrigin: '100% 0'
    }
  },
  [`&[data-popper-placement*="right"] .${tooltipClasses.arrow}`]: _extends({}, !ownerState.isRtl ? {
    left: 0,
    marginLeft: '-0.71em'
  } : {
    right: 0,
    marginRight: '-0.71em'
  }, {
    height: '1em',
    width: '0.71em',
    '&::before': {
      transformOrigin: '100% 100%'
    }
  }),
  [`&[data-popper-placement*="left"] .${tooltipClasses.arrow}`]: _extends({}, !ownerState.isRtl ? {
    right: 0,
    marginRight: '-0.71em'
  } : {
    left: 0,
    marginLeft: '-0.71em'
  }, {
    height: '1em',
    width: '0.71em',
    '&::before': {
      transformOrigin: '0 0'
    }
  })
}));
const TooltipTooltip = styled('div', {
  name: 'MuiTooltip',
  slot: 'Tooltip',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.tooltip, ownerState.touch && styles.touch, ownerState.arrow && styles.tooltipArrow, styles[`tooltipPlacement${capitalize(ownerState.placement.split('-')[0])}`]];
  }
})(({
  theme,
  ownerState
}) => _extends({
  backgroundColor: theme.vars ? `rgba(${theme.vars.palette.grey.darkChannel} / 0.92)` : alpha(theme.palette.grey[700], 0.92),
  borderRadius: (theme.vars || theme).shape.borderRadius,
  color: (theme.vars || theme).palette.common.white,
  fontFamily: theme.typography.fontFamily,
  padding: '4px 8px',
  fontSize: theme.typography.pxToRem(11),
  maxWidth: 300,
  margin: 2,
  wordWrap: 'break-word',
  fontWeight: theme.typography.fontWeightMedium
}, ownerState.arrow && {
  position: 'relative',
  margin: 0
}, ownerState.touch && {
  padding: '8px 16px',
  fontSize: theme.typography.pxToRem(14),
  lineHeight: `${round(16 / 14)}em`,
  fontWeight: theme.typography.fontWeightRegular
}, {
  [`.${tooltipClasses.popper}[data-popper-placement*="left"] &`]: _extends({
    transformOrigin: 'right center'
  }, !ownerState.isRtl ? _extends({
    marginRight: '14px'
  }, ownerState.touch && {
    marginRight: '24px'
  }) : _extends({
    marginLeft: '14px'
  }, ownerState.touch && {
    marginLeft: '24px'
  })),
  [`.${tooltipClasses.popper}[data-popper-placement*="right"] &`]: _extends({
    transformOrigin: 'left center'
  }, !ownerState.isRtl ? _extends({
    marginLeft: '14px'
  }, ownerState.touch && {
    marginLeft: '24px'
  }) : _extends({
    marginRight: '14px'
  }, ownerState.touch && {
    marginRight: '24px'
  })),
  [`.${tooltipClasses.popper}[data-popper-placement*="top"] &`]: _extends({
    transformOrigin: 'center bottom',
    marginBottom: '14px'
  }, ownerState.touch && {
    marginBottom: '24px'
  }),
  [`.${tooltipClasses.popper}[data-popper-placement*="bottom"] &`]: _extends({
    transformOrigin: 'center top',
    marginTop: '14px'
  }, ownerState.touch && {
    marginTop: '24px'
  })
}));
const TooltipArrow = styled('span', {
  name: 'MuiTooltip',
  slot: 'Arrow',
  overridesResolver: (props, styles) => styles.arrow
})(({
  theme
}) => ({
  overflow: 'hidden',
  position: 'absolute',
  width: '1em',
  height: '0.71em'
  /* = width / sqrt(2) = (length of the hypotenuse) */
  ,
  boxSizing: 'border-box',
  color: theme.vars ? `rgba(${theme.vars.palette.grey.darkChannel} / 0.9)` : alpha(theme.palette.grey[700], 0.9),
  '&::before': {
    content: '""',
    margin: 'auto',
    display: 'block',
    width: '100%',
    height: '100%',
    backgroundColor: 'currentColor',
    transform: 'rotate(45deg)'
  }
}));
let hystersisOpen = false;
let hystersisTimer = null;

function composeEventHandler(handler, eventHandler) {
  return event => {
    if (eventHandler) {
      eventHandler(event);
    }

    handler(event);
  };
} // TODO v6: Remove PopperComponent, PopperProps, TransitionComponent and TransitionProps.


const Tooltip = /*#__PURE__*/React__namespace.forwardRef(function Tooltip(inProps, ref) {
  var _components$Popper, _ref, _components$Transitio, _components$Tooltip, _components$Arrow, _componentsProps$popp;

  const props = useThemeProps({
    props: inProps,
    name: 'MuiTooltip'
  });

  const {
    arrow = false,
    children,
    components = {},
    componentsProps = {},
    describeChild = false,
    disableFocusListener = false,
    disableHoverListener = false,
    disableInteractive: disableInteractiveProp = false,
    disableTouchListener = false,
    enterDelay = 100,
    enterNextDelay = 0,
    enterTouchDelay = 700,
    followCursor = false,
    id: idProp,
    leaveDelay = 0,
    leaveTouchDelay = 1500,
    onClose,
    onOpen,
    open: openProp,
    placement = 'bottom',
    PopperComponent: PopperComponentProp,
    PopperProps = {},
    title,
    TransitionComponent: TransitionComponentProp = Grow,
    TransitionProps
  } = props,
        other = _objectWithoutPropertiesLoose(props, _excluded);

  const theme = useTheme();
  const isRtl = theme.direction === 'rtl';
  const [childNode, setChildNode] = React__namespace.useState();
  const [arrowRef, setArrowRef] = React__namespace.useState(null);
  const ignoreNonTouchEvents = React__namespace.useRef(false);
  const disableInteractive = disableInteractiveProp || followCursor;
  const closeTimer = React__namespace.useRef();
  const enterTimer = React__namespace.useRef();
  const leaveTimer = React__namespace.useRef();
  const touchTimer = React__namespace.useRef();
  const [openState, setOpenState] = useControlled({
    controlled: openProp,
    default: false,
    name: 'Tooltip',
    state: 'open'
  });
  let open = openState;

  if (process.env.NODE_ENV !== 'production') {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    const {
      current: isControlled
    } = React__namespace.useRef(openProp !== undefined); // eslint-disable-next-line react-hooks/rules-of-hooks

    React__namespace.useEffect(() => {
      if (childNode && childNode.disabled && !isControlled && title !== '' && childNode.tagName.toLowerCase() === 'button') {
        console.error(['MUI: You are providing a disabled `button` child to the Tooltip component.', 'A disabled element does not fire events.', "Tooltip needs to listen to the child element's events to display the title.", '', 'Add a simple wrapper element, such as a `span`.'].join('\n'));
      }
    }, [title, childNode, isControlled]);
  }

  const id = useId(idProp);
  const prevUserSelect = React__namespace.useRef();
  const stopTouchInteraction = React__namespace.useCallback(() => {
    if (prevUserSelect.current !== undefined) {
      document.body.style.WebkitUserSelect = prevUserSelect.current;
      prevUserSelect.current = undefined;
    }

    clearTimeout(touchTimer.current);
  }, []);
  React__namespace.useEffect(() => {
    return () => {
      clearTimeout(closeTimer.current);
      clearTimeout(enterTimer.current);
      clearTimeout(leaveTimer.current);
      stopTouchInteraction();
    };
  }, [stopTouchInteraction]);

  const handleOpen = event => {
    clearTimeout(hystersisTimer);
    hystersisOpen = true; // The mouseover event will trigger for every nested element in the tooltip.
    // We can skip rerendering when the tooltip is already open.
    // We are using the mouseover event instead of the mouseenter event to fix a hide/show issue.

    setOpenState(true);

    if (onOpen && !open) {
      onOpen(event);
    }
  };

  const handleClose = useEventCallback(
  /**
   * @param {React.SyntheticEvent | Event} event
   */
  event => {
    clearTimeout(hystersisTimer);
    hystersisTimer = setTimeout(() => {
      hystersisOpen = false;
    }, 800 + leaveDelay);
    setOpenState(false);

    if (onClose && open) {
      onClose(event);
    }

    clearTimeout(closeTimer.current);
    closeTimer.current = setTimeout(() => {
      ignoreNonTouchEvents.current = false;
    }, theme.transitions.duration.shortest);
  });

  const handleEnter = event => {
    if (ignoreNonTouchEvents.current && event.type !== 'touchstart') {
      return;
    } // Remove the title ahead of time.
    // We don't want to wait for the next render commit.
    // We would risk displaying two tooltips at the same time (native + this one).


    if (childNode) {
      childNode.removeAttribute('title');
    }

    clearTimeout(enterTimer.current);
    clearTimeout(leaveTimer.current);

    if (enterDelay || hystersisOpen && enterNextDelay) {
      enterTimer.current = setTimeout(() => {
        handleOpen(event);
      }, hystersisOpen ? enterNextDelay : enterDelay);
    } else {
      handleOpen(event);
    }
  };

  const handleLeave = event => {
    clearTimeout(enterTimer.current);
    clearTimeout(leaveTimer.current);
    leaveTimer.current = setTimeout(() => {
      handleClose(event);
    }, leaveDelay);
  };

  const {
    isFocusVisibleRef,
    onBlur: handleBlurVisible,
    onFocus: handleFocusVisible,
    ref: focusVisibleRef
  } = useIsFocusVisible(); // We don't necessarily care about the focusVisible state (which is safe to access via ref anyway).
  // We just need to re-render the Tooltip if the focus-visible state changes.

  const [, setChildIsFocusVisible] = React__namespace.useState(false);

  const handleBlur = event => {
    handleBlurVisible(event);

    if (isFocusVisibleRef.current === false) {
      setChildIsFocusVisible(false);
      handleLeave(event);
    }
  };

  const handleFocus = event => {
    // Workaround for https://github.com/facebook/react/issues/7769
    // The autoFocus of React might trigger the event before the componentDidMount.
    // We need to account for this eventuality.
    if (!childNode) {
      setChildNode(event.currentTarget);
    }

    handleFocusVisible(event);

    if (isFocusVisibleRef.current === true) {
      setChildIsFocusVisible(true);
      handleEnter(event);
    }
  };

  const detectTouchStart = event => {
    ignoreNonTouchEvents.current = true;
    const childrenProps = children.props;

    if (childrenProps.onTouchStart) {
      childrenProps.onTouchStart(event);
    }
  };

  const handleMouseOver = handleEnter;
  const handleMouseLeave = handleLeave;

  const handleTouchStart = event => {
    detectTouchStart(event);
    clearTimeout(leaveTimer.current);
    clearTimeout(closeTimer.current);
    stopTouchInteraction();
    prevUserSelect.current = document.body.style.WebkitUserSelect; // Prevent iOS text selection on long-tap.

    document.body.style.WebkitUserSelect = 'none';
    touchTimer.current = setTimeout(() => {
      document.body.style.WebkitUserSelect = prevUserSelect.current;
      handleEnter(event);
    }, enterTouchDelay);
  };

  const handleTouchEnd = event => {
    if (children.props.onTouchEnd) {
      children.props.onTouchEnd(event);
    }

    stopTouchInteraction();
    clearTimeout(leaveTimer.current);
    leaveTimer.current = setTimeout(() => {
      handleClose(event);
    }, leaveTouchDelay);
  };

  React__namespace.useEffect(() => {
    if (!open) {
      return undefined;
    }
    /**
     * @param {KeyboardEvent} nativeEvent
     */


    function handleKeyDown(nativeEvent) {
      // IE11, Edge (prior to using Bink?) use 'Esc'
      if (nativeEvent.key === 'Escape' || nativeEvent.key === 'Esc') {
        handleClose(nativeEvent);
      }
    }

    document.addEventListener('keydown', handleKeyDown);
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [handleClose, open]);
  const handleUseRef = useForkRef(setChildNode, ref);
  const handleFocusRef = useForkRef(focusVisibleRef, handleUseRef);
  const handleRef = useForkRef(children.ref, handleFocusRef); // There is no point in displaying an empty tooltip.

  if (title === '') {
    open = false;
  }

  const positionRef = React__namespace.useRef({
    x: 0,
    y: 0
  });
  const popperRef = React__namespace.useRef();

  const handleMouseMove = event => {
    const childrenProps = children.props;

    if (childrenProps.onMouseMove) {
      childrenProps.onMouseMove(event);
    }

    positionRef.current = {
      x: event.clientX,
      y: event.clientY
    };

    if (popperRef.current) {
      popperRef.current.update();
    }
  };

  const nameOrDescProps = {};
  const titleIsString = typeof title === 'string';

  if (describeChild) {
    nameOrDescProps.title = !open && titleIsString && !disableHoverListener ? title : null;
    nameOrDescProps['aria-describedby'] = open ? id : null;
  } else {
    nameOrDescProps['aria-label'] = titleIsString ? title : null;
    nameOrDescProps['aria-labelledby'] = open && !titleIsString ? id : null;
  }

  const childrenProps = _extends({}, nameOrDescProps, other, children.props, {
    className: clsx(other.className, children.props.className),
    onTouchStart: detectTouchStart,
    ref: handleRef
  }, followCursor ? {
    onMouseMove: handleMouseMove
  } : {});

  if (process.env.NODE_ENV !== 'production') {
    childrenProps['data-mui-internal-clone-element'] = true; // eslint-disable-next-line react-hooks/rules-of-hooks

    React__namespace.useEffect(() => {
      if (childNode && !childNode.getAttribute('data-mui-internal-clone-element')) {
        console.error(['MUI: The `children` component of the Tooltip is not forwarding its props correctly.', 'Please make sure that props are spread on the same element that the ref is applied to.'].join('\n'));
      }
    }, [childNode]);
  }

  const interactiveWrapperListeners = {};

  if (!disableTouchListener) {
    childrenProps.onTouchStart = handleTouchStart;
    childrenProps.onTouchEnd = handleTouchEnd;
  }

  if (!disableHoverListener) {
    childrenProps.onMouseOver = composeEventHandler(handleMouseOver, childrenProps.onMouseOver);
    childrenProps.onMouseLeave = composeEventHandler(handleMouseLeave, childrenProps.onMouseLeave);

    if (!disableInteractive) {
      interactiveWrapperListeners.onMouseOver = handleMouseOver;
      interactiveWrapperListeners.onMouseLeave = handleMouseLeave;
    }
  }

  if (!disableFocusListener) {
    childrenProps.onFocus = composeEventHandler(handleFocus, childrenProps.onFocus);
    childrenProps.onBlur = composeEventHandler(handleBlur, childrenProps.onBlur);

    if (!disableInteractive) {
      interactiveWrapperListeners.onFocus = handleFocus;
      interactiveWrapperListeners.onBlur = handleBlur;
    }
  }

  if (process.env.NODE_ENV !== 'production') {
    if (children.props.title) {
      console.error(['MUI: You have provided a `title` prop to the child of <Tooltip />.', `Remove this title prop \`${children.props.title}\` or the Tooltip component.`].join('\n'));
    }
  }

  const popperOptions = React__namespace.useMemo(() => {
    var _PopperProps$popperOp;

    let tooltipModifiers = [{
      name: 'arrow',
      enabled: Boolean(arrowRef),
      options: {
        element: arrowRef,
        padding: 4
      }
    }];

    if ((_PopperProps$popperOp = PopperProps.popperOptions) != null && _PopperProps$popperOp.modifiers) {
      tooltipModifiers = tooltipModifiers.concat(PopperProps.popperOptions.modifiers);
    }

    return _extends({}, PopperProps.popperOptions, {
      modifiers: tooltipModifiers
    });
  }, [arrowRef, PopperProps]);

  const ownerState = _extends({}, props, {
    isRtl,
    arrow,
    disableInteractive,
    placement,
    PopperComponentProp,
    touch: ignoreNonTouchEvents.current
  });

  const classes = useUtilityClasses(ownerState);
  const PopperComponent = (_components$Popper = components.Popper) != null ? _components$Popper : TooltipPopper;
  const TransitionComponent = (_ref = (_components$Transitio = components.Transition) != null ? _components$Transitio : TransitionComponentProp) != null ? _ref : Grow;
  const TooltipComponent = (_components$Tooltip = components.Tooltip) != null ? _components$Tooltip : TooltipTooltip;
  const ArrowComponent = (_components$Arrow = components.Arrow) != null ? _components$Arrow : TooltipArrow;
  const popperProps = appendOwnerState(PopperComponent, _extends({}, PopperProps, componentsProps.popper), ownerState);
  const transitionProps = appendOwnerState(TransitionComponent, _extends({}, TransitionProps, componentsProps.transition), ownerState);
  const tooltipProps = appendOwnerState(TooltipComponent, _extends({}, componentsProps.tooltip), ownerState);
  const tooltipArrowProps = appendOwnerState(ArrowComponent, _extends({}, componentsProps.arrow), ownerState);
  return /*#__PURE__*/jsxRuntime.exports.jsxs(React__namespace.Fragment, {
    children: [/*#__PURE__*/React__namespace.cloneElement(children, childrenProps), /*#__PURE__*/jsxRuntime.exports.jsx(PopperComponent, _extends({
      as: PopperComponentProp != null ? PopperComponentProp : Popper,
      placement: placement,
      anchorEl: followCursor ? {
        getBoundingClientRect: () => ({
          top: positionRef.current.y,
          left: positionRef.current.x,
          right: positionRef.current.x,
          bottom: positionRef.current.y,
          width: 0,
          height: 0
        })
      } : childNode,
      popperRef: popperRef,
      open: childNode ? open : false,
      id: id,
      transition: true
    }, interactiveWrapperListeners, popperProps, {
      className: clsx(classes.popper, PopperProps == null ? void 0 : PopperProps.className, (_componentsProps$popp = componentsProps.popper) == null ? void 0 : _componentsProps$popp.className),
      popperOptions: popperOptions,
      children: ({
        TransitionProps: TransitionPropsInner
      }) => {
        var _componentsProps$tool, _componentsProps$arro;

        return /*#__PURE__*/jsxRuntime.exports.jsx(TransitionComponent, _extends({
          timeout: theme.transitions.duration.shorter
        }, TransitionPropsInner, transitionProps, {
          children: /*#__PURE__*/jsxRuntime.exports.jsxs(TooltipComponent, _extends({}, tooltipProps, {
            className: clsx(classes.tooltip, (_componentsProps$tool = componentsProps.tooltip) == null ? void 0 : _componentsProps$tool.className),
            children: [title, arrow ? /*#__PURE__*/jsxRuntime.exports.jsx(ArrowComponent, _extends({}, tooltipArrowProps, {
              className: clsx(classes.arrow, (_componentsProps$arro = componentsProps.arrow) == null ? void 0 : _componentsProps$arro.className),
              ref: setArrowRef
            })) : null]
          }))
        }));
      }
    }))]
  });
});
process.env.NODE_ENV !== "production" ? Tooltip.propTypes
/* remove-proptypes */
= {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------

  /**
   * If `true`, adds an arrow to the tooltip.
   * @default false
   */
  arrow: propTypes.exports.bool,

  /**
   * Tooltip reference element.
   */
  children: elementAcceptingRef.isRequired,

  /**
   * Override or extend the styles applied to the component.
   */
  classes: propTypes.exports.object,

  /**
   * @ignore
   */
  className: propTypes.exports.string,

  /**
   * The components used for each slot inside the Tooltip.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  components: propTypes.exports.shape({
    Arrow: propTypes.exports.elementType,
    Popper: propTypes.exports.elementType,
    Tooltip: propTypes.exports.elementType,
    Transition: propTypes.exports.elementType
  }),

  /**
   * The props used for each slot inside the Tooltip.
   * Note that `componentsProps.popper` prop values win over `PopperProps`
   * and `componentsProps.transition` prop values win over `TransitionProps` if both are applied.
   * @default {}
   */
  componentsProps: propTypes.exports.shape({
    arrow: propTypes.exports.object,
    popper: propTypes.exports.object,
    tooltip: propTypes.exports.object,
    transition: propTypes.exports.object
  }),

  /**
   * Set to `true` if the `title` acts as an accessible description.
   * By default the `title` acts as an accessible label for the child.
   * @default false
   */
  describeChild: propTypes.exports.bool,

  /**
   * Do not respond to focus-visible events.
   * @default false
   */
  disableFocusListener: propTypes.exports.bool,

  /**
   * Do not respond to hover events.
   * @default false
   */
  disableHoverListener: propTypes.exports.bool,

  /**
   * Makes a tooltip not interactive, i.e. it will close when the user
   * hovers over the tooltip before the `leaveDelay` is expired.
   * @default false
   */
  disableInteractive: propTypes.exports.bool,

  /**
   * Do not respond to long press touch events.
   * @default false
   */
  disableTouchListener: propTypes.exports.bool,

  /**
   * The number of milliseconds to wait before showing the tooltip.
   * This prop won't impact the enter touch delay (`enterTouchDelay`).
   * @default 100
   */
  enterDelay: propTypes.exports.number,

  /**
   * The number of milliseconds to wait before showing the tooltip when one was already recently opened.
   * @default 0
   */
  enterNextDelay: propTypes.exports.number,

  /**
   * The number of milliseconds a user must touch the element before showing the tooltip.
   * @default 700
   */
  enterTouchDelay: propTypes.exports.number,

  /**
   * If `true`, the tooltip follow the cursor over the wrapped element.
   * @default false
   */
  followCursor: propTypes.exports.bool,

  /**
   * This prop is used to help implement the accessibility logic.
   * If you don't provide this prop. It falls back to a randomly generated id.
   */
  id: propTypes.exports.string,

  /**
   * The number of milliseconds to wait before hiding the tooltip.
   * This prop won't impact the leave touch delay (`leaveTouchDelay`).
   * @default 0
   */
  leaveDelay: propTypes.exports.number,

  /**
   * The number of milliseconds after the user stops touching an element before hiding the tooltip.
   * @default 1500
   */
  leaveTouchDelay: propTypes.exports.number,

  /**
   * Callback fired when the component requests to be closed.
   *
   * @param {React.SyntheticEvent} event The event source of the callback.
   */
  onClose: propTypes.exports.func,

  /**
   * Callback fired when the component requests to be open.
   *
   * @param {React.SyntheticEvent} event The event source of the callback.
   */
  onOpen: propTypes.exports.func,

  /**
   * If `true`, the component is shown.
   */
  open: propTypes.exports.bool,

  /**
   * Tooltip placement.
   * @default 'bottom'
   */
  placement: propTypes.exports.oneOf(['bottom-end', 'bottom-start', 'bottom', 'left-end', 'left-start', 'left', 'right-end', 'right-start', 'right', 'top-end', 'top-start', 'top']),

  /**
   * The component used for the popper.
   * @default Popper
   */
  PopperComponent: propTypes.exports.elementType,

  /**
   * Props applied to the [`Popper`](/material-ui/api/popper/) element.
   * @default {}
   */
  PopperProps: propTypes.exports.object,

  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: propTypes.exports.oneOfType([propTypes.exports.arrayOf(propTypes.exports.oneOfType([propTypes.exports.func, propTypes.exports.object, propTypes.exports.bool])), propTypes.exports.func, propTypes.exports.object]),

  /**
   * Tooltip title. Zero-length titles string are never displayed.
   */
  title: propTypes.exports
  /* @typescript-to-proptypes-ignore */
  .node.isRequired,

  /**
   * The component used for the transition.
   * [Follow this guide](/material-ui/transitions/#transitioncomponent-prop) to learn more about the requirements for this component.
   * @default Grow
   */
  TransitionComponent: propTypes.exports.elementType,

  /**
   * Props applied to the transition element.
   * By default, the element is based on this [`Transition`](http://reactcommunity.org/react-transition-group/transition/) component.
   */
  TransitionProps: propTypes.exports.object
} : void 0;

var LightTooltip = styled(function (_a) {
    var className = _a.className, props = __rest(_a, ["className"]);
    return (jsxRuntime.exports.jsx(Tooltip, __assign({}, props, { classes: { popper: className } })));
})(function (_a) {
    var _b;
    var theme = _a.theme;
    return (_b = {},
        _b["& .".concat(tooltipClasses.tooltip)] = {
            backgroundColor: theme.palette.common.white,
            color: "rgba(0, 0, 0, 0.87)",
            boxShadow: theme.shadows[1],
            fontSize: 11,
        },
        _b);
});
var MembershipTooltip = styled(function (_a) {
    var className = _a.className, props = __rest(_a, ["className"]);
    return (jsxRuntime.exports.jsx(Tooltip, __assign({}, props, { classes: { popper: className }, arrow: true })));
})(function (_a) {
    var _b;
    _a.theme;
    return (_b = {},
        _b["& .".concat(tooltipClasses.tooltip)] = {
            backgroundColor: "#293354",
            color: "white",
            fontWeight: 600,
            boxShadow: "0px 4px 12px rgba(0, 0, 0, 0.1);",
            maxWidth: 320,
            padding: 16,
            fontSize: 16,
            borderRadius: 16,
        },
        _b["& .".concat(tooltipClasses.arrow)] = {
            color: "#293354",
        },
        _b);
});
var ToolTip = function (_a) {
    var children = _a.children, _b = _a.isMembership, isMembership = _b === void 0 ? false : _b, props = __rest(_a, ["children", "isMembership"]);
    if (isMembership) {
        return (jsxRuntime.exports.jsx(MembershipTooltip, __assign({}, props, { children: children })));
    }
    return (jsxRuntime.exports.jsx(LightTooltip, __assign({}, props, { children: children })));
};

var DEFAULT_MAX_DIGITS = 4;
var maxDigitsStr = function (s, digits) {
    if (s === void 0) { s = ""; }
    var _a = s.split("."), n = _a[0], d = _a[1];
    if (d) {
        return d.length > digits ? "".concat(n, ".").concat(d.substring(0, digits)) : "".concat(n, ".").concat(d);
    }
    return "".concat(n, ".").concat(d);
};
var Value = function (_a) {
    var displayValue = _a.displayValue; _a.decimals; var _b = _a.maxDigits, maxDigits = _b === void 0 ? DEFAULT_MAX_DIGITS : _b, style = _a.style, renderValue = _a.renderValue;
    var defaultVal = maxDigitsStr(displayValue, maxDigits);
    return (jsxRuntime.exports.jsx(ToolTip, __assign({ placement: "top", title: displayValue }, { children: jsxRuntime.exports.jsx("span", { children: renderValue ? (renderValue(commafy(displayValue, maxDigits))) : (jsxRuntime.exports.jsx(Body, __assign({ style: style }, { children: commafy(defaultVal, maxDigits) }))) }) })));
};

var commafy = function (n, digits) {
    if (digits === void 0) { digits = 2; }
    var fallback = 0;
    if (!n)
        return fallback.toFixed(digits);
    var handleOutput = function (num) {
        return num.toLocaleString("en-US", {
            minimumFractionDigits: digits,
            maximumFractionDigits: digits,
        });
    };
    if (typeof n === "string") {
        return handleOutput(Number(n));
    }
    return handleOutput(n);
};
var truncateText = function (str, len) {
    if (str.length < len)
        return str;
    return "".concat(str.substring(0, len), "...");
};

exports.Body = Body;
exports.Button = Button$2;
exports.Caption = Caption$1;
exports.CircleImg = CircleImg;
exports.DEFAULT_CIRCLE_IMG_SIZE = DEFAULT_CIRCLE_IMG_SIZE;
exports.DEFAULT_MAX_DIGITS = DEFAULT_MAX_DIGITS;
exports.FONT_SIZE_BODY = FONT_SIZE_BODY;
exports.FONT_SIZE_CAPTION = FONT_SIZE_CAPTION;
exports.FONT_SIZE_HEADER = FONT_SIZE_HEADER;
exports.FONT_SIZE_LARGE_HEADER = FONT_SIZE_LARGE_HEADER;
exports.FONT_SIZE_LARGE_TITLE = FONT_SIZE_LARGE_TITLE;
exports.FONT_SIZE_SUB_CAPTION = FONT_SIZE_SUB_CAPTION;
exports.FONT_SIZE_SUB_HEADER = FONT_SIZE_SUB_HEADER;
exports.FONT_SIZE_TITLE = FONT_SIZE_TITLE;
exports.Header = Header;
exports.LargeHeader = LargeHeader;
exports.LargeTitle = LargeTitle;
exports.SubCaption = SubCaption;
exports.SubHeader = SubHeader;
exports.Surface = Surface$2;
exports.TextField = TextField;
exports.ThemeCtx = ThemeCtx;
exports.ThemeProvider = ThemeProvider$2;
exports.Title = Title$1;
exports.TypographyBase = TypographyBase;
exports.Value = Value;
exports.aliceBlue = aliceBlue;
exports.charcoalBlack = charcoalBlack;
exports.commafy = commafy;
exports.containers = containers;
exports.crimson = crimson;
exports.cyanBlue = cyanBlue;
exports.darkNavy = darkNavy;
exports.dodgerBlue = dodgerBlue;
exports.ghostWhite = ghostWhite;
exports.grey = grey$1;
exports.injectFonts = injectFonts;
exports.lavendar = lavendar;
exports.lightGray = lightGray;
exports.makeStyles = makeStyles;
exports.makeTextStyles = makeTextStyles;
exports.makeViewStyles = makeViewStyles;
exports.margins = margins;
exports.mistyRose = mistyRose;
exports.openSans = openSans;
exports.orange = orange$1;
exports.padding = padding;
exports.solitudeGrey = solitudeGrey;
exports.text = text;
exports.truncateMaxChars = truncateMaxChars;
exports.truncateText = truncateText;
exports.useModal = useModal;
exports.useTheme = useTheme$4;
exports.white = white$1;
